{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JWSKATE \u00b6 A Pythonic implementation of Json Web Signature, Keys, Algorithms, Tokens and Encryption (RFC7514 to 7519), and their extensions ECDH Signatures (RFC8037), and JWK Thumbprints (RFC7638). Free software: MIT Documentation: https://guillp.github.io/jwskate/ A quick usage example, generating an RSA private key, signing some data, then validating that signature: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from jwskate import Jwk # generate a RSA Jwk and sign a plaintext with it rsa_private_jwk = Jwk . generate_for_kty ( \"RSA\" , key_size = 2048 , kid = \"my_key\" ) data = b \"Signing is easy!\" alg = \"RS256\" signature = rsa_private_jwk . sign ( data , alg ) # extract the public key, and verify the signature with it rsa_public_jwk = rsa_private_jwk . public_jwk () assert rsa_public_jwk . verify ( data , signature , alg ) # let's see what a Jwk looks like: assert isinstance ( rsa_private_jwk , dict ) # Jwk are dict print ( rsa_private_jwk ) The result of this print JWK will look like this: 1 2 3 4 5 6 7 8 9 10 11 { 'kty': 'RSA', 'n': '...', 'e': 'AQAB', 'd': '...', 'p': '...', 'q': '...', 'dp': '...', 'dq': '...', 'qi': '...', 'kid': 'my_key' } Now let's sign a JWT containing arbitrary claims: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from jwskate import Jwk , Jwt private_jwk = Jwk . generate_for_kty ( \"RSA\" , kid = \"mykey\" ) claims = { \"sub\" : \"some_sub\" , \"claim1\" : \"value1\" } sign_alg = \"RS256\" jwt = Jwt . sign ( claims , private_jwk , sign_alg ) # that's it! we have a signed JWT assert jwt . claims == claims # claims can be accessed as a dict assert jwt . sub == \"some_sub\" # or individual claims can be accessed as attributes assert jwt [ \"claim1\" ] == \"value1\" # or as dict items assert jwt . alg == sign_alg # alg and kid headers are also accessible as attributes assert jwt . kid == private_jwk . kid assert jwt . verify_signature ( private_jwk . public_jwk (), sign_alg ) print ( jwt ) 1 eyJhbGciOiJSUzI1NiIsImtpZCI6IkhyRnRZRk52U2g2WVp4WVpNY043XzM0dWNrN1hodTZFT2JoLWhkQVdqbHMifQ.eyJzdWIiOiJzb21lX3N1YiIsImNsYWltMSI6InZhbHVlMSJ9.RiBmKWC1Tu2IgUZNqSv84Gv1X-TttuKcUnee38Jn_KvRDjBw3ZQ1dEuG6hI8FVX4rDXmRMGNNsS51KL5BLTZNYd6Q34SJr_udIkwlW6xW-s39XzW1eMUSUkHa0p7CMpH32Vf-1ZPqnJMjMX6iq2nUOYxtPDZ5xdEjcTQhQf8llWunWhnTLLyMhY8Npz4c0veJkI9KxjM4_zLchpM0TR7OleBqflmbOzU14z2490K8VhHOfGxBr7Hj1WHvFMwC77qPU6jr6TSmHMFy5WvERfkbfpNgRQPFBWBDXT2uuWbFELUZHjfjaVA-uEy7SclDswTURKc-H-XWtdWKjb-tKKO5iNXd4qCeCakun5B3ykN7pE_u_bXO4fb5eSHWnBVByEa7UFBNLHIX2-aXOHZ95LpylDmXSpDTfHmpOGxxwT5SaRzosGH_cRbdmBKNEtTb0PG8tBQeq1uTpbhTL2u_H0KHUN8_C5GO5-5yelKhpMsHObFIcmy3WktRsgL98ATOXGYK0zShGeHc7JRHGJ5DQmU-FMK-eVe6J19LEpT0CgN4EljfsfSY7LBAFTE3yk3y95FDoYun7u_NcyZB5q_lhtHUKkTPqGLUEahNKCbn85AjMA8oLjlsAH123Hwz89NpxSY_FFWxSkUPAz477LWJUbgwGZhXUZYSFUQzk5DQ-0XMQU Or let's sign a JWT with the standardised lifetime, subject, audience and ID claims: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk , JwtSigner private_jwk = Jwk . generate_for_kty ( \"RSA\" ) signer = JwtSigner ( issuer = \"https://myissuer.com\" , jwk = private_jwk , alg = \"RS256\" ) jwt = signer . sign ( subject = \"some_sub\" , audience = \"some_aud\" , extra_claims = { \"custom_claim1\" : \"value1\" , \"custom_claim2\" : \"value2\" }, ) print ( jwt ) Features \u00b6 Simple, Clean, Pythonic interface Convenience wrappers around cryptography for all algorithms described in JWA Json Web Keys (JWK) loading and generation Arbitrary data signature and verification using Json Web Keys Json Web Signatures (JWS) signing and verification Json Web Encryption (JWE) encryption and decryption Json Web Tokens (JWT) signing, verification and validation 100% type annotated nearly 100% code coverage Relies on cryptography for all cryptographic operations Relies on BinaPy for binary data manipulations Why a new lib ? \u00b6 There are already multiple implementations of JOSE and Json Web Crypto related specifications in Python. However, I have been dissatisfied by all of them so far, so I decided to come up with my own module. PyJWT : lacks support for JWK, JWE, JWS, requires keys in PEM format. JWCrypto : very inconsistent and complex API. Python-JOSE : lacks easy support for JWT validation (checking the standard claims like iss, exp, etc.), lacks easy access to claims Design \u00b6 JWK are dicts \u00b6 JWK are specified as JSON objects, which are parsed as dict in Python. The Jwk class in jwskate is actually a dict subclass, so you can use it exactly like you would use a dict: you can access its members, dump it back as JSON, etc. The same is true for Json Web tokens in JSON format. JWA Wrappers \u00b6 While you can directly use cryptography to do the cryptographic operations that are described in JWA , its usage is not straightforward and leaves you with plenty of options to carefully select, leaving room for errors. To work around this, jwskate comes with a set of wrappers that implement the exact JWA specification, with minimum risk of mistakes. Safe Signature Verification \u00b6 For every signature verification method in jwskate , you have to provide the expected signature(s) algorithm(s). That is to avoid a security flaw where your application accepts tokens with a weaker encryption scheme than what your security policy mandates; or even worse, where it accepts unsigned tokens, or tokens that are symmetrically signed with an improperly used public key, leaving your application exposed to exploitation by attackers. Each signature verification accepts 2 args alg and algs . If you always expect to verify tokens signed with a single signature algorithm, pass that algorithm ID to alg. If you accept multiple algs (for example, any asymmetric alg that you consider strong enough), you can instead pass an iterable of allowed algorithms with algs . The signature will be validated as long as it is signed with one of the provided algs. For verification methods that accept a Jwk key, you don't have to provide an alg or algs if that Jwk has the appropriate alg member that define which algorithm is supposed to be used with that key. Credits \u00b6 All cryptographic operations are handled by cryptography .","title":"home"},{"location":"#jwskate","text":"A Pythonic implementation of Json Web Signature, Keys, Algorithms, Tokens and Encryption (RFC7514 to 7519), and their extensions ECDH Signatures (RFC8037), and JWK Thumbprints (RFC7638). Free software: MIT Documentation: https://guillp.github.io/jwskate/ A quick usage example, generating an RSA private key, signing some data, then validating that signature: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from jwskate import Jwk # generate a RSA Jwk and sign a plaintext with it rsa_private_jwk = Jwk . generate_for_kty ( \"RSA\" , key_size = 2048 , kid = \"my_key\" ) data = b \"Signing is easy!\" alg = \"RS256\" signature = rsa_private_jwk . sign ( data , alg ) # extract the public key, and verify the signature with it rsa_public_jwk = rsa_private_jwk . public_jwk () assert rsa_public_jwk . verify ( data , signature , alg ) # let's see what a Jwk looks like: assert isinstance ( rsa_private_jwk , dict ) # Jwk are dict print ( rsa_private_jwk ) The result of this print JWK will look like this: 1 2 3 4 5 6 7 8 9 10 11 { 'kty': 'RSA', 'n': '...', 'e': 'AQAB', 'd': '...', 'p': '...', 'q': '...', 'dp': '...', 'dq': '...', 'qi': '...', 'kid': 'my_key' } Now let's sign a JWT containing arbitrary claims: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from jwskate import Jwk , Jwt private_jwk = Jwk . generate_for_kty ( \"RSA\" , kid = \"mykey\" ) claims = { \"sub\" : \"some_sub\" , \"claim1\" : \"value1\" } sign_alg = \"RS256\" jwt = Jwt . sign ( claims , private_jwk , sign_alg ) # that's it! we have a signed JWT assert jwt . claims == claims # claims can be accessed as a dict assert jwt . sub == \"some_sub\" # or individual claims can be accessed as attributes assert jwt [ \"claim1\" ] == \"value1\" # or as dict items assert jwt . alg == sign_alg # alg and kid headers are also accessible as attributes assert jwt . kid == private_jwk . kid assert jwt . verify_signature ( private_jwk . public_jwk (), sign_alg ) print ( jwt ) 1 eyJhbGciOiJSUzI1NiIsImtpZCI6IkhyRnRZRk52U2g2WVp4WVpNY043XzM0dWNrN1hodTZFT2JoLWhkQVdqbHMifQ.eyJzdWIiOiJzb21lX3N1YiIsImNsYWltMSI6InZhbHVlMSJ9.RiBmKWC1Tu2IgUZNqSv84Gv1X-TttuKcUnee38Jn_KvRDjBw3ZQ1dEuG6hI8FVX4rDXmRMGNNsS51KL5BLTZNYd6Q34SJr_udIkwlW6xW-s39XzW1eMUSUkHa0p7CMpH32Vf-1ZPqnJMjMX6iq2nUOYxtPDZ5xdEjcTQhQf8llWunWhnTLLyMhY8Npz4c0veJkI9KxjM4_zLchpM0TR7OleBqflmbOzU14z2490K8VhHOfGxBr7Hj1WHvFMwC77qPU6jr6TSmHMFy5WvERfkbfpNgRQPFBWBDXT2uuWbFELUZHjfjaVA-uEy7SclDswTURKc-H-XWtdWKjb-tKKO5iNXd4qCeCakun5B3ykN7pE_u_bXO4fb5eSHWnBVByEa7UFBNLHIX2-aXOHZ95LpylDmXSpDTfHmpOGxxwT5SaRzosGH_cRbdmBKNEtTb0PG8tBQeq1uTpbhTL2u_H0KHUN8_C5GO5-5yelKhpMsHObFIcmy3WktRsgL98ATOXGYK0zShGeHc7JRHGJ5DQmU-FMK-eVe6J19LEpT0CgN4EljfsfSY7LBAFTE3yk3y95FDoYun7u_NcyZB5q_lhtHUKkTPqGLUEahNKCbn85AjMA8oLjlsAH123Hwz89NpxSY_FFWxSkUPAz477LWJUbgwGZhXUZYSFUQzk5DQ-0XMQU Or let's sign a JWT with the standardised lifetime, subject, audience and ID claims: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk , JwtSigner private_jwk = Jwk . generate_for_kty ( \"RSA\" ) signer = JwtSigner ( issuer = \"https://myissuer.com\" , jwk = private_jwk , alg = \"RS256\" ) jwt = signer . sign ( subject = \"some_sub\" , audience = \"some_aud\" , extra_claims = { \"custom_claim1\" : \"value1\" , \"custom_claim2\" : \"value2\" }, ) print ( jwt )","title":"JWSKATE"},{"location":"#features","text":"Simple, Clean, Pythonic interface Convenience wrappers around cryptography for all algorithms described in JWA Json Web Keys (JWK) loading and generation Arbitrary data signature and verification using Json Web Keys Json Web Signatures (JWS) signing and verification Json Web Encryption (JWE) encryption and decryption Json Web Tokens (JWT) signing, verification and validation 100% type annotated nearly 100% code coverage Relies on cryptography for all cryptographic operations Relies on BinaPy for binary data manipulations","title":"Features"},{"location":"#why-a-new-lib-","text":"There are already multiple implementations of JOSE and Json Web Crypto related specifications in Python. However, I have been dissatisfied by all of them so far, so I decided to come up with my own module. PyJWT : lacks support for JWK, JWE, JWS, requires keys in PEM format. JWCrypto : very inconsistent and complex API. Python-JOSE : lacks easy support for JWT validation (checking the standard claims like iss, exp, etc.), lacks easy access to claims","title":"Why a new lib ?"},{"location":"#design","text":"","title":"Design"},{"location":"#jwk-are-dicts","text":"JWK are specified as JSON objects, which are parsed as dict in Python. The Jwk class in jwskate is actually a dict subclass, so you can use it exactly like you would use a dict: you can access its members, dump it back as JSON, etc. The same is true for Json Web tokens in JSON format.","title":"JWK are dicts"},{"location":"#jwa-wrappers","text":"While you can directly use cryptography to do the cryptographic operations that are described in JWA , its usage is not straightforward and leaves you with plenty of options to carefully select, leaving room for errors. To work around this, jwskate comes with a set of wrappers that implement the exact JWA specification, with minimum risk of mistakes.","title":"JWA Wrappers"},{"location":"#safe-signature-verification","text":"For every signature verification method in jwskate , you have to provide the expected signature(s) algorithm(s). That is to avoid a security flaw where your application accepts tokens with a weaker encryption scheme than what your security policy mandates; or even worse, where it accepts unsigned tokens, or tokens that are symmetrically signed with an improperly used public key, leaving your application exposed to exploitation by attackers. Each signature verification accepts 2 args alg and algs . If you always expect to verify tokens signed with a single signature algorithm, pass that algorithm ID to alg. If you accept multiple algs (for example, any asymmetric alg that you consider strong enough), you can instead pass an iterable of allowed algorithms with algs . The signature will be validated as long as it is signed with one of the provided algs. For verification methods that accept a Jwk key, you don't have to provide an alg or algs if that Jwk has the appropriate alg member that define which algorithm is supposed to be used with that key.","title":"Safe Signature Verification"},{"location":"#credits","text":"All cryptographic operations are handled by cryptography .","title":"Credits"},{"location":"api/","text":"jwskate \u00b6 Main module for jwskate . The jwskate module implements the various Json Web Crypto-related standards: JWA, JWK, JWKS, JWE, JWT. Each standard has its own submodule, but for convenience, you can import any class or component directly from the root jwskate module. jwskate doesn't implement any actual cryptographic operation, it just provides a set of convenient wrappers around the cryptography module. token \u00b6 This module contains base classes for all tokens types handled by jwskate . BaseCompactToken \u00b6 Base class for all tokens in Compact representation. This includes JWS, JWE, and JWT tokens. Source code in jwskate\\token.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class BaseCompactToken : \"\"\"Base class for all tokens in Compact representation. This includes JWS, JWE, and JWT tokens. \"\"\" def __init__ ( self , value : Union [ bytes , str ], max_size : int = 16 * 1024 ): \"\"\"Initialize a JW{S,E,T} from its string representation. Args: value: the string or bytes representation of this Jwt max_size: if the JWT length is larger than this value, raise a `ValueError`. This is to avoid JSON deserialization vulnerabilities. \"\"\" if len ( value ) > max_size : raise ValueError ( f \"This JWT size exceeds { max_size } bytes, which is abnormally big. \" \"This size limit is made to avoid potential JSON deserialization vulnerabilities or issues. \" \"You can increase this limit by passing a different `max_size` value as parameter.\" ) if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) self . value = value self . headers : Dict [ str , Any ] def __eq__ ( self , other : Any ) -> bool : \"\"\"Check that a Jwt is equal to another. Works with other instances of `Jwt`, or with `str` or `bytes`. Args: other: the other token to compare with Returns: `True` if the other token has the same representation, `False` otherwise \"\"\" if isinstance ( other , BaseCompactToken ): return self . value == other . value if isinstance ( other , str ): return self . value . decode () == other if isinstance ( other , bytes ): return self . value == other return super () . __eq__ ( other ) def get_header ( self , name : str ) -> Any : \"\"\"Get a header from this Jwt. Args: name: the header name Returns: the header value \"\"\" return self . headers . get ( name ) def __repr__ ( self ) -> str : \"\"\"Returns the `str` representation of this token.\"\"\" return self . value . decode () def __bytes__ ( self ) -> bytes : \"\"\"Return the `bytes` representation of this token.\"\"\" return self . value __init__ ( value , max_size = 16 * 1024 ) \u00b6 Initialize a JW{S,E,T} from its string representation. Parameters: Name Type Description Default value Union [ bytes , str ] the string or bytes representation of this Jwt required max_size int if the JWT length is larger than this value, raise a ValueError . This is to avoid JSON deserialization vulnerabilities. 16 * 1024 Source code in jwskate\\token.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , value : Union [ bytes , str ], max_size : int = 16 * 1024 ): \"\"\"Initialize a JW{S,E,T} from its string representation. Args: value: the string or bytes representation of this Jwt max_size: if the JWT length is larger than this value, raise a `ValueError`. This is to avoid JSON deserialization vulnerabilities. \"\"\" if len ( value ) > max_size : raise ValueError ( f \"This JWT size exceeds { max_size } bytes, which is abnormally big. \" \"This size limit is made to avoid potential JSON deserialization vulnerabilities or issues. \" \"You can increase this limit by passing a different `max_size` value as parameter.\" ) if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) self . value = value self . headers : Dict [ str , Any ] __eq__ ( other ) \u00b6 Check that a Jwt is equal to another. Works with other instances of Jwt , or with str or bytes . Parameters: Name Type Description Default other Any the other token to compare with required Returns: Type Description bool True if the other token has the same representation, False otherwise Source code in jwskate\\token.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __eq__ ( self , other : Any ) -> bool : \"\"\"Check that a Jwt is equal to another. Works with other instances of `Jwt`, or with `str` or `bytes`. Args: other: the other token to compare with Returns: `True` if the other token has the same representation, `False` otherwise \"\"\" if isinstance ( other , BaseCompactToken ): return self . value == other . value if isinstance ( other , str ): return self . value . decode () == other if isinstance ( other , bytes ): return self . value == other return super () . __eq__ ( other ) get_header ( name ) \u00b6 Get a header from this Jwt. Parameters: Name Type Description Default name str the header name required Returns: Type Description Any the header value Source code in jwskate\\token.py 52 53 54 55 56 57 58 59 60 61 def get_header ( self , name : str ) -> Any : \"\"\"Get a header from this Jwt. Args: name: the header name Returns: the header value \"\"\" return self . headers . get ( name ) __repr__ () \u00b6 Returns the str representation of this token. Source code in jwskate\\token.py 63 64 65 def __repr__ ( self ) -> str : \"\"\"Returns the `str` representation of this token.\"\"\" return self . value . decode () __bytes__ () \u00b6 Return the bytes representation of this token. Source code in jwskate\\token.py 67 68 69 def __bytes__ ( self ) -> bytes : \"\"\"Return the `bytes` representation of this token.\"\"\" return self . value BaseJsonDict \u00b6 Bases: Dict [ str , Any ] Base class Jwk and tokens in JSON representation. Source code in jwskate\\token.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class BaseJsonDict ( Dict [ str , Any ]): \"\"\"Base class Jwk and tokens in JSON representation.\"\"\" @classmethod def from_json ( cls : Type [ D ], j : str ) -> D : \"\"\"Initialize an object based on a string containing a JSON representation. Args: j: the JSON to parse, still serialized Returns: the resulting object \"\"\" return cls ( json . loads ( j )) def to_json ( self , * args : Any , ** kwargs : Any ) -> str : \"\"\"Serialize the current object into a JSON representation. Args: *args: additional args for json.dumps() **kwargs: additional kwargs for json.dumps() Returns: a JSON representation of the current object \"\"\" return json . dumps ( self , * args , ** kwargs ) from_json ( j ) \u00b6 Initialize an object based on a string containing a JSON representation. Parameters: Name Type Description Default j str the JSON to parse, still serialized required Returns: Type Description D the resulting object Source code in jwskate\\token.py 78 79 80 81 82 83 84 85 86 87 88 @classmethod def from_json ( cls : Type [ D ], j : str ) -> D : \"\"\"Initialize an object based on a string containing a JSON representation. Args: j: the JSON to parse, still serialized Returns: the resulting object \"\"\" return cls ( json . loads ( j )) to_json ( * args , ** kwargs ) \u00b6 Serialize the current object into a JSON representation. Parameters: Name Type Description Default *args Any additional args for json.dumps() () **kwargs Any additional kwargs for json.dumps() {} Returns: Type Description str a JSON representation of the current object Source code in jwskate\\token.py 90 91 92 93 94 95 96 97 98 99 100 def to_json ( self , * args : Any , ** kwargs : Any ) -> str : \"\"\"Serialize the current object into a JSON representation. Args: *args: additional args for json.dumps() **kwargs: additional kwargs for json.dumps() Returns: a JSON representation of the current object \"\"\" return json . dumps ( self , * args , ** kwargs ) jwa \u00b6 This module implements the Json Web Algorithms as defined in RFC7518. Each algorithm is represented as a wrapper around a symmetric or asymmetric key, and exposes the cryptographic operations as methods. The cryptographic operations themselves are delegated to cryptography . Ed25519 = OKPCurve ( name = 'Ed25519' , description = 'Ed25519 signature algorithm key pairs' , cryptography_private_key_class = ed25519 . Ed25519PrivateKey , cryptography_public_key_class = ed25519 . Ed25519PublicKey , use = 'sig' ) module-attribute \u00b6 Ed25519 curve. P_256 = EllipticCurve ( name = 'P-256' , cryptography_curve = ec . SECP256R1 (), coordinate_size = 32 ) module-attribute \u00b6 P-256 curve Ed448 = OKPCurve ( name = 'Ed448' , description = 'Ed448 signature algorithm key pairs' , cryptography_private_key_class = ed448 . Ed448PrivateKey , cryptography_public_key_class = ed448 . Ed448PublicKey , use = 'sig' ) module-attribute \u00b6 Ed448 curve. P_384 = EllipticCurve ( name = 'P-384' , cryptography_curve = ec . SECP384R1 (), coordinate_size = 48 ) module-attribute \u00b6 P-384 curve X25519 = OKPCurve ( name = 'X25519' , description = 'X25519 function key pairs' , cryptography_private_key_class = x25519 . X25519PrivateKey , cryptography_public_key_class = x25519 . X25519PublicKey , use = 'enc' ) module-attribute \u00b6 X25519 curve. P_521 = EllipticCurve ( name = 'P-521' , cryptography_curve = ec . SECP521R1 (), coordinate_size = 66 ) module-attribute \u00b6 P-521 curve X448 = OKPCurve ( name = 'X448' , description = 'X448 function key pairs' , cryptography_private_key_class = x448 . X448PrivateKey , cryptography_public_key_class = x448 . X448PublicKey , use = 'enc' ) module-attribute \u00b6 X448 curve. secp256k1 = EllipticCurve ( name = 'secp256k1' , cryptography_curve = ec . SECP256K1 (), coordinate_size = 32 ) module-attribute \u00b6 secp256k1 curve PrivateKeyRequired \u00b6 Bases: AttributeError Raised when a cryptographic operation requires a private key, and a public key has been provided instead. Source code in jwskate\\jwa\\base.py 9 10 class PrivateKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a private key, and a public key has been provided instead.\"\"\" BaseAesKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Base class for AES KW algorithms. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class BaseAesKeyWrap ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Base class for AES KW algorithms.\"\"\" key_size : int \"\"\"Required AES key size in bits.\"\"\" @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) key_size : int = None class-attribute \u00b6 Required AES key size in bits. check_key ( key ) \u00b6 Check that a key is valid for usage with this algorithm. To be valid, a key must be bytes and be of appropriate length (128, 192 or 256 bits). Parameters: Name Type Description Default key bytes a key to check required Raises: Type Description ValueError if the key is not appropriate Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) wrap_key ( plainkey ) \u00b6 Wrap a key. Parameters: Name Type Description Default plainkey bytes the key to wrap. required Returns: Name Type Description BinaPy BinaPy the wrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 30 31 32 33 34 35 36 37 38 39 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) unwrap_key ( cipherkey ) \u00b6 Unwrap a key. Parameters: Name Type Description Default cipherkey bytes the wrapped key. required Returns: Name Type Description BinaPy BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 41 42 43 44 45 46 47 48 49 50 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) DirectKeyUse \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate\\jwa\\key_mgmt\\dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) direct_key ( aesalg ) \u00b6 Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate\\jwa\\key_mgmt\\dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) BaseAesGcmKeyWrap \u00b6 Bases: BaseAESGCM , BaseKeyManagementAlg Base class for AES-GCM Key wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class BaseAesGcmKeyWrap ( BaseAESGCM , BaseKeyManagementAlg ): \"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\" key_size : int \"\"\"Required key size, in bits.\"\"\" tag_size : int = 16 \"\"\"Authentication tag size, in bits.\"\"\" iv_size : int = 96 \"\"\"Initialisation Vector size, in bits.\"\"\" def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" ) key_size : int = None class-attribute \u00b6 Required key size, in bits. tag_size : int = 16 class-attribute \u00b6 Authentication tag size, in bits. iv_size : int = 96 class-attribute \u00b6 Initialisation Vector size, in bits. wrap_key ( plainkey , iv ) \u00b6 Wrap a key using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default plainkey bytes the key to wrap required iv bytes the Initialisation Vector to use required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (wrapped_key, authentication_tag) Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 21 22 23 24 25 26 27 28 29 30 31 def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) unwrap_key ( cipherkey , tag , iv ) \u00b6 Unwrap a key and authenticates it with the authentication tag , using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default cipherkey bytes the wrapped key required tag bytes the authentication tag required iv bytes the Initialisation Vector required Returns: Type Description BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 33 34 35 36 37 38 39 40 41 42 43 44 def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" ) EllipticCurve \u00b6 A descriptive class for Elliptic Curves. Elliptic Curves have a name, a cryptography.ec.EllipticCurve , and a coordinate size. Source code in jwskate\\jwa\\ec.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class EllipticCurve : \"\"\"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size. \"\"\" name : str \"\"\" Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` or `enc` fields in JOSE headers.\"\"\" cryptography_curve : ec . EllipticCurve \"\"\"`cryptography` curve instance.\"\"\" coordinate_size : int \"\"\"Coordinate size, in bytes.\"\"\" instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey]): an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) @classmethod def get_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a tuple of `x`, `y` (public coordinates) and `d` (private key), as `int` Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = ( BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) y = ( BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters name : str = None class-attribute \u00b6 Curve name as defined in IANA JOSE . This name will appear in alg or enc fields in JOSE headers. cryptography_curve : ec . EllipticCurve = None class-attribute \u00b6 cryptography curve instance. coordinate_size : int = None class-attribute \u00b6 Coordinate size, in bytes. instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} class-attribute \u00b6 Registry of subclasses, in a {name: instance} mapping. __post_init__ () \u00b6 Automatically register subclasses in the instance registry. Source code in jwskate\\jwa\\ec.py 34 35 36 def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self generate () \u00b6 Generate a new EC key on this curve. Returns: Type Description Tuple [ int , int , int ] a tuple of 4 int s: x and y coordinates (public key) and d (private key) Source code in jwskate\\jwa\\ec.py 38 39 40 41 42 43 44 45 46 47 48 49 def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d get_curve ( key ) \u00b6 Get the appropriate EllipticCurve instance for a given cryptography EllipticCurvePublicKey . Parameters: Name Type Description Default key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey] an Elliptic Curve private or public key from cryptography . required Returns: Type Description 'EllipticCurve' the appropriate instance of EllipticCurve for the given key. Raises: Type Description NotImplementedError if the curve is not supported Source code in jwskate\\jwa\\ec.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey]): an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) get_parameters ( key ) \u00b6 Extract all private and public parameters from a given cryptography EllipticCurvePrivateKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] an Elliptic Curve public or private key from cryptography . required Returns: Type Description Dict [ str , Any ] a tuple of x , y (public coordinates) and d (private key), as int Raises: Type Description TypeError if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey Source code in jwskate\\jwa\\ec.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @classmethod def get_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a tuple of `x`, `y` (public coordinates) and `d` (private key), as `int` Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = ( BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) y = ( BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters BaseRsaKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms.\"\"\" padding : Any name = \"RSA1_5\" description = \"RSAES-PKCS1-v1_5\" private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) __init__ ( key ) \u00b6 Initialize an alg with a given RSA key. Parameters: Name Type Description Default key Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate\\jwa\\key_mgmt\\rsa.py 26 27 28 29 30 31 32 33 34 def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key wrap_key ( plainkey ) \u00b6 Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) unwrap_key ( cipherkey ) \u00b6 Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) EdDsa \u00b6 Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate\\jwa\\signature\\eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False PublicKeyRequired \u00b6 Bases: AttributeError Raised when a cryptographic operation requires a public key, and a private key has been provided instead. Source code in jwskate\\jwa\\base.py 13 14 class PublicKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a public key, and a private key has been provided instead.\"\"\" BasePbes2 \u00b6 Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) __init__ ( password ) \u00b6 Initialize this alg with the given password. Parameters: Name Type Description Default password Union [ bytes , str ] the encryption/decryption password to use required Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 19 20 21 22 23 24 25 26 27 def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password generate_salt ( size = 12 ) \u00b6 Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) derive ( salt , count ) \u00b6 Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) wrap_key ( plainkey , salt , count ) \u00b6 Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) unwrap_key ( cipherkey , salt , count ) \u00b6 Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 78 79 80 81 82 83 84 85 86 87 88 89 90 def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) EcdhEs \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = asymmetric . ec . EllipticCurvePublicKey private_key_class = asymmetric . ec . EllipticCurvePrivateKey @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek otherinfo ( alg , apu , apv , keysize ) \u00b6 Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required keysize int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) ecdh ( private_key , public_key ) \u00b6 This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey a private EC key required public_key asymmetric . ec . EllipticCurvePublicKey a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) derive ( private_key , public_key , otherinfo , keysize ) \u00b6 Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey the private key required public_key asymmetric . ec . EllipticCurvePublicKey the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required keysize int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) generate_ephemeral_key () \u00b6 Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description asymmetric . ec . EllipticCurvePrivateKey a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 93 94 95 96 97 98 99 def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) sender_key ( ephemeral_private_key , alg , key_size , ** headers ) \u00b6 Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek recipient_key ( ephemeral_public_key , alg , key_size , ** headers ) \u00b6 Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek BaseAlg \u00b6 Base class for all algorithms. An algorithm has a name and a description , whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms Source code in jwskate\\jwa\\base.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class BaseAlg : \"\"\"Base class for all algorithms. An algorithm has a `name` and a `description`, whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms \"\"\" name : str \"\"\"Technical name of the algorithm\"\"\" description : str \"\"\"Description of the algorithm (human readable)\"\"\" read_only : bool = False \"\"\"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.\"\"\" def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name name : str = None class-attribute \u00b6 Technical name of the algorithm description : str = None class-attribute \u00b6 Description of the algorithm (human readable) read_only : bool = False class-attribute \u00b6 For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions. __repr__ () \u00b6 Use the name of the alg as repr. Source code in jwskate\\jwa\\base.py 30 31 32 def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name HS256 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-256 Source code in jwskate\\jwa\\signature\\hmac.py 31 32 33 34 35 36 37 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256\"\"\" name = \"HS256\" description = __doc__ hash_alg = hashes . SHA256 () min_key_size = 256 BaseSymmetricAlg \u00b6 Bases: BaseAlg Base class for Symmetric algorithms (using a raw bytes key). Source code in jwskate\\jwa\\base.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class BaseSymmetricAlg ( BaseAlg ): \"\"\"Base class for Symmetric algorithms (using a raw bytes key).\"\"\" def __init__ ( self , key : bytes ): \"\"\"Initialize a Symmetric alg with a given key. Args: key: the key to use for cryptographic operations \"\"\" self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False __init__ ( key ) \u00b6 Initialize a Symmetric alg with a given key. Parameters: Name Type Description Default key bytes the key to use for cryptographic operations required Source code in jwskate\\jwa\\base.py 38 39 40 41 42 43 44 45 def __init__ ( self , key : bytes ): \"\"\"Initialize a Symmetric alg with a given key. Args: key: the key to use for cryptographic operations \"\"\" self . check_key ( key ) self . key = key check_key ( key ) \u00b6 Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description None Returns None . Raises an exception if the key is not suitable Source code in jwskate\\jwa\\base.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass supports_key ( key ) \u00b6 Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate\\jwa\\base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False HS384 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-384 Source code in jwskate\\jwa\\signature\\hmac.py 40 41 42 43 44 45 46 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384\"\"\" name = \"HS384\" description = __doc__ hash_alg = hashes . SHA384 () min_key_size = 384 OKPCurve \u00b6 Represent an Octet Key Pair (OKP) Curve. Source code in jwskate\\jwa\\okp.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @dataclass class OKPCurve : \"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\" name : str \"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` headers.\"\"\" description : str \"\"\"Curve description (human readable).\"\"\" cryptography_private_key_class : Type [ Any ] \"\"\"`cryptography` private key class.\"\"\" cryptography_public_key_class : Type [ Any ] \"\"\"`cryptography` public key class.\"\"\" use : str \"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\" instances : ClassVar [ Dict [ str , OKPCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key(Union[PublicKeyProtocol, PrivateKeyProtocol]): `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" ) name : str = None class-attribute \u00b6 Curve name as defined in IANA JOSE . This name will appear in alg headers. description : str = None class-attribute \u00b6 Curve description (human readable). cryptography_private_key_class : Type [ Any ] = None class-attribute \u00b6 cryptography private key class. cryptography_public_key_class : Type [ Any ] = None class-attribute \u00b6 cryptography public key class. use : str = None class-attribute \u00b6 Curve usage ( 'sig' or ' enc' ). instances : ClassVar [ Dict [ str , OKPCurve ]] = {} class-attribute \u00b6 Registry of subclasses, in a {name: instance} mapping. __post_init__ () \u00b6 Automatically registers subclasses in the instance registry. Source code in jwskate\\jwa\\okp.py 67 68 69 def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self generate () \u00b6 Generate a new private key on this curve. Returns: Type Description Tuple [ bytes , bytes ] a tuple of x (public part), and d (private part), as bytes Source code in jwskate\\jwa\\okp.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d get_curve ( key ) \u00b6 Return the appropriate OKPCurve instance for a given cryptography private or public key. Parameters: Name Type Description Default key(Union[PublicKeyProtocol, PrivateKeyProtocol] cryptography private or public OKP key. required Returns: Name Type Description OKPCurve OKPCurve the appropriate OKPCurve for the given key Raises: Type Description NotImplementedError if the required OKP curve is not supported Source code in jwskate\\jwa\\okp.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key(Union[PublicKeyProtocol, PrivateKeyProtocol]): `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" ) A128GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 47 48 49 50 51 52 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128 HS512 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-512 Source code in jwskate\\jwa\\signature\\hmac.py 49 50 51 52 53 54 55 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512\"\"\" name = \"HS512\" description = __doc__ hash_alg = hashes . SHA512 () min_key_size = 512 A128KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 53 54 55 56 57 58 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128 A192GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 55 56 57 58 59 60 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192 ES256 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 58 59 60 61 62 63 64 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 () A192KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 61 62 63 64 65 66 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192 A128GCM \u00b6 Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 62 63 64 65 66 67 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128 A256GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 63 64 65 66 67 68 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256 RS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 65 66 67 68 69 70 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 () RsaEsPcks1v1_5 \u00b6 Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 66 67 68 69 70 71 72 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5\"\"\" name = \"RSA1_5\" description = __doc__ padding = padding . PKCS1v15 () ES384 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384 Source code in jwskate\\jwa\\signature\\ec.py 67 68 69 70 71 72 73 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 () A256KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 69 70 71 72 73 74 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256 A192GCM \u00b6 Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 70 71 72 73 74 75 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192 RS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 73 74 75 76 77 78 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 () RsaEsOaep \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using default parameters Source code in jwskate\\jwa\\key_mgmt\\rsa.py 75 76 77 78 79 80 81 82 83 84 85 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , ) ES512 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512 Source code in jwskate\\jwa\\signature\\ec.py 76 77 78 79 80 81 82 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 () A256GCM \u00b6 Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 78 79 80 81 82 83 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256 RS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 81 82 83 84 85 86 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 () BaseAsymmetricAlg \u00b6 Bases: Generic [ Kpriv , Kpub ] , BaseAlg Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Source code in jwskate\\jwa\\base.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class BaseAsymmetricAlg ( Generic [ Kpriv , Kpub ], BaseAlg ): \"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. \"\"\" private_key_class : Union [ Type [ Kpriv ], Tuple [ Type [ Kpriv ], ... ]] public_key_class : Union [ Type [ Kpub ], Tuple [ Type [ Kpub ], ... ]] def __init__ ( self , key : Union [ Kpriv , Kpub ]): \"\"\"Initialise an Asymmetric alg with either a private or a public key from the `cryptography` lib. Args: key: the key to use. \"\"\" self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore __init__ ( key ) \u00b6 Initialise an Asymmetric alg with either a private or a public key from the cryptography lib. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Source code in jwskate\\jwa\\base.py 95 96 97 98 99 100 101 102 def __init__ ( self , key : Union [ Kpriv , Kpub ]): \"\"\"Initialise an Asymmetric alg with either a private or a public key from the `cryptography` lib. Args: key: the key to use. \"\"\" self . check_key ( key ) self . key = key check_key ( key ) \u00b6 Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Returns: Type Description None Returns None. Raises an exception if the key is not suitable. Raises: Type Description Exception if the key is not suitable for use with this alg class Source code in jwskate\\jwa\\base.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" supports_key ( key ) \u00b6 Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate\\jwa\\base.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False private_key_required () \u00b6 A context manager that checks if this alg is initialised with a private key. Yields: Type Description Iterator [ Kpriv ] the private key Raises: Type Description PrivateKeyRequired if the configured key is not private Source code in jwskate\\jwa\\base.py 138 139 140 141 142 143 144 145 146 147 148 149 150 @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore public_key_required () \u00b6 A context manager that checks if this alg is initialised with a public key. Yields: Type Description Iterator [ Kpub ] The public key Raises: Type Description PublicKeyRequired if the configured key is private Source code in jwskate\\jwa\\base.py 152 153 154 155 156 157 158 159 160 161 162 163 164 @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore ES256K \u00b6 Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 85 86 87 88 89 90 91 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 () RsaEsOaepSha256 \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 88 89 90 91 92 93 94 95 96 97 98 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , ) PS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 89 90 91 92 93 94 95 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 ) Pbes2_HS256_A128KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 93 94 95 96 97 98 99 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 () PS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 98 99 100 101 102 103 104 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 ) RsaEsOaepSha384 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 101 102 103 104 105 106 107 108 109 110 111 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , ) Pbes2_HS384_A192KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 102 103 104 105 106 107 108 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 () PS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\signature\\rsa.py 107 108 109 110 111 112 113 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 ) Aes128CbcHmacSha256 \u00b6 Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 108 109 110 111 112 113 114 115 116 class Aes128CbcHmacSha256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 () Pbes2_HS512_A256KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 111 112 113 114 115 116 117 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 () RsaEsOaepSha512 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 114 115 116 117 118 119 120 121 122 123 124 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , ) Aes192CbcHmacSha384 \u00b6 Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 119 120 121 122 123 124 125 126 127 class Aes192CbcHmacSha384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 () Aes256CbcHmacSha512 \u00b6 Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 130 131 132 133 134 135 136 137 138 139 class Aes256CbcHmacSha512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 () BaseEcdhEs_AesKw \u00b6 Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) wrap_key_with_epk ( plainkey , ephemeral_private_key , ** headers ) \u00b6 Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) unwrap_key_with_epk ( cipherkey , ephemeral_public_key , ** headers ) \u00b6 Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey bytes the wrapped key required ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) BaseSignatureAlg \u00b6 Bases: BaseAlg Base class for signature algorithms. Source code in jwskate\\jwa\\base.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BaseSignatureAlg ( BaseAlg ): \"\"\"Base class for signature algorithms.\"\"\" def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError sign ( data ) \u00b6 Sign arbitrary data, return the signature. Parameters: Name Type Description Default data bytes raw data to sign required Returns: Type Description BinaPy the raw signature Source code in jwskate\\jwa\\base.py 170 171 172 173 174 175 176 177 178 179 def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError verify ( data , signature ) \u00b6 Verify a signature against some data. Parameters: Name Type Description Default data bytes the raw data to verify required signature bytes the raw signature required Returns: Type Description bool True if the signature matches, False otherwise. Source code in jwskate\\jwa\\base.py 181 182 183 184 185 186 187 188 189 190 191 def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError BaseAESEncryptionAlg \u00b6 Bases: BaseSymmetricAlg Base class for AES encryption algorithms. Source code in jwskate\\jwa\\base.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class BaseAESEncryptionAlg ( BaseSymmetricAlg ): \"\"\"Base class for AES encryption algorithms.\"\"\" key_size : int tag_size : int iv_size : int @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt auth_tag: the authentication tag iv: the Initialisation Vector to use. Must be the same one used during encryption aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError check_key ( key ) \u00b6 Check that a key is suitable for this algorithm. Parameters: Name Type Description Default key bytes the key to check required Raises: Type Description ValueError if the key is not suitable Source code in jwskate\\jwa\\base.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) generate_key () \u00b6 Generate a key of an appropriate size for this AES alg subclass. Returns: Type Description BinaPy a random AES key Source code in jwskate\\jwa\\base.py 216 217 218 219 220 221 222 223 @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) generate_iv () \u00b6 Generate an Initialisation Vector of the appropriate size. Returns: Type Description BinaPy a random IV Source code in jwskate\\jwa\\base.py 225 226 227 228 229 230 231 232 @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) encrypt ( plaintext , iv , aad ) \u00b6 Encrypt arbitrary data ( plaintext ) with the given Initialisation Vector ( iv ) and optional Additional Authentication Data ( aad ), return the ciphered text and authentication tag. Parameters: Name Type Description Default plaintext bytes the data to encrypt required iv bytes the Initialisation Vector to use required aad Optional [ bytes ] the Additional Authentication Data required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple of ciphered data and authentication tag Source code in jwskate\\jwa\\base.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError decrypt ( ciphertext , auth_tag , iv , aad ) \u00b6 Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required auth_tag bytes the authentication tag required iv bytes the Initialisation Vector to use. Must be the same one used during encryption required aad Optional [ bytes ] the Additional Authentication Data. Must be the same one used during encryption required Returns: Type Description BinaPy the deciphered data Source code in jwskate\\jwa\\base.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt auth_tag: the authentication tag iv: the Initialisation Vector to use. Must be the same one used during encryption aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError EcdhEs_A128KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 200 201 202 203 204 205 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW EcdhEs_A192KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 208 209 210 211 212 213 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW EcdhEs_A256KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 216 217 218 219 220 221 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW BaseKeyManagementAlg \u00b6 Bases: BaseAlg Base class for Key Management algorithms. Source code in jwskate\\jwa\\base.py 266 267 class BaseKeyManagementAlg ( BaseAlg ): \"\"\"Base class for Key Management algorithms.\"\"\" base \u00b6 This module implement base classes used by Signature, Encryption and Key Management JWA algorithms. PrivateKeyRequired \u00b6 Bases: AttributeError Raised when a cryptographic operation requires a private key, and a public key has been provided instead. Source code in jwskate\\jwa\\base.py 9 10 class PrivateKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a private key, and a public key has been provided instead.\"\"\" PublicKeyRequired \u00b6 Bases: AttributeError Raised when a cryptographic operation requires a public key, and a private key has been provided instead. Source code in jwskate\\jwa\\base.py 13 14 class PublicKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a public key, and a private key has been provided instead.\"\"\" BaseAlg \u00b6 Base class for all algorithms. An algorithm has a name and a description , whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms Source code in jwskate\\jwa\\base.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class BaseAlg : \"\"\"Base class for all algorithms. An algorithm has a `name` and a `description`, whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms \"\"\" name : str \"\"\"Technical name of the algorithm\"\"\" description : str \"\"\"Description of the algorithm (human readable)\"\"\" read_only : bool = False \"\"\"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.\"\"\" def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name name : str = None class-attribute \u00b6 Technical name of the algorithm description : str = None class-attribute \u00b6 Description of the algorithm (human readable) read_only : bool = False class-attribute \u00b6 For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions. __repr__ () \u00b6 Use the name of the alg as repr. Source code in jwskate\\jwa\\base.py 30 31 32 def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name BaseSymmetricAlg \u00b6 Bases: BaseAlg Base class for Symmetric algorithms (using a raw bytes key). Source code in jwskate\\jwa\\base.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class BaseSymmetricAlg ( BaseAlg ): \"\"\"Base class for Symmetric algorithms (using a raw bytes key).\"\"\" def __init__ ( self , key : bytes ): \"\"\"Initialize a Symmetric alg with a given key. Args: key: the key to use for cryptographic operations \"\"\" self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False __init__ ( key ) \u00b6 Initialize a Symmetric alg with a given key. Parameters: Name Type Description Default key bytes the key to use for cryptographic operations required Source code in jwskate\\jwa\\base.py 38 39 40 41 42 43 44 45 def __init__ ( self , key : bytes ): \"\"\"Initialize a Symmetric alg with a given key. Args: key: the key to use for cryptographic operations \"\"\" self . check_key ( key ) self . key = key check_key ( key ) \u00b6 Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description None Returns None . Raises an exception if the key is not suitable Source code in jwskate\\jwa\\base.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass supports_key ( key ) \u00b6 Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate\\jwa\\base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False BaseAsymmetricAlg \u00b6 Bases: Generic [ Kpriv , Kpub ] , BaseAlg Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Source code in jwskate\\jwa\\base.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class BaseAsymmetricAlg ( Generic [ Kpriv , Kpub ], BaseAlg ): \"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. \"\"\" private_key_class : Union [ Type [ Kpriv ], Tuple [ Type [ Kpriv ], ... ]] public_key_class : Union [ Type [ Kpub ], Tuple [ Type [ Kpub ], ... ]] def __init__ ( self , key : Union [ Kpriv , Kpub ]): \"\"\"Initialise an Asymmetric alg with either a private or a public key from the `cryptography` lib. Args: key: the key to use. \"\"\" self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore __init__ ( key ) \u00b6 Initialise an Asymmetric alg with either a private or a public key from the cryptography lib. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Source code in jwskate\\jwa\\base.py 95 96 97 98 99 100 101 102 def __init__ ( self , key : Union [ Kpriv , Kpub ]): \"\"\"Initialise an Asymmetric alg with either a private or a public key from the `cryptography` lib. Args: key: the key to use. \"\"\" self . check_key ( key ) self . key = key check_key ( key ) \u00b6 Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Returns: Type Description None Returns None. Raises an exception if the key is not suitable. Raises: Type Description Exception if the key is not suitable for use with this alg class Source code in jwskate\\jwa\\base.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" supports_key ( key ) \u00b6 Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate\\jwa\\base.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False private_key_required () \u00b6 A context manager that checks if this alg is initialised with a private key. Yields: Type Description Iterator [ Kpriv ] the private key Raises: Type Description PrivateKeyRequired if the configured key is not private Source code in jwskate\\jwa\\base.py 138 139 140 141 142 143 144 145 146 147 148 149 150 @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore public_key_required () \u00b6 A context manager that checks if this alg is initialised with a public key. Yields: Type Description Iterator [ Kpub ] The public key Raises: Type Description PublicKeyRequired if the configured key is private Source code in jwskate\\jwa\\base.py 152 153 154 155 156 157 158 159 160 161 162 163 164 @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore BaseSignatureAlg \u00b6 Bases: BaseAlg Base class for signature algorithms. Source code in jwskate\\jwa\\base.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BaseSignatureAlg ( BaseAlg ): \"\"\"Base class for signature algorithms.\"\"\" def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError sign ( data ) \u00b6 Sign arbitrary data, return the signature. Parameters: Name Type Description Default data bytes raw data to sign required Returns: Type Description BinaPy the raw signature Source code in jwskate\\jwa\\base.py 170 171 172 173 174 175 176 177 178 179 def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError verify ( data , signature ) \u00b6 Verify a signature against some data. Parameters: Name Type Description Default data bytes the raw data to verify required signature bytes the raw signature required Returns: Type Description bool True if the signature matches, False otherwise. Source code in jwskate\\jwa\\base.py 181 182 183 184 185 186 187 188 189 190 191 def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError BaseAESEncryptionAlg \u00b6 Bases: BaseSymmetricAlg Base class for AES encryption algorithms. Source code in jwskate\\jwa\\base.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class BaseAESEncryptionAlg ( BaseSymmetricAlg ): \"\"\"Base class for AES encryption algorithms.\"\"\" key_size : int tag_size : int iv_size : int @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt auth_tag: the authentication tag iv: the Initialisation Vector to use. Must be the same one used during encryption aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError check_key ( key ) \u00b6 Check that a key is suitable for this algorithm. Parameters: Name Type Description Default key bytes the key to check required Raises: Type Description ValueError if the key is not suitable Source code in jwskate\\jwa\\base.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) generate_key () \u00b6 Generate a key of an appropriate size for this AES alg subclass. Returns: Type Description BinaPy a random AES key Source code in jwskate\\jwa\\base.py 216 217 218 219 220 221 222 223 @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) generate_iv () \u00b6 Generate an Initialisation Vector of the appropriate size. Returns: Type Description BinaPy a random IV Source code in jwskate\\jwa\\base.py 225 226 227 228 229 230 231 232 @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) encrypt ( plaintext , iv , aad ) \u00b6 Encrypt arbitrary data ( plaintext ) with the given Initialisation Vector ( iv ) and optional Additional Authentication Data ( aad ), return the ciphered text and authentication tag. Parameters: Name Type Description Default plaintext bytes the data to encrypt required iv bytes the Initialisation Vector to use required aad Optional [ bytes ] the Additional Authentication Data required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple of ciphered data and authentication tag Source code in jwskate\\jwa\\base.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError decrypt ( ciphertext , auth_tag , iv , aad ) \u00b6 Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required auth_tag bytes the authentication tag required iv bytes the Initialisation Vector to use. Must be the same one used during encryption required aad Optional [ bytes ] the Additional Authentication Data. Must be the same one used during encryption required Returns: Type Description BinaPy the deciphered data Source code in jwskate\\jwa\\base.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt auth_tag: the authentication tag iv: the Initialisation Vector to use. Must be the same one used during encryption aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError BaseKeyManagementAlg \u00b6 Bases: BaseAlg Base class for Key Management algorithms. Source code in jwskate\\jwa\\base.py 266 267 class BaseKeyManagementAlg ( BaseAlg ): \"\"\"Base class for Key Management algorithms.\"\"\" ec \u00b6 This module contains classes that describe Elliptic Curves as described in RFC7518. P_256 = EllipticCurve ( name = 'P-256' , cryptography_curve = ec . SECP256R1 (), coordinate_size = 32 ) module-attribute \u00b6 P-256 curve P_384 = EllipticCurve ( name = 'P-384' , cryptography_curve = ec . SECP384R1 (), coordinate_size = 48 ) module-attribute \u00b6 P-384 curve P_521 = EllipticCurve ( name = 'P-521' , cryptography_curve = ec . SECP521R1 (), coordinate_size = 66 ) module-attribute \u00b6 P-521 curve secp256k1 = EllipticCurve ( name = 'secp256k1' , cryptography_curve = ec . SECP256K1 (), coordinate_size = 32 ) module-attribute \u00b6 secp256k1 curve EllipticCurve \u00b6 A descriptive class for Elliptic Curves. Elliptic Curves have a name, a cryptography.ec.EllipticCurve , and a coordinate size. Source code in jwskate\\jwa\\ec.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class EllipticCurve : \"\"\"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size. \"\"\" name : str \"\"\" Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` or `enc` fields in JOSE headers.\"\"\" cryptography_curve : ec . EllipticCurve \"\"\"`cryptography` curve instance.\"\"\" coordinate_size : int \"\"\"Coordinate size, in bytes.\"\"\" instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey]): an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) @classmethod def get_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a tuple of `x`, `y` (public coordinates) and `d` (private key), as `int` Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = ( BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) y = ( BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters name : str = None class-attribute \u00b6 Curve name as defined in IANA JOSE . This name will appear in alg or enc fields in JOSE headers. cryptography_curve : ec . EllipticCurve = None class-attribute \u00b6 cryptography curve instance. coordinate_size : int = None class-attribute \u00b6 Coordinate size, in bytes. instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} class-attribute \u00b6 Registry of subclasses, in a {name: instance} mapping. __post_init__ () \u00b6 Automatically register subclasses in the instance registry. Source code in jwskate\\jwa\\ec.py 34 35 36 def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self generate () \u00b6 Generate a new EC key on this curve. Returns: Type Description Tuple [ int , int , int ] a tuple of 4 int s: x and y coordinates (public key) and d (private key) Source code in jwskate\\jwa\\ec.py 38 39 40 41 42 43 44 45 46 47 48 49 def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d get_curve ( key ) \u00b6 Get the appropriate EllipticCurve instance for a given cryptography EllipticCurvePublicKey . Parameters: Name Type Description Default key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey] an Elliptic Curve private or public key from cryptography . required Returns: Type Description 'EllipticCurve' the appropriate instance of EllipticCurve for the given key. Raises: Type Description NotImplementedError if the curve is not supported Source code in jwskate\\jwa\\ec.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey]): an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) get_parameters ( key ) \u00b6 Extract all private and public parameters from a given cryptography EllipticCurvePrivateKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] an Elliptic Curve public or private key from cryptography . required Returns: Type Description Dict [ str , Any ] a tuple of x , y (public coordinates) and d (private key), as int Raises: Type Description TypeError if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey Source code in jwskate\\jwa\\ec.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @classmethod def get_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a tuple of `x`, `y` (public coordinates) and `d` (private key), as `int` Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = ( BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) y = ( BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters okp \u00b6 This module contains classes that describe CFRG Elliptic Curve Diffie- Hellman algorithms as specified in RFC8037. Ed25519 = OKPCurve ( name = 'Ed25519' , description = 'Ed25519 signature algorithm key pairs' , cryptography_private_key_class = ed25519 . Ed25519PrivateKey , cryptography_public_key_class = ed25519 . Ed25519PublicKey , use = 'sig' ) module-attribute \u00b6 Ed25519 curve. Ed448 = OKPCurve ( name = 'Ed448' , description = 'Ed448 signature algorithm key pairs' , cryptography_private_key_class = ed448 . Ed448PrivateKey , cryptography_public_key_class = ed448 . Ed448PublicKey , use = 'sig' ) module-attribute \u00b6 Ed448 curve. X25519 = OKPCurve ( name = 'X25519' , description = 'X25519 function key pairs' , cryptography_private_key_class = x25519 . X25519PrivateKey , cryptography_public_key_class = x25519 . X25519PublicKey , use = 'enc' ) module-attribute \u00b6 X25519 curve. X448 = OKPCurve ( name = 'X448' , description = 'X448 function key pairs' , cryptography_private_key_class = x448 . X448PrivateKey , cryptography_public_key_class = x448 . X448PublicKey , use = 'enc' ) module-attribute \u00b6 X448 curve. OKPCurve \u00b6 Represent an Octet Key Pair (OKP) Curve. Source code in jwskate\\jwa\\okp.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @dataclass class OKPCurve : \"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\" name : str \"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` headers.\"\"\" description : str \"\"\"Curve description (human readable).\"\"\" cryptography_private_key_class : Type [ Any ] \"\"\"`cryptography` private key class.\"\"\" cryptography_public_key_class : Type [ Any ] \"\"\"`cryptography` public key class.\"\"\" use : str \"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\" instances : ClassVar [ Dict [ str , OKPCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key(Union[PublicKeyProtocol, PrivateKeyProtocol]): `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" ) name : str = None class-attribute \u00b6 Curve name as defined in IANA JOSE . This name will appear in alg headers. description : str = None class-attribute \u00b6 Curve description (human readable). cryptography_private_key_class : Type [ Any ] = None class-attribute \u00b6 cryptography private key class. cryptography_public_key_class : Type [ Any ] = None class-attribute \u00b6 cryptography public key class. use : str = None class-attribute \u00b6 Curve usage ( 'sig' or ' enc' ). instances : ClassVar [ Dict [ str , OKPCurve ]] = {} class-attribute \u00b6 Registry of subclasses, in a {name: instance} mapping. __post_init__ () \u00b6 Automatically registers subclasses in the instance registry. Source code in jwskate\\jwa\\okp.py 67 68 69 def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self generate () \u00b6 Generate a new private key on this curve. Returns: Type Description Tuple [ bytes , bytes ] a tuple of x (public part), and d (private part), as bytes Source code in jwskate\\jwa\\okp.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d get_curve ( key ) \u00b6 Return the appropriate OKPCurve instance for a given cryptography private or public key. Parameters: Name Type Description Default key(Union[PublicKeyProtocol, PrivateKeyProtocol] cryptography private or public OKP key. required Returns: Name Type Description OKPCurve OKPCurve the appropriate OKPCurve for the given key Raises: Type Description NotImplementedError if the required OKP curve is not supported Source code in jwskate\\jwa\\okp.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key(Union[PublicKeyProtocol, PrivateKeyProtocol]): `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" ) encryption \u00b6 This module exposes the Encryption algorithms that are available in jwskate . A128GCM \u00b6 Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 62 63 64 65 66 67 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128 A192GCM \u00b6 Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 70 71 72 73 74 75 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192 A256GCM \u00b6 Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 78 79 80 81 82 83 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256 Aes128CbcHmacSha256 \u00b6 Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 108 109 110 111 112 113 114 115 116 class Aes128CbcHmacSha256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 () Aes192CbcHmacSha384 \u00b6 Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 119 120 121 122 123 124 125 126 127 class Aes192CbcHmacSha384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 () Aes256CbcHmacSha512 \u00b6 Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 130 131 132 133 134 135 136 137 138 139 class Aes256CbcHmacSha512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 () aescbchmac \u00b6 This module implements AES-CBC with HMAC-SHA based Encryption algorithms. BaseAesCbcHmacSha2 \u00b6 Bases: BaseAESEncryptionAlg Implements the family of AES-CBC with HMAC-SHA encryption algorithms. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class BaseAesCbcHmacSha2 ( BaseAESEncryptionAlg ): \"\"\"Implements the family of AES-CBC with HMAC-SHA encryption algorithms.\"\"\" mac_key_size : int \"\"\"Required key size for the Hash algorithm, in bits.\"\"\" aes_key_size : int \"\"\"Required key size for the AES algorithm, in bits.\"\"\" iv_size : int = 128 \"\"\"Initialization Vector size for the AES algorithm, in bits.\"\"\" hash_alg : hashes . HashAlgorithm \"\"\"Hash algorithm to use.\"\"\" def __init_subclass__ ( cls ) -> None : \"\"\"This automatically sets the total key size based on the MAC and AES key sizes.\"\"\" cls . key_size = cls . mac_key_size + cls . aes_key_size def __init__ ( self , key : bytes ) -> None : \"\"\"Initialize this wrapper with the given key. Args: key: the key to use for encryption and decryption. \"\"\" super () . __init__ ( key ) self . mac_key = self . key [: self . mac_key_size // 8 ] self . aes_key = self . key [ self . mac_key_size // 8 :] self . padding = padding . PKCS7 ( algorithms . AES . block_size ) def mac ( self , ciphertext : bytes , iv : bytes , aad : Optional [ bytes ] = None ) -> BinaPy : \"\"\"Produce a Message Authentication Code for the given `ciphertext`, `iv` and `aad`. Args: ciphertext: the ciphertext iv: the Initialization Vector aad: the Additional Authenticated data Returns: the resulting MAC. \"\"\" if aad is None : aad = b \"\" al = BinaPy . from_int ( len ( aad ) * 8 , length = 8 , byteorder = \"big\" , signed = False ) hasher = hmac . HMAC ( self . mac_key , self . hash_alg ) for param in ( aad , iv , ciphertext , al ): hasher . update ( param ) digest = hasher . finalize () mac = digest [: self . tag_size ] return BinaPy ( mac ) def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] = None ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt and MAC the given `plaintext`, using the given Initialization Vector (`iv`) and optional Additional Authenticated Data (`aad`). Args: plaintext: the plain data to encrypt iv: the Initialization Vector aad: the Additional Authenticated Data, if any Returns: a tuple (encrypted_data, authentication_tag) \"\"\" cipher = ciphers . Cipher ( algorithms . AES ( self . aes_key ), modes . CBC ( iv )) . encryptor () padder = self . padding . padder () padded_text = padder . update ( plaintext ) + padder . finalize () ciphertext = cipher . update ( padded_text ) + cipher . finalize () mac = self . mac ( ciphertext , iv , aad ) return BinaPy ( ciphertext ), BinaPy ( mac ) def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt and authenticate the given ciphertext with authentication tag (`ciphertext_with_tag`), as produced by `encrypt()`. Args: ciphertext: the ciphertext auth_tag: the authentication tag iv: the Initialization Vector aad: the Additional Authenticated Data, if any Returns: the decrypted data \"\"\" mac = self . mac ( ciphertext , iv , aad ) if not constant_time . bytes_eq ( mac , auth_tag ): raise exceptions . InvalidSignature () cipher = ciphers . Cipher ( algorithms . AES ( self . aes_key ), modes . CBC ( iv )) . decryptor () padded_text = cipher . update ( ciphertext ) + cipher . finalize () unpadder = self . padding . unpadder () return BinaPy ( unpadder . update ( padded_text ) + unpadder . finalize ()) mac_key_size : int = None class-attribute \u00b6 Required key size for the Hash algorithm, in bits. aes_key_size : int = None class-attribute \u00b6 Required key size for the AES algorithm, in bits. iv_size : int = 128 class-attribute \u00b6 Initialization Vector size for the AES algorithm, in bits. hash_alg : hashes . HashAlgorithm = None class-attribute \u00b6 Hash algorithm to use. __init_subclass__ () \u00b6 This automatically sets the total key size based on the MAC and AES key sizes. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 28 29 30 def __init_subclass__ ( cls ) -> None : \"\"\"This automatically sets the total key size based on the MAC and AES key sizes.\"\"\" cls . key_size = cls . mac_key_size + cls . aes_key_size __init__ ( key ) \u00b6 Initialize this wrapper with the given key. Parameters: Name Type Description Default key bytes the key to use for encryption and decryption. required Source code in jwskate\\jwa\\encryption\\aescbchmac.py 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , key : bytes ) -> None : \"\"\"Initialize this wrapper with the given key. Args: key: the key to use for encryption and decryption. \"\"\" super () . __init__ ( key ) self . mac_key = self . key [: self . mac_key_size // 8 ] self . aes_key = self . key [ self . mac_key_size // 8 :] self . padding = padding . PKCS7 ( algorithms . AES . block_size ) mac ( ciphertext , iv , aad = None ) \u00b6 Produce a Message Authentication Code for the given ciphertext , iv and aad . Parameters: Name Type Description Default ciphertext bytes the ciphertext required iv bytes the Initialization Vector required aad Optional [ bytes ] the Additional Authenticated data None Returns: Type Description BinaPy the resulting MAC. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def mac ( self , ciphertext : bytes , iv : bytes , aad : Optional [ bytes ] = None ) -> BinaPy : \"\"\"Produce a Message Authentication Code for the given `ciphertext`, `iv` and `aad`. Args: ciphertext: the ciphertext iv: the Initialization Vector aad: the Additional Authenticated data Returns: the resulting MAC. \"\"\" if aad is None : aad = b \"\" al = BinaPy . from_int ( len ( aad ) * 8 , length = 8 , byteorder = \"big\" , signed = False ) hasher = hmac . HMAC ( self . mac_key , self . hash_alg ) for param in ( aad , iv , ciphertext , al ): hasher . update ( param ) digest = hasher . finalize () mac = digest [: self . tag_size ] return BinaPy ( mac ) encrypt ( plaintext , iv , aad = None ) \u00b6 Encrypt and MAC the given plaintext , using the given Initialization Vector ( iv ) and optional Additional Authenticated Data ( aad ). Parameters: Name Type Description Default plaintext bytes the plain data to encrypt required iv bytes the Initialization Vector required aad Optional [ bytes ] the Additional Authenticated Data, if any None Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (encrypted_data, authentication_tag) Source code in jwskate\\jwa\\encryption\\aescbchmac.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] = None ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt and MAC the given `plaintext`, using the given Initialization Vector (`iv`) and optional Additional Authenticated Data (`aad`). Args: plaintext: the plain data to encrypt iv: the Initialization Vector aad: the Additional Authenticated Data, if any Returns: a tuple (encrypted_data, authentication_tag) \"\"\" cipher = ciphers . Cipher ( algorithms . AES ( self . aes_key ), modes . CBC ( iv )) . encryptor () padder = self . padding . padder () padded_text = padder . update ( plaintext ) + padder . finalize () ciphertext = cipher . update ( padded_text ) + cipher . finalize () mac = self . mac ( ciphertext , iv , aad ) return BinaPy ( ciphertext ), BinaPy ( mac ) decrypt ( ciphertext , auth_tag , iv , aad ) \u00b6 Decrypt and authenticate the given ciphertext with authentication tag ( ciphertext_with_tag ), as produced by encrypt() . Parameters: Name Type Description Default ciphertext bytes the ciphertext required auth_tag bytes the authentication tag required iv bytes the Initialization Vector required aad Optional [ bytes ] the Additional Authenticated Data, if any required Returns: Type Description BinaPy the decrypted data Source code in jwskate\\jwa\\encryption\\aescbchmac.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt and authenticate the given ciphertext with authentication tag (`ciphertext_with_tag`), as produced by `encrypt()`. Args: ciphertext: the ciphertext auth_tag: the authentication tag iv: the Initialization Vector aad: the Additional Authenticated Data, if any Returns: the decrypted data \"\"\" mac = self . mac ( ciphertext , iv , aad ) if not constant_time . bytes_eq ( mac , auth_tag ): raise exceptions . InvalidSignature () cipher = ciphers . Cipher ( algorithms . AES ( self . aes_key ), modes . CBC ( iv )) . decryptor () padded_text = cipher . update ( ciphertext ) + cipher . finalize () unpadder = self . padding . unpadder () return BinaPy ( unpadder . update ( padded_text ) + unpadder . finalize ()) Aes128CbcHmacSha256 \u00b6 Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 108 109 110 111 112 113 114 115 116 class Aes128CbcHmacSha256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 () Aes192CbcHmacSha384 \u00b6 Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 119 120 121 122 123 124 125 126 127 class Aes192CbcHmacSha384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 () Aes256CbcHmacSha512 \u00b6 Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 130 131 132 133 134 135 136 137 138 139 class Aes256CbcHmacSha512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 () aesgcm \u00b6 This module implements AES-GCM based encryption algorithms. BaseAESGCM \u00b6 Bases: BaseAESEncryptionAlg Base class for AES-GCM encryption algorithms. Source code in jwskate\\jwa\\encryption\\aesgcm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class BaseAESGCM ( BaseAESEncryptionAlg ): \"\"\"Base class for AES-GCM encryption algorithms.\"\"\" iv_size = 96 tag_size = 16 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with the given IV and Additional Authenticated Data.\". Args: plaintext: the data to encrypt iv: the IV to use aad: Additional Authenticated Data, if any Returns: a (ciphertext, authentication_tag) tuple Raises: ValueError: if the IV size is not appropriate \"\"\" if len ( iv ) * 8 != self . iv_size : raise ValueError ( f \"Invalid IV size, must be { self . iv_size } bits\" ) ciphertext_with_tag = BinaPy ( aead . AESGCM ( self . key ) . encrypt ( iv , plaintext , aad )) ciphertext , tag = ciphertext_with_tag . cut_at ( - self . tag_size ) return ciphertext , tag def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext. Args: ciphertext: the data to decrypt auth_tag: the Authentication Tag iv: the Initialization Vector aad: the Additional Authentication Tag Returns: the decrypted data Raises: ValueError: if the IV size is not appropriate \"\"\" if len ( iv ) * 8 != self . iv_size : raise ValueError ( f \"Invalid IV size, must be { self . iv_size } bits\" ) ciphertext_with_tag = ciphertext + auth_tag return BinaPy ( aead . AESGCM ( self . key ) . decrypt ( iv , ciphertext_with_tag , aad )) encrypt ( plaintext , iv , aad ) \u00b6 Encrypt a plaintext, with the given IV and Additional Authenticated Data.\". Parameters: Name Type Description Default plaintext bytes the data to encrypt required iv bytes the IV to use required aad Optional [ bytes ] Additional Authenticated Data, if any required Returns: Type Description Tuple [ BinaPy , BinaPy ] a (ciphertext, authentication_tag) tuple Raises: Type Description ValueError if the IV size is not appropriate Source code in jwskate\\jwa\\encryption\\aesgcm.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with the given IV and Additional Authenticated Data.\". Args: plaintext: the data to encrypt iv: the IV to use aad: Additional Authenticated Data, if any Returns: a (ciphertext, authentication_tag) tuple Raises: ValueError: if the IV size is not appropriate \"\"\" if len ( iv ) * 8 != self . iv_size : raise ValueError ( f \"Invalid IV size, must be { self . iv_size } bits\" ) ciphertext_with_tag = BinaPy ( aead . AESGCM ( self . key ) . encrypt ( iv , plaintext , aad )) ciphertext , tag = ciphertext_with_tag . cut_at ( - self . tag_size ) return ciphertext , tag decrypt ( ciphertext , auth_tag , iv , aad ) \u00b6 Decrypt a ciphertext. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required auth_tag bytes the Authentication Tag required iv bytes the Initialization Vector required aad Optional [ bytes ] the Additional Authentication Tag required Returns: Type Description BinaPy the decrypted data Raises: Type Description ValueError if the IV size is not appropriate Source code in jwskate\\jwa\\encryption\\aesgcm.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext. Args: ciphertext: the data to decrypt auth_tag: the Authentication Tag iv: the Initialization Vector aad: the Additional Authentication Tag Returns: the decrypted data Raises: ValueError: if the IV size is not appropriate \"\"\" if len ( iv ) * 8 != self . iv_size : raise ValueError ( f \"Invalid IV size, must be { self . iv_size } bits\" ) ciphertext_with_tag = ciphertext + auth_tag return BinaPy ( aead . AESGCM ( self . key ) . decrypt ( iv , ciphertext_with_tag , aad )) A128GCM \u00b6 Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 62 63 64 65 66 67 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128 A192GCM \u00b6 Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 70 71 72 73 74 75 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192 A256GCM \u00b6 Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 78 79 80 81 82 83 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256 key_mgmt \u00b6 This module exposes all Key Management algorithms available in jwskate . BaseAesKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Base class for AES KW algorithms. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class BaseAesKeyWrap ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Base class for AES KW algorithms.\"\"\" key_size : int \"\"\"Required AES key size in bits.\"\"\" @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) key_size : int = None class-attribute \u00b6 Required AES key size in bits. check_key ( key ) \u00b6 Check that a key is valid for usage with this algorithm. To be valid, a key must be bytes and be of appropriate length (128, 192 or 256 bits). Parameters: Name Type Description Default key bytes a key to check required Raises: Type Description ValueError if the key is not appropriate Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) wrap_key ( plainkey ) \u00b6 Wrap a key. Parameters: Name Type Description Default plainkey bytes the key to wrap. required Returns: Name Type Description BinaPy BinaPy the wrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 30 31 32 33 34 35 36 37 38 39 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) unwrap_key ( cipherkey ) \u00b6 Unwrap a key. Parameters: Name Type Description Default cipherkey bytes the wrapped key. required Returns: Name Type Description BinaPy BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 41 42 43 44 45 46 47 48 49 50 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) DirectKeyUse \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate\\jwa\\key_mgmt\\dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) direct_key ( aesalg ) \u00b6 Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate\\jwa\\key_mgmt\\dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) BaseAesGcmKeyWrap \u00b6 Bases: BaseAESGCM , BaseKeyManagementAlg Base class for AES-GCM Key wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class BaseAesGcmKeyWrap ( BaseAESGCM , BaseKeyManagementAlg ): \"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\" key_size : int \"\"\"Required key size, in bits.\"\"\" tag_size : int = 16 \"\"\"Authentication tag size, in bits.\"\"\" iv_size : int = 96 \"\"\"Initialisation Vector size, in bits.\"\"\" def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" ) key_size : int = None class-attribute \u00b6 Required key size, in bits. tag_size : int = 16 class-attribute \u00b6 Authentication tag size, in bits. iv_size : int = 96 class-attribute \u00b6 Initialisation Vector size, in bits. wrap_key ( plainkey , iv ) \u00b6 Wrap a key using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default plainkey bytes the key to wrap required iv bytes the Initialisation Vector to use required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (wrapped_key, authentication_tag) Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 21 22 23 24 25 26 27 28 29 30 31 def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) unwrap_key ( cipherkey , tag , iv ) \u00b6 Unwrap a key and authenticates it with the authentication tag , using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default cipherkey bytes the wrapped key required tag bytes the authentication tag required iv bytes the Initialisation Vector required Returns: Type Description BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 33 34 35 36 37 38 39 40 41 42 43 44 def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" ) BaseRsaKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms.\"\"\" padding : Any name = \"RSA1_5\" description = \"RSAES-PKCS1-v1_5\" private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) __init__ ( key ) \u00b6 Initialize an alg with a given RSA key. Parameters: Name Type Description Default key Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate\\jwa\\key_mgmt\\rsa.py 26 27 28 29 30 31 32 33 34 def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key wrap_key ( plainkey ) \u00b6 Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) unwrap_key ( cipherkey ) \u00b6 Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) EcdhEs \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = asymmetric . ec . EllipticCurvePublicKey private_key_class = asymmetric . ec . EllipticCurvePrivateKey @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek otherinfo ( alg , apu , apv , keysize ) \u00b6 Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required keysize int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) ecdh ( private_key , public_key ) \u00b6 This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey a private EC key required public_key asymmetric . ec . EllipticCurvePublicKey a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) derive ( private_key , public_key , otherinfo , keysize ) \u00b6 Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey the private key required public_key asymmetric . ec . EllipticCurvePublicKey the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required keysize int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) generate_ephemeral_key () \u00b6 Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description asymmetric . ec . EllipticCurvePrivateKey a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 93 94 95 96 97 98 99 def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) sender_key ( ephemeral_private_key , alg , key_size , ** headers ) \u00b6 Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek recipient_key ( ephemeral_public_key , alg , key_size , ** headers ) \u00b6 Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek BasePbes2 \u00b6 Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) __init__ ( password ) \u00b6 Initialize this alg with the given password. Parameters: Name Type Description Default password Union [ bytes , str ] the encryption/decryption password to use required Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 19 20 21 22 23 24 25 26 27 def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password generate_salt ( size = 12 ) \u00b6 Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) derive ( salt , count ) \u00b6 Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) wrap_key ( plainkey , salt , count ) \u00b6 Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) unwrap_key ( cipherkey , salt , count ) \u00b6 Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 78 79 80 81 82 83 84 85 86 87 88 89 90 def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) A128GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 47 48 49 50 51 52 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128 A128KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 53 54 55 56 57 58 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128 A192GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 55 56 57 58 59 60 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192 A192KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 61 62 63 64 65 66 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192 A256GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 63 64 65 66 67 68 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256 RsaEsPcks1v1_5 \u00b6 Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 66 67 68 69 70 71 72 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5\"\"\" name = \"RSA1_5\" description = __doc__ padding = padding . PKCS1v15 () A256KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 69 70 71 72 73 74 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256 RsaEsOaep \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using default parameters Source code in jwskate\\jwa\\key_mgmt\\rsa.py 75 76 77 78 79 80 81 82 83 84 85 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , ) RsaEsOaepSha256 \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 88 89 90 91 92 93 94 95 96 97 98 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , ) Pbes2_HS256_A128KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 93 94 95 96 97 98 99 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 () RsaEsOaepSha384 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 101 102 103 104 105 106 107 108 109 110 111 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , ) Pbes2_HS384_A192KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 102 103 104 105 106 107 108 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 () Pbes2_HS512_A256KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 111 112 113 114 115 116 117 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 () RsaEsOaepSha512 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 114 115 116 117 118 119 120 121 122 123 124 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , ) BaseEcdhEs_AesKw \u00b6 Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) wrap_key_with_epk ( plainkey , ephemeral_private_key , ** headers ) \u00b6 Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) unwrap_key_with_epk ( cipherkey , ephemeral_public_key , ** headers ) \u00b6 Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey bytes the wrapped key required ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) EcdhEs_A128KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 200 201 202 203 204 205 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW EcdhEs_A192KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 208 209 210 211 212 213 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW EcdhEs_A256KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 216 217 218 219 220 221 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW aesgcmkw \u00b6 This module implements AES-GCM based Key Management algorithms. BaseAesGcmKeyWrap \u00b6 Bases: BaseAESGCM , BaseKeyManagementAlg Base class for AES-GCM Key wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class BaseAesGcmKeyWrap ( BaseAESGCM , BaseKeyManagementAlg ): \"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\" key_size : int \"\"\"Required key size, in bits.\"\"\" tag_size : int = 16 \"\"\"Authentication tag size, in bits.\"\"\" iv_size : int = 96 \"\"\"Initialisation Vector size, in bits.\"\"\" def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" ) key_size : int = None class-attribute \u00b6 Required key size, in bits. tag_size : int = 16 class-attribute \u00b6 Authentication tag size, in bits. iv_size : int = 96 class-attribute \u00b6 Initialisation Vector size, in bits. wrap_key ( plainkey , iv ) \u00b6 Wrap a key using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default plainkey bytes the key to wrap required iv bytes the Initialisation Vector to use required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (wrapped_key, authentication_tag) Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 21 22 23 24 25 26 27 28 29 30 31 def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) unwrap_key ( cipherkey , tag , iv ) \u00b6 Unwrap a key and authenticates it with the authentication tag , using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default cipherkey bytes the wrapped key required tag bytes the authentication tag required iv bytes the Initialisation Vector required Returns: Type Description BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 33 34 35 36 37 38 39 40 41 42 43 44 def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" ) A128GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 47 48 49 50 51 52 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128 A192GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 55 56 57 58 59 60 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192 A256GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 63 64 65 66 67 68 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256 aeskw \u00b6 This module implements AES based Key Management algorithms. BaseAesKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Base class for AES KW algorithms. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class BaseAesKeyWrap ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Base class for AES KW algorithms.\"\"\" key_size : int \"\"\"Required AES key size in bits.\"\"\" @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) key_size : int = None class-attribute \u00b6 Required AES key size in bits. check_key ( key ) \u00b6 Check that a key is valid for usage with this algorithm. To be valid, a key must be bytes and be of appropriate length (128, 192 or 256 bits). Parameters: Name Type Description Default key bytes a key to check required Raises: Type Description ValueError if the key is not appropriate Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) wrap_key ( plainkey ) \u00b6 Wrap a key. Parameters: Name Type Description Default plainkey bytes the key to wrap. required Returns: Name Type Description BinaPy BinaPy the wrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 30 31 32 33 34 35 36 37 38 39 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) unwrap_key ( cipherkey ) \u00b6 Unwrap a key. Parameters: Name Type Description Default cipherkey bytes the wrapped key. required Returns: Name Type Description BinaPy BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 41 42 43 44 45 46 47 48 49 50 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) A128KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 53 54 55 56 57 58 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128 A192KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 61 62 63 64 65 66 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192 A256KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 69 70 71 72 73 74 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256 dir \u00b6 This module implements direct use of a shared symmetric key as Key Management algorithm. DirectKeyUse \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate\\jwa\\key_mgmt\\dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) direct_key ( aesalg ) \u00b6 Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate\\jwa\\key_mgmt\\dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) ecdh \u00b6 This module implements Elliptic Curve Diffie-Hellman based Key Management algorithms. EcdhEs \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = asymmetric . ec . EllipticCurvePublicKey private_key_class = asymmetric . ec . EllipticCurvePrivateKey @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek otherinfo ( alg , apu , apv , keysize ) \u00b6 Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required keysize int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) ecdh ( private_key , public_key ) \u00b6 This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey a private EC key required public_key asymmetric . ec . EllipticCurvePublicKey a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) derive ( private_key , public_key , otherinfo , keysize ) \u00b6 Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey the private key required public_key asymmetric . ec . EllipticCurvePublicKey the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required keysize int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) generate_ephemeral_key () \u00b6 Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description asymmetric . ec . EllipticCurvePrivateKey a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 93 94 95 96 97 98 99 def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) sender_key ( ephemeral_private_key , alg , key_size , ** headers ) \u00b6 Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek recipient_key ( ephemeral_public_key , alg , key_size , ** headers ) \u00b6 Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek BaseEcdhEs_AesKw \u00b6 Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) wrap_key_with_epk ( plainkey , ephemeral_private_key , ** headers ) \u00b6 Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) unwrap_key_with_epk ( cipherkey , ephemeral_public_key , ** headers ) \u00b6 Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey bytes the wrapped key required ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) EcdhEs_A128KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 200 201 202 203 204 205 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW EcdhEs_A192KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 208 209 210 211 212 213 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW EcdhEs_A256KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 216 217 218 219 220 221 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW pbes2 \u00b6 This module implements password-based Key Management Algorithms relying on PBES2. BasePbes2 \u00b6 Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) __init__ ( password ) \u00b6 Initialize this alg with the given password. Parameters: Name Type Description Default password Union [ bytes , str ] the encryption/decryption password to use required Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 19 20 21 22 23 24 25 26 27 def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password generate_salt ( size = 12 ) \u00b6 Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) derive ( salt , count ) \u00b6 Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) wrap_key ( plainkey , salt , count ) \u00b6 Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) unwrap_key ( cipherkey , salt , count ) \u00b6 Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 78 79 80 81 82 83 84 85 86 87 88 89 90 def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) Pbes2_HS256_A128KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 93 94 95 96 97 98 99 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 () Pbes2_HS384_A192KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 102 103 104 105 106 107 108 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 () Pbes2_HS512_A256KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 111 112 113 114 115 116 117 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 () rsa \u00b6 This module implements RSA based Key Management algorithms. BaseRsaKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms.\"\"\" padding : Any name = \"RSA1_5\" description = \"RSAES-PKCS1-v1_5\" private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) __init__ ( key ) \u00b6 Initialize an alg with a given RSA key. Parameters: Name Type Description Default key Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate\\jwa\\key_mgmt\\rsa.py 26 27 28 29 30 31 32 33 34 def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key wrap_key ( plainkey ) \u00b6 Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) unwrap_key ( cipherkey ) \u00b6 Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) RsaEsPcks1v1_5 \u00b6 Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 66 67 68 69 70 71 72 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5\"\"\" name = \"RSA1_5\" description = __doc__ padding = padding . PKCS1v15 () RsaEsOaep \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using default parameters Source code in jwskate\\jwa\\key_mgmt\\rsa.py 75 76 77 78 79 80 81 82 83 84 85 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , ) RsaEsOaepSha256 \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 88 89 90 91 92 93 94 95 96 97 98 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , ) RsaEsOaepSha384 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 101 102 103 104 105 106 107 108 109 110 111 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , ) RsaEsOaepSha512 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 114 115 116 117 118 119 120 121 122 123 124 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , ) signature \u00b6 This module exposes all the Signature algorithms available from jwskate . EdDsa \u00b6 Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate\\jwa\\signature\\eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False HS256 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-256 Source code in jwskate\\jwa\\signature\\hmac.py 31 32 33 34 35 36 37 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256\"\"\" name = \"HS256\" description = __doc__ hash_alg = hashes . SHA256 () min_key_size = 256 HS384 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-384 Source code in jwskate\\jwa\\signature\\hmac.py 40 41 42 43 44 45 46 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384\"\"\" name = \"HS384\" description = __doc__ hash_alg = hashes . SHA384 () min_key_size = 384 HS512 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-512 Source code in jwskate\\jwa\\signature\\hmac.py 49 50 51 52 53 54 55 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512\"\"\" name = \"HS512\" description = __doc__ hash_alg = hashes . SHA512 () min_key_size = 512 ES256 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 58 59 60 61 62 63 64 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 () RS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 65 66 67 68 69 70 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 () ES384 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384 Source code in jwskate\\jwa\\signature\\ec.py 67 68 69 70 71 72 73 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 () RS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 73 74 75 76 77 78 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 () ES512 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512 Source code in jwskate\\jwa\\signature\\ec.py 76 77 78 79 80 81 82 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 () RS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 81 82 83 84 85 86 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 () ES256K \u00b6 Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 85 86 87 88 89 90 91 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 () PS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 89 90 91 92 93 94 95 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 ) PS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 98 99 100 101 102 103 104 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 ) PS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\signature\\rsa.py 107 108 109 110 111 112 113 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 ) ec \u00b6 This module implement Elliptic Curve signature algorithms. BaseECSignatureAlg \u00b6 Bases: BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] , BaseSignatureAlg Base class for Elliptic Curve signature algorithms. Source code in jwskate\\jwa\\signature\\ec.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class BaseECSignatureAlg ( BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ], BaseSignatureAlg , ): \"\"\"Base class for Elliptic Curve signature algorithms.\"\"\" curve : EllipticCurve hashing_alg : hashes . HashAlgorithm public_key_class = asymmetric . ec . EllipticCurvePublicKey private_key_class = asymmetric . ec . EllipticCurvePrivateKey def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : dss_sig = key . sign ( data , asymmetric . ec . ECDSA ( self . hashing_alg )) r , s = asymmetric . utils . decode_dss_signature ( dss_sig ) return BinaPy . from_int ( r , self . curve . coordinate_size ) + BinaPy . from_int ( s , self . curve . coordinate_size ) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : if len ( signature ) != self . curve . coordinate_size * 2 : raise ValueError ( f \"Invalid signature length { len ( signature ) } bytes, expected { self . curve . coordinate_size * 2 } bytes\" ) r_bytes , s_bytes = ( signature [: self . curve . coordinate_size ], signature [ self . curve . coordinate_size :], ) r = int . from_bytes ( r_bytes , \"big\" , signed = False ) s = int . from_bytes ( s_bytes , \"big\" , signed = False ) dss_signature = asymmetric . utils . encode_dss_signature ( r , s ) try : key . verify ( dss_signature , data , asymmetric . ec . ECDSA ( self . hashing_alg ), ) return True except exceptions . InvalidSignature : return False ES256 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 58 59 60 61 62 63 64 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 () ES384 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384 Source code in jwskate\\jwa\\signature\\ec.py 67 68 69 70 71 72 73 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 () ES512 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512 Source code in jwskate\\jwa\\signature\\ec.py 76 77 78 79 80 81 82 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 () ES256K \u00b6 Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 85 86 87 88 89 90 91 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 () eddsa \u00b6 This module implements the Edwards-curve Digital Signature Algorithm (EdDSA). EdDsa \u00b6 Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate\\jwa\\signature\\eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False hmac \u00b6 This module implements HMAC based signature algorithms. BaseHMACSigAlg \u00b6 Bases: BaseSymmetricAlg , BaseSignatureAlg Base class for HMAC signature algorithms. Source code in jwskate\\jwa\\signature\\hmac.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BaseHMACSigAlg ( BaseSymmetricAlg , BaseSignatureAlg ): \"\"\"Base class for HMAC signature algorithms.\"\"\" mac : Type [ hmac . HMAC ] = hmac . HMAC hash_alg : hashes . HashAlgorithm min_key_size : int def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 if self . read_only : raise NotImplementedError m = self . mac ( self . key , self . hash_alg ) m . update ( data ) signature = m . finalize () return BinaPy ( signature ) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 candidate_signature = self . sign ( data ) return candidate_signature == signature HS256 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-256 Source code in jwskate\\jwa\\signature\\hmac.py 31 32 33 34 35 36 37 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256\"\"\" name = \"HS256\" description = __doc__ hash_alg = hashes . SHA256 () min_key_size = 256 HS384 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-384 Source code in jwskate\\jwa\\signature\\hmac.py 40 41 42 43 44 45 46 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384\"\"\" name = \"HS384\" description = __doc__ hash_alg = hashes . SHA384 () min_key_size = 384 HS512 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-512 Source code in jwskate\\jwa\\signature\\hmac.py 49 50 51 52 53 54 55 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512\"\"\" name = \"HS512\" description = __doc__ hash_alg = hashes . SHA512 () min_key_size = 512 HS1 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-1 Source code in jwskate\\jwa\\signature\\hmac.py 58 59 60 61 62 63 64 65 class HS1 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-1\"\"\" name = \"HS1\" description = __doc__ read_only = True min_key_size = 160 hash_alg = hashes . SHA1 () rsa \u00b6 This module implements RSA signature algorithms. BaseRSASigAlg \u00b6 Bases: BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] , BaseSignatureAlg Base class for RSA based signature algorithms. Source code in jwskate\\jwa\\signature\\rsa.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class BaseRSASigAlg ( BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], BaseSignatureAlg , ): \"\"\"Base class for RSA based signature algorithms.\"\"\" hashing_alg : hashes . HashAlgorithm padding_alg : padding . AsymmetricPadding = padding . PKCS1v15 () min_key_size : int = 2048 private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data. Args: data: the data to sign Returns: the generated signature Raises: NotImplementedError: for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired: if the configured key is not private \"\"\" if self . read_only : raise NotImplementedError with self . private_key_required () as key : return BinaPy ( key . sign ( data , self . padding_alg , self . hashing_alg )) def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the data to verify signature: the signature Returns: `True` if the signature is valid, `False` otherwise \"\"\" with self . public_key_required () as key : try : key . verify ( signature , data , self . padding_alg , self . hashing_alg , ) return True except exceptions . InvalidSignature : return False sign ( data ) \u00b6 Sign arbitrary data. Parameters: Name Type Description Default data bytes the data to sign required Returns: Type Description BinaPy the generated signature Raises: Type Description NotImplementedError for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired if the configured key is not private Source code in jwskate\\jwa\\signature\\rsa.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data. Args: data: the data to sign Returns: the generated signature Raises: NotImplementedError: for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired: if the configured key is not private \"\"\" if self . read_only : raise NotImplementedError with self . private_key_required () as key : return BinaPy ( key . sign ( data , self . padding_alg , self . hashing_alg )) verify ( data , signature ) \u00b6 Verify a signature against some data. Parameters: Name Type Description Default data bytes the data to verify required signature bytes the signature required Returns: Type Description bool True if the signature is valid, False otherwise Source code in jwskate\\jwa\\signature\\rsa.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the data to verify signature: the signature Returns: `True` if the signature is valid, `False` otherwise \"\"\" with self . public_key_required () as key : try : key . verify ( signature , data , self . padding_alg , self . hashing_alg , ) return True except exceptions . InvalidSignature : return False RS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 65 66 67 68 69 70 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 () RS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 73 74 75 76 77 78 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 () RS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 81 82 83 84 85 86 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 () PS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 89 90 91 92 93 94 95 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 ) PS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 98 99 100 101 102 103 104 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 ) PS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\signature\\rsa.py 107 108 109 110 111 112 113 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 ) RS1 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 with SHA-1 Source code in jwskate\\jwa\\signature\\rsa.py 116 117 118 119 120 121 122 class RS1 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 with SHA-1\"\"\" name = \"RS1\" description = __doc__ hashing_alg = hashes . SHA1 () read_only = True jwe \u00b6 This module implements Json Web Encryption RFC7516 . compact \u00b6 This module implements the JWE Compact format. InvalidJwe \u00b6 Bases: ValueError Raised when an invalid JWE token is parsed. Source code in jwskate\\jwe\\compact.py 19 20 class InvalidJwe ( ValueError ): \"\"\"Raised when an invalid JWE token is parsed.\"\"\" JweCompact \u00b6 Bases: BaseCompactToken Represents a Json Web Encryption object, as defined in RFC7516. Source code in jwskate\\jwe\\compact.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 class JweCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Encryption object, as defined in RFC7516.\"\"\" def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize a Jwe based on its compact representation. Args: value: the compact representation for this Jwe \"\"\" super () . __init__ ( value ) if self . value . count ( b \".\" ) != 4 : raise InvalidJwe ( \"A JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots\" ) header , cek , iv , ciphertext , auth_tag = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) self . additional_authenticated_data = header except ValueError : raise InvalidJwe ( \"Invalid JWE header: it must be a Base64URL-encoded JSON object\" ) try : self . wrapped_cek = BinaPy ( cek ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE cek: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . initialization_vector = BinaPy ( iv ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE iv: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . ciphertext = BinaPy ( ciphertext ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . authentication_tag = BinaPy ( auth_tag ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def from_parts ( cls , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ), BinaPy ( cek ) . encode_to ( \"b64u\" ), BinaPy ( iv ) . encode_to ( \"b64u\" ), BinaPy ( ciphertext ) . encode_to ( \"b64u\" ), BinaPy ( tag ) . encode_to ( \"b64u\" ), ) ) ) @property def alg ( self ) -> str : \"\"\"Return the alg from the JWE header. The `alg` header contains the Key Management algorithm used to wrap or derive the CEK. Returns: the alg value Raises: AttributeError: if there is no alg header or it is not a str \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or not isinstance ( alg , str ): raise AttributeError ( \"This JWE doesn't have a valid 'alg' header\" ) return alg @property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" enc = self . get_header ( \"enc\" ) if enc is None or not isinstance ( enc , str ): raise AttributeError ( \"This JWE doesn't have a valid 'enc' header\" ) return enc @classmethod def encrypt ( cls , plaintext : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext and return the resulting JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use enc: the CEK encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" jwk = Jwk ( jwk ) extra_headers = extra_headers or {} cek_jwk , cek_headers , wrapped_cek = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) aad = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) ciphertext , tag , iv = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers , wrapped_cek , iv , ciphertext , tag ) PBES2_ALGORITHMS : Mapping [ str , Type [ BasePbes2 ]] = { alg . name : alg for alg in [ Pbes2_HS256_A128KW , Pbes2_HS384_A192KW , Pbes2_HS512_A256KW ] } def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> bytes : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: bytes: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext @classmethod def encrypt_with_password ( cls , plaintext : bytes , password : Union [ bytes , str ], alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000\" ) wrapped_cek = wrapper . wrap_key ( cek , salt , count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . encode_to ( \"b64u\" ) . decode (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) ciphertext , tag , iv = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers , wrapped_cek , iv , ciphertext , tag ) def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise AttributeError ( \"No 'p2s' in headers!\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise AttributeError ( \"No 'p2c' in headers!\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise AttributeError ( \"Invalid value for p2c, must be a positive integer\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt , p2c ) return SymmetricJwk . from_bytes ( cek ) def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext __init__ ( value ) \u00b6 Initialize a Jwe based on its compact representation. Parameters: Name Type Description Default value Union [ bytes , str ] the compact representation for this Jwe required Source code in jwskate\\jwe\\compact.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize a Jwe based on its compact representation. Args: value: the compact representation for this Jwe \"\"\" super () . __init__ ( value ) if self . value . count ( b \".\" ) != 4 : raise InvalidJwe ( \"A JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots\" ) header , cek , iv , ciphertext , auth_tag = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) self . additional_authenticated_data = header except ValueError : raise InvalidJwe ( \"Invalid JWE header: it must be a Base64URL-encoded JSON object\" ) try : self . wrapped_cek = BinaPy ( cek ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE cek: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . initialization_vector = BinaPy ( iv ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE iv: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . ciphertext = BinaPy ( ciphertext ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . authentication_tag = BinaPy ( auth_tag ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data (bytes)\" ) from_parts ( headers , cek , iv , ciphertext , tag ) \u00b6 Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Parameters: Name Type Description Default headers Mapping [ str , Any ] the headers (as a mapping of name: value) required cek bytes the raw cek required iv bytes the raw iv required ciphertext bytes the raw ciphertext required tag bytes the authentication tag required Returns: Type Description 'JweCompact' the initialized JweCompact instance Source code in jwskate\\jwe\\compact.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @classmethod def from_parts ( cls , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ), BinaPy ( cek ) . encode_to ( \"b64u\" ), BinaPy ( iv ) . encode_to ( \"b64u\" ), BinaPy ( ciphertext ) . encode_to ( \"b64u\" ), BinaPy ( tag ) . encode_to ( \"b64u\" ), ) ) ) alg () \u00b6 Return the alg from the JWE header. The alg header contains the Key Management algorithm used to wrap or derive the CEK. Returns: Type Description str the alg value Raises: Type Description AttributeError if there is no alg header or it is not a str Source code in jwskate\\jwe\\compact.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @property def alg ( self ) -> str : \"\"\"Return the alg from the JWE header. The `alg` header contains the Key Management algorithm used to wrap or derive the CEK. Returns: the alg value Raises: AttributeError: if there is no alg header or it is not a str \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or not isinstance ( alg , str ): raise AttributeError ( \"This JWE doesn't have a valid 'alg' header\" ) return alg enc () \u00b6 Return the enc from the JWE header. The enc header contains the identifier of the CEK encryption algorithm. Returns: Type Description str the enc value Raises: Type Description AttributeError if there is no enc header or it is not a string Source code in jwskate\\jwe\\compact.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" enc = self . get_header ( \"enc\" ) if enc is None or not isinstance ( enc , str ): raise AttributeError ( \"This JWE doesn't have a valid 'enc' header\" ) return enc encrypt ( plaintext , jwk , enc , alg = None , extra_headers = None , cek = None , iv = None , epk = None ) \u00b6 Encrypt an arbitrary plaintext and return the resulting JweCompact. Parameters: Name Type Description Default plaintext bytes the raw plaintext to encrypt required jwk Union [ Jwk , Dict [ str , Any ]] the public or symmetric key to use required enc str the CEK encryption algorithm to use required alg Optional [ str ] the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the generated token None cek Optional [ bytes ] the CEK to force use, for algorithms relying on a random CEK. Leave None to have a safe value generated by jwskate . None iv Optional [ bytes ] the IV to force use. Leave None to have a safe value generated by jwskate . None epk Optional [ Jwk ] the EPK to force use. Leave None to have a safe value generated by jwskate . None Returns: Type Description 'JweCompact' the generated JweCompact instance Source code in jwskate\\jwe\\compact.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @classmethod def encrypt ( cls , plaintext : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext and return the resulting JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use enc: the CEK encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" jwk = Jwk ( jwk ) extra_headers = extra_headers or {} cek_jwk , cek_headers , wrapped_cek = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) aad = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) ciphertext , tag , iv = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers , wrapped_cek , iv , ciphertext , tag ) unwrap_cek ( jwk_or_password ) \u00b6 Unwrap the CEK from this JWE token using the provided key or password. Parameters: Name Type Description Default jwk_or_password Union [ Jwk , Dict [ str , Any ], bytes , str ] the decryption JWK or password required Returns: Type Description Jwk the unwrapped CEK, as a SymmetricJwk Source code in jwskate\\jwe\\compact.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek decrypt ( jwk ) \u00b6 Decrypts this Jwe payload using a JWK. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required Returns: Name Type Description bytes bytes the decrypted payload Source code in jwskate\\jwe\\compact.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> bytes : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: bytes: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext encrypt_with_password ( plaintext , password , alg , enc , salt = None , count = 2000 , cek = None , iv = None ) \u00b6 Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Parameters: Name Type Description Default plaintext bytes the data to encrypt required password Union [ bytes , str ] the password to use required alg str the Key Management alg to use required enc str the Payload Encryption alg to use required salt Optional [ bytes ] the salt to use. Leave None (default) to have jwskate generate a safe random value None count int the number of PBES2 iterations (recommended minimum 1000) 2000 cek Optional [ bytes ] the CEK to force use. Leave None (default) to have jwskate generate a safe random value None iv Optional [ bytes ] the IV to force use. Leave None (default) to have jwskate generate a safe random value None Returns: Type Description 'JweCompact' the resulting JweCompact Raises: Type Description UnsupportedAlg if the key management alg is not supported ValueError if the count parameter is not a positive integer Source code in jwskate\\jwe\\compact.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 @classmethod def encrypt_with_password ( cls , plaintext : bytes , password : Union [ bytes , str ], alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000\" ) wrapped_cek = wrapper . wrap_key ( cek , salt , count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . encode_to ( \"b64u\" ) . decode (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) ciphertext , tag , iv = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers , wrapped_cek , iv , ciphertext , tag ) unwrap_cek_with_password ( password ) \u00b6 Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Parameters: Name Type Description Default password Union [ bytes , str ] the decryption password required Returns: Type Description Jwk the CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the token key management algorithm is not supported AttributeError if the token misses the PBES2-related headers Source code in jwskate\\jwe\\compact.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise AttributeError ( \"No 'p2s' in headers!\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise AttributeError ( \"No 'p2c' in headers!\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise AttributeError ( \"Invalid value for p2c, must be a positive integer\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt , p2c ) return SymmetricJwk . from_bytes ( cek ) decrypt_with_password ( password ) \u00b6 Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Parameters: Name Type Description Default password Union [ bytes , str ] the password to use required Returns: Type Description bytes the unencrypted payload Source code in jwskate\\jwe\\compact.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext jwk \u00b6 This module implements Json Web Key RFC7517 . alg \u00b6 This module contains several utilities for algorithmic agility. UnsupportedAlg \u00b6 Bases: ValueError Raised when an UnsupportedAlg is requested. Source code in jwskate\\jwk\\alg.py 9 10 class UnsupportedAlg ( ValueError ): \"\"\"Raised when an UnsupportedAlg is requested.\"\"\" select_alg ( jwk_alg , alg , supported_algs ) \u00b6 Given an alg parameter from a JWK, and/or a user-specified alg, return the alg to use. This checks the coherency between the user specified alg and the jwk_alg , and will emit a warning if the user specified alg is different from the jwk_alg . Parameters: Name Type Description Default jwk_alg Optional [ str ] the alg from the JWK, if any required alg Optional [ str ] a user specified alg required supported_algs Mapping [ str , T ] a mapping of supported alg names to alg wrapper required Returns: Type Description T the alg to use Raises: Type Description UnsupportedAlg if the requested alg is not supported Source code in jwskate\\jwk\\alg.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def select_alg ( jwk_alg : Optional [ str ], alg : Optional [ str ], supported_algs : Mapping [ str , T ] ) -> T : \"\"\"Given an alg parameter from a JWK, and/or a user-specified alg, return the alg to use. This checks the coherency between the user specified `alg` and the `jwk_alg`, and will emit a warning if the user specified alg is different from the `jwk_alg`. Args: jwk_alg: the alg from the JWK, if any alg: a user specified alg supported_algs: a mapping of supported alg names to alg wrapper Returns: the alg to use Raises: UnsupportedAlg: if the requested alg is not supported \"\"\" choosen_alg : str if jwk_alg is not None : if alg is not None : if jwk_alg != alg : warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) choosen_alg = alg else : choosen_alg = jwk_alg elif alg is not None : choosen_alg = alg try : return supported_algs [ choosen_alg ] except KeyError : raise UnsupportedAlg ( f \"Alg { choosen_alg } is not supported. Supported algs: { list ( supported_algs ) } .\" ) select_algs ( jwk_alg , alg , algs , supported_algs ) \u00b6 Given an alg parameter from a JWK, and/or a user-specified alg, and/or a user specified list of useable algs, return a list of algorithms. This method is typically used to get the list of possible algs when checking a signature. Parameters: Name Type Description Default jwk_alg Optional [ str ] the alg from the JWK, if any required alg Optional [ str ] a user specified alg to use required algs Optional [ Iterable [ str ]] a user specified list of algs to use, if several are allowed required supported_algs Mapping [ str , T ] a mapping of alg names to alg wrappers required Returns: Type Description List [ T ] a list of possible algs to check Raises: Type Description ValueError if both 'alg' and 'algs' parameters are used UnsupportedAlg if none of the requested alg are supported Warnings if the requested 'alg' is different that the 'jwk_alg', or the 'jwk_alg' is not in the 'algs' Source code in jwskate\\jwk\\alg.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def select_algs ( jwk_alg : Optional [ str ], alg : Optional [ str ], algs : Optional [ Iterable [ str ]], supported_algs : Mapping [ str , T ], ) -> List [ T ]: \"\"\"Given an alg parameter from a JWK, and/or a user-specified alg, and/or a user specified list of useable algs, return a list of algorithms. This method is typically used to get the list of possible algs when checking a signature. Args: jwk_alg: the alg from the JWK, if any alg: a user specified alg to use algs: a user specified list of algs to use, if several are allowed supported_algs: a mapping of alg names to alg wrappers Returns: a list of possible algs to check Raises: ValueError: if both 'alg' and 'algs' parameters are used UnsupportedAlg: if none of the requested alg are supported Warnings: if the requested 'alg' is different that the 'jwk_alg', or the 'jwk_alg' is not in the 'algs' \"\"\" if alg and algs : raise ValueError ( \"Please use either parameter 'alg' or 'algs', not both.\" ) if jwk_alg is not None : if alg and alg != jwk_alg : warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) if algs and jwk_alg not in algs : warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) possible_algs : List [ str ] = [] if alg : possible_algs = [ alg ] elif algs : possible_algs = list ( algs ) elif jwk_alg : possible_algs = [ jwk_alg ] if possible_algs : possible_supported_algs = [ supported_algs [ alg ] for alg in possible_algs if alg in supported_algs ] if possible_supported_algs : return possible_supported_algs else : raise UnsupportedAlg ( f \"None of the user-specified alg(s) are supported. { possible_algs } \" ) raise ValueError ( \"This key doesn't have an 'alg' parameter, you need to provide the signing alg for each operation.\" ) base \u00b6 This module implements the Jwk base class, which provides most of the common features of all JWK types. UnsupportedKeyType \u00b6 Bases: ValueError Raised when an unsupported Key Type is requested. Source code in jwskate\\jwk\\base.py 46 47 class UnsupportedKeyType ( ValueError ): \"\"\"Raised when an unsupported Key Type is requested.\"\"\" InvalidJwk \u00b6 Bases: ValueError Raised when an invalid JWK is encountered. Source code in jwskate\\jwk\\base.py 50 51 class InvalidJwk ( ValueError ): \"\"\"Raised when an invalid JWK is encountered.\"\"\" Jwk \u00b6 Bases: BaseJsonDict Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class: Jwk is a dict, so you can do with a Jwk anything you can do with a dict . In addition, all keys parameters are exposed as attributes. There are subclasses of Jwk for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Source code in jwskate\\jwk\\base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 class Jwk ( BaseJsonDict ): \"\"\"Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class:`Jwk` is a dict, so you can do with a Jwk anything you can do with a `dict`. In addition, all keys parameters are exposed as attributes. There are subclasses of `Jwk` for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. \"\"\" subclasses : Dict [ str , Type [ Jwk ]] = {} \"\"\"A dict of 'kty' values to subclasses implementing each specific Key Type\"\"\" cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} \"\"\"A dict of cryptography key classes to its specific 'kty' value\"\"\" PARAMS : Mapping [ str , JwkParameter ] \"\"\"A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)\"\"\" KTY : ClassVar [ str ] \"\"\"The Key Type associated with this JWK.\"\"\" CRYPTOGRAPHY_KEY_CLASSES : ClassVar [ Iterable [ Any ]] SIGNATURE_ALGORITHMS : Mapping [ str , Type [ BaseSignatureAlg ]] = {} KEY_MANAGEMENT_ALGORITHMS : Mapping [ str , Type [ BaseKeyManagementAlg ]] = {} ENCRYPTION_ALGORITHMS : Mapping [ str , Type [ BaseAESEncryptionAlg ]] = {} def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls def __new__ ( cls , jwk : Union [ Jwk , Dict [ str , Any ]], * args , ** kwargs ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: jwk: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key \"\"\" if cls == Jwk : if isinstance ( jwk , Jwk ): return jwk elif isinstance ( jwk , dict ): kty : Optional [ str ] = jwk . get ( \"kty\" ) if kty is None : raise ValueError ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise ValueError ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) else : # this will trigger double __init__ return cls . from_cryptography_key ( jwk , * args , ** kwargs ) return super () . __new__ ( cls , jwk , * args , ** jwk ) def __init__ ( self , params : Union [ Dict [ str , Any ], Any ], include_kid_thumbprint : bool = False ): \"\"\"Initialize a Jwk. This accepts a `dict` with the parsed Jwk contents, and an optional kid if it isn't already part of the dict. If no `kid` is supplied and `include_kid_thumbprint`, a default kid is generated based on the key thumbprint (defined in RFC7638). Args: params: a dict with the parsed Jwk parameters include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint \"\"\" if isinstance ( params , dict ): # this is to avoid double init due to the __new__ above super () . __init__ ( { key : val for key , val in params . items () if val is not None } ) self . is_private = False self . _validate () if self . get ( \"kid\" ) is None and include_kid_thumbprint : self [ \"kid\" ] = self . thumbprint () def __getattr__ ( self , item : str ) -> Any : \"\"\"Allows access to key parameters as attributes, like `jwk.kid`, `jwk.kty`, instead of `jwk['kid']`, `jwk['kty']`, etc. Args: item: the member to access Return: the member value Raises: AttributeError: if the member is not found \"\"\" value = self . get ( item ) if value is None : raise AttributeError ( item ) return value def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" digest = hashlib . new ( hashalg ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) intermediary = json . dumps ( t , separators = ( \",\" , \":\" ), sort_keys = True ) digest . update ( intermediary . encode ( \"utf8\" )) return BinaPy ( digest . digest ()) . encode_to ( \"b64u\" ) . decode () @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): raise TypeError ( f \"Invalid alg type { type ( str ) } \" , alg ) return alg def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"decrypt\" , \"unwrapKey\" ) and not jwk_is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) self . is_private = jwk_is_private def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } key_ops = self . get ( \"key_ops\" ) if key_ops : if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"decrypt\" in key_ops : key_ops . remove ( \"decrypt\" ) key_ops . append ( \"encrypt\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) def sign ( self , data : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" sigalg = select_alg ( self . alg , alg , self . SIGNATURE_ALGORITHMS ) wrapper : BaseSignatureAlg if issubclass ( sigalg , BaseAsymmetricAlg ): wrapper = sigalg ( self . to_cryptography_key ()) elif issubclass ( sigalg , BaseSymmetricAlg ): wrapper = sigalg ( self . key ) signature = wrapper . sign ( data ) return BinaPy ( signature ) def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" wrapper : BaseSignatureAlg for sigalg in select_algs ( self . alg , alg , algs , self . SIGNATURE_ALGORITHMS ): if issubclass ( sigalg , BaseAsymmetricAlg ): key = self . public_jwk () . to_cryptography_key () wrapper = sigalg ( key ) elif issubclass ( sigalg , BaseSymmetricAlg ): key = self . key wrapper = sigalg ( key ) if wrapper . verify ( data , signature ): return True return False def encrypt ( self , plaintext : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Authentication Tag and the used Initialization Vector. Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector that was used to encrypt the data. If `iv` is passed as parameter, this will return that same value. Otherwise, an IV is generated. Returns: a tuple (ciphertext, authentication_tag, iv), as raw data \"\"\" raise NotImplementedError # pragma: no cover def decrypt ( self , ciphertext : bytes , tag : bytes , iv : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt tag: the Authentication Tag that will be verified while decrypting data iv: the Initialization Vector (IV) that was used for encryption aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover def wrap_key ( self , key : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key using a Key Management Algorithm alg. Args: key: the symmetric key to wrap alg: the Key Management alg to use Returns: the wrapped key \"\"\" raise NotImplementedError def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None ) -> Jwk : \"\"\"Unwrap a symmetric key using a Key Management Algorithm alg. Args: cipherkey: the wrapped key alg: the Key Management alg to use Returns: the unwrapped key \"\"\" raise NotImplementedError def sender_key ( self , enc : str , alg : Optional [ str ], cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , Mapping [ str , Any ], BinaPy ]: \"\"\"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. For algorithms that rely on a random CEK, you can provide that value instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only use this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: Tuple[Jwk,Mapping[str,Any],BinaPy]: a tuple (CEK, additional_headers_map, wrapped_cek) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) cek_headers : Dict [ str , Any ] = {} if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . public_jwk () . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = rsa . wrap_key ( cek ) elif issubclass ( keyalg , EcdhEs ): ecdh : EcdhEs = keyalg ( self . public_jwk () . to_cryptography_key ()) epk = epk or Jwk . from_cryptography_key ( ecdh . generate_ephemeral_key ()) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( ecdh , BaseEcdhEs_AesKw ): if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = ecdh . wrap_key_with_epk ( cek , epk . to_cryptography_key (), alg = alg , ** headers ) else : cek = ecdh . sender_key ( epk . to_cryptography_key (), encalg . name , encalg . key_size , ** headers ) wrapped_cek = BinaPy ( b \"\" ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes : BaseAesKeyWrap = keyalg ( self . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = aes . wrap_key ( cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm : BaseAesGcmKeyWrap = keyalg ( self . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () iv = aesgcm . generate_iv () wrapped_cek , tag = aesgcm . wrap_key ( cek , iv ) cek_headers = { \"iv\" : iv . encode_to ( \"b64u\" ) . decode (), \"tag\" : tag . encode_to ( \"b64u\" ) . decode (), } elif issubclass ( keyalg , DirectKeyUse ): dir = keyalg ( self . key ) cek = dir . direct_key ( encalg ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ), cek_headers , wrapped_cek def recipient_key ( self , wrapped_cek : bytes , alg : str , enc : str , ** headers : Any ) -> Jwk : \"\"\"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Args: wrapped_cek: the wrapped CEK alg: the Key Management algorithm to use to unwrap the CEK enc: the encryption algorithm to use with the CEK **headers: Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . to_cryptography_key ()) cek = rsa . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , EcdhEs ): ecdh = keyalg ( self . to_cryptography_key ()) epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . to_cryptography_key () encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if isinstance ( ecdh , BaseEcdhEs_AesKw ): cek = ecdh . unwrap_key_with_epk ( wrapped_cek , epk , alg = alg ) else : cek = ecdh . recipient_key ( epk , alg = encalg . name , key_size = encalg . key_size , ** headers ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes = keyalg ( self . to_cryptography_key ()) cek = aes . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm = keyalg ( self . to_cryptography_key ()) iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = aesgcm . unwrap_key ( wrapped_cek , tag , iv ) elif issubclass ( keyalg , DirectKeyUse ): dir_ = keyalg ( self . key ) cek = dir_ . direct_key ( encalg ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) def to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError @classmethod def from_pem_key ( cls , data : bytes , password : Optional [ bytes ] = None ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required Returns: a Jwk instance from the loaded key \"\"\" try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) return cls . from_cryptography_key ( cryptography_key ) def to_pem_key ( self , password : Optional [ bytes ] = None ) -> str : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM encrypted key, as \"\"\" raise NotImplementedError @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs ) subclasses : Dict [ str , Type [ Jwk ]] = {} class-attribute \u00b6 A dict of 'kty' values to subclasses implementing each specific Key Type cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} class-attribute \u00b6 A dict of cryptography key classes to its specific 'kty' value PARAMS : Mapping [ str , JwkParameter ] = None class-attribute \u00b6 A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind) KTY : ClassVar [ str ] = None class-attribute \u00b6 The Key Type associated with this JWK. __init_subclass__ () \u00b6 Automatically add subclasses to the registry. This allows new to pick the appropriate subclass when creating a Jwk Source code in jwskate\\jwk\\base.py 93 94 95 96 97 98 99 100 101 def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls __new__ ( jwk , * args , ** kwargs ) \u00b6 The Jwk constructor will accept a dict with the parsed Jwk content another Jwk, which will be used as-is instead of creating a copy an instance from a cryptography public or private key class Overridden __new__ to make the Jwk constructor smarter. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] a dict containing JWK parameters, or another Jwk instance, or a cryptography key required Source code in jwskate\\jwk\\base.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def __new__ ( cls , jwk : Union [ Jwk , Dict [ str , Any ]], * args , ** kwargs ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: jwk: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key \"\"\" if cls == Jwk : if isinstance ( jwk , Jwk ): return jwk elif isinstance ( jwk , dict ): kty : Optional [ str ] = jwk . get ( \"kty\" ) if kty is None : raise ValueError ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise ValueError ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) else : # this will trigger double __init__ return cls . from_cryptography_key ( jwk , * args , ** kwargs ) return super () . __new__ ( cls , jwk , * args , ** jwk ) __init__ ( params , include_kid_thumbprint = False ) \u00b6 Initialize a Jwk. This accepts a dict with the parsed Jwk contents, and an optional kid if it isn't already part of the dict. If no kid is supplied and include_kid_thumbprint , a default kid is generated based on the key thumbprint (defined in RFC7638). Parameters: Name Type Description Default params Union [ Dict [ str , Any ], Any ] a dict with the parsed Jwk parameters required include_kid_thumbprint bool if True (default), and there is no kid in the provided params, generate a kid based on the key thumbprint False Source code in jwskate\\jwk\\base.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , params : Union [ Dict [ str , Any ], Any ], include_kid_thumbprint : bool = False ): \"\"\"Initialize a Jwk. This accepts a `dict` with the parsed Jwk contents, and an optional kid if it isn't already part of the dict. If no `kid` is supplied and `include_kid_thumbprint`, a default kid is generated based on the key thumbprint (defined in RFC7638). Args: params: a dict with the parsed Jwk parameters include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint \"\"\" if isinstance ( params , dict ): # this is to avoid double init due to the __new__ above super () . __init__ ( { key : val for key , val in params . items () if val is not None } ) self . is_private = False self . _validate () if self . get ( \"kid\" ) is None and include_kid_thumbprint : self [ \"kid\" ] = self . thumbprint () __getattr__ ( item ) \u00b6 Allows access to key parameters as attributes, like jwk.kid , jwk.kty , instead of jwk['kid'] , jwk['kty'] , etc. Parameters: Name Type Description Default item str the member to access required Return the member value Raises: Type Description AttributeError if the member is not found Source code in jwskate\\jwk\\base.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allows access to key parameters as attributes, like `jwk.kid`, `jwk.kty`, instead of `jwk['kid']`, `jwk['kty']`, etc. Args: item: the member to access Return: the member value Raises: AttributeError: if the member is not found \"\"\" value = self . get ( item ) if value is None : raise AttributeError ( item ) return value thumbprint ( hashalg = 'SHA256' ) \u00b6 Return the key thumbprint as specified by RFC 7638. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Returns: Type Description str the calculated thumbprint Source code in jwskate\\jwk\\base.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" digest = hashlib . new ( hashalg ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) intermediary = json . dumps ( t , separators = ( \",\" , \":\" ), sort_keys = True ) digest . update ( intermediary . encode ( \"utf8\" )) return BinaPy ( digest . digest ()) . encode_to ( \"b64u\" ) . decode () kty () \u00b6 Return the Key Type. Returns: Type Description str the key type Source code in jwskate\\jwk\\base.py 191 192 193 194 195 196 197 198 @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY alg () \u00b6 Return the configured key alg, if any. Returns: Type Description Optional [ str ] the key alg Source code in jwskate\\jwk\\base.py 200 201 202 203 204 205 206 207 208 209 210 @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): raise TypeError ( f \"Invalid alg type { type ( str ) } \" , alg ) return alg _validate () \u00b6 Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the is_private flag to True . Raises: Type Description TypeError if the key type doesn't match the subclass InvalidJwk if the JWK misses required members or has invalid members Source code in jwskate\\jwk\\base.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"decrypt\" , \"unwrapKey\" ) and not jwk_is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) self . is_private = jwk_is_private supported_signing_algorithms () \u00b6 Return the list of Signature algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate\\jwk\\base.py 274 275 276 277 278 279 280 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) supported_key_management_algorithms () \u00b6 Return the list of Key Management algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate\\jwk\\base.py 282 283 284 285 286 287 288 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) supported_encryption_algorithms () \u00b6 Return the list of Encryption algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate\\jwk\\base.py 290 291 292 293 294 295 296 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) public_jwk () \u00b6 Return the public Jwk associated with this key. Returns: Type Description Jwk a Jwk with the public key Source code in jwskate\\jwk\\base.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } key_ops = self . get ( \"key_ops\" ) if key_ops : if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"decrypt\" in key_ops : key_ops . remove ( \"decrypt\" ) key_ops . append ( \"encrypt\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) as_jwks () \u00b6 Return a JwkSet with this key as single element. Returns: Type Description JwkSet a JwsSet with this single key Source code in jwskate\\jwk\\base.py 336 337 338 339 340 341 342 343 344 def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) sign ( data , alg = None ) \u00b6 Sign a data using this Jwk, and return the generated signature. Parameters: Name Type Description Default data bytes the data to sign required alg Optional [ str ] the alg to use (if this key doesn't have an alg parameter) None Returns: Type Description BinaPy the generated signature Source code in jwskate\\jwk\\base.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 def sign ( self , data : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" sigalg = select_alg ( self . alg , alg , self . SIGNATURE_ALGORITHMS ) wrapper : BaseSignatureAlg if issubclass ( sigalg , BaseAsymmetricAlg ): wrapper = sigalg ( self . to_cryptography_key ()) elif issubclass ( sigalg , BaseSymmetricAlg ): wrapper = sigalg ( self . key ) signature = wrapper . sign ( data ) return BinaPy ( signature ) verify ( data , signature , alg = None , algs = None ) \u00b6 Verify a signature using this Jwk, and return True if valid. Parameters: Name Type Description Default data bytes the data to verify required signature bytes the signature to verify required alg Optional [ str ] the allowed signature alg, if there is only one None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate\\jwk\\base.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" wrapper : BaseSignatureAlg for sigalg in select_algs ( self . alg , alg , algs , self . SIGNATURE_ALGORITHMS ): if issubclass ( sigalg , BaseAsymmetricAlg ): key = self . public_jwk () . to_cryptography_key () wrapper = sigalg ( key ) elif issubclass ( sigalg , BaseSymmetricAlg ): key = self . key wrapper = sigalg ( key ) if wrapper . verify ( data , signature ): return True return False encrypt ( plaintext , aad = None , alg = None , iv = None ) \u00b6 Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Authentication Tag and the used Initialization Vector. Parameters: Name Type Description Default plaintext bytes the data to encrypt. required aad Optional [ bytes ] the Additional Authenticated Data (AAD) to include in the authentication tag None alg Optional [ str ] the alg to use to encrypt the data None iv Optional [ bytes ] the Initialization Vector that was used to encrypt the data. If iv is passed as parameter, this None will return that same value. Otherwise, an IV is generated. Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a tuple (ciphertext, authentication_tag, iv), as raw data Source code in jwskate\\jwk\\base.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 def encrypt ( self , plaintext : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Authentication Tag and the used Initialization Vector. Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector that was used to encrypt the data. If `iv` is passed as parameter, this will return that same value. Otherwise, an IV is generated. Returns: a tuple (ciphertext, authentication_tag, iv), as raw data \"\"\" raise NotImplementedError # pragma: no cover decrypt ( ciphertext , tag , iv , aad = None , alg = None ) \u00b6 Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required tag bytes the Authentication Tag that will be verified while decrypting data required iv bytes the Initialization Vector (IV) that was used for encryption required aad Optional [ bytes ] the Additional Authentication Data (AAD) to verify the Tag against None alg Optional [ str ] the alg to use for decryption None Returns: Type Description BinaPy the clear-text data Source code in jwskate\\jwk\\base.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def decrypt ( self , ciphertext : bytes , tag : bytes , iv : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt tag: the Authentication Tag that will be verified while decrypting data iv: the Initialization Vector (IV) that was used for encryption aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover wrap_key ( key , alg = None ) \u00b6 Wrap a symmetric key using a Key Management Algorithm alg. Parameters: Name Type Description Default key bytes the symmetric key to wrap required alg Optional [ str ] the Key Management alg to use None Returns: Type Description BinaPy the wrapped key Source code in jwskate\\jwk\\base.py 443 444 445 446 447 448 449 450 451 452 453 def wrap_key ( self , key : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key using a Key Management Algorithm alg. Args: key: the symmetric key to wrap alg: the Key Management alg to use Returns: the wrapped key \"\"\" raise NotImplementedError unwrap_key ( cipherkey , alg = None ) \u00b6 Unwrap a symmetric key using a Key Management Algorithm alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required alg Optional [ str ] the Key Management alg to use None Returns: Type Description Jwk the unwrapped key Source code in jwskate\\jwk\\base.py 455 456 457 458 459 460 461 462 463 464 465 def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None ) -> Jwk : \"\"\"Unwrap a symmetric key using a Key Management Algorithm alg. Args: cipherkey: the wrapped key alg: the Key Management alg to use Returns: the unwrapped key \"\"\" raise NotImplementedError sender_key ( enc , alg , cek = None , epk = None , ** headers ) \u00b6 For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. For algorithms that rely on a random CEK, you can provide that value instead of letting jwskate generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting jwskate generate an appropriate value for you. Only use this if you know what you are doing! Parameters: Name Type Description Default enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to produce the CEK required cek Optional [ bytes ] CEK to use (leave None to have an adequate random value generated automatically) None epk Optional [ Jwk ] EPK to use (leave None to have an adequate ephemeral key generated automatically) None **headers Any additional headers to include for the CEK derivation {} Returns: Type Description Tuple [ Jwk , Mapping [ str , Any ], BinaPy ] Tuple[Jwk,Mapping[str,Any],BinaPy]: a tuple (CEK, additional_headers_map, wrapped_cek) Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate\\jwk\\base.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 def sender_key ( self , enc : str , alg : Optional [ str ], cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , Mapping [ str , Any ], BinaPy ]: \"\"\"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. For algorithms that rely on a random CEK, you can provide that value instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only use this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: Tuple[Jwk,Mapping[str,Any],BinaPy]: a tuple (CEK, additional_headers_map, wrapped_cek) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) cek_headers : Dict [ str , Any ] = {} if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . public_jwk () . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = rsa . wrap_key ( cek ) elif issubclass ( keyalg , EcdhEs ): ecdh : EcdhEs = keyalg ( self . public_jwk () . to_cryptography_key ()) epk = epk or Jwk . from_cryptography_key ( ecdh . generate_ephemeral_key ()) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( ecdh , BaseEcdhEs_AesKw ): if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = ecdh . wrap_key_with_epk ( cek , epk . to_cryptography_key (), alg = alg , ** headers ) else : cek = ecdh . sender_key ( epk . to_cryptography_key (), encalg . name , encalg . key_size , ** headers ) wrapped_cek = BinaPy ( b \"\" ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes : BaseAesKeyWrap = keyalg ( self . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = aes . wrap_key ( cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm : BaseAesGcmKeyWrap = keyalg ( self . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () iv = aesgcm . generate_iv () wrapped_cek , tag = aesgcm . wrap_key ( cek , iv ) cek_headers = { \"iv\" : iv . encode_to ( \"b64u\" ) . decode (), \"tag\" : tag . encode_to ( \"b64u\" ) . decode (), } elif issubclass ( keyalg , DirectKeyUse ): dir = keyalg ( self . key ) cek = dir . direct_key ( encalg ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ), cek_headers , wrapped_cek recipient_key ( wrapped_cek , alg , enc , ** headers ) \u00b6 For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Parameters: Name Type Description Default wrapped_cek bytes the wrapped CEK required alg str the Key Management algorithm to use to unwrap the CEK required enc str the encryption algorithm to use with the CEK required **headers Any {} Returns: Type Description Jwk the clear-text CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate\\jwk\\base.py 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 def recipient_key ( self , wrapped_cek : bytes , alg : str , enc : str , ** headers : Any ) -> Jwk : \"\"\"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Args: wrapped_cek: the wrapped CEK alg: the Key Management algorithm to use to unwrap the CEK enc: the encryption algorithm to use with the CEK **headers: Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . to_cryptography_key ()) cek = rsa . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , EcdhEs ): ecdh = keyalg ( self . to_cryptography_key ()) epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . to_cryptography_key () encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if isinstance ( ecdh , BaseEcdhEs_AesKw ): cek = ecdh . unwrap_key_with_epk ( wrapped_cek , epk , alg = alg ) else : cek = ecdh . recipient_key ( epk , alg = encalg . name , key_size = encalg . key_size , ** headers ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes = keyalg ( self . to_cryptography_key ()) cek = aes . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm = keyalg ( self . to_cryptography_key ()) iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = aesgcm . unwrap_key ( wrapped_cek , tag , iv ) elif issubclass ( keyalg , DirectKeyUse ): dir_ = keyalg ( self . key ) cek = dir_ . direct_key ( encalg ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ) from_cryptography_key ( cryptography_key ) \u00b6 Initialize a Jwk from a key from the cryptography library. The input key can be any private or public key supported by cryptography. Parameters: Name Type Description Default cryptography_key Any a cryptography key instance required Returns: Type Description Jwk the matching Jwk instance Raises: Type Description TypeError if the key type is not supported Source code in jwskate\\jwk\\base.py 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 @classmethod def from_cryptography_key ( cls , cryptography_key : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) to_cryptography_key () \u00b6 Return a key from the cryptography library that matches this Jwk. This is implemented by subclasses. Returns: Type Description Any a cryptography key instance initialized from the current key Source code in jwskate\\jwk\\base.py 646 647 648 649 650 651 652 653 654 def to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError from_pem_key ( data , password = None ) \u00b6 Load a Jwk from a PEM encoded private or public key. Parameters: Name Type Description Default data bytes the PEM encoded data to load required password Optional [ bytes ] the password to decrypt the PEM, if required None Returns: Type Description Jwk a Jwk instance from the loaded key Source code in jwskate\\jwk\\base.py 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 @classmethod def from_pem_key ( cls , data : bytes , password : Optional [ bytes ] = None ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required Returns: a Jwk instance from the loaded key \"\"\" try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) return cls . from_cryptography_key ( cryptography_key ) to_pem_key ( password = None ) \u00b6 Serialize this key to PEM format. For private keys, you can provide a password for encryption. Parameters: Name Type Description Default password Optional [ bytes ] password to use to encrypt the PEM None Returns: Type Description str the PEM encrypted key, as Source code in jwskate\\jwk\\base.py 684 685 686 687 688 689 690 691 692 693 694 695 def to_pem_key ( self , password : Optional [ bytes ] = None ) -> str : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM encrypted key, as \"\"\" raise NotImplementedError generate ( ** kwargs ) \u00b6 Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Parameters: Name Type Description Default **kwargs Any specific parameters depending on the type of key, or additional members to include in the Jwk {} Returns: Type Description Jwk a Jwk instance with a generated key Source code in jwskate\\jwk\\base.py 697 698 699 700 701 702 703 704 705 706 707 @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError generate_for_kty ( kty , ** kwargs ) \u00b6 Generate a key with a specific type and return the resulting Jwk. Parameters: Name Type Description Default kty str key type to generate required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Raises: Type Description UnsupportedKeyType if the key type is not supported Source code in jwskate\\jwk\\base.py 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs ) ec \u00b6 This module implements JWK representing Elliptic Curve keys. UnsupportedEllipticCurve \u00b6 Bases: KeyError Raised when an unsupported Elliptic curve is requested. Source code in jwskate\\jwk\\ec.py 29 30 class UnsupportedEllipticCurve ( KeyError ): \"\"\"Raised when an unsupported Elliptic curve is requested.\"\"\" ECJwk \u00b6 Bases: Jwk Represent an Elliptic Curve Jwk, with kty=EC . Source code in jwskate\\jwk\\ec.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class ECJwk ( Jwk ): \"\"\"Represent an Elliptic Curve Jwk, with `kty=EC`.\"\"\" KTY = \"EC\" CRYPTOGRAPHY_KEY_CLASSES = ( asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ) PARAMS : Mapping [ str , JwkParameter ] = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"X Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"y\" : JwkParameter ( \"Y Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"ECC Private Key\" , is_private = True , is_required = True , kind = \"b64u\" ), } CURVES : Mapping [ str , EllipticCurve ] = { curve . name : curve for curve in [ P_256 , P_384 , P_521 , secp256k1 ] } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ ES256 , ES384 , ES512 , ES256K ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedEllipticCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . encode_to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . encode_to ( \"b64u\" ), ** params , ) ) @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . encode_to ( \"b64u\" ) . decode (), y = BinaPy . from_int ( y , coord_size ) . encode_to ( \"b64u\" ) . decode (), d = BinaPy . from_int ( d , coord_size ) . encode_to ( \"b64u\" ) . decode (), ** params , ) ) @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size @classmethod def from_cryptography_key ( cls , key : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: key: `cryptography` key Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_parameters ( key ) return cls ( parameters ) def to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key () @classmethod def generate ( cls , crv : str = \"P-256\" , ** params : str ) -> \"ECJwk\" : \"\"\"Generates a random ECJwk. Args: crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" curve = cls . get_curve ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = crv , x = x , y = y , d = d , ** params , ) @property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () @property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () @property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) get_curve ( crv ) \u00b6 Get the EllipticCurve instance for a given curve identifier. Parameters: Name Type Description Default crv str the curve identifier required Returns: Type Description EllipticCurve the matching EllipticCurve instance Raises: Type Description UnsupportedEllipticCurve if the curve identifier is not supported Source code in jwskate\\jwk\\ec.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve curve () \u00b6 Get the EllipticCurve instance for this key. Returns: Type Description EllipticCurve the EllipticCurve instance Source code in jwskate\\jwk\\ec.py 92 93 94 95 96 97 98 99 @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) public ( crv , x , y , ** params ) \u00b6 Initialize a public ECJwk from its public parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required **params str additional member to include in the Jwk {} Returns: Type Description 'ECJwk' an ECJwk initialized with the supplied parameters Source code in jwskate\\jwk\\ec.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . encode_to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . encode_to ( \"b64u\" ), ** params , ) ) private ( crv , x , y , d , ** params ) \u00b6 Initialize a private ECJwk from its private parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required d int the elliptic curve private key required **params Any additional members to include in the JWK {} Returns: Type Description 'ECJwk' an ECJWk initialized with the supplied parameters Source code in jwskate\\jwk\\ec.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . encode_to ( \"b64u\" ) . decode (), y = BinaPy . from_int ( y , coord_size ) . encode_to ( \"b64u\" ) . decode (), d = BinaPy . from_int ( d , coord_size ) . encode_to ( \"b64u\" ) . decode (), ** params , ) ) coordinate_size () \u00b6 The coordinate size to use with the key curve. Returns: Type Description int 32, 48, or 66 (bits) Source code in jwskate\\jwk\\ec.py 151 152 153 154 155 156 157 158 @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size from_cryptography_key ( key ) \u00b6 Initialize an ECJwk from a cryptography key. Parameters: Name Type Description Default key Any cryptography key required Returns: Type Description ECJwk an ECJwk initialized from the provided cryptography key Source code in jwskate\\jwk\\ec.py 160 161 162 163 164 165 166 167 168 169 170 171 @classmethod def from_cryptography_key ( cls , key : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: key: `cryptography` key Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_parameters ( key ) return cls ( parameters ) to_cryptography_key () \u00b6 Initialize a cryptography key based on this Jwk. Returns: Type Description Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] an EllipticCurvePublicKey or EllipticCurvePrivateKey Source code in jwskate\\jwk\\ec.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key () generate ( crv = 'P-256' , ** params ) \u00b6 Generates a random ECJwk. Parameters: Name Type Description Default crv str the curve to use 'P-256' **params str {} Returns: Type Description 'ECJwk' a generated ECJwk Raises: Type Description UnsupportedEllipticCurve if the provided curve identifier is not supported. Source code in jwskate\\jwk\\ec.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @classmethod def generate ( cls , crv : str = \"P-256\" , ** params : str ) -> \"ECJwk\" : \"\"\"Generates a random ECJwk. Args: crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" curve = cls . get_curve ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = crv , x = x , y = y , d = d , ** params , ) x_coordinate () \u00b6 Return the x coordinate from this ECJwk. Returns: Type Description int the x coordinate (from parameter x ) Source code in jwskate\\jwk\\ec.py 226 227 228 229 230 231 232 233 @property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () y_coordinate () \u00b6 Return the y coordinate from this ECJwk. Returns: Type Description int the y coordinate (from parameter y ) Source code in jwskate\\jwk\\ec.py 235 236 237 238 239 240 241 242 @property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () ecc_private_key () \u00b6 Return the ECC private key from this ECJwk. Returns: Type Description int the ECC private key (from parameter d ) Source code in jwskate\\jwk\\ec.py 244 245 246 247 248 249 250 251 @property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () supported_signing_algorithms () \u00b6 Return the list of supported signature algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\ec.py 253 254 255 256 257 258 259 260 261 262 263 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] supported_key_management_algorithms () \u00b6 Return the list of supported Key Management algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\ec.py 265 266 267 268 269 270 271 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) supported_encryption_algorithms () \u00b6 Return the list of support Encryption algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\ec.py 273 274 275 276 277 278 279 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) jwks \u00b6 This module implements Json Web Key Sets (JWKS). JwkSet \u00b6 Bases: BaseJsonDict A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. Source code in jwskate\\jwk\\jwks.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class JwkSet ( BaseJsonDict ): \"\"\"A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. \"\"\" def __init__ ( self , jwks : Optional [ Dict [ str , Any ]] = None , keys : Optional [ Iterable [ Jwk ]] = None , ): \"\"\"Intiialize a JwkSet. Multiple inputs can be provided. - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`) - a list of `Jwk` (in parameter `keys` - nothing, to initialize an empty JwkSet Args: jwks: a dict, containing the JwkSet, parsed as a JSON object. keys: a list of Jwk, that will be added to this JwkSet \"\"\" if jwks is None and keys is None : keys = [] if jwks is not None : keys = jwks . pop ( \"keys\" , []) super () . __init__ ( jwks ) # init the dict with all the dict content that is not keys else : super () . __init__ () if keys is not None : for jwk in keys : self . add_jwk ( jwk ) @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" if not isinstance ( jwk , Jwk ): jwk = Jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) # if one or several alg are provided, try only the keys that are compatible with one of the provided alg(s) if alg : for jwk in self . jwks : if jwk . get ( \"alg\" ) == alg : if jwk . verify ( data , signature , alg = alg ): return True if algs : for jwk in self . jwks : alg = jwk . get ( \"alg\" ) if alg is not None and alg in algs : if jwk . verify ( data , signature , algs = algs ): return True # if no kid and no alg are provided, try first the keys flagged for signature verification (`\"use\": \"verify\"`) for jwk in self . jwks : if jwk . get ( \"use\" ) == \"verify\" : if jwk . verify ( data , signature , alg ): return True # then with the keys that have no defined `use` for jwk in self . jwks : if jwk . get ( \"use\" ) is None and jwk . get ( \"alg\" ) is None : try : if jwk . verify ( data , signature , alg ): return True except UnsupportedAlg : continue # no key matches, so consider the signature invalid return False __init__ ( jwks = None , keys = None ) \u00b6 Intiialize a JwkSet. Multiple inputs can be provided. a dict from the parsed JSON object representing this JwkSet (in paramter jwks ) a list of Jwk (in parameter keys nothing, to initialize an empty JwkSet Parameters: Name Type Description Default jwks Optional [ Dict [ str , Any ]] a dict, containing the JwkSet, parsed as a JSON object. None keys Optional [ Iterable [ Jwk ]] a list of Jwk, that will be added to this JwkSet None Source code in jwskate\\jwk\\jwks.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , jwks : Optional [ Dict [ str , Any ]] = None , keys : Optional [ Iterable [ Jwk ]] = None , ): \"\"\"Intiialize a JwkSet. Multiple inputs can be provided. - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`) - a list of `Jwk` (in parameter `keys` - nothing, to initialize an empty JwkSet Args: jwks: a dict, containing the JwkSet, parsed as a JSON object. keys: a list of Jwk, that will be added to this JwkSet \"\"\" if jwks is None and keys is None : keys = [] if jwks is not None : keys = jwks . pop ( \"keys\" , []) super () . __init__ ( jwks ) # init the dict with all the dict content that is not keys else : super () . __init__ () if keys is not None : for jwk in keys : self . add_jwk ( jwk ) jwks () \u00b6 Return the list of keys from this JwkSet, as Jwk instances. Returns: Type Description List [ Jwk ] a list of Jwk Source code in jwskate\\jwk\\jwks.py 48 49 50 51 52 53 54 55 @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) get_jwk_by_kid ( kid ) \u00b6 Return a Jwk from this JwkSet, based on its kid. Parameters: Name Type Description Default kid str the kid of the key to obtain required Returns: Type Description Jwk the key with the matching Key ID Raises: Type Description KeyError if no key matches Source code in jwskate\\jwk\\jwks.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) __len__ () \u00b6 Return the number of Jwk in this JwkSet. Returns: Type Description int the number of keys Source code in jwskate\\jwk\\jwks.py 74 75 76 77 78 79 80 def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) add_jwk ( jwk , kid = None , use = None ) \u00b6 Add a Jwk in this JwkSet. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to add (either a Jwk instance, or a dict containing the Jwk parameters) required kid Optional [ str ] the kid to use, if jwk doesn't contain one None use Optional [ str ] the defined use for the added Jwk None Returns: Type Description str the kid from the added Jwk (it may be generated if no kid is provided) Source code in jwskate\\jwk\\jwks.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" if not isinstance ( jwk , Jwk ): jwk = Jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid remove_jwk ( kid ) \u00b6 Removes a Jwk from this JwkSet, based on a kid . Parameters: Name Type Description Default kid str the kid from the key to be removed. required Raises: Type Description KeyError if no key matches Source code in jwskate\\jwk\\jwks.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass verify ( data , signature , alg = None , algs = None , kid = None ) \u00b6 Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a kid is provided, only the key with this kid will be tried. Otherwise, if an alg or several algs are provided, only keys that are compatible with the supplied alg will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Parameters: Name Type Description Default data bytes the signed data to verify required signature bytes the signature to verify against the signed data required alg Optional [ str ] alg to verify the signature, if there is only 1 None algs Optional [ Iterable [ str ]] list of allowed signature algs, if there are several None kid Optional [ str ] the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys None from this key set may be tried. Returns: Type Description bool True if the signature validates with any of the tried keys, False otherwise Source code in jwskate\\jwk\\jwks.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) # if one or several alg are provided, try only the keys that are compatible with one of the provided alg(s) if alg : for jwk in self . jwks : if jwk . get ( \"alg\" ) == alg : if jwk . verify ( data , signature , alg = alg ): return True if algs : for jwk in self . jwks : alg = jwk . get ( \"alg\" ) if alg is not None and alg in algs : if jwk . verify ( data , signature , algs = algs ): return True # if no kid and no alg are provided, try first the keys flagged for signature verification (`\"use\": \"verify\"`) for jwk in self . jwks : if jwk . get ( \"use\" ) == \"verify\" : if jwk . verify ( data , signature , alg ): return True # then with the keys that have no defined `use` for jwk in self . jwks : if jwk . get ( \"use\" ) is None and jwk . get ( \"alg\" ) is None : try : if jwk . verify ( data , signature , alg ): return True except UnsupportedAlg : continue # no key matches, so consider the signature invalid return False okp \u00b6 This module implements JWK representing Octet Key Pairs from RFC8037 . UnsupportedOKPCurve \u00b6 Bases: KeyError Raised when an unsupported OKP curve is requested. Source code in jwskate\\jwk\\okp.py 21 22 class UnsupportedOKPCurve ( KeyError ): \"\"\"Raised when an unsupported OKP curve is requested.\"\"\" OKPJwk \u00b6 Bases: Jwk Represent an OKP Jwk, with kty=OKP . Source code in jwskate\\jwk\\okp.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 class OKPJwk ( Jwk ): \"\"\"Represent an OKP Jwk, with `kty=OKP`.\"\"\" KTY = \"OKP\" CRYPTOGRAPHY_KEY_CLASSES = ( ed25519 . Ed25519PrivateKey , ed25519 . Ed25519PublicKey , ed448 . Ed448PrivateKey , ed448 . Ed448PublicKey , x25519 . X25519PrivateKey , x25519 . X25519PublicKey , x448 . X448PrivateKey , x448 . X448PublicKey , ) PARAMS = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"Public Key\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Key\" , is_private = True , is_required = False , kind = \"b64u\" ), } CURVES : Mapping [ str , OKPCurve ] = { curve . name : curve for curve in [ Ed25519 , Ed448 , X448 , X25519 ] } SIGNATURE_ALGORITHMS = { alg . name : alg for alg in ( EdDsa ,)} def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedOKPCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) @property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) @property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) @classmethod def from_cryptography_key ( cls , key : Any ) -> OKPJwk : \"\"\"Initialize a OKPJwk from a `cryptography` key. Args: key: Returns: the matching OKPJwk \"\"\" if isinstance ( key , ed25519 . Ed25519PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( key , ed25519 . Ed25519PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( key , ed448 . Ed448PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( key , ed448 . Ed448PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( key , x25519 . X25519PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( key , x25519 . X25519PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( key , x448 . X448PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( key , x448 . X448PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in cls . CRYPTOGRAPHY_KEY_CLASSES ) ) def to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . encode_to ( \"b64u\" ) . ascii (), ** params ) ) @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . encode_to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . encode_to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def generate ( cls , crv : str = \"Ed25519\" , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. Args: crv: the curve to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" curve = cls . get_curve ( crv ) x , d = curve . generate () return cls . private ( crv = crv , x = x , d = d , ** params ) get_curve ( crv ) \u00b6 Get the OKPCurve instance from a curve identifier. Parameters: Name Type Description Default crv str a crv identifier required Returns: Type Description OKPCurve the matching OKPCurve instance Raises: Type Description UnsupportedOKPCurve if the curve is not supported Source code in jwskate\\jwk\\okp.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve curve () \u00b6 Get the OKPCurve instance for this key. Returns: Type Description OKPCurve the OKPCurve for this key Source code in jwskate\\jwk\\okp.py 80 81 82 83 84 85 86 87 @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) public_key () \u00b6 Get the public key from this Jwk. Returns: Type Description bytes the public key (from param x ) Source code in jwskate\\jwk\\okp.py 89 90 91 92 93 94 95 96 @property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) private_key () \u00b6 Get the private key from this Jwk. Returns: Type Description bytes the private key (from param d ) Source code in jwskate\\jwk\\okp.py 98 99 100 101 102 103 104 105 @property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) from_cryptography_key ( key ) \u00b6 Initialize a OKPJwk from a cryptography key. Parameters: Name Type Description Default key Any required Returns: Type Description OKPJwk the matching OKPJwk Source code in jwskate\\jwk\\okp.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 @classmethod def from_cryptography_key ( cls , key : Any ) -> OKPJwk : \"\"\"Initialize a OKPJwk from a `cryptography` key. Args: key: Returns: the matching OKPJwk \"\"\" if isinstance ( key , ed25519 . Ed25519PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( key , ed25519 . Ed25519PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( key , ed448 . Ed448PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( key , ed448 . Ed448PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( key , x25519 . X25519PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( key , x25519 . X25519PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( key , x448 . X448PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( key , x448 . X448PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in cls . CRYPTOGRAPHY_KEY_CLASSES ) ) to_cryptography_key () \u00b6 Intialize a cryptography key based on this Jwk. Returns: Type Description Any a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: Type Description UnsupportedOKPCurve if this Jwk curve is not supported. Source code in jwskate\\jwk\\okp.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) public ( crv , x , ** params ) \u00b6 Initialize a public OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the key curve required x bytes the public key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate\\jwk\\okp.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . encode_to ( \"b64u\" ) . ascii (), ** params ) ) private ( crv , x , d , ** params ) \u00b6 Initialize a private OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the OKP curve required x bytes the public key required d bytes the private key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate\\jwk\\okp.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . encode_to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . encode_to ( \"b64u\" ) . ascii (), ** params , ) ) generate ( crv = 'Ed25519' , ** params ) \u00b6 Generate a private OKPJwk on a given curve. Parameters: Name Type Description Default crv str the curve to use 'Ed25519' **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate\\jwk\\okp.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 @classmethod def generate ( cls , crv : str = \"Ed25519\" , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. Args: crv: the curve to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" curve = cls . get_curve ( crv ) x , d = curve . generate () return cls . private ( crv = crv , x = x , d = d , ** params ) rsa \u00b6 This module implements JWK representing RSA keys. RSAJwk \u00b6 Bases: Jwk Represent a RSA Jwk, with kty=RSA . Source code in jwskate\\jwk\\rsa.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 class RSAJwk ( Jwk ): \"\"\"Represent a RSA Jwk, with `kty=RSA`.\"\"\" KTY = \"RSA\" CRYPTOGRAPHY_KEY_CLASSES = ( rsa . RSAPrivateKey , rsa . RSAPublicKey ) PARAMS = { \"n\" : JwkParameter ( \"Modulus\" , is_private = False , is_required = True , kind = \"b64u\" ), \"e\" : JwkParameter ( \"Exponent\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Exponent\" , is_private = True , is_required = True , kind = \"b64u\" ), \"p\" : JwkParameter ( \"First Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"q\" : JwkParameter ( \"Second Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dp\" : JwkParameter ( \"First Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dq\" : JwkParameter ( \"Second Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" , ), \"qi\" : JwkParameter ( \"First CRT Coefficient\" , is_private = True , is_required = False , kind = \"b64u\" ), \"oth\" : JwkParameter ( \"Other Primes Info\" , is_private = True , is_required = False , kind = \"unsupported\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ RS256 , RS384 , RS512 , PS256 , PS384 , PS512 ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ RsaEsPcks1v1_5 , RsaEsOaep , RsaEsOaepSha256 , RsaEsOaepSha384 , RsaEsOaepSha512 , ] } @classmethod def from_cryptography_key ( cls , key : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: key: a `cryptography` RSA key Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( key , rsa . RSAPrivateKey ): priv = key . private_numbers () # type: ignore[attr-defined] pub = key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( key , rsa . RSAPublicKey ): pub = key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) def to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key () @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public RsaJwk from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . encode_to ( \"b64u\" ) . decode (), e = BinaPy . from_int ( e ) . encode_to ( \"b64u\" ) . decode (), ** params , ) ) @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initializes a Private RsaJwk from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . encode_to ( \"b64u\" ) . decode (), e = BinaPy . from_int ( e ) . encode_to ( \"b64u\" ) . decode (), d = BinaPy . from_int ( d ) . encode_to ( \"b64u\" ) . decode (), p = BinaPy . from_int ( p ) . encode_to ( \"b64u\" ) . decode () if p is not None else None , q = BinaPy . from_int ( q ) . encode_to ( \"b64u\" ) . decode () if q is not None else None , dp = BinaPy . from_int ( dp ) . encode_to ( \"b64u\" ) . decode () if dp is not None else None , dq = BinaPy . from_int ( dq ) . encode_to ( \"b64u\" ) . decode () if dq is not None else None , qi = BinaPy . from_int ( qi ) . encode_to ( \"b64u\" ) . decode () if qi is not None else None , ** params , ) ) @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generates a new random private RSAJwk. Args: key_size: the key size to use for the generated key. (Default value = 4096) **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) @property def modulus ( self ) -> int : \"\"\"Returns the modulus from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () @property def exponent ( self ) -> int : \"\"\"Returns the exponent from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () @property def private_exponent ( self ) -> int : \"\"\"Returns the private exponent from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () @property def first_prime_factor ( self ) -> int : \"\"\"Returns the first prime factor from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int () @property def second_prime_factor ( self ) -> int : \"\"\"Returns the second prime factor from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int () @property def first_factor_crt_exponent ( self ) -> int : \"\"\"Returns the first factor CRT exponent from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () @property def second_factor_crt_exponent ( self ) -> int : \"\"\"Returns the second factor CRT exponent from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () @property def first_crt_coefficient ( self ) -> int : \"\"\"Returns the first CRT coefficient from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () def wrap_key ( self , plainkey : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key using this RSA key. Args: plainkey: the symmetric key to wrap alg: the Key Management alg to use Returns: the wrapped symmetric key \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . public_jwk () . to_cryptography_key ()) ciphertext = wrapper . wrap_key ( plainkey ) return BinaPy ( ciphertext ) def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None , ) -> Jwk : \"\"\"Unwrap a symmetric key using this RSA key. Args: cipherkey: the wrapped symmetric key alg: the Key Management alg to use Returns: the clear-text unwrapped key \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . to_cryptography_key ()) plaintext = wrapper . unwrap_key ( cipherkey ) return SymmetricJwk . from_bytes ( plaintext ) from_cryptography_key ( key ) \u00b6 Initialize a Jwk from a cryptography RSA key. Parameters: Name Type Description Default key Any a cryptography RSA key required Returns: Type Description RSAJwk a RSAJwk initialized with the given key Raises: Type Description TypeError if the given key type is not supported Source code in jwskate\\jwk\\rsa.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @classmethod def from_cryptography_key ( cls , key : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: key: a `cryptography` RSA key Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( key , rsa . RSAPrivateKey ): priv = key . private_numbers () # type: ignore[attr-defined] pub = key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( key , rsa . RSAPublicKey ): pub = key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) to_cryptography_key () \u00b6 Initialize a cryptography key based on this Jwk. Returns: Type Description Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ] a cryptography RSAPrivateKey or RSAPublicKey Source code in jwskate\\jwk\\rsa.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key () public ( n , e , ** params ) \u00b6 Initialize a public RsaJwk from a modulus and an exponent. Parameters: Name Type Description Default n int the modulus required e int the exponent required **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RsaJwk initialized from the provided parameters Source code in jwskate\\jwk\\rsa.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public RsaJwk from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . encode_to ( \"b64u\" ) . decode (), e = BinaPy . from_int ( e ) . encode_to ( \"b64u\" ) . decode (), ** params , ) ) private ( n , e , d , p = None , q = None , dp = None , dq = None , qi = None , ** params ) \u00b6 Initializes a Private RsaJwk from its required parameters. Parameters: Name Type Description Default n int the modulus required e int the exponent required d int the private exponent required p Optional [ int ] the first prime factor None q Optional [ int ] the second prime factor None dp Optional [ int ] the first factor CRT exponent None dq Optional [ int ] the second factor CRT exponent None qi Optional [ int ] the first CRT coefficient None **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized from the given parameters Source code in jwskate\\jwk\\rsa.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initializes a Private RsaJwk from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . encode_to ( \"b64u\" ) . decode (), e = BinaPy . from_int ( e ) . encode_to ( \"b64u\" ) . decode (), d = BinaPy . from_int ( d ) . encode_to ( \"b64u\" ) . decode (), p = BinaPy . from_int ( p ) . encode_to ( \"b64u\" ) . decode () if p is not None else None , q = BinaPy . from_int ( q ) . encode_to ( \"b64u\" ) . decode () if q is not None else None , dp = BinaPy . from_int ( dp ) . encode_to ( \"b64u\" ) . decode () if dp is not None else None , dq = BinaPy . from_int ( dq ) . encode_to ( \"b64u\" ) . decode () if dq is not None else None , qi = BinaPy . from_int ( qi ) . encode_to ( \"b64u\" ) . decode () if qi is not None else None , ** params , ) ) generate ( key_size = 4096 , ** params ) \u00b6 Generates a new random private RSAJwk. Parameters: Name Type Description Default key_size int the key size to use for the generated key. (Default value = 4096) 4096 **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a generated RSAJwk Source code in jwskate\\jwk\\rsa.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generates a new random private RSAJwk. Args: key_size: the key size to use for the generated key. (Default value = 4096) **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) modulus () \u00b6 Returns the modulus from this Jwk. Returns: Type Description int the key modulus (from parameter n ) Source code in jwskate\\jwk\\rsa.py 233 234 235 236 237 238 239 240 @property def modulus ( self ) -> int : \"\"\"Returns the modulus from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () exponent () \u00b6 Returns the exponent from this Jwk. Returns: Type Description int the key exponent (from parameter e ) Source code in jwskate\\jwk\\rsa.py 242 243 244 245 246 247 248 249 @property def exponent ( self ) -> int : \"\"\"Returns the exponent from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () private_exponent () \u00b6 Returns the private exponent from this Jwk. Returns: Type Description int the key private exponent (from parameter d ) Source code in jwskate\\jwk\\rsa.py 251 252 253 254 255 256 257 258 @property def private_exponent ( self ) -> int : \"\"\"Returns the private exponent from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () first_prime_factor () \u00b6 Returns the first prime factor from this Jwk. Returns: Type Description int the first prime factor (from parameter p ) Source code in jwskate\\jwk\\rsa.py 260 261 262 263 264 265 266 267 @property def first_prime_factor ( self ) -> int : \"\"\"Returns the first prime factor from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int () second_prime_factor () \u00b6 Returns the second prime factor from this Jwk. Returns: Type Description int the second prime factor (from parameter q ) Source code in jwskate\\jwk\\rsa.py 269 270 271 272 273 274 275 276 @property def second_prime_factor ( self ) -> int : \"\"\"Returns the second prime factor from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int () first_factor_crt_exponent () \u00b6 Returns the first factor CRT exponent from this Jwk. Returns: Type Description int the first factor CRT coefficient (from parameter dp ) Source code in jwskate\\jwk\\rsa.py 278 279 280 281 282 283 284 285 @property def first_factor_crt_exponent ( self ) -> int : \"\"\"Returns the first factor CRT exponent from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () second_factor_crt_exponent () \u00b6 Returns the second factor CRT exponent from this Jwk. Returns: Type Description int the second factor CRT coefficient (from parameter dq ) Source code in jwskate\\jwk\\rsa.py 287 288 289 290 291 292 293 294 @property def second_factor_crt_exponent ( self ) -> int : \"\"\"Returns the second factor CRT exponent from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () first_crt_coefficient () \u00b6 Returns the first CRT coefficient from this Jwk. Returns: Type Description int the first CRT coefficient (from parameter qi ) Source code in jwskate\\jwk\\rsa.py 296 297 298 299 300 301 302 303 @property def first_crt_coefficient ( self ) -> int : \"\"\"Returns the first CRT coefficient from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () wrap_key ( plainkey , alg = None ) \u00b6 Wrap a symmetric key using this RSA key. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required alg Optional [ str ] the Key Management alg to use None Returns: Type Description BinaPy the wrapped symmetric key Source code in jwskate\\jwk\\rsa.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def wrap_key ( self , plainkey : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key using this RSA key. Args: plainkey: the symmetric key to wrap alg: the Key Management alg to use Returns: the wrapped symmetric key \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . public_jwk () . to_cryptography_key ()) ciphertext = wrapper . wrap_key ( plainkey ) return BinaPy ( ciphertext ) unwrap_key ( cipherkey , alg = None ) \u00b6 Unwrap a symmetric key using this RSA key. Parameters: Name Type Description Default cipherkey bytes the wrapped symmetric key required alg Optional [ str ] the Key Management alg to use None Returns: Type Description Jwk the clear-text unwrapped key Source code in jwskate\\jwk\\rsa.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None , ) -> Jwk : \"\"\"Unwrap a symmetric key using this RSA key. Args: cipherkey: the wrapped symmetric key alg: the Key Management alg to use Returns: the clear-text unwrapped key \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . to_cryptography_key ()) plaintext = wrapper . unwrap_key ( cipherkey ) return SymmetricJwk . from_bytes ( plaintext ) symetric \u00b6 This module implements JWK representing Symmetric keys. SymmetricJwk \u00b6 Bases: Jwk Implement Symetric keys, with kty=oct . Source code in jwskate\\jwk\\symetric.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class SymmetricJwk ( Jwk ): \"\"\"Implement Symetric keys, with `kty=oct`.\"\"\" KTY = \"oct\" CRYPTOGRAPHY_KEY_CLASSES = ( bytes ,) PARAMS = { \"k\" : JwkParameter ( \"Key Value\" , is_private = True , is_required = True , kind = \"b64u\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ HS256 , HS384 , HS512 ]} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ A128KW , A192KW , A256KW , A128GCMKW , A192GCMKW , A256GCMKW , DirectKeyUse , ] } ENCRYPTION_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ Aes128CbcHmacSha256 , Aes192CbcHmacSha384 , Aes256CbcHmacSha512 , A128GCM , A192GCM , A256GCM , ] } def public_jwk ( self ) -> \"Jwk\" : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> \"SymmetricJwk\" : \"\"\"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . encode_to ( \"b64u\" ) . decode (), ** params )) @classmethod def generate ( cls , size : int = 128 , ** params : str ) -> \"SymmetricJwk\" : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: size: the size of the generated key, in bytes **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( size ) return cls . from_bytes ( key , ** params ) @classmethod def generate_for_alg ( cls , alg : str , ** params : str ) -> \"SymmetricJwk\" : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the signing algorithm to use this key with **params: additional members to include in the Jwk Returns: the resulting Jwk Raises: ValueError: if the provided `alg` is not supported \"\"\" if alg in cls . SIGNATURE_ALGORITHMS : sigalg = cls . SIGNATURE_ALGORITHMS [ alg ] return cls . generate ( sigalg . min_key_size , alg = alg , ** params ) if alg in cls . ENCRYPTION_ALGORITHMS : encalg = cls . ENCRYPTION_ALGORITHMS [ alg ] return cls . generate ( encalg . key_size , alg = alg , ** params ) raise ValueError ( \"Unsupported alg\" , alg ) def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . encode_to ( \"sha256\" ) . encode_to ( \"b64u\" ) . ascii () ) def to_cryptography_key ( self ) -> Any : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return self . key @property def key ( self ) -> bytes : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" ) @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 def encrypt ( self , plaintext : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data (`aad`). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) if iv is None : iv = encalg . generate_iv () wrapper = encalg ( self . key ) ciphertext , tag = wrapper . encrypt ( plaintext , iv , aad ) return ciphertext , tag , BinaPy ( iv ) def decrypt ( self , ciphertext : bytes , tag : bytes , iv : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data tag: the authentication tag iv: the Initialization Vector (must be the same as used during encryption) aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) decryptor = encalg ( self . key ) plaintext : bytes = decryptor . decrypt ( ciphertext , tag , iv , aad ) return BinaPy ( plaintext ) def wrap_key ( self , plainkey : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key. Args: plainkey: the symmetric key to wrap alg: the encryption alg to use Returns: the wrapped key Raises: UnsupportedAlg: if the provided alg is not supported \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . to_cryptography_key ()) if isinstance ( wrapper , BaseAesKeyWrap ): cipherkey = wrapper . wrap_key ( plainkey ) else : raise UnsupportedAlg ( keyalg ) return BinaPy ( cipherkey ) def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None ) -> Jwk : \"\"\"Unwrap a symmetric key. Args: cipherkey: the wrapped key alg: the decryption alg Returns: the clear-text symmetric key Raises: UnsupportedAlg: if the provided alg is not supported \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . key ) if isinstance ( wrapper , BaseAesKeyWrap ): plaintext = wrapper . unwrap_key ( cipherkey ) else : raise UnsupportedAlg ( keyalg ) return SymmetricJwk . from_bytes ( plaintext ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . key ) # type: ignore ] def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . key ) ] public_jwk () \u00b6 This always raises a ValueError since SymmetricKeys are always private. Raises: Type Description ValueError symmetric keys are always private, it makes no sense to use them as public keys Source code in jwskate\\jwk\\symetric.py 67 68 69 70 71 72 73 def public_jwk ( self ) -> \"Jwk\" : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) from_bytes ( k , ** params ) \u00b6 Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the k parameter for the returned SymetricKey. Parameters: Name Type Description Default k Union [ bytes , str ] the key to use required **params Any additional members to include in the Jwk {} Returns: Type Description 'SymmetricJwk' the resulting SymmetricJwk Source code in jwskate\\jwk\\symetric.py 75 76 77 78 79 80 81 82 83 84 85 86 @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> \"SymmetricJwk\" : \"\"\"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . encode_to ( \"b64u\" ) . decode (), ** params )) generate ( size = 128 , ** params ) \u00b6 Generate a random SymmetricJwk, with a given key size. Parameters: Name Type Description Default size int the size of the generated key, in bytes 128 **params str additional members to include in the Jwk {} Returns: Type Description 'SymmetricJwk' a SymmetricJwk with a randomly generated key Source code in jwskate\\jwk\\symetric.py 88 89 90 91 92 93 94 95 96 97 98 99 100 @classmethod def generate ( cls , size : int = 128 , ** params : str ) -> \"SymmetricJwk\" : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: size: the size of the generated key, in bytes **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( size ) return cls . from_bytes ( key , ** params ) generate_for_alg ( alg , ** params ) \u00b6 Generate a SymmetricJwk that is suitable for use with the given alg. Parameters: Name Type Description Default alg str the signing algorithm to use this key with required **params str additional members to include in the Jwk {} Returns: Type Description 'SymmetricJwk' the resulting Jwk Raises: Type Description ValueError if the provided alg is not supported Source code in jwskate\\jwk\\symetric.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @classmethod def generate_for_alg ( cls , alg : str , ** params : str ) -> \"SymmetricJwk\" : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the signing algorithm to use this key with **params: additional members to include in the Jwk Returns: the resulting Jwk Raises: ValueError: if the provided `alg` is not supported \"\"\" if alg in cls . SIGNATURE_ALGORITHMS : sigalg = cls . SIGNATURE_ALGORITHMS [ alg ] return cls . generate ( sigalg . min_key_size , alg = alg , ** params ) if alg in cls . ENCRYPTION_ALGORITHMS : encalg = cls . ENCRYPTION_ALGORITHMS [ alg ] return cls . generate ( encalg . key_size , alg = alg , ** params ) raise ValueError ( \"Unsupported alg\" , alg ) thumbprint ( hashalg = 'SHA256' ) \u00b6 Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Returns: Type Description str the calculated thumbprint Source code in jwskate\\jwk\\symetric.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . encode_to ( \"sha256\" ) . encode_to ( \"b64u\" ) . ascii () ) to_cryptography_key () \u00b6 Converts this Jwk into a key usable with cryptography . For SymmetricJwk instances, those are just bytes values. Returns: Type Description Any the raw private key, as bytes Source code in jwskate\\jwk\\symetric.py 142 143 144 145 146 147 148 149 150 def to_cryptography_key ( self ) -> Any : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return self . key key () \u00b6 Returns the raw symmetric key. Returns: Type Description bytes the key from the k parameter, base64u-decoded Source code in jwskate\\jwk\\symetric.py 152 153 154 155 156 157 158 159 @property def key ( self ) -> bytes : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" ) key_size () \u00b6 The key size, in bits. Returns: Type Description int the key size in bits Source code in jwskate\\jwk\\symetric.py 161 162 163 164 165 166 167 168 @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 encrypt ( plaintext , aad = None , alg = None , iv = None ) \u00b6 Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data ( aad ). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the iv parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Parameters: Name Type Description Default plaintext bytes the plaintext to encrypt required aad Optional [ bytes ] the Additional Authentication Data, if any None alg Optional [ str ] the encryption alg to use None iv Optional [ bytes ] the IV to use, if you want a specific value None Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (ciphertext, authentication_tag, iv) tuple Source code in jwskate\\jwk\\symetric.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def encrypt ( self , plaintext : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data (`aad`). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) if iv is None : iv = encalg . generate_iv () wrapper = encalg ( self . key ) ciphertext , tag = wrapper . encrypt ( plaintext , iv , aad ) return ciphertext , tag , BinaPy ( iv ) decrypt ( ciphertext , tag , iv , aad = None , alg = None ) \u00b6 Decrypt arbitrary data. Parameters: Name Type Description Default ciphertext bytes the encrypted data required tag bytes the authentication tag required iv bytes the Initialization Vector (must be the same as used during encryption) required aad Optional [ bytes ] the Additional Authenticated Data (must be the same as used during encryption) None alg Optional [ str ] the decryption alg (must be the same as used during encryption) None Returns: Type Description BinaPy the decrypted clear-text Source code in jwskate\\jwk\\symetric.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def decrypt ( self , ciphertext : bytes , tag : bytes , iv : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data tag: the authentication tag iv: the Initialization Vector (must be the same as used during encryption) aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) decryptor = encalg ( self . key ) plaintext : bytes = decryptor . decrypt ( ciphertext , tag , iv , aad ) return BinaPy ( plaintext ) wrap_key ( plainkey , alg = None ) \u00b6 Wrap a symmetric key. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required alg Optional [ str ] the encryption alg to use None Returns: Type Description BinaPy the wrapped key Raises: Type Description UnsupportedAlg if the provided alg is not supported Source code in jwskate\\jwk\\symetric.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def wrap_key ( self , plainkey : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key. Args: plainkey: the symmetric key to wrap alg: the encryption alg to use Returns: the wrapped key Raises: UnsupportedAlg: if the provided alg is not supported \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . to_cryptography_key ()) if isinstance ( wrapper , BaseAesKeyWrap ): cipherkey = wrapper . wrap_key ( plainkey ) else : raise UnsupportedAlg ( keyalg ) return BinaPy ( cipherkey ) unwrap_key ( cipherkey , alg = None ) \u00b6 Unwrap a symmetric key. Parameters: Name Type Description Default cipherkey bytes the wrapped key required alg Optional [ str ] the decryption alg None Returns: Type Description Jwk the clear-text symmetric key Raises: Type Description UnsupportedAlg if the provided alg is not supported Source code in jwskate\\jwk\\symetric.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None ) -> Jwk : \"\"\"Unwrap a symmetric key. Args: cipherkey: the wrapped key alg: the decryption alg Returns: the clear-text symmetric key Raises: UnsupportedAlg: if the provided alg is not supported \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . key ) if isinstance ( wrapper , BaseAesKeyWrap ): plaintext = wrapper . unwrap_key ( cipherkey ) else : raise UnsupportedAlg ( keyalg ) return SymmetricJwk . from_bytes ( plaintext ) supported_key_management_algorithms () \u00b6 Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\symetric.py 265 266 267 268 269 270 271 272 273 274 275 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . key ) # type: ignore ] supported_encryption_algorithms () \u00b6 Return the list of supported Encryption/Decryption algorithms with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\symetric.py 277 278 279 280 281 282 283 284 285 286 287 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . key ) ] jws \u00b6 This module implements JWS token handling. compact \u00b6 This module implements the JWS Compact format. InvalidJws \u00b6 Bases: ValueError Raised when an invalid Jws is parsed. Source code in jwskate\\jws\\compact.py 18 19 class InvalidJws ( ValueError ): \"\"\"Raised when an invalid Jws is parsed.\"\"\" JwsCompact \u00b6 Bases: BaseCompactToken Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Source code in jwskate\\jws\\compact.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class JwsCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515.\"\"\" def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize a Jws, from its compact representation. Args: value: the JWS token value \"\"\" super () . __init__ ( value ) header , payload , signature = self . split ( self . value ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJws ( \"Invalid JWS header: it must be a Base64URL-encoded JSON object\" ) try : self . payload = BinaPy ( payload ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def split ( cls , value : bytes ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Splits a JWS token value into its (header, payload, signature) parts. Args: value: the JWS token value Returns: a (header, payload, signature) Raises: InvalidJws: if the provided value doesn't have 2 dots. \"\"\" if value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = value . split ( b \".\" ) return BinaPy ( header ), BinaPy ( payload ), BinaPy ( signature ) @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"JwsCompact\" : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) @classmethod def from_parts ( cls , signed_part : Union [ bytes , str ], signature : Union [ bytes , str ] ) -> \"JwsCompact\" : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if not isinstance ( signed_part , bytes ): signed_part = signed_part . encode ( \"ascii\" ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . encode_to ( \"b64u\" )))) @property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) @property def alg ( self ) -> str : \"\"\"Get the signature algorithm (alg) from this token headers. Returns: the `alg` value Raises: AttributeError: if the `alg` header value is not a string \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or not isinstance ( alg , str ): raise AttributeError ( \"This JWS doesn't have a valid 'alg' header\" ) return alg def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg , algs ) def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . split ( self . value ) content = { \"payload\" : payload . ascii (), \"protected\" : protected . ascii (), \"signature\" : signature . ascii (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize () __init__ ( value ) \u00b6 Initialize a Jws, from its compact representation. Parameters: Name Type Description Default value Union [ bytes , str ] the JWS token value required Source code in jwskate\\jws\\compact.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize a Jws, from its compact representation. Args: value: the JWS token value \"\"\" super () . __init__ ( value ) header , payload , signature = self . split ( self . value ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJws ( \"Invalid JWS header: it must be a Base64URL-encoded JSON object\" ) try : self . payload = BinaPy ( payload ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\" ) split ( value ) \u00b6 Splits a JWS token value into its (header, payload, signature) parts. Parameters: Name Type Description Default value bytes the JWS token value required Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (header, payload, signature) Raises: Type Description InvalidJws if the provided value doesn't have 2 dots. Source code in jwskate\\jws\\compact.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @classmethod def split ( cls , value : bytes ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Splits a JWS token value into its (header, payload, signature) parts. Args: value: the JWS token value Returns: a (header, payload, signature) Raises: InvalidJws: if the provided value doesn't have 2 dots. \"\"\" if value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = value . split ( b \".\" ) return BinaPy ( header ), BinaPy ( payload ), BinaPy ( signature ) sign ( payload , jwk , alg = None , extra_headers = None ) \u00b6 Sign a payload and returns the resulting JwsCompact. Parameters: Name Type Description Default payload bytes the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the jwk to use to sign this payload required alg Optional [ str ] the alg to use None extra_headers Optional [ Dict [ str , Any ]] additional headers to add to the Jws Headers None Returns: Type Description 'JwsCompact' the resulting token Source code in jwskate\\jws\\compact.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"JwsCompact\" : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) from_parts ( signed_part , signature ) \u00b6 Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Parameters: Name Type Description Default signed_part Union [ bytes , str ] the signed part required signature Union [ bytes , str ] the signature value required Returns: Type Description 'JwsCompact' the resulting token Source code in jwskate\\jws\\compact.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @classmethod def from_parts ( cls , signed_part : Union [ bytes , str ], signature : Union [ bytes , str ] ) -> \"JwsCompact\" : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if not isinstance ( signed_part , bytes ): signed_part = signed_part . encode ( \"ascii\" ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . encode_to ( \"b64u\" )))) signed_part () \u00b6 Returns the signed part (header + payload) from this JwsCompact. Returns: Type Description bytes the signed part Source code in jwskate\\jws\\compact.py 127 128 129 130 131 132 133 134 @property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) alg () \u00b6 Get the signature algorithm (alg) from this token headers. Returns: Type Description str the alg value Raises: Type Description AttributeError if the alg header value is not a string Source code in jwskate\\jws\\compact.py 136 137 138 139 140 141 142 143 144 145 146 147 148 @property def alg ( self ) -> str : \"\"\"Get the signature algorithm (alg) from this token headers. Returns: the `alg` value Raises: AttributeError: if the `alg` header value is not a string \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or not isinstance ( alg , str ): raise AttributeError ( \"This JWS doesn't have a valid 'alg' header\" ) return alg verify_signature ( jwk , alg = None , algs = None ) \u00b6 Verify the signature from this JwsCompact using a Jwk. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use to validate this signature required alg Optional [ str ] the alg to use, if there is only 1 allowed None algs Optional [ Iterable [ str ]] the allowed algs, if here are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate\\jws\\compact.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg , algs ) flat_json ( unprotected_header = None ) \u00b6 Create a JWS in JSON flat format based on this Compact JWS. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonFlat the resulting token Source code in jwskate\\jws\\compact.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . split ( self . value ) content = { \"payload\" : payload . ascii (), \"protected\" : protected . ascii (), \"signature\" : signature . ascii (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) general_json ( unprotected_header = None ) \u00b6 Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonGeneral the resulting token Source code in jwskate\\jws\\compact.py 190 191 192 193 194 195 196 197 198 199 200 201 202 def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize () json \u00b6 This module implement the JWS JSON flat and general formats. JwsJsonFlat \u00b6 Bases: JwsSignature Represent a JWS with a single signature in JSON flat format. Source code in jwskate\\jws\\json.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class JwsJsonFlat ( JwsSignature ): \"\"\"Represent a JWS with a single signature in JSON flat format.\"\"\" @property def payload ( self ) -> bytes : \"\"\"The JWS payload, decoded. Returns: The raw JWS payload. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) @property def jws_signature ( self ) -> JwsSignature : \"\"\"The JWS signature. Returns: The JWS signature. \"\"\" content = { \"protected\" : self [ \"protected\" ], \"signature\" : self [ \"signature\" ], } header = self . get ( \"header\" ) if header : content [ \"header\" ] = self . header return JwsSignature ( content ) @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> JwsJsonFlat : \"\"\"Signs a payload into a JWS in JSON flat format. Args: payload: the data to sign. jwk: the key to use alg: the signature alg to use extra_protected_headers: additional protected headers to include header: the unprotected header to include **kwargs: extra attributes to include in the JWS Returns: The JWS with the payload, signature, header and extra claims. \"\"\" signature = super () . sign ( payload , jwk , alg , extra_protected_headers , header , ** kwargs ) signature [ \"payload\" ] = BinaPy ( payload ) . encode_to ( \"b64u\" ) . ascii () return cls ( signature ) def generalize ( self ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON general format from this JWS in JSON flat. Returns: A JwsJsonGeneral with the same payload and signature. \"\"\" content = self . copy () protected = content . pop ( \"protected\" ) header = content . pop ( \"header\" , None ) signature = content . pop ( \"signature\" ) jws_signature = { \"protected\" : protected , \"signature\" : signature } if header is not None : jws_signature [ \"header\" ] = header content [ \"signatures\" ] = [ jws_signature ] return JwsJsonGeneral ( content ) def signed_part ( self ) -> bytes : \"\"\"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot (`.`). Returns: The signed data part. \"\"\" return JwsSignature . assemble_signed_part ( self . protected , self . payload ) def compact ( self ) -> JwsCompact : \"\"\"Create a JWS in compact format from this JWS JSON. Returns: A `JwsCompact` with the same payload and signature. \"\"\" return JwsCompact . from_parts ( self . signed_part (), self . signature ) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWS signature with a given key. Args: jwk: the key to use to validate this signature. alg: the signature alg, if only 1 is allowed. algs: the allowed signature algs, if there are several. Returns: `True` if the signature is verified, `False` otherwise. \"\"\" return self . jws_signature . verify ( self . payload , jwk , alg , algs ) payload () \u00b6 The JWS payload, decoded. Returns: Type Description bytes The raw JWS payload. Source code in jwskate\\jws\\json.py 18 19 20 21 22 23 24 25 26 27 28 @property def payload ( self ) -> bytes : \"\"\"The JWS payload, decoded. Returns: The raw JWS payload. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) jws_signature () \u00b6 The JWS signature. Returns: Type Description JwsSignature The JWS signature. Source code in jwskate\\jws\\json.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @property def jws_signature ( self ) -> JwsSignature : \"\"\"The JWS signature. Returns: The JWS signature. \"\"\" content = { \"protected\" : self [ \"protected\" ], \"signature\" : self [ \"signature\" ], } header = self . get ( \"header\" ) if header : content [ \"header\" ] = self . header return JwsSignature ( content ) sign ( payload , jwk , alg = None , extra_protected_headers = None , header = None , ** kwargs ) \u00b6 Signs a payload into a JWS in JSON flat format. Parameters: Name Type Description Default payload bytes the data to sign. required jwk Union [ Jwk , Dict [ str , Any ]] the key to use required alg Optional [ str ] the signature alg to use None extra_protected_headers Optional [ Mapping [ str , Any ]] additional protected headers to include None header Optional [ Any ] the unprotected header to include None **kwargs Any extra attributes to include in the JWS {} Returns: Type Description JwsJsonFlat The JWS with the payload, signature, header and extra claims. Source code in jwskate\\jws\\json.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> JwsJsonFlat : \"\"\"Signs a payload into a JWS in JSON flat format. Args: payload: the data to sign. jwk: the key to use alg: the signature alg to use extra_protected_headers: additional protected headers to include header: the unprotected header to include **kwargs: extra attributes to include in the JWS Returns: The JWS with the payload, signature, header and extra claims. \"\"\" signature = super () . sign ( payload , jwk , alg , extra_protected_headers , header , ** kwargs ) signature [ \"payload\" ] = BinaPy ( payload ) . encode_to ( \"b64u\" ) . ascii () return cls ( signature ) generalize () \u00b6 Create a JWS in JSON general format from this JWS in JSON flat. Returns: Type Description JwsJsonGeneral A JwsJsonGeneral with the same payload and signature. Source code in jwskate\\jws\\json.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def generalize ( self ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON general format from this JWS in JSON flat. Returns: A JwsJsonGeneral with the same payload and signature. \"\"\" content = self . copy () protected = content . pop ( \"protected\" ) header = content . pop ( \"header\" , None ) signature = content . pop ( \"signature\" ) jws_signature = { \"protected\" : protected , \"signature\" : signature } if header is not None : jws_signature [ \"header\" ] = header content [ \"signatures\" ] = [ jws_signature ] return JwsJsonGeneral ( content ) signed_part () \u00b6 The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot ( . ). Returns: Type Description bytes The signed data part. Source code in jwskate\\jws\\json.py 91 92 93 94 95 96 97 98 99 def signed_part ( self ) -> bytes : \"\"\"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot (`.`). Returns: The signed data part. \"\"\" return JwsSignature . assemble_signed_part ( self . protected , self . payload ) compact () \u00b6 Create a JWS in compact format from this JWS JSON. Returns: Type Description JwsCompact A JwsCompact with the same payload and signature. Source code in jwskate\\jws\\json.py 101 102 103 104 105 106 107 def compact ( self ) -> JwsCompact : \"\"\"Create a JWS in compact format from this JWS JSON. Returns: A `JwsCompact` with the same payload and signature. \"\"\" return JwsCompact . from_parts ( self . signed_part (), self . signature ) verify_signature ( jwk , alg = None , algs = None ) \u00b6 Verify this JWS signature with a given key. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the key to use to validate this signature. required alg Optional [ str ] the signature alg, if only 1 is allowed. None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several. None Returns: Type Description bool True if the signature is verified, False otherwise. Source code in jwskate\\jws\\json.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWS signature with a given key. Args: jwk: the key to use to validate this signature. alg: the signature alg, if only 1 is allowed. algs: the allowed signature algs, if there are several. Returns: `True` if the signature is verified, `False` otherwise. \"\"\" return self . jws_signature . verify ( self . payload , jwk , alg , algs ) JwsJsonGeneral \u00b6 Bases: BaseJsonDict Represents a JWS in JSON general format (possibly with multiple signatures). Source code in jwskate\\jws\\json.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 class JwsJsonGeneral ( BaseJsonDict ): \"\"\"Represents a JWS in JSON general format (possibly with multiple signatures).\"\"\" @property def payload ( self ) -> bytes : \"\"\"The raw signed data. Returns: The signed data. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) @classmethod def sign ( cls , payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , ], Union [ Jwk , Mapping [ str , Any ]], ], ) -> JwsJsonGeneral : \"\"\"Sign a payload with several keys and return the resulting JWS JSON in general format. Args: payload: the data to sign *signature_parameters: each of those parameter can be: - a `(jwk, alg, extra_protected_headers, header)` tuple - a `(jwk, alg, extra_protected_headers)` tuple, - a `(jwk, alg)` tuple, - a `jwk` with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. Returns: A JwsJsonGeneral with the generated signatures. \"\"\" jws = cls ({ \"payload\" : BinaPy ( payload ) . encode_to ( \"b64u\" ) . ascii ()}) for parameters in signature_parameters : jws . add_signature ( * parameters ) return jws @property def signatures ( self ) -> List [ JwsSignature ]: \"\"\"The list of `JwsSignature` from this JWS. Returns: The list of signatures from this JWS. \"\"\" signatures = self . get ( \"signatures\" ) if signatures is None : raise AttributeError ( \"This Jws JSON does not contain a 'signatures' member\" ) return [ JwsSignature ( sig ) for sig in signatures ] def add_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral : \"\"\"Add a new signature in this JWS. Args: jwk: the private key to use alg: the signature algorithm extra_protected_headers: additional headers to include, as a {key: value} mapping header: the raw unprotected header to include in the signature Returns: the same JWS with the new signature included. \"\"\" self . setdefault ( \"signatures\" , []) self [ \"signatures\" ] . append ( JwsSignature . sign ( self . payload , jwk , alg , extra_protected_headers , header ) ) return self def signed_part ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> bytes : \"\"\"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (`.`). You can select the specific signature with the `signature_chooser` parameter. By default, the first signature is selected. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: The raw signed part from the chosen signature. \"\"\" signature = signature_chooser ( self . signatures ) return JwsSignature . assemble_signed_part ( signature . protected , self . payload ) def compact ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsCompact : \"\"\"Create a compact JWS from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsCompact with the payload and the chosen signature from this JWS. \"\"\" return JwsCompact . from_parts ( self . signed_part ( signature_chooser ), self . payload ) def flatten ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsJsonFlat with the payload and the chosen signature from this JWS. \"\"\" signature = signature_chooser ( self . signatures ) return JwsJsonFlat . from_parts ( payload = self [ \"payload\" ], protected = signature . protected , header = signature . header , signature = signature . signature , ) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns `True` if at least one signature verifies. Args: jwk: the public key to use alg: the signature algorithm to use, if only 1 is allowed. algs: the allowed signature algorithms, if there are several. Returns: `True` if any of the signature verifies with the given key, `False` otherwise. \"\"\" for signature in self . signatures : if signature . verify ( self . payload , jwk , alg , algs ): return True return False payload () \u00b6 The raw signed data. Returns: Type Description bytes The signed data. Source code in jwskate\\jws\\json.py 131 132 133 134 135 136 137 138 139 140 141 @property def payload ( self ) -> bytes : \"\"\"The raw signed data. Returns: The signed data. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) sign ( payload , * signature_parameters ) \u00b6 Sign a payload with several keys and return the resulting JWS JSON in general format. Parameters: Name Type Description Default payload bytes the data to sign required *signature_parameters Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]]], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]]], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str ], Union [ Jwk , Mapping [ str , Any ]]] each of those parameter can be: - a (jwk, alg, extra_protected_headers, header) tuple - a (jwk, alg, extra_protected_headers) tuple, - a (jwk, alg) tuple, - a jwk with jwk being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. () Returns: Type Description JwsJsonGeneral A JwsJsonGeneral with the generated signatures. Source code in jwskate\\jws\\json.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @classmethod def sign ( cls , payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , ], Union [ Jwk , Mapping [ str , Any ]], ], ) -> JwsJsonGeneral : \"\"\"Sign a payload with several keys and return the resulting JWS JSON in general format. Args: payload: the data to sign *signature_parameters: each of those parameter can be: - a `(jwk, alg, extra_protected_headers, header)` tuple - a `(jwk, alg, extra_protected_headers)` tuple, - a `(jwk, alg)` tuple, - a `jwk` with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. Returns: A JwsJsonGeneral with the generated signatures. \"\"\" jws = cls ({ \"payload\" : BinaPy ( payload ) . encode_to ( \"b64u\" ) . ascii ()}) for parameters in signature_parameters : jws . add_signature ( * parameters ) return jws signatures () \u00b6 The list of JwsSignature from this JWS. Returns: Type Description List [ JwsSignature ] The list of signatures from this JWS. Source code in jwskate\\jws\\json.py 185 186 187 188 189 190 191 192 193 194 195 @property def signatures ( self ) -> List [ JwsSignature ]: \"\"\"The list of `JwsSignature` from this JWS. Returns: The list of signatures from this JWS. \"\"\" signatures = self . get ( \"signatures\" ) if signatures is None : raise AttributeError ( \"This Jws JSON does not contain a 'signatures' member\" ) return [ JwsSignature ( sig ) for sig in signatures ] add_signature ( jwk , alg = None , extra_protected_headers = None , header = None ) \u00b6 Add a new signature in this JWS. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private key to use required alg Optional [ str ] the signature algorithm None extra_protected_headers Optional [ Mapping [ str , Any ]] additional headers to include, as a {key: value} mapping None header Optional [ Mapping [ str , Any ]] the raw unprotected header to include in the signature None Returns: Type Description JwsJsonGeneral the same JWS with the new signature included. Source code in jwskate\\jws\\json.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def add_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral : \"\"\"Add a new signature in this JWS. Args: jwk: the private key to use alg: the signature algorithm extra_protected_headers: additional headers to include, as a {key: value} mapping header: the raw unprotected header to include in the signature Returns: the same JWS with the new signature included. \"\"\" self . setdefault ( \"signatures\" , []) self [ \"signatures\" ] . append ( JwsSignature . sign ( self . payload , jwk , alg , extra_protected_headers , header ) ) return self signed_part ( signature_chooser = lambda sigs : sigs [ 0 ]) \u00b6 Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot ( . ). You can select the specific signature with the signature_chooser parameter. By default, the first signature is selected. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description bytes The raw signed part from the chosen signature. Source code in jwskate\\jws\\json.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def signed_part ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> bytes : \"\"\"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (`.`). You can select the specific signature with the `signature_chooser` parameter. By default, the first signature is selected. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: The raw signed part from the chosen signature. \"\"\" signature = signature_chooser ( self . signatures ) return JwsSignature . assemble_signed_part ( signature . protected , self . payload ) compact ( signature_chooser = lambda sigs : sigs [ 0 ]) \u00b6 Create a compact JWS from a specific signature from this JWS. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description JwsCompact A JwsCompact with the payload and the chosen signature from this JWS. Source code in jwskate\\jws\\json.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def compact ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsCompact : \"\"\"Create a compact JWS from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsCompact with the payload and the chosen signature from this JWS. \"\"\" return JwsCompact . from_parts ( self . signed_part ( signature_chooser ), self . payload ) flatten ( signature_chooser = lambda sigs : sigs [ 0 ]) \u00b6 Create a JWS in JSON flat format from a specific signature from this JWS. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description JwsJsonFlat A JwsJsonFlat with the payload and the chosen signature from this JWS. Source code in jwskate\\jws\\json.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def flatten ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsJsonFlat with the payload and the chosen signature from this JWS. \"\"\" signature = signature_chooser ( self . signatures ) return JwsJsonFlat . from_parts ( payload = self [ \"payload\" ], protected = signature . protected , header = signature . header , signature = signature . signature , ) verify_signature ( jwk , alg = None , algs = None ) \u00b6 Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns True if at least one signature verifies. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the public key to use required alg Optional [ str ] the signature algorithm to use, if only 1 is allowed. None algs Optional [ Iterable [ str ]] the allowed signature algorithms, if there are several. None Returns: Type Description bool True if any of the signature verifies with the given key, False otherwise. Source code in jwskate\\jws\\json.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns `True` if at least one signature verifies. Args: jwk: the public key to use alg: the signature algorithm to use, if only 1 is allowed. algs: the allowed signature algorithms, if there are several. Returns: `True` if any of the signature verifies with the given key, `False` otherwise. \"\"\" for signature in self . signatures : if signature . verify ( self . payload , jwk , alg , algs ): return True return False signature \u00b6 This module implement JWS signatures. JwsSignature \u00b6 Bases: BaseJsonDict Represents a JWS Signature. A JWS Signature has a protected header (as a JSON object) a signature value (as raw data) an unprotected header (as arbitrary JSON data) optional extra JSON attributes Source code in jwskate\\jws\\signature.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class JwsSignature ( BaseJsonDict ): \"\"\"Represents a JWS Signature. A JWS Signature has - a protected header (as a JSON object) - a signature value (as raw data) - an unprotected header (as arbitrary JSON data) - optional extra JSON attributes \"\"\" @classmethod def from_parts ( cls : Type [ S ], protected : Mapping [ str , Any ], signature : bytes , header : Optional [ Any ], ** kwargs : Any , ) -> S : \"\"\"Initialize a JwsSignature based on the provided parts. Args: protected: the protected headers, as a key: value mapping signature: the raw signature value header: the unprotected header, if any **kwargs: extra attributes, if any Returns: A `JwsSignature` based on the provided parts. \"\"\" content = dict ( kwargs , protected = BinaPy . serialize_to ( \"json\" , protected ) . encode_to ( \"b64u\" ) . ascii (), signature = BinaPy ( signature ) . encode_to ( \"b64u\" ) . ascii (), ) if header is not None : content [ \"header\" ] = header return cls ( content ) @property def protected ( self ) -> Dict [ str , Any ]: \"\"\"The protected header. Returns: the protected headers, as a `dict`. Raises: AttributeError: if this signature doesn't have protected headers. \"\"\" protected = self . get ( \"protected\" ) if protected is None : raise AttributeError ( \"This Jws JSON does not contain a 'protected' member\" ) return BinaPy ( protected ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) # type: ignore @property def header ( self ) -> Any : \"\"\"The unprotected header, unaltered. Returns: The unprotected header \"\"\" return self . get ( \"header\" ) @property def signature ( self ) -> bytes : \"\"\"The raw signature. Returns: The raw signed data, unencoded Raises: AttributeError: if no 'signature' member is present \"\"\" signature = self . get ( \"signature\" ) if signature is None : raise AttributeError ( \"This Jws JSON does not contain a 'signature' member\" ) return BinaPy ( signature ) . decode_from ( \"b64u\" ) @classmethod def sign ( cls : Type [ S ], payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> S : \"\"\"Sign a payload and return the generated JWS signature. Args: payload: the raw data to sign jwk: the signature key to use alg: the signature algorithm to use extra_protected_headers: additional protected headers to include, if any header: the unprotected header, if any. **kwargs: additional members to include in this signature Returns: The generated signature. \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_protected_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( protected = headers , signature = signature , header = header , ** kwargs ) @classmethod def assemble_signed_part ( cls , headers : Dict [ str , Any ], payload : Union [ bytes , str ] ) -> bytes : \"\"\"Assemble the protected header and payload to sign, as specified in. [RFC7515 $5.1](https://datatracker.ietf.org/doc/html/rfc7515#section-5.1). Args: headers: the protected headers payload: the raw payload to sign Returns: the raw data to sign \"\"\" return b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ), BinaPy ( payload ) . encode_to ( \"b64u\" ), ) ) def verify ( self , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this signature against the given payload using the provided key. Args: payload: the raw payload jwk: the validation key to use alg: the signature alg t if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the signature is verifier, `False` otherwise \"\"\" jwk = Jwk ( jwk ) signed_part = self . assemble_signed_part ( self . protected , payload ) return jwk . verify ( signed_part , self . signature , alg , algs ) from_parts ( protected , signature , header , ** kwargs ) \u00b6 Initialize a JwsSignature based on the provided parts. Parameters: Name Type Description Default protected Mapping [ str , Any ] the protected headers, as a key: value mapping required signature bytes the raw signature value required header Optional [ Any ] the unprotected header, if any required **kwargs Any extra attributes, if any {} Returns: Type Description S A JwsSignature based on the provided parts. Source code in jwskate\\jws\\signature.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @classmethod def from_parts ( cls : Type [ S ], protected : Mapping [ str , Any ], signature : bytes , header : Optional [ Any ], ** kwargs : Any , ) -> S : \"\"\"Initialize a JwsSignature based on the provided parts. Args: protected: the protected headers, as a key: value mapping signature: the raw signature value header: the unprotected header, if any **kwargs: extra attributes, if any Returns: A `JwsSignature` based on the provided parts. \"\"\" content = dict ( kwargs , protected = BinaPy . serialize_to ( \"json\" , protected ) . encode_to ( \"b64u\" ) . ascii (), signature = BinaPy ( signature ) . encode_to ( \"b64u\" ) . ascii (), ) if header is not None : content [ \"header\" ] = header return cls ( content ) protected () \u00b6 The protected header. Returns: Type Description Dict [ str , Any ] the protected headers, as a dict . Raises: Type Description AttributeError if this signature doesn't have protected headers. Source code in jwskate\\jws\\signature.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @property def protected ( self ) -> Dict [ str , Any ]: \"\"\"The protected header. Returns: the protected headers, as a `dict`. Raises: AttributeError: if this signature doesn't have protected headers. \"\"\" protected = self . get ( \"protected\" ) if protected is None : raise AttributeError ( \"This Jws JSON does not contain a 'protected' member\" ) return BinaPy ( protected ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) # type: ignore header () \u00b6 The unprotected header, unaltered. Returns: Type Description Any The unprotected header Source code in jwskate\\jws\\signature.py 68 69 70 71 72 73 74 75 @property def header ( self ) -> Any : \"\"\"The unprotected header, unaltered. Returns: The unprotected header \"\"\" return self . get ( \"header\" ) signature () \u00b6 The raw signature. Returns: Type Description bytes The raw signed data, unencoded Raises: Type Description AttributeError if no 'signature' member is present Source code in jwskate\\jws\\signature.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @property def signature ( self ) -> bytes : \"\"\"The raw signature. Returns: The raw signed data, unencoded Raises: AttributeError: if no 'signature' member is present \"\"\" signature = self . get ( \"signature\" ) if signature is None : raise AttributeError ( \"This Jws JSON does not contain a 'signature' member\" ) return BinaPy ( signature ) . decode_from ( \"b64u\" ) sign ( payload , jwk , alg = None , extra_protected_headers = None , header = None , ** kwargs ) \u00b6 Sign a payload and return the generated JWS signature. Parameters: Name Type Description Default payload bytes the raw data to sign required jwk Union [ Jwk , Dict [ str , Any ]] the signature key to use required alg Optional [ str ] the signature algorithm to use None extra_protected_headers Optional [ Mapping [ str , Any ]] additional protected headers to include, if any None header Optional [ Any ] the unprotected header, if any. None **kwargs Any additional members to include in this signature {} Returns: Type Description S The generated signature. Source code in jwskate\\jws\\signature.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 @classmethod def sign ( cls : Type [ S ], payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> S : \"\"\"Sign a payload and return the generated JWS signature. Args: payload: the raw data to sign jwk: the signature key to use alg: the signature algorithm to use extra_protected_headers: additional protected headers to include, if any header: the unprotected header, if any. **kwargs: additional members to include in this signature Returns: The generated signature. \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_protected_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( protected = headers , signature = signature , header = header , ** kwargs ) assemble_signed_part ( headers , payload ) \u00b6 Assemble the protected header and payload to sign, as specified in. RFC7515 $5.1 . Parameters: Name Type Description Default headers Dict [ str , Any ] the protected headers required payload Union [ bytes , str ] the raw payload to sign required Returns: Type Description bytes the raw data to sign Source code in jwskate\\jws\\signature.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @classmethod def assemble_signed_part ( cls , headers : Dict [ str , Any ], payload : Union [ bytes , str ] ) -> bytes : \"\"\"Assemble the protected header and payload to sign, as specified in. [RFC7515 $5.1](https://datatracker.ietf.org/doc/html/rfc7515#section-5.1). Args: headers: the protected headers payload: the raw payload to sign Returns: the raw data to sign \"\"\" return b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ), BinaPy ( payload ) . encode_to ( \"b64u\" ), ) ) verify ( payload , jwk , alg = None , algs = None ) \u00b6 Verify this signature against the given payload using the provided key. Parameters: Name Type Description Default payload bytes the raw payload required jwk Union [ Jwk , Dict [ str , Any ]] the validation key to use required alg Optional [ str ] the signature alg t if only 1 is allowed None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the signature is verifier, False otherwise Source code in jwskate\\jws\\signature.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def verify ( self , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this signature against the given payload using the provided key. Args: payload: the raw payload jwk: the validation key to use alg: the signature alg t if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the signature is verifier, `False` otherwise \"\"\" jwk = Jwk ( jwk ) signed_part = self . assemble_signed_part ( self . protected , payload ) return jwk . verify ( signed_part , self . signature , alg , algs ) jwt \u00b6 This module contains all Json Web Key (Jwk) related classes and utilities. base \u00b6 This modules contains the Jwt base class. InvalidJwt \u00b6 Bases: ValueError Raised when an invalid Jwt is parsed. Source code in jwskate\\jwt\\base.py 17 18 class InvalidJwt ( ValueError ): \"\"\"Raised when an invalid Jwt is parsed.\"\"\" Jwt \u00b6 Bases: BaseCompactToken Represents a Json Web Token. Source code in jwskate\\jwt\\base.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class Jwt ( BaseCompactToken ): \"\"\"Represents a Json Web Token.\"\"\" def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 3 : from .encrypted import EncryptedJwt return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls ) @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = Jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) kid = jwk . get ( \"kid\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) headers = dict ( extra_headers or {}, alg = alg ) if kid : headers [ \"kid\" ] = kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . encode_to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . encode_to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . encode_to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc_alg : Optional [ str ], enc : Optional [ str ], ) -> \"EncryptedJwt\" : \"\"\"Sign then encrypt a payload with a `Jwk` and returns the resulting `EncryptedJwt`. NOT IMPLEMENTED YET. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption Returns: the resulting token \"\"\" raise NotImplementedError __new__ ( value ) \u00b6 Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Parameters: Name Type Description Default value Union [ bytes , str ] the token value required Source code in jwskate\\jwt\\base.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 3 : from .encrypted import EncryptedJwt return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls ) sign ( claims , jwk , alg = None , extra_headers = None ) \u00b6 Sign a JSON payload with a Jwk and returns the resulting SignedJwt . This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use .unprotected() instead. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signing required alg Optional [ str ] the alg to use for signing None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the Jwt None Returns: Type Description 'SignedJwt' the resulting token Source code in jwskate\\jwt\\base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = Jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) kid = jwk . get ( \"kid\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) headers = dict ( extra_headers or {}, alg = alg ) if kid : headers [ \"kid\" ] = kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . encode_to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . encode_to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) unprotected ( claims , extra_headers = None ) \u00b6 Generate a JWT that is not signed and not encrypted (with alg=none). Parameters: Name Type Description Default claims Dict [ str , Any ] the claims to set in the token. required extra_headers Optional [ Dict [ str , Any ]] additional headers to insert in the token. None Returns: Type Description 'SignedJwt' the resulting token Source code in jwskate\\jwt\\base.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . encode_to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) sign_and_encrypt ( claims , sign_jwk , sign_alg , enc_jwk , enc_alg , enc ) \u00b6 Sign then encrypt a payload with a Jwk and returns the resulting EncryptedJwt . NOT IMPLEMENTED YET. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to encrypt required sign_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signature required sign_alg Optional [ str ] the alg to use for signature required enc_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for encryption required enc_alg Optional [ str ] the alg to use for CEK encryption required enc Optional [ str ] the alg to use for payload encryption required Returns: Type Description 'EncryptedJwt' the resulting token Source code in jwskate\\jwt\\base.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc_alg : Optional [ str ], enc : Optional [ str ], ) -> \"EncryptedJwt\" : \"\"\"Sign then encrypt a payload with a `Jwk` and returns the resulting `EncryptedJwt`. NOT IMPLEMENTED YET. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption Returns: the resulting token \"\"\" raise NotImplementedError encrypted \u00b6 This module implements Encrypted JWT token handling. EncryptedJwt \u00b6 Bases: Jwt Represent an encrypted JWT. Source code in jwskate\\jwt\\encrypted.py 8 9 10 11 12 13 class EncryptedJwt ( Jwt ): \"\"\"Represent an encrypted JWT.\"\"\" def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize an EncryptedJwt based on its serialized value.\"\"\" raise NotImplementedError __init__ ( value ) \u00b6 Initialize an EncryptedJwt based on its serialized value. Source code in jwskate\\jwt\\encrypted.py 11 12 13 def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize an EncryptedJwt based on its serialized value.\"\"\" raise NotImplementedError signed \u00b6 This modules contains classes and utilities to generate and validate signed JWT. ExpiredJwt \u00b6 Bases: ValueError Raised when trying to validate an expired JWT token. Source code in jwskate\\jwt\\signed.py 13 14 class ExpiredJwt ( ValueError ): \"\"\"Raised when trying to validate an expired JWT token.\"\"\" InvalidSignature \u00b6 Bases: ValueError Raised when trying to validate a JWT with an invalid signature. Source code in jwskate\\jwt\\signed.py 17 18 class InvalidSignature ( ValueError ): \"\"\"Raised when trying to validate a JWT with an invalid signature.\"\"\" InvalidClaim \u00b6 Bases: ValueError Raised when trying to validate a JWT with unexpected claims. Source code in jwskate\\jwt\\signed.py 21 22 class InvalidClaim ( ValueError ): \"\"\"Raised when trying to validate a JWT with unexpected claims.\"\"\" SignedJwt \u00b6 Bases: Jwt Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use Jwt.sign . Source code in jwskate\\jwt\\signed.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 class SignedJwt ( Jwt ): \"\"\"Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use [Jwt.sign][jwskate.jwt.Jwt.sign]. \"\"\" def __init__ ( self , value : Union [ bytes , str ]) -> None : \"\"\"Initialize a `SignedJwt`, from its compact serialized value. Args: value: the token value. \"\"\" super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJwt ( \"A JWT must contain a header, a payload and a signature, separated by dots\" , value , ) header , payload , signature = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT header: it must be a Base64URL-encoded JSON object\" ) try : self . claims = BinaPy ( payload ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\" ) @property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) def is_expired ( self ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < datetime . now () @property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = datetime . fromtimestamp ( exp ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) @property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = datetime . fromtimestamp ( iat ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) @property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = datetime . fromtimestamp ( nbf ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) @property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) @property def audiences ( self ) -> Optional [ List [ str ]]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return None if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) @property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) @property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) @property def alg ( self ) -> Optional [ str ]: \"\"\"Get the signature algorithm from the header. Returns: the token signing alg, from the `alg` header Raises: AttributeError: if the alg is not a string \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or isinstance ( alg , str ): return alg raise AttributeError ( \"alg has an unexpected type\" , type ( alg )) @property def kid ( self ) -> Optional [ str ]: \"\"\"Get the Key ID (kid) from the JWT header. Returns: the token signing key id, from the `kid` header Raises: AttributeError: if the kid is present but is not a string \"\"\" kid = self . get_header ( \"kid\" ) if kid is None or isinstance ( kid , str ): return kid raise AttributeError ( \"kid has an unexpected type\" , type ( kid )) def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signing alg to use to verify the signature. (Default value = None) issuer: the expected issuer for this token. (Default value = None) audience: the expected audience for this token. (Default value = None) check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audience ) if check_exp : if self . is_expired (): raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim ) __init__ ( value ) \u00b6 Initialize a SignedJwt , from its compact serialized value. Parameters: Name Type Description Default value Union [ bytes , str ] the token value. required Source code in jwskate\\jwt\\signed.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , value : Union [ bytes , str ]) -> None : \"\"\"Initialize a `SignedJwt`, from its compact serialized value. Args: value: the token value. \"\"\" super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJwt ( \"A JWT must contain a header, a payload and a signature, separated by dots\" , value , ) header , payload , signature = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT header: it must be a Base64URL-encoded JSON object\" ) try : self . claims = BinaPy ( payload ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\" ) signed_part () \u00b6 Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: Type Description bytes the signed part as bytes Source code in jwskate\\jwt\\signed.py 69 70 71 72 73 74 75 76 77 78 @property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) verify_signature ( jwk , alg = None , algs = None ) \u00b6 Verify this JWT signature using a given key and algorithm(s). Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private Jwk to use to verify the signature required alg Optional [ str ] the alg to use to verify the signature, if only 1 is allowed None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the token signature is verified, False otherwise Source code in jwskate\\jwt\\signed.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) is_expired () \u00b6 Check if this token is expired, based on its exp claim. Returns: Type Description Optional [ bool ] True if the token is expired, False if it's not, None if there is no exp claim. Source code in jwskate\\jwt\\signed.py 102 103 104 105 106 107 108 109 110 111 def is_expired ( self ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < datetime . now () expires_at () \u00b6 Get the \"Expires At\" (exp) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the exp claim, or None if there is no exp claim Raises: Type Description AttributeError if the exp claim cannot be parsed to a date Source code in jwskate\\jwt\\signed.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 @property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = datetime . fromtimestamp ( exp ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) issued_at () \u00b6 Get the \"Issued At\" (iat) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the iat claim, or None if there is no iat claim Raises: Type Description AttributeError if the iss claim cannot be parsed to a date Source code in jwskate\\jwt\\signed.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = datetime . fromtimestamp ( iat ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) not_before () \u00b6 Get the \"Not Before\" (nbf) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the nbf claim, or None if there is no nbf claim Raises: Type Description AttributeError if the nbf claim cannot be parsed to a date Source code in jwskate\\jwt\\signed.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = datetime . fromtimestamp ( nbf ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) issuer () \u00b6 Get the Issuer (iss) claim from this token. Returns: Type Description Optional [ str ] the issuer, as str , or None if there is no \u00ecss claim Raises: Type Description AttributeError if the \u00ecss claim value is not a string Source code in jwskate\\jwt\\signed.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) audiences () \u00b6 Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a list anyway. Returns: Type Description Optional [ List [ str ]] the list of audiences from this token, from the aud claim. Raises: Type Description AttributeError if the audience is an unexpected type Source code in jwskate\\jwt\\signed.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 @property def audiences ( self ) -> Optional [ List [ str ]]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return None if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) subject () \u00b6 Get the Subject (sub) from this token claims. Returns: Type Description Optional [ str ] the subject, as str , or None if there is no sub claim Raises: Type Description AttributeError if the sub value is not a string Source code in jwskate\\jwt\\signed.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 @property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) jwt_token_id () \u00b6 Get the JWT Token ID (jti) from this token claims. Returns: Type Description Optional [ str ] the token identifier, as str , or None if there is no jti claim Raises: Type Description AttributeError if the jti value is not a string Source code in jwskate\\jwt\\signed.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 @property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) alg () \u00b6 Get the signature algorithm from the header. Returns: Type Description Optional [ str ] the token signing alg, from the alg header Raises: Type Description AttributeError if the alg is not a string Source code in jwskate\\jwt\\signed.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 @property def alg ( self ) -> Optional [ str ]: \"\"\"Get the signature algorithm from the header. Returns: the token signing alg, from the `alg` header Raises: AttributeError: if the alg is not a string \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or isinstance ( alg , str ): return alg raise AttributeError ( \"alg has an unexpected type\" , type ( alg )) kid () \u00b6 Get the Key ID (kid) from the JWT header. Returns: Type Description Optional [ str ] the token signing key id, from the kid header Raises: Type Description AttributeError if the kid is present but is not a string Source code in jwskate\\jwt\\signed.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 @property def kid ( self ) -> Optional [ str ]: \"\"\"Get the Key ID (kid) from the JWT header. Returns: the token signing key id, from the `kid` header Raises: AttributeError: if the kid is present but is not a string \"\"\" kid = self . get_header ( \"kid\" ) if kid is None or isinstance ( kid , str ): return kid raise AttributeError ( \"kid has an unexpected type\" , type ( kid )) get_claim ( key , default = None ) \u00b6 Get a claim from this Jwt. Parameters: Name Type Description Default key str the claim name. required default Any a default value if the claim is not found None Returns: Type Description Any the claim value if found, or default if not found Source code in jwskate\\jwt\\signed.py 266 267 268 269 270 271 272 273 274 275 276 def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) __getitem__ ( item ) \u00b6 Allow claim access with subscription. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate\\jwt\\signed.py 278 279 280 281 282 283 284 285 286 287 288 289 290 def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value __getattr__ ( item ) \u00b6 Allow claim access as attributes. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate\\jwt\\signed.py 292 293 294 295 296 297 298 299 300 301 302 303 304 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value __str__ () \u00b6 Return the Jwt serialized value, as str . Returns: Type Description str the serialized token value. Source code in jwskate\\jwt\\signed.py 306 307 308 309 310 311 312 def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () __bytes__ () \u00b6 Return the Jwt serialized value, as bytes . Returns: Type Description bytes the serialized token value. Source code in jwskate\\jwt\\signed.py 314 315 316 317 318 319 320 def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value validate ( jwk , alg = None , issuer = None , audience = None , check_exp = True , ** kwargs ) \u00b6 Validate a SignedJwt signature and expected claims. This verifies the signature using the provided jwk and alg , then checks the token issuer, audience and expiration date. This can also check custom claims using extra kwargs , whose values can be: a static value ( str , int , etc.): the value from the token will be compared \"as-is\" a callable, taking the claim value as parameter: if that callable returns True , the claim is considered as valid Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the signing key to use to verify the signature. required alg Optional [ str ] the signing alg to use to verify the signature. (Default value = None) None issuer Optional [ str ] the expected issuer for this token. (Default value = None) None audience Union [None, str ] the expected audience for this token. (Default value = None) None check_exp bool \u00ecf True (default), check that the token is not expired. True **kwargs Any additional claims to check {} Returns: Type Description None Raises exceptions if any validation check fails. Raises: Type Description InvalidSignature if the signature is not valid InvalidClaim if a claim doesn't validate ExpiredJwt if the expiration date is passed Source code in jwskate\\jwt\\signed.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signing alg to use to verify the signature. (Default value = None) issuer: the expected issuer for this token. (Default value = None) audience: the expected audience for this token. (Default value = None) check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audience ) if check_exp : if self . is_expired (): raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim ) signer \u00b6 This module contains the JwtSigner class. JwtSigner \u00b6 The standardised claims include \u00ecat : issued at date exp : expiration date nbf : not before date: iss : issuer identifier sub : subject identifier aud : audience identifier jti : JWT token ID A helper class to easily sign JWTs with standardised claims. The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling JwtSigner.sign() . This can be used as an alternative to Jwt.sign() when a single issuer issues multiple tokens. Source code in jwskate\\jwt\\signer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class JwtSigner : \"\"\"A helper class to easily sign JWTs with standardised claims. The standardised claims include: - `\u00ecat`: issued at date - `exp`: expiration date - `nbf`: not before date: - `iss`: issuer identifier - `sub`: subject identifier - `aud`: audience identifier - `jti`: JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling `JwtSigner.sign()`. This can be used as an alternative to `Jwt.sign()` when a single issuer issues multiple tokens. \"\"\" def __init__ ( self , issuer : str , jwk : Jwk , alg : Optional [ str ] = None , default_lifetime : int = 60 , default_leeway : Optional [ int ] = None , ): \"\"\"Initialize a `JwtSigner`. Args: issuer: the issuer string to use as `\u00ecss` claim for signed tokens. jwk: the private Jwk to use to sign tokens. alg: the signing alg to use to sign tokens. default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden when calling `.sign()` default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is included. This can be overridden when calling `.sign()` \"\"\" self . issuer = issuer self . jwk = jwk self . alg = jwk . alg or alg self . default_lifetime = default_lifetime self . default_leeway = default_leeway def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = int ( datetime . now () . timestamp ()) lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ()) __init__ ( issuer , jwk , alg = None , default_lifetime = 60 , default_leeway = None ) \u00b6 Initialize a JwtSigner . Parameters: Name Type Description Default issuer str the issuer string to use as \u00ecss claim for signed tokens. required jwk Jwk the private Jwk to use to sign tokens. required alg Optional [ str ] the signing alg to use to sign tokens. None default_lifetime int the default lifetime, in seconds, to use for claim exp . This can be overridden 60 when calling .sign() default_leeway: the default leeway, in seconds, to use for claim nbf . If None, no nbf claim is included. This can be overridden when calling .sign() Source code in jwskate\\jwt\\signer.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , issuer : str , jwk : Jwk , alg : Optional [ str ] = None , default_lifetime : int = 60 , default_leeway : Optional [ int ] = None , ): \"\"\"Initialize a `JwtSigner`. Args: issuer: the issuer string to use as `\u00ecss` claim for signed tokens. jwk: the private Jwk to use to sign tokens. alg: the signing alg to use to sign tokens. default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden when calling `.sign()` default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is included. This can be overridden when calling `.sign()` \"\"\" self . issuer = issuer self . jwk = jwk self . alg = jwk . alg or alg self . default_lifetime = default_lifetime self . default_leeway = default_leeway sign ( subject = None , audience = None , extra_claims = None , extra_headers = None , lifetime = None , leeway = None ) \u00b6 Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim iat , nbf and exp will reflect the current time when the token is signed. exp includes lifetime seconds in the future, and nbf includes leeway seconds in the past. Parameters: Name Type Description Default subject Optional [ str ] the subject to include in claim sub . (Default value = None) None audience Union [ str , Iterable [ str ], None] the audience identifier(s) to include in claim aud . None extra_claims Optional [ Dict [ str , Any ]] additional claims to include in the signed token. (Default value = None) None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the header part. (Default value = None) None lifetime Optional [ int ] lifetime, in seconds, to use for the exp claim. If None, use the default_lifetime defined at initialization time. None leeway Optional [ int ] leeway, in seconds, to use for the nbf claim. If None, use the default_leeway defined at initialization time. None Returns: Type Description SignedJwt the resulting signed token. Source code in jwskate\\jwt\\signer.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = int ( datetime . now () . timestamp ()) lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) generate_jti () \u00b6 Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: Type Description str A unique value suitable for use as JWT Token ID (jti) claim. Source code in jwskate\\jwt\\signer.py 107 108 109 110 111 112 113 114 115 def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ())","title":"API"},{"location":"api/#jwskate","text":"Main module for jwskate . The jwskate module implements the various Json Web Crypto-related standards: JWA, JWK, JWKS, JWE, JWT. Each standard has its own submodule, but for convenience, you can import any class or component directly from the root jwskate module. jwskate doesn't implement any actual cryptographic operation, it just provides a set of convenient wrappers around the cryptography module.","title":"jwskate"},{"location":"api/#jwskate.token","text":"This module contains base classes for all tokens types handled by jwskate .","title":"token"},{"location":"api/#jwskate.token.BaseCompactToken","text":"Base class for all tokens in Compact representation. This includes JWS, JWE, and JWT tokens. Source code in jwskate\\token.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class BaseCompactToken : \"\"\"Base class for all tokens in Compact representation. This includes JWS, JWE, and JWT tokens. \"\"\" def __init__ ( self , value : Union [ bytes , str ], max_size : int = 16 * 1024 ): \"\"\"Initialize a JW{S,E,T} from its string representation. Args: value: the string or bytes representation of this Jwt max_size: if the JWT length is larger than this value, raise a `ValueError`. This is to avoid JSON deserialization vulnerabilities. \"\"\" if len ( value ) > max_size : raise ValueError ( f \"This JWT size exceeds { max_size } bytes, which is abnormally big. \" \"This size limit is made to avoid potential JSON deserialization vulnerabilities or issues. \" \"You can increase this limit by passing a different `max_size` value as parameter.\" ) if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) self . value = value self . headers : Dict [ str , Any ] def __eq__ ( self , other : Any ) -> bool : \"\"\"Check that a Jwt is equal to another. Works with other instances of `Jwt`, or with `str` or `bytes`. Args: other: the other token to compare with Returns: `True` if the other token has the same representation, `False` otherwise \"\"\" if isinstance ( other , BaseCompactToken ): return self . value == other . value if isinstance ( other , str ): return self . value . decode () == other if isinstance ( other , bytes ): return self . value == other return super () . __eq__ ( other ) def get_header ( self , name : str ) -> Any : \"\"\"Get a header from this Jwt. Args: name: the header name Returns: the header value \"\"\" return self . headers . get ( name ) def __repr__ ( self ) -> str : \"\"\"Returns the `str` representation of this token.\"\"\" return self . value . decode () def __bytes__ ( self ) -> bytes : \"\"\"Return the `bytes` representation of this token.\"\"\" return self . value","title":"BaseCompactToken"},{"location":"api/#jwskate.token.BaseCompactToken.__init__","text":"Initialize a JW{S,E,T} from its string representation. Parameters: Name Type Description Default value Union [ bytes , str ] the string or bytes representation of this Jwt required max_size int if the JWT length is larger than this value, raise a ValueError . This is to avoid JSON deserialization vulnerabilities. 16 * 1024 Source code in jwskate\\token.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , value : Union [ bytes , str ], max_size : int = 16 * 1024 ): \"\"\"Initialize a JW{S,E,T} from its string representation. Args: value: the string or bytes representation of this Jwt max_size: if the JWT length is larger than this value, raise a `ValueError`. This is to avoid JSON deserialization vulnerabilities. \"\"\" if len ( value ) > max_size : raise ValueError ( f \"This JWT size exceeds { max_size } bytes, which is abnormally big. \" \"This size limit is made to avoid potential JSON deserialization vulnerabilities or issues. \" \"You can increase this limit by passing a different `max_size` value as parameter.\" ) if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) self . value = value self . headers : Dict [ str , Any ]","title":"__init__()"},{"location":"api/#jwskate.token.BaseCompactToken.__eq__","text":"Check that a Jwt is equal to another. Works with other instances of Jwt , or with str or bytes . Parameters: Name Type Description Default other Any the other token to compare with required Returns: Type Description bool True if the other token has the same representation, False otherwise Source code in jwskate\\token.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __eq__ ( self , other : Any ) -> bool : \"\"\"Check that a Jwt is equal to another. Works with other instances of `Jwt`, or with `str` or `bytes`. Args: other: the other token to compare with Returns: `True` if the other token has the same representation, `False` otherwise \"\"\" if isinstance ( other , BaseCompactToken ): return self . value == other . value if isinstance ( other , str ): return self . value . decode () == other if isinstance ( other , bytes ): return self . value == other return super () . __eq__ ( other )","title":"__eq__()"},{"location":"api/#jwskate.token.BaseCompactToken.get_header","text":"Get a header from this Jwt. Parameters: Name Type Description Default name str the header name required Returns: Type Description Any the header value Source code in jwskate\\token.py 52 53 54 55 56 57 58 59 60 61 def get_header ( self , name : str ) -> Any : \"\"\"Get a header from this Jwt. Args: name: the header name Returns: the header value \"\"\" return self . headers . get ( name )","title":"get_header()"},{"location":"api/#jwskate.token.BaseCompactToken.__repr__","text":"Returns the str representation of this token. Source code in jwskate\\token.py 63 64 65 def __repr__ ( self ) -> str : \"\"\"Returns the `str` representation of this token.\"\"\" return self . value . decode ()","title":"__repr__()"},{"location":"api/#jwskate.token.BaseCompactToken.__bytes__","text":"Return the bytes representation of this token. Source code in jwskate\\token.py 67 68 69 def __bytes__ ( self ) -> bytes : \"\"\"Return the `bytes` representation of this token.\"\"\" return self . value","title":"__bytes__()"},{"location":"api/#jwskate.token.BaseJsonDict","text":"Bases: Dict [ str , Any ] Base class Jwk and tokens in JSON representation. Source code in jwskate\\token.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class BaseJsonDict ( Dict [ str , Any ]): \"\"\"Base class Jwk and tokens in JSON representation.\"\"\" @classmethod def from_json ( cls : Type [ D ], j : str ) -> D : \"\"\"Initialize an object based on a string containing a JSON representation. Args: j: the JSON to parse, still serialized Returns: the resulting object \"\"\" return cls ( json . loads ( j )) def to_json ( self , * args : Any , ** kwargs : Any ) -> str : \"\"\"Serialize the current object into a JSON representation. Args: *args: additional args for json.dumps() **kwargs: additional kwargs for json.dumps() Returns: a JSON representation of the current object \"\"\" return json . dumps ( self , * args , ** kwargs )","title":"BaseJsonDict"},{"location":"api/#jwskate.token.BaseJsonDict.from_json","text":"Initialize an object based on a string containing a JSON representation. Parameters: Name Type Description Default j str the JSON to parse, still serialized required Returns: Type Description D the resulting object Source code in jwskate\\token.py 78 79 80 81 82 83 84 85 86 87 88 @classmethod def from_json ( cls : Type [ D ], j : str ) -> D : \"\"\"Initialize an object based on a string containing a JSON representation. Args: j: the JSON to parse, still serialized Returns: the resulting object \"\"\" return cls ( json . loads ( j ))","title":"from_json()"},{"location":"api/#jwskate.token.BaseJsonDict.to_json","text":"Serialize the current object into a JSON representation. Parameters: Name Type Description Default *args Any additional args for json.dumps() () **kwargs Any additional kwargs for json.dumps() {} Returns: Type Description str a JSON representation of the current object Source code in jwskate\\token.py 90 91 92 93 94 95 96 97 98 99 100 def to_json ( self , * args : Any , ** kwargs : Any ) -> str : \"\"\"Serialize the current object into a JSON representation. Args: *args: additional args for json.dumps() **kwargs: additional kwargs for json.dumps() Returns: a JSON representation of the current object \"\"\" return json . dumps ( self , * args , ** kwargs )","title":"to_json()"},{"location":"api/#jwskate.jwa","text":"This module implements the Json Web Algorithms as defined in RFC7518. Each algorithm is represented as a wrapper around a symmetric or asymmetric key, and exposes the cryptographic operations as methods. The cryptographic operations themselves are delegated to cryptography .","title":"jwa"},{"location":"api/#jwskate.jwa.Ed25519","text":"Ed25519 curve.","title":"Ed25519"},{"location":"api/#jwskate.jwa.P_256","text":"P-256 curve","title":"P_256"},{"location":"api/#jwskate.jwa.Ed448","text":"Ed448 curve.","title":"Ed448"},{"location":"api/#jwskate.jwa.P_384","text":"P-384 curve","title":"P_384"},{"location":"api/#jwskate.jwa.X25519","text":"X25519 curve.","title":"X25519"},{"location":"api/#jwskate.jwa.P_521","text":"P-521 curve","title":"P_521"},{"location":"api/#jwskate.jwa.X448","text":"X448 curve.","title":"X448"},{"location":"api/#jwskate.jwa.secp256k1","text":"secp256k1 curve","title":"secp256k1"},{"location":"api/#jwskate.jwa.PrivateKeyRequired","text":"Bases: AttributeError Raised when a cryptographic operation requires a private key, and a public key has been provided instead. Source code in jwskate\\jwa\\base.py 9 10 class PrivateKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a private key, and a public key has been provided instead.\"\"\"","title":"PrivateKeyRequired"},{"location":"api/#jwskate.jwa.BaseAesKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Base class for AES KW algorithms. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class BaseAesKeyWrap ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Base class for AES KW algorithms.\"\"\" key_size : int \"\"\"Required AES key size in bits.\"\"\" @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey ))","title":"BaseAesKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.key_size","text":"Required AES key size in bits.","title":"key_size"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.check_key","text":"Check that a key is valid for usage with this algorithm. To be valid, a key must be bytes and be of appropriate length (128, 192 or 256 bits). Parameters: Name Type Description Default key bytes a key to check required Raises: Type Description ValueError if the key is not appropriate Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" )","title":"check_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.wrap_key","text":"Wrap a key. Parameters: Name Type Description Default plainkey bytes the key to wrap. required Returns: Name Type Description BinaPy BinaPy the wrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 30 31 32 33 34 35 36 37 38 39 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.unwrap_key","text":"Unwrap a key. Parameters: Name Type Description Default cipherkey bytes the wrapped key. required Returns: Name Type Description BinaPy BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 41 42 43 44 45 46 47 48 49 50 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.DirectKeyUse","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate\\jwa\\key_mgmt\\dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"DirectKeyUse"},{"location":"api/#jwskate.jwa.key_mgmt.dir.DirectKeyUse.direct_key","text":"Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate\\jwa\\key_mgmt\\dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"direct_key()"},{"location":"api/#jwskate.jwa.BaseAesGcmKeyWrap","text":"Bases: BaseAESGCM , BaseKeyManagementAlg Base class for AES-GCM Key wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class BaseAesGcmKeyWrap ( BaseAESGCM , BaseKeyManagementAlg ): \"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\" key_size : int \"\"\"Required key size, in bits.\"\"\" tag_size : int = 16 \"\"\"Authentication tag size, in bits.\"\"\" iv_size : int = 96 \"\"\"Initialisation Vector size, in bits.\"\"\" def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" )","title":"BaseAesGcmKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.key_size","text":"Required key size, in bits.","title":"key_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.tag_size","text":"Authentication tag size, in bits.","title":"tag_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.iv_size","text":"Initialisation Vector size, in bits.","title":"iv_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.wrap_key","text":"Wrap a key using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default plainkey bytes the key to wrap required iv bytes the Initialisation Vector to use required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (wrapped_key, authentication_tag) Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 21 22 23 24 25 26 27 28 29 30 31 def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" )","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.unwrap_key","text":"Unwrap a key and authenticates it with the authentication tag , using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default cipherkey bytes the wrapped key required tag bytes the authentication tag required iv bytes the Initialisation Vector required Returns: Type Description BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 33 34 35 36 37 38 39 40 41 42 43 44 def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" )","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.EllipticCurve","text":"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a cryptography.ec.EllipticCurve , and a coordinate size. Source code in jwskate\\jwa\\ec.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class EllipticCurve : \"\"\"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size. \"\"\" name : str \"\"\" Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` or `enc` fields in JOSE headers.\"\"\" cryptography_curve : ec . EllipticCurve \"\"\"`cryptography` curve instance.\"\"\" coordinate_size : int \"\"\"Coordinate size, in bytes.\"\"\" instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey]): an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) @classmethod def get_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a tuple of `x`, `y` (public coordinates) and `d` (private key), as `int` Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = ( BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) y = ( BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters","title":"EllipticCurve"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.name","text":"Curve name as defined in IANA JOSE . This name will appear in alg or enc fields in JOSE headers.","title":"name"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.cryptography_curve","text":"cryptography curve instance.","title":"cryptography_curve"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.coordinate_size","text":"Coordinate size, in bytes.","title":"coordinate_size"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.instances","text":"Registry of subclasses, in a {name: instance} mapping.","title":"instances"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.__post_init__","text":"Automatically register subclasses in the instance registry. Source code in jwskate\\jwa\\ec.py 34 35 36 def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self","title":"__post_init__()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.generate","text":"Generate a new EC key on this curve. Returns: Type Description Tuple [ int , int , int ] a tuple of 4 int s: x and y coordinates (public key) and d (private key) Source code in jwskate\\jwa\\ec.py 38 39 40 41 42 43 44 45 46 47 48 49 def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d","title":"generate()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_curve","text":"Get the appropriate EllipticCurve instance for a given cryptography EllipticCurvePublicKey . Parameters: Name Type Description Default key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey] an Elliptic Curve private or public key from cryptography . required Returns: Type Description 'EllipticCurve' the appropriate instance of EllipticCurve for the given key. Raises: Type Description NotImplementedError if the curve is not supported Source code in jwskate\\jwa\\ec.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey]): an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" )","title":"get_curve()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_parameters","text":"Extract all private and public parameters from a given cryptography EllipticCurvePrivateKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] an Elliptic Curve public or private key from cryptography . required Returns: Type Description Dict [ str , Any ] a tuple of x , y (public coordinates) and d (private key), as int Raises: Type Description TypeError if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey Source code in jwskate\\jwa\\ec.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @classmethod def get_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a tuple of `x`, `y` (public coordinates) and `d` (private key), as `int` Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = ( BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) y = ( BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters","title":"get_parameters()"},{"location":"api/#jwskate.jwa.BaseRsaKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms.\"\"\" padding : Any name = \"RSA1_5\" description = \"RSAES-PKCS1-v1_5\" private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"BaseRsaKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.__init__","text":"Initialize an alg with a given RSA key. Parameters: Name Type Description Default key Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate\\jwa\\key_mgmt\\rsa.py 26 27 28 29 30 31 32 33 34 def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key","title":"__init__()"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.wrap_key","text":"Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.unwrap_key","text":"Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.EdDsa","text":"Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate\\jwa\\signature\\eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False","title":"EdDsa"},{"location":"api/#jwskate.jwa.PublicKeyRequired","text":"Bases: AttributeError Raised when a cryptographic operation requires a public key, and a private key has been provided instead. Source code in jwskate\\jwa\\base.py 13 14 class PublicKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a public key, and a private key has been provided instead.\"\"\"","title":"PublicKeyRequired"},{"location":"api/#jwskate.jwa.BasePbes2","text":"Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"BasePbes2"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.__init__","text":"Initialize this alg with the given password. Parameters: Name Type Description Default password Union [ bytes , str ] the encryption/decryption password to use required Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 19 20 21 22 23 24 25 26 27 def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password","title":"__init__()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.generate_salt","text":"Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size )","title":"generate_salt()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.derive","text":"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password ))","title":"derive()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.wrap_key","text":"Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.unwrap_key","text":"Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 78 79 80 81 82 83 84 85 86 87 88 89 90 def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.EcdhEs","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = asymmetric . ec . EllipticCurvePublicKey private_key_class = asymmetric . ec . EllipticCurvePrivateKey @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek","title":"EcdhEs"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.otherinfo","text":"Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required keysize int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo )","title":"otherinfo()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.ecdh","text":"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey a private EC key required public_key asymmetric . ec . EllipticCurvePublicKey a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key )","title":"ecdh()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.derive","text":"Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey the private key required public_key asymmetric . ec . EllipticCurvePublicKey the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required keysize int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key ))","title":"derive()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.generate_ephemeral_key","text":"Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description asymmetric . ec . EllipticCurvePrivateKey a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 93 94 95 96 97 98 99 def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve )","title":"generate_ephemeral_key()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.sender_key","text":"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek","title":"sender_key()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.recipient_key","text":"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek","title":"recipient_key()"},{"location":"api/#jwskate.jwa.BaseAlg","text":"Base class for all algorithms. An algorithm has a name and a description , whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms Source code in jwskate\\jwa\\base.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class BaseAlg : \"\"\"Base class for all algorithms. An algorithm has a `name` and a `description`, whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms \"\"\" name : str \"\"\"Technical name of the algorithm\"\"\" description : str \"\"\"Description of the algorithm (human readable)\"\"\" read_only : bool = False \"\"\"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.\"\"\" def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name","title":"BaseAlg"},{"location":"api/#jwskate.jwa.base.BaseAlg.name","text":"Technical name of the algorithm","title":"name"},{"location":"api/#jwskate.jwa.base.BaseAlg.description","text":"Description of the algorithm (human readable)","title":"description"},{"location":"api/#jwskate.jwa.base.BaseAlg.read_only","text":"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.","title":"read_only"},{"location":"api/#jwskate.jwa.base.BaseAlg.__repr__","text":"Use the name of the alg as repr. Source code in jwskate\\jwa\\base.py 30 31 32 def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name","title":"__repr__()"},{"location":"api/#jwskate.jwa.HS256","text":"Bases: BaseHMACSigAlg HMAC using SHA-256 Source code in jwskate\\jwa\\signature\\hmac.py 31 32 33 34 35 36 37 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256\"\"\" name = \"HS256\" description = __doc__ hash_alg = hashes . SHA256 () min_key_size = 256","title":"HS256"},{"location":"api/#jwskate.jwa.BaseSymmetricAlg","text":"Bases: BaseAlg Base class for Symmetric algorithms (using a raw bytes key). Source code in jwskate\\jwa\\base.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class BaseSymmetricAlg ( BaseAlg ): \"\"\"Base class for Symmetric algorithms (using a raw bytes key).\"\"\" def __init__ ( self , key : bytes ): \"\"\"Initialize a Symmetric alg with a given key. Args: key: the key to use for cryptographic operations \"\"\" self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"BaseSymmetricAlg"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.__init__","text":"Initialize a Symmetric alg with a given key. Parameters: Name Type Description Default key bytes the key to use for cryptographic operations required Source code in jwskate\\jwa\\base.py 38 39 40 41 42 43 44 45 def __init__ ( self , key : bytes ): \"\"\"Initialize a Symmetric alg with a given key. Args: key: the key to use for cryptographic operations \"\"\" self . check_key ( key ) self . key = key","title":"__init__()"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.check_key","text":"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description None Returns None . Raises an exception if the key is not suitable Source code in jwskate\\jwa\\base.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.supports_key","text":"Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate\\jwa\\base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"supports_key()"},{"location":"api/#jwskate.jwa.HS384","text":"Bases: BaseHMACSigAlg HMAC using SHA-384 Source code in jwskate\\jwa\\signature\\hmac.py 40 41 42 43 44 45 46 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384\"\"\" name = \"HS384\" description = __doc__ hash_alg = hashes . SHA384 () min_key_size = 384","title":"HS384"},{"location":"api/#jwskate.jwa.OKPCurve","text":"Represent an Octet Key Pair (OKP) Curve. Source code in jwskate\\jwa\\okp.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @dataclass class OKPCurve : \"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\" name : str \"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` headers.\"\"\" description : str \"\"\"Curve description (human readable).\"\"\" cryptography_private_key_class : Type [ Any ] \"\"\"`cryptography` private key class.\"\"\" cryptography_public_key_class : Type [ Any ] \"\"\"`cryptography` public key class.\"\"\" use : str \"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\" instances : ClassVar [ Dict [ str , OKPCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key(Union[PublicKeyProtocol, PrivateKeyProtocol]): `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" )","title":"OKPCurve"},{"location":"api/#jwskate.jwa.okp.OKPCurve.name","text":"Curve name as defined in IANA JOSE . This name will appear in alg headers.","title":"name"},{"location":"api/#jwskate.jwa.okp.OKPCurve.description","text":"Curve description (human readable).","title":"description"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_private_key_class","text":"cryptography private key class.","title":"cryptography_private_key_class"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_public_key_class","text":"cryptography public key class.","title":"cryptography_public_key_class"},{"location":"api/#jwskate.jwa.okp.OKPCurve.use","text":"Curve usage ( 'sig' or ' enc' ).","title":"use"},{"location":"api/#jwskate.jwa.okp.OKPCurve.instances","text":"Registry of subclasses, in a {name: instance} mapping.","title":"instances"},{"location":"api/#jwskate.jwa.okp.OKPCurve.__post_init__","text":"Automatically registers subclasses in the instance registry. Source code in jwskate\\jwa\\okp.py 67 68 69 def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self","title":"__post_init__()"},{"location":"api/#jwskate.jwa.okp.OKPCurve.generate","text":"Generate a new private key on this curve. Returns: Type Description Tuple [ bytes , bytes ] a tuple of x (public part), and d (private part), as bytes Source code in jwskate\\jwa\\okp.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d","title":"generate()"},{"location":"api/#jwskate.jwa.okp.OKPCurve.get_curve","text":"Return the appropriate OKPCurve instance for a given cryptography private or public key. Parameters: Name Type Description Default key(Union[PublicKeyProtocol, PrivateKeyProtocol] cryptography private or public OKP key. required Returns: Name Type Description OKPCurve OKPCurve the appropriate OKPCurve for the given key Raises: Type Description NotImplementedError if the required OKP curve is not supported Source code in jwskate\\jwa\\okp.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key(Union[PublicKeyProtocol, PrivateKeyProtocol]): `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" )","title":"get_curve()"},{"location":"api/#jwskate.jwa.A128GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 47 48 49 50 51 52 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128","title":"A128GCMKW"},{"location":"api/#jwskate.jwa.HS512","text":"Bases: BaseHMACSigAlg HMAC using SHA-512 Source code in jwskate\\jwa\\signature\\hmac.py 49 50 51 52 53 54 55 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512\"\"\" name = \"HS512\" description = __doc__ hash_alg = hashes . SHA512 () min_key_size = 512","title":"HS512"},{"location":"api/#jwskate.jwa.A128KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 53 54 55 56 57 58 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128","title":"A128KW"},{"location":"api/#jwskate.jwa.A192GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 55 56 57 58 59 60 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192","title":"A192GCMKW"},{"location":"api/#jwskate.jwa.ES256","text":"Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 58 59 60 61 62 63 64 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 ()","title":"ES256"},{"location":"api/#jwskate.jwa.A192KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 61 62 63 64 65 66 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192","title":"A192KW"},{"location":"api/#jwskate.jwa.A128GCM","text":"Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 62 63 64 65 66 67 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128","title":"A128GCM"},{"location":"api/#jwskate.jwa.A256GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 63 64 65 66 67 68 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256","title":"A256GCMKW"},{"location":"api/#jwskate.jwa.RS256","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 65 66 67 68 69 70 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 ()","title":"RS256"},{"location":"api/#jwskate.jwa.RsaEsPcks1v1_5","text":"Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 66 67 68 69 70 71 72 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5\"\"\" name = \"RSA1_5\" description = __doc__ padding = padding . PKCS1v15 ()","title":"RsaEsPcks1v1_5"},{"location":"api/#jwskate.jwa.ES384","text":"Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384 Source code in jwskate\\jwa\\signature\\ec.py 67 68 69 70 71 72 73 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 ()","title":"ES384"},{"location":"api/#jwskate.jwa.A256KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 69 70 71 72 73 74 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256","title":"A256KW"},{"location":"api/#jwskate.jwa.A192GCM","text":"Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 70 71 72 73 74 75 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192","title":"A192GCM"},{"location":"api/#jwskate.jwa.RS384","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 73 74 75 76 77 78 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 ()","title":"RS384"},{"location":"api/#jwskate.jwa.RsaEsOaep","text":"Bases: BaseRsaKeyWrap RSAES OAEP using default parameters Source code in jwskate\\jwa\\key_mgmt\\rsa.py 75 76 77 78 79 80 81 82 83 84 85 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , )","title":"RsaEsOaep"},{"location":"api/#jwskate.jwa.ES512","text":"Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512 Source code in jwskate\\jwa\\signature\\ec.py 76 77 78 79 80 81 82 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 ()","title":"ES512"},{"location":"api/#jwskate.jwa.A256GCM","text":"Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 78 79 80 81 82 83 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256","title":"A256GCM"},{"location":"api/#jwskate.jwa.RS512","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 81 82 83 84 85 86 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 ()","title":"RS512"},{"location":"api/#jwskate.jwa.BaseAsymmetricAlg","text":"Bases: Generic [ Kpriv , Kpub ] , BaseAlg Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Source code in jwskate\\jwa\\base.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class BaseAsymmetricAlg ( Generic [ Kpriv , Kpub ], BaseAlg ): \"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. \"\"\" private_key_class : Union [ Type [ Kpriv ], Tuple [ Type [ Kpriv ], ... ]] public_key_class : Union [ Type [ Kpub ], Tuple [ Type [ Kpub ], ... ]] def __init__ ( self , key : Union [ Kpriv , Kpub ]): \"\"\"Initialise an Asymmetric alg with either a private or a public key from the `cryptography` lib. Args: key: the key to use. \"\"\" self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore","title":"BaseAsymmetricAlg"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.__init__","text":"Initialise an Asymmetric alg with either a private or a public key from the cryptography lib. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Source code in jwskate\\jwa\\base.py 95 96 97 98 99 100 101 102 def __init__ ( self , key : Union [ Kpriv , Kpub ]): \"\"\"Initialise an Asymmetric alg with either a private or a public key from the `cryptography` lib. Args: key: the key to use. \"\"\" self . check_key ( key ) self . key = key","title":"__init__()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.check_key","text":"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Returns: Type Description None Returns None. Raises an exception if the key is not suitable. Raises: Type Description Exception if the key is not suitable for use with this alg class Source code in jwskate\\jwa\\base.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\"","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.supports_key","text":"Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate\\jwa\\base.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"supports_key()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.private_key_required","text":"A context manager that checks if this alg is initialised with a private key. Yields: Type Description Iterator [ Kpriv ] the private key Raises: Type Description PrivateKeyRequired if the configured key is not private Source code in jwskate\\jwa\\base.py 138 139 140 141 142 143 144 145 146 147 148 149 150 @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore","title":"private_key_required()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.public_key_required","text":"A context manager that checks if this alg is initialised with a public key. Yields: Type Description Iterator [ Kpub ] The public key Raises: Type Description PublicKeyRequired if the configured key is private Source code in jwskate\\jwa\\base.py 152 153 154 155 156 157 158 159 160 161 162 163 164 @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore","title":"public_key_required()"},{"location":"api/#jwskate.jwa.ES256K","text":"Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 85 86 87 88 89 90 91 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 ()","title":"ES256K"},{"location":"api/#jwskate.jwa.RsaEsOaepSha256","text":"Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 88 89 90 91 92 93 94 95 96 97 98 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , )","title":"RsaEsOaepSha256"},{"location":"api/#jwskate.jwa.PS256","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 89 90 91 92 93 94 95 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 )","title":"PS256"},{"location":"api/#jwskate.jwa.Pbes2_HS256_A128KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 93 94 95 96 97 98 99 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 ()","title":"Pbes2_HS256_A128KW"},{"location":"api/#jwskate.jwa.PS384","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 98 99 100 101 102 103 104 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 )","title":"PS384"},{"location":"api/#jwskate.jwa.RsaEsOaepSha384","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 101 102 103 104 105 106 107 108 109 110 111 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , )","title":"RsaEsOaepSha384"},{"location":"api/#jwskate.jwa.Pbes2_HS384_A192KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 102 103 104 105 106 107 108 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 ()","title":"Pbes2_HS384_A192KW"},{"location":"api/#jwskate.jwa.PS512","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\signature\\rsa.py 107 108 109 110 111 112 113 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 )","title":"PS512"},{"location":"api/#jwskate.jwa.Aes128CbcHmacSha256","text":"Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 108 109 110 111 112 113 114 115 116 class Aes128CbcHmacSha256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 ()","title":"Aes128CbcHmacSha256"},{"location":"api/#jwskate.jwa.Pbes2_HS512_A256KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 111 112 113 114 115 116 117 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 ()","title":"Pbes2_HS512_A256KW"},{"location":"api/#jwskate.jwa.RsaEsOaepSha512","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 114 115 116 117 118 119 120 121 122 123 124 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , )","title":"RsaEsOaepSha512"},{"location":"api/#jwskate.jwa.Aes192CbcHmacSha384","text":"Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 119 120 121 122 123 124 125 126 127 class Aes192CbcHmacSha384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 ()","title":"Aes192CbcHmacSha384"},{"location":"api/#jwskate.jwa.Aes256CbcHmacSha512","text":"Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 130 131 132 133 134 135 136 137 138 139 class Aes256CbcHmacSha512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 ()","title":"Aes256CbcHmacSha512"},{"location":"api/#jwskate.jwa.BaseEcdhEs_AesKw","text":"Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"BaseEcdhEs_AesKw"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.wrap_key_with_epk","text":"Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey )","title":"wrap_key_with_epk()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.unwrap_key_with_epk","text":"Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey bytes the wrapped key required ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"unwrap_key_with_epk()"},{"location":"api/#jwskate.jwa.BaseSignatureAlg","text":"Bases: BaseAlg Base class for signature algorithms. Source code in jwskate\\jwa\\base.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BaseSignatureAlg ( BaseAlg ): \"\"\"Base class for signature algorithms.\"\"\" def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError","title":"BaseSignatureAlg"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.sign","text":"Sign arbitrary data, return the signature. Parameters: Name Type Description Default data bytes raw data to sign required Returns: Type Description BinaPy the raw signature Source code in jwskate\\jwa\\base.py 170 171 172 173 174 175 176 177 178 179 def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError","title":"sign()"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.verify","text":"Verify a signature against some data. Parameters: Name Type Description Default data bytes the raw data to verify required signature bytes the raw signature required Returns: Type Description bool True if the signature matches, False otherwise. Source code in jwskate\\jwa\\base.py 181 182 183 184 185 186 187 188 189 190 191 def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError","title":"verify()"},{"location":"api/#jwskate.jwa.BaseAESEncryptionAlg","text":"Bases: BaseSymmetricAlg Base class for AES encryption algorithms. Source code in jwskate\\jwa\\base.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class BaseAESEncryptionAlg ( BaseSymmetricAlg ): \"\"\"Base class for AES encryption algorithms.\"\"\" key_size : int tag_size : int iv_size : int @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt auth_tag: the authentication tag iv: the Initialisation Vector to use. Must be the same one used during encryption aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError","title":"BaseAESEncryptionAlg"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.check_key","text":"Check that a key is suitable for this algorithm. Parameters: Name Type Description Default key bytes the key to check required Raises: Type Description ValueError if the key is not suitable Source code in jwskate\\jwa\\base.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" )","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_key","text":"Generate a key of an appropriate size for this AES alg subclass. Returns: Type Description BinaPy a random AES key Source code in jwskate\\jwa\\base.py 216 217 218 219 220 221 222 223 @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size )","title":"generate_key()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_iv","text":"Generate an Initialisation Vector of the appropriate size. Returns: Type Description BinaPy a random IV Source code in jwskate\\jwa\\base.py 225 226 227 228 229 230 231 232 @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size )","title":"generate_iv()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.encrypt","text":"Encrypt arbitrary data ( plaintext ) with the given Initialisation Vector ( iv ) and optional Additional Authentication Data ( aad ), return the ciphered text and authentication tag. Parameters: Name Type Description Default plaintext bytes the data to encrypt required iv bytes the Initialisation Vector to use required aad Optional [ bytes ] the Additional Authentication Data required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple of ciphered data and authentication tag Source code in jwskate\\jwa\\base.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError","title":"encrypt()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.decrypt","text":"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required auth_tag bytes the authentication tag required iv bytes the Initialisation Vector to use. Must be the same one used during encryption required aad Optional [ bytes ] the Additional Authentication Data. Must be the same one used during encryption required Returns: Type Description BinaPy the deciphered data Source code in jwskate\\jwa\\base.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt auth_tag: the authentication tag iv: the Initialisation Vector to use. Must be the same one used during encryption aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError","title":"decrypt()"},{"location":"api/#jwskate.jwa.EcdhEs_A128KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 200 201 202 203 204 205 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW","title":"EcdhEs_A128KW"},{"location":"api/#jwskate.jwa.EcdhEs_A192KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 208 209 210 211 212 213 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW","title":"EcdhEs_A192KW"},{"location":"api/#jwskate.jwa.EcdhEs_A256KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 216 217 218 219 220 221 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW","title":"EcdhEs_A256KW"},{"location":"api/#jwskate.jwa.BaseKeyManagementAlg","text":"Bases: BaseAlg Base class for Key Management algorithms. Source code in jwskate\\jwa\\base.py 266 267 class BaseKeyManagementAlg ( BaseAlg ): \"\"\"Base class for Key Management algorithms.\"\"\"","title":"BaseKeyManagementAlg"},{"location":"api/#jwskate.jwa.base","text":"This module implement base classes used by Signature, Encryption and Key Management JWA algorithms.","title":"base"},{"location":"api/#jwskate.jwa.base.PrivateKeyRequired","text":"Bases: AttributeError Raised when a cryptographic operation requires a private key, and a public key has been provided instead. Source code in jwskate\\jwa\\base.py 9 10 class PrivateKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a private key, and a public key has been provided instead.\"\"\"","title":"PrivateKeyRequired"},{"location":"api/#jwskate.jwa.base.PublicKeyRequired","text":"Bases: AttributeError Raised when a cryptographic operation requires a public key, and a private key has been provided instead. Source code in jwskate\\jwa\\base.py 13 14 class PublicKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a public key, and a private key has been provided instead.\"\"\"","title":"PublicKeyRequired"},{"location":"api/#jwskate.jwa.base.BaseAlg","text":"Base class for all algorithms. An algorithm has a name and a description , whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms Source code in jwskate\\jwa\\base.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class BaseAlg : \"\"\"Base class for all algorithms. An algorithm has a `name` and a `description`, whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms \"\"\" name : str \"\"\"Technical name of the algorithm\"\"\" description : str \"\"\"Description of the algorithm (human readable)\"\"\" read_only : bool = False \"\"\"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.\"\"\" def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name","title":"BaseAlg"},{"location":"api/#jwskate.jwa.base.BaseAlg.name","text":"Technical name of the algorithm","title":"name"},{"location":"api/#jwskate.jwa.base.BaseAlg.description","text":"Description of the algorithm (human readable)","title":"description"},{"location":"api/#jwskate.jwa.base.BaseAlg.read_only","text":"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.","title":"read_only"},{"location":"api/#jwskate.jwa.base.BaseAlg.__repr__","text":"Use the name of the alg as repr. Source code in jwskate\\jwa\\base.py 30 31 32 def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name","title":"__repr__()"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg","text":"Bases: BaseAlg Base class for Symmetric algorithms (using a raw bytes key). Source code in jwskate\\jwa\\base.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class BaseSymmetricAlg ( BaseAlg ): \"\"\"Base class for Symmetric algorithms (using a raw bytes key).\"\"\" def __init__ ( self , key : bytes ): \"\"\"Initialize a Symmetric alg with a given key. Args: key: the key to use for cryptographic operations \"\"\" self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"BaseSymmetricAlg"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.__init__","text":"Initialize a Symmetric alg with a given key. Parameters: Name Type Description Default key bytes the key to use for cryptographic operations required Source code in jwskate\\jwa\\base.py 38 39 40 41 42 43 44 45 def __init__ ( self , key : bytes ): \"\"\"Initialize a Symmetric alg with a given key. Args: key: the key to use for cryptographic operations \"\"\" self . check_key ( key ) self . key = key","title":"__init__()"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.check_key","text":"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description None Returns None . Raises an exception if the key is not suitable Source code in jwskate\\jwa\\base.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.supports_key","text":"Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate\\jwa\\base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"supports_key()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg","text":"Bases: Generic [ Kpriv , Kpub ] , BaseAlg Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Source code in jwskate\\jwa\\base.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class BaseAsymmetricAlg ( Generic [ Kpriv , Kpub ], BaseAlg ): \"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. \"\"\" private_key_class : Union [ Type [ Kpriv ], Tuple [ Type [ Kpriv ], ... ]] public_key_class : Union [ Type [ Kpub ], Tuple [ Type [ Kpub ], ... ]] def __init__ ( self , key : Union [ Kpriv , Kpub ]): \"\"\"Initialise an Asymmetric alg with either a private or a public key from the `cryptography` lib. Args: key: the key to use. \"\"\" self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore","title":"BaseAsymmetricAlg"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.__init__","text":"Initialise an Asymmetric alg with either a private or a public key from the cryptography lib. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Source code in jwskate\\jwa\\base.py 95 96 97 98 99 100 101 102 def __init__ ( self , key : Union [ Kpriv , Kpub ]): \"\"\"Initialise an Asymmetric alg with either a private or a public key from the `cryptography` lib. Args: key: the key to use. \"\"\" self . check_key ( key ) self . key = key","title":"__init__()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.check_key","text":"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Returns: Type Description None Returns None. Raises an exception if the key is not suitable. Raises: Type Description Exception if the key is not suitable for use with this alg class Source code in jwskate\\jwa\\base.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\"","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.supports_key","text":"Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate\\jwa\\base.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"supports_key()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.private_key_required","text":"A context manager that checks if this alg is initialised with a private key. Yields: Type Description Iterator [ Kpriv ] the private key Raises: Type Description PrivateKeyRequired if the configured key is not private Source code in jwskate\\jwa\\base.py 138 139 140 141 142 143 144 145 146 147 148 149 150 @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore","title":"private_key_required()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.public_key_required","text":"A context manager that checks if this alg is initialised with a public key. Yields: Type Description Iterator [ Kpub ] The public key Raises: Type Description PublicKeyRequired if the configured key is private Source code in jwskate\\jwa\\base.py 152 153 154 155 156 157 158 159 160 161 162 163 164 @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore","title":"public_key_required()"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg","text":"Bases: BaseAlg Base class for signature algorithms. Source code in jwskate\\jwa\\base.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BaseSignatureAlg ( BaseAlg ): \"\"\"Base class for signature algorithms.\"\"\" def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError","title":"BaseSignatureAlg"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.sign","text":"Sign arbitrary data, return the signature. Parameters: Name Type Description Default data bytes raw data to sign required Returns: Type Description BinaPy the raw signature Source code in jwskate\\jwa\\base.py 170 171 172 173 174 175 176 177 178 179 def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError","title":"sign()"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.verify","text":"Verify a signature against some data. Parameters: Name Type Description Default data bytes the raw data to verify required signature bytes the raw signature required Returns: Type Description bool True if the signature matches, False otherwise. Source code in jwskate\\jwa\\base.py 181 182 183 184 185 186 187 188 189 190 191 def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError","title":"verify()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg","text":"Bases: BaseSymmetricAlg Base class for AES encryption algorithms. Source code in jwskate\\jwa\\base.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class BaseAESEncryptionAlg ( BaseSymmetricAlg ): \"\"\"Base class for AES encryption algorithms.\"\"\" key_size : int tag_size : int iv_size : int @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt auth_tag: the authentication tag iv: the Initialisation Vector to use. Must be the same one used during encryption aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError","title":"BaseAESEncryptionAlg"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.check_key","text":"Check that a key is suitable for this algorithm. Parameters: Name Type Description Default key bytes the key to check required Raises: Type Description ValueError if the key is not suitable Source code in jwskate\\jwa\\base.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" )","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_key","text":"Generate a key of an appropriate size for this AES alg subclass. Returns: Type Description BinaPy a random AES key Source code in jwskate\\jwa\\base.py 216 217 218 219 220 221 222 223 @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size )","title":"generate_key()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_iv","text":"Generate an Initialisation Vector of the appropriate size. Returns: Type Description BinaPy a random IV Source code in jwskate\\jwa\\base.py 225 226 227 228 229 230 231 232 @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size )","title":"generate_iv()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.encrypt","text":"Encrypt arbitrary data ( plaintext ) with the given Initialisation Vector ( iv ) and optional Additional Authentication Data ( aad ), return the ciphered text and authentication tag. Parameters: Name Type Description Default plaintext bytes the data to encrypt required iv bytes the Initialisation Vector to use required aad Optional [ bytes ] the Additional Authentication Data required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple of ciphered data and authentication tag Source code in jwskate\\jwa\\base.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError","title":"encrypt()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.decrypt","text":"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required auth_tag bytes the authentication tag required iv bytes the Initialisation Vector to use. Must be the same one used during encryption required aad Optional [ bytes ] the Additional Authentication Data. Must be the same one used during encryption required Returns: Type Description BinaPy the deciphered data Source code in jwskate\\jwa\\base.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt auth_tag: the authentication tag iv: the Initialisation Vector to use. Must be the same one used during encryption aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError","title":"decrypt()"},{"location":"api/#jwskate.jwa.base.BaseKeyManagementAlg","text":"Bases: BaseAlg Base class for Key Management algorithms. Source code in jwskate\\jwa\\base.py 266 267 class BaseKeyManagementAlg ( BaseAlg ): \"\"\"Base class for Key Management algorithms.\"\"\"","title":"BaseKeyManagementAlg"},{"location":"api/#jwskate.jwa.ec","text":"This module contains classes that describe Elliptic Curves as described in RFC7518.","title":"ec"},{"location":"api/#jwskate.jwa.ec.P_256","text":"P-256 curve","title":"P_256"},{"location":"api/#jwskate.jwa.ec.P_384","text":"P-384 curve","title":"P_384"},{"location":"api/#jwskate.jwa.ec.P_521","text":"P-521 curve","title":"P_521"},{"location":"api/#jwskate.jwa.ec.secp256k1","text":"secp256k1 curve","title":"secp256k1"},{"location":"api/#jwskate.jwa.ec.EllipticCurve","text":"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a cryptography.ec.EllipticCurve , and a coordinate size. Source code in jwskate\\jwa\\ec.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class EllipticCurve : \"\"\"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size. \"\"\" name : str \"\"\" Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` or `enc` fields in JOSE headers.\"\"\" cryptography_curve : ec . EllipticCurve \"\"\"`cryptography` curve instance.\"\"\" coordinate_size : int \"\"\"Coordinate size, in bytes.\"\"\" instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey]): an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) @classmethod def get_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a tuple of `x`, `y` (public coordinates) and `d` (private key), as `int` Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = ( BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) y = ( BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters","title":"EllipticCurve"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.name","text":"Curve name as defined in IANA JOSE . This name will appear in alg or enc fields in JOSE headers.","title":"name"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.cryptography_curve","text":"cryptography curve instance.","title":"cryptography_curve"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.coordinate_size","text":"Coordinate size, in bytes.","title":"coordinate_size"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.instances","text":"Registry of subclasses, in a {name: instance} mapping.","title":"instances"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.__post_init__","text":"Automatically register subclasses in the instance registry. Source code in jwskate\\jwa\\ec.py 34 35 36 def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self","title":"__post_init__()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.generate","text":"Generate a new EC key on this curve. Returns: Type Description Tuple [ int , int , int ] a tuple of 4 int s: x and y coordinates (public key) and d (private key) Source code in jwskate\\jwa\\ec.py 38 39 40 41 42 43 44 45 46 47 48 49 def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d","title":"generate()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_curve","text":"Get the appropriate EllipticCurve instance for a given cryptography EllipticCurvePublicKey . Parameters: Name Type Description Default key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey] an Elliptic Curve private or public key from cryptography . required Returns: Type Description 'EllipticCurve' the appropriate instance of EllipticCurve for the given key. Raises: Type Description NotImplementedError if the curve is not supported Source code in jwskate\\jwa\\ec.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key(Union[ec.EllipticCurvePublicKey, ec.EllipticCurvePrivateKey]): an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" )","title":"get_curve()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_parameters","text":"Extract all private and public parameters from a given cryptography EllipticCurvePrivateKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] an Elliptic Curve public or private key from cryptography . required Returns: Type Description Dict [ str , Any ] a tuple of x , y (public coordinates) and d (private key), as int Raises: Type Description TypeError if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey Source code in jwskate\\jwa\\ec.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @classmethod def get_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a tuple of `x`, `y` (public coordinates) and `d` (private key), as `int` Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = ( BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) y = ( BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . encode_to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters","title":"get_parameters()"},{"location":"api/#jwskate.jwa.okp","text":"This module contains classes that describe CFRG Elliptic Curve Diffie- Hellman algorithms as specified in RFC8037.","title":"okp"},{"location":"api/#jwskate.jwa.okp.Ed25519","text":"Ed25519 curve.","title":"Ed25519"},{"location":"api/#jwskate.jwa.okp.Ed448","text":"Ed448 curve.","title":"Ed448"},{"location":"api/#jwskate.jwa.okp.X25519","text":"X25519 curve.","title":"X25519"},{"location":"api/#jwskate.jwa.okp.X448","text":"X448 curve.","title":"X448"},{"location":"api/#jwskate.jwa.okp.OKPCurve","text":"Represent an Octet Key Pair (OKP) Curve. Source code in jwskate\\jwa\\okp.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @dataclass class OKPCurve : \"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\" name : str \"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` headers.\"\"\" description : str \"\"\"Curve description (human readable).\"\"\" cryptography_private_key_class : Type [ Any ] \"\"\"`cryptography` private key class.\"\"\" cryptography_public_key_class : Type [ Any ] \"\"\"`cryptography` public key class.\"\"\" use : str \"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\" instances : ClassVar [ Dict [ str , OKPCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key(Union[PublicKeyProtocol, PrivateKeyProtocol]): `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" )","title":"OKPCurve"},{"location":"api/#jwskate.jwa.okp.OKPCurve.name","text":"Curve name as defined in IANA JOSE . This name will appear in alg headers.","title":"name"},{"location":"api/#jwskate.jwa.okp.OKPCurve.description","text":"Curve description (human readable).","title":"description"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_private_key_class","text":"cryptography private key class.","title":"cryptography_private_key_class"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_public_key_class","text":"cryptography public key class.","title":"cryptography_public_key_class"},{"location":"api/#jwskate.jwa.okp.OKPCurve.use","text":"Curve usage ( 'sig' or ' enc' ).","title":"use"},{"location":"api/#jwskate.jwa.okp.OKPCurve.instances","text":"Registry of subclasses, in a {name: instance} mapping.","title":"instances"},{"location":"api/#jwskate.jwa.okp.OKPCurve.__post_init__","text":"Automatically registers subclasses in the instance registry. Source code in jwskate\\jwa\\okp.py 67 68 69 def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self","title":"__post_init__()"},{"location":"api/#jwskate.jwa.okp.OKPCurve.generate","text":"Generate a new private key on this curve. Returns: Type Description Tuple [ bytes , bytes ] a tuple of x (public part), and d (private part), as bytes Source code in jwskate\\jwa\\okp.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d","title":"generate()"},{"location":"api/#jwskate.jwa.okp.OKPCurve.get_curve","text":"Return the appropriate OKPCurve instance for a given cryptography private or public key. Parameters: Name Type Description Default key(Union[PublicKeyProtocol, PrivateKeyProtocol] cryptography private or public OKP key. required Returns: Name Type Description OKPCurve OKPCurve the appropriate OKPCurve for the given key Raises: Type Description NotImplementedError if the required OKP curve is not supported Source code in jwskate\\jwa\\okp.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key(Union[PublicKeyProtocol, PrivateKeyProtocol]): `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" )","title":"get_curve()"},{"location":"api/#jwskate.jwa.encryption","text":"This module exposes the Encryption algorithms that are available in jwskate .","title":"encryption"},{"location":"api/#jwskate.jwa.encryption.A128GCM","text":"Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 62 63 64 65 66 67 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128","title":"A128GCM"},{"location":"api/#jwskate.jwa.encryption.A192GCM","text":"Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 70 71 72 73 74 75 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192","title":"A192GCM"},{"location":"api/#jwskate.jwa.encryption.A256GCM","text":"Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 78 79 80 81 82 83 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256","title":"A256GCM"},{"location":"api/#jwskate.jwa.encryption.Aes128CbcHmacSha256","text":"Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 108 109 110 111 112 113 114 115 116 class Aes128CbcHmacSha256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 ()","title":"Aes128CbcHmacSha256"},{"location":"api/#jwskate.jwa.encryption.Aes192CbcHmacSha384","text":"Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 119 120 121 122 123 124 125 126 127 class Aes192CbcHmacSha384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 ()","title":"Aes192CbcHmacSha384"},{"location":"api/#jwskate.jwa.encryption.Aes256CbcHmacSha512","text":"Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 130 131 132 133 134 135 136 137 138 139 class Aes256CbcHmacSha512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 ()","title":"Aes256CbcHmacSha512"},{"location":"api/#jwskate.jwa.encryption.aescbchmac","text":"This module implements AES-CBC with HMAC-SHA based Encryption algorithms.","title":"aescbchmac"},{"location":"api/#jwskate.jwa.encryption.aescbchmac.BaseAesCbcHmacSha2","text":"Bases: BaseAESEncryptionAlg Implements the family of AES-CBC with HMAC-SHA encryption algorithms. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class BaseAesCbcHmacSha2 ( BaseAESEncryptionAlg ): \"\"\"Implements the family of AES-CBC with HMAC-SHA encryption algorithms.\"\"\" mac_key_size : int \"\"\"Required key size for the Hash algorithm, in bits.\"\"\" aes_key_size : int \"\"\"Required key size for the AES algorithm, in bits.\"\"\" iv_size : int = 128 \"\"\"Initialization Vector size for the AES algorithm, in bits.\"\"\" hash_alg : hashes . HashAlgorithm \"\"\"Hash algorithm to use.\"\"\" def __init_subclass__ ( cls ) -> None : \"\"\"This automatically sets the total key size based on the MAC and AES key sizes.\"\"\" cls . key_size = cls . mac_key_size + cls . aes_key_size def __init__ ( self , key : bytes ) -> None : \"\"\"Initialize this wrapper with the given key. Args: key: the key to use for encryption and decryption. \"\"\" super () . __init__ ( key ) self . mac_key = self . key [: self . mac_key_size // 8 ] self . aes_key = self . key [ self . mac_key_size // 8 :] self . padding = padding . PKCS7 ( algorithms . AES . block_size ) def mac ( self , ciphertext : bytes , iv : bytes , aad : Optional [ bytes ] = None ) -> BinaPy : \"\"\"Produce a Message Authentication Code for the given `ciphertext`, `iv` and `aad`. Args: ciphertext: the ciphertext iv: the Initialization Vector aad: the Additional Authenticated data Returns: the resulting MAC. \"\"\" if aad is None : aad = b \"\" al = BinaPy . from_int ( len ( aad ) * 8 , length = 8 , byteorder = \"big\" , signed = False ) hasher = hmac . HMAC ( self . mac_key , self . hash_alg ) for param in ( aad , iv , ciphertext , al ): hasher . update ( param ) digest = hasher . finalize () mac = digest [: self . tag_size ] return BinaPy ( mac ) def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] = None ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt and MAC the given `plaintext`, using the given Initialization Vector (`iv`) and optional Additional Authenticated Data (`aad`). Args: plaintext: the plain data to encrypt iv: the Initialization Vector aad: the Additional Authenticated Data, if any Returns: a tuple (encrypted_data, authentication_tag) \"\"\" cipher = ciphers . Cipher ( algorithms . AES ( self . aes_key ), modes . CBC ( iv )) . encryptor () padder = self . padding . padder () padded_text = padder . update ( plaintext ) + padder . finalize () ciphertext = cipher . update ( padded_text ) + cipher . finalize () mac = self . mac ( ciphertext , iv , aad ) return BinaPy ( ciphertext ), BinaPy ( mac ) def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt and authenticate the given ciphertext with authentication tag (`ciphertext_with_tag`), as produced by `encrypt()`. Args: ciphertext: the ciphertext auth_tag: the authentication tag iv: the Initialization Vector aad: the Additional Authenticated Data, if any Returns: the decrypted data \"\"\" mac = self . mac ( ciphertext , iv , aad ) if not constant_time . bytes_eq ( mac , auth_tag ): raise exceptions . InvalidSignature () cipher = ciphers . Cipher ( algorithms . AES ( self . aes_key ), modes . CBC ( iv )) . decryptor () padded_text = cipher . update ( ciphertext ) + cipher . finalize () unpadder = self . padding . unpadder () return BinaPy ( unpadder . update ( padded_text ) + unpadder . finalize ()) mac_key_size : int = None class-attribute \u00b6 Required key size for the Hash algorithm, in bits. aes_key_size : int = None class-attribute \u00b6 Required key size for the AES algorithm, in bits. iv_size : int = 128 class-attribute \u00b6 Initialization Vector size for the AES algorithm, in bits. hash_alg : hashes . HashAlgorithm = None class-attribute \u00b6 Hash algorithm to use. __init_subclass__ () \u00b6 This automatically sets the total key size based on the MAC and AES key sizes. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 28 29 30 def __init_subclass__ ( cls ) -> None : \"\"\"This automatically sets the total key size based on the MAC and AES key sizes.\"\"\" cls . key_size = cls . mac_key_size + cls . aes_key_size __init__ ( key ) \u00b6 Initialize this wrapper with the given key. Parameters: Name Type Description Default key bytes the key to use for encryption and decryption. required Source code in jwskate\\jwa\\encryption\\aescbchmac.py 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , key : bytes ) -> None : \"\"\"Initialize this wrapper with the given key. Args: key: the key to use for encryption and decryption. \"\"\" super () . __init__ ( key ) self . mac_key = self . key [: self . mac_key_size // 8 ] self . aes_key = self . key [ self . mac_key_size // 8 :] self . padding = padding . PKCS7 ( algorithms . AES . block_size ) mac ( ciphertext , iv , aad = None ) \u00b6 Produce a Message Authentication Code for the given ciphertext , iv and aad . Parameters: Name Type Description Default ciphertext bytes the ciphertext required iv bytes the Initialization Vector required aad Optional [ bytes ] the Additional Authenticated data None Returns: Type Description BinaPy the resulting MAC. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def mac ( self , ciphertext : bytes , iv : bytes , aad : Optional [ bytes ] = None ) -> BinaPy : \"\"\"Produce a Message Authentication Code for the given `ciphertext`, `iv` and `aad`. Args: ciphertext: the ciphertext iv: the Initialization Vector aad: the Additional Authenticated data Returns: the resulting MAC. \"\"\" if aad is None : aad = b \"\" al = BinaPy . from_int ( len ( aad ) * 8 , length = 8 , byteorder = \"big\" , signed = False ) hasher = hmac . HMAC ( self . mac_key , self . hash_alg ) for param in ( aad , iv , ciphertext , al ): hasher . update ( param ) digest = hasher . finalize () mac = digest [: self . tag_size ] return BinaPy ( mac ) encrypt ( plaintext , iv , aad = None ) \u00b6 Encrypt and MAC the given plaintext , using the given Initialization Vector ( iv ) and optional Additional Authenticated Data ( aad ). Parameters: Name Type Description Default plaintext bytes the plain data to encrypt required iv bytes the Initialization Vector required aad Optional [ bytes ] the Additional Authenticated Data, if any None Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (encrypted_data, authentication_tag) Source code in jwskate\\jwa\\encryption\\aescbchmac.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] = None ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt and MAC the given `plaintext`, using the given Initialization Vector (`iv`) and optional Additional Authenticated Data (`aad`). Args: plaintext: the plain data to encrypt iv: the Initialization Vector aad: the Additional Authenticated Data, if any Returns: a tuple (encrypted_data, authentication_tag) \"\"\" cipher = ciphers . Cipher ( algorithms . AES ( self . aes_key ), modes . CBC ( iv )) . encryptor () padder = self . padding . padder () padded_text = padder . update ( plaintext ) + padder . finalize () ciphertext = cipher . update ( padded_text ) + cipher . finalize () mac = self . mac ( ciphertext , iv , aad ) return BinaPy ( ciphertext ), BinaPy ( mac ) decrypt ( ciphertext , auth_tag , iv , aad ) \u00b6 Decrypt and authenticate the given ciphertext with authentication tag ( ciphertext_with_tag ), as produced by encrypt() . Parameters: Name Type Description Default ciphertext bytes the ciphertext required auth_tag bytes the authentication tag required iv bytes the Initialization Vector required aad Optional [ bytes ] the Additional Authenticated Data, if any required Returns: Type Description BinaPy the decrypted data Source code in jwskate\\jwa\\encryption\\aescbchmac.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt and authenticate the given ciphertext with authentication tag (`ciphertext_with_tag`), as produced by `encrypt()`. Args: ciphertext: the ciphertext auth_tag: the authentication tag iv: the Initialization Vector aad: the Additional Authenticated Data, if any Returns: the decrypted data \"\"\" mac = self . mac ( ciphertext , iv , aad ) if not constant_time . bytes_eq ( mac , auth_tag ): raise exceptions . InvalidSignature () cipher = ciphers . Cipher ( algorithms . AES ( self . aes_key ), modes . CBC ( iv )) . decryptor () padded_text = cipher . update ( ciphertext ) + cipher . finalize () unpadder = self . padding . unpadder () return BinaPy ( unpadder . update ( padded_text ) + unpadder . finalize ())","title":"BaseAesCbcHmacSha2"},{"location":"api/#jwskate.jwa.encryption.aescbchmac.Aes128CbcHmacSha256","text":"Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 108 109 110 111 112 113 114 115 116 class Aes128CbcHmacSha256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 ()","title":"Aes128CbcHmacSha256"},{"location":"api/#jwskate.jwa.encryption.aescbchmac.Aes192CbcHmacSha384","text":"Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 119 120 121 122 123 124 125 126 127 class Aes192CbcHmacSha384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 ()","title":"Aes192CbcHmacSha384"},{"location":"api/#jwskate.jwa.encryption.aescbchmac.Aes256CbcHmacSha512","text":"Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate\\jwa\\encryption\\aescbchmac.py 130 131 132 133 134 135 136 137 138 139 class Aes256CbcHmacSha512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 ()","title":"Aes256CbcHmacSha512"},{"location":"api/#jwskate.jwa.encryption.aesgcm","text":"This module implements AES-GCM based encryption algorithms.","title":"aesgcm"},{"location":"api/#jwskate.jwa.encryption.aesgcm.BaseAESGCM","text":"Bases: BaseAESEncryptionAlg Base class for AES-GCM encryption algorithms. Source code in jwskate\\jwa\\encryption\\aesgcm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class BaseAESGCM ( BaseAESEncryptionAlg ): \"\"\"Base class for AES-GCM encryption algorithms.\"\"\" iv_size = 96 tag_size = 16 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with the given IV and Additional Authenticated Data.\". Args: plaintext: the data to encrypt iv: the IV to use aad: Additional Authenticated Data, if any Returns: a (ciphertext, authentication_tag) tuple Raises: ValueError: if the IV size is not appropriate \"\"\" if len ( iv ) * 8 != self . iv_size : raise ValueError ( f \"Invalid IV size, must be { self . iv_size } bits\" ) ciphertext_with_tag = BinaPy ( aead . AESGCM ( self . key ) . encrypt ( iv , plaintext , aad )) ciphertext , tag = ciphertext_with_tag . cut_at ( - self . tag_size ) return ciphertext , tag def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext. Args: ciphertext: the data to decrypt auth_tag: the Authentication Tag iv: the Initialization Vector aad: the Additional Authentication Tag Returns: the decrypted data Raises: ValueError: if the IV size is not appropriate \"\"\" if len ( iv ) * 8 != self . iv_size : raise ValueError ( f \"Invalid IV size, must be { self . iv_size } bits\" ) ciphertext_with_tag = ciphertext + auth_tag return BinaPy ( aead . AESGCM ( self . key ) . decrypt ( iv , ciphertext_with_tag , aad )) encrypt ( plaintext , iv , aad ) \u00b6 Encrypt a plaintext, with the given IV and Additional Authenticated Data.\". Parameters: Name Type Description Default plaintext bytes the data to encrypt required iv bytes the IV to use required aad Optional [ bytes ] Additional Authenticated Data, if any required Returns: Type Description Tuple [ BinaPy , BinaPy ] a (ciphertext, authentication_tag) tuple Raises: Type Description ValueError if the IV size is not appropriate Source code in jwskate\\jwa\\encryption\\aesgcm.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def encrypt ( self , plaintext : bytes , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with the given IV and Additional Authenticated Data.\". Args: plaintext: the data to encrypt iv: the IV to use aad: Additional Authenticated Data, if any Returns: a (ciphertext, authentication_tag) tuple Raises: ValueError: if the IV size is not appropriate \"\"\" if len ( iv ) * 8 != self . iv_size : raise ValueError ( f \"Invalid IV size, must be { self . iv_size } bits\" ) ciphertext_with_tag = BinaPy ( aead . AESGCM ( self . key ) . encrypt ( iv , plaintext , aad )) ciphertext , tag = ciphertext_with_tag . cut_at ( - self . tag_size ) return ciphertext , tag decrypt ( ciphertext , auth_tag , iv , aad ) \u00b6 Decrypt a ciphertext. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required auth_tag bytes the Authentication Tag required iv bytes the Initialization Vector required aad Optional [ bytes ] the Additional Authentication Tag required Returns: Type Description BinaPy the decrypted data Raises: Type Description ValueError if the IV size is not appropriate Source code in jwskate\\jwa\\encryption\\aesgcm.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def decrypt ( self , ciphertext : bytes , auth_tag : bytes , iv : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext. Args: ciphertext: the data to decrypt auth_tag: the Authentication Tag iv: the Initialization Vector aad: the Additional Authentication Tag Returns: the decrypted data Raises: ValueError: if the IV size is not appropriate \"\"\" if len ( iv ) * 8 != self . iv_size : raise ValueError ( f \"Invalid IV size, must be { self . iv_size } bits\" ) ciphertext_with_tag = ciphertext + auth_tag return BinaPy ( aead . AESGCM ( self . key ) . decrypt ( iv , ciphertext_with_tag , aad ))","title":"BaseAESGCM"},{"location":"api/#jwskate.jwa.encryption.aesgcm.A128GCM","text":"Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 62 63 64 65 66 67 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128","title":"A128GCM"},{"location":"api/#jwskate.jwa.encryption.aesgcm.A192GCM","text":"Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 70 71 72 73 74 75 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192","title":"A192GCM"},{"location":"api/#jwskate.jwa.encryption.aesgcm.A256GCM","text":"Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate\\jwa\\encryption\\aesgcm.py 78 79 80 81 82 83 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256","title":"A256GCM"},{"location":"api/#jwskate.jwa.key_mgmt","text":"This module exposes all Key Management algorithms available in jwskate .","title":"key_mgmt"},{"location":"api/#jwskate.jwa.key_mgmt.BaseAesKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Base class for AES KW algorithms. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class BaseAesKeyWrap ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Base class for AES KW algorithms.\"\"\" key_size : int \"\"\"Required AES key size in bits.\"\"\" @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey ))","title":"BaseAesKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.key_size","text":"Required AES key size in bits.","title":"key_size"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.check_key","text":"Check that a key is valid for usage with this algorithm. To be valid, a key must be bytes and be of appropriate length (128, 192 or 256 bits). Parameters: Name Type Description Default key bytes a key to check required Raises: Type Description ValueError if the key is not appropriate Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" )","title":"check_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.wrap_key","text":"Wrap a key. Parameters: Name Type Description Default plainkey bytes the key to wrap. required Returns: Name Type Description BinaPy BinaPy the wrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 30 31 32 33 34 35 36 37 38 39 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.unwrap_key","text":"Unwrap a key. Parameters: Name Type Description Default cipherkey bytes the wrapped key. required Returns: Name Type Description BinaPy BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 41 42 43 44 45 46 47 48 49 50 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.DirectKeyUse","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate\\jwa\\key_mgmt\\dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"DirectKeyUse"},{"location":"api/#jwskate.jwa.key_mgmt.dir.DirectKeyUse.direct_key","text":"Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate\\jwa\\key_mgmt\\dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"direct_key()"},{"location":"api/#jwskate.jwa.key_mgmt.BaseAesGcmKeyWrap","text":"Bases: BaseAESGCM , BaseKeyManagementAlg Base class for AES-GCM Key wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class BaseAesGcmKeyWrap ( BaseAESGCM , BaseKeyManagementAlg ): \"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\" key_size : int \"\"\"Required key size, in bits.\"\"\" tag_size : int = 16 \"\"\"Authentication tag size, in bits.\"\"\" iv_size : int = 96 \"\"\"Initialisation Vector size, in bits.\"\"\" def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" )","title":"BaseAesGcmKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.key_size","text":"Required key size, in bits.","title":"key_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.tag_size","text":"Authentication tag size, in bits.","title":"tag_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.iv_size","text":"Initialisation Vector size, in bits.","title":"iv_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.wrap_key","text":"Wrap a key using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default plainkey bytes the key to wrap required iv bytes the Initialisation Vector to use required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (wrapped_key, authentication_tag) Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 21 22 23 24 25 26 27 28 29 30 31 def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" )","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.unwrap_key","text":"Unwrap a key and authenticates it with the authentication tag , using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default cipherkey bytes the wrapped key required tag bytes the authentication tag required iv bytes the Initialisation Vector required Returns: Type Description BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 33 34 35 36 37 38 39 40 41 42 43 44 def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" )","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.BaseRsaKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms.\"\"\" padding : Any name = \"RSA1_5\" description = \"RSAES-PKCS1-v1_5\" private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"BaseRsaKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.__init__","text":"Initialize an alg with a given RSA key. Parameters: Name Type Description Default key Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate\\jwa\\key_mgmt\\rsa.py 26 27 28 29 30 31 32 33 34 def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key","title":"__init__()"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.wrap_key","text":"Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.unwrap_key","text":"Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.EcdhEs","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = asymmetric . ec . EllipticCurvePublicKey private_key_class = asymmetric . ec . EllipticCurvePrivateKey @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek","title":"EcdhEs"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.otherinfo","text":"Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required keysize int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo )","title":"otherinfo()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.ecdh","text":"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey a private EC key required public_key asymmetric . ec . EllipticCurvePublicKey a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key )","title":"ecdh()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.derive","text":"Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey the private key required public_key asymmetric . ec . EllipticCurvePublicKey the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required keysize int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key ))","title":"derive()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.generate_ephemeral_key","text":"Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description asymmetric . ec . EllipticCurvePrivateKey a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 93 94 95 96 97 98 99 def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve )","title":"generate_ephemeral_key()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.sender_key","text":"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek","title":"sender_key()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.recipient_key","text":"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek","title":"recipient_key()"},{"location":"api/#jwskate.jwa.key_mgmt.BasePbes2","text":"Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"BasePbes2"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.__init__","text":"Initialize this alg with the given password. Parameters: Name Type Description Default password Union [ bytes , str ] the encryption/decryption password to use required Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 19 20 21 22 23 24 25 26 27 def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password","title":"__init__()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.generate_salt","text":"Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size )","title":"generate_salt()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.derive","text":"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password ))","title":"derive()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.wrap_key","text":"Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.unwrap_key","text":"Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 78 79 80 81 82 83 84 85 86 87 88 89 90 def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.A128GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 47 48 49 50 51 52 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128","title":"A128GCMKW"},{"location":"api/#jwskate.jwa.key_mgmt.A128KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 53 54 55 56 57 58 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128","title":"A128KW"},{"location":"api/#jwskate.jwa.key_mgmt.A192GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 55 56 57 58 59 60 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192","title":"A192GCMKW"},{"location":"api/#jwskate.jwa.key_mgmt.A192KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 61 62 63 64 65 66 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192","title":"A192KW"},{"location":"api/#jwskate.jwa.key_mgmt.A256GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 63 64 65 66 67 68 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256","title":"A256GCMKW"},{"location":"api/#jwskate.jwa.key_mgmt.RsaEsPcks1v1_5","text":"Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 66 67 68 69 70 71 72 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5\"\"\" name = \"RSA1_5\" description = __doc__ padding = padding . PKCS1v15 ()","title":"RsaEsPcks1v1_5"},{"location":"api/#jwskate.jwa.key_mgmt.A256KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 69 70 71 72 73 74 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256","title":"A256KW"},{"location":"api/#jwskate.jwa.key_mgmt.RsaEsOaep","text":"Bases: BaseRsaKeyWrap RSAES OAEP using default parameters Source code in jwskate\\jwa\\key_mgmt\\rsa.py 75 76 77 78 79 80 81 82 83 84 85 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , )","title":"RsaEsOaep"},{"location":"api/#jwskate.jwa.key_mgmt.RsaEsOaepSha256","text":"Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 88 89 90 91 92 93 94 95 96 97 98 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , )","title":"RsaEsOaepSha256"},{"location":"api/#jwskate.jwa.key_mgmt.Pbes2_HS256_A128KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 93 94 95 96 97 98 99 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 ()","title":"Pbes2_HS256_A128KW"},{"location":"api/#jwskate.jwa.key_mgmt.RsaEsOaepSha384","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 101 102 103 104 105 106 107 108 109 110 111 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , )","title":"RsaEsOaepSha384"},{"location":"api/#jwskate.jwa.key_mgmt.Pbes2_HS384_A192KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 102 103 104 105 106 107 108 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 ()","title":"Pbes2_HS384_A192KW"},{"location":"api/#jwskate.jwa.key_mgmt.Pbes2_HS512_A256KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 111 112 113 114 115 116 117 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 ()","title":"Pbes2_HS512_A256KW"},{"location":"api/#jwskate.jwa.key_mgmt.RsaEsOaepSha512","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 114 115 116 117 118 119 120 121 122 123 124 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , )","title":"RsaEsOaepSha512"},{"location":"api/#jwskate.jwa.key_mgmt.BaseEcdhEs_AesKw","text":"Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"BaseEcdhEs_AesKw"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.wrap_key_with_epk","text":"Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey )","title":"wrap_key_with_epk()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.unwrap_key_with_epk","text":"Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey bytes the wrapped key required ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"unwrap_key_with_epk()"},{"location":"api/#jwskate.jwa.key_mgmt.EcdhEs_A128KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 200 201 202 203 204 205 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW","title":"EcdhEs_A128KW"},{"location":"api/#jwskate.jwa.key_mgmt.EcdhEs_A192KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 208 209 210 211 212 213 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW","title":"EcdhEs_A192KW"},{"location":"api/#jwskate.jwa.key_mgmt.EcdhEs_A256KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 216 217 218 219 220 221 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW","title":"EcdhEs_A256KW"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw","text":"This module implements AES-GCM based Key Management algorithms.","title":"aesgcmkw"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap","text":"Bases: BaseAESGCM , BaseKeyManagementAlg Base class for AES-GCM Key wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class BaseAesGcmKeyWrap ( BaseAESGCM , BaseKeyManagementAlg ): \"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\" key_size : int \"\"\"Required key size, in bits.\"\"\" tag_size : int = 16 \"\"\"Authentication tag size, in bits.\"\"\" iv_size : int = 96 \"\"\"Initialisation Vector size, in bits.\"\"\" def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" ) key_size : int = None class-attribute \u00b6 Required key size, in bits. tag_size : int = 16 class-attribute \u00b6 Authentication tag size, in bits. iv_size : int = 96 class-attribute \u00b6 Initialisation Vector size, in bits. wrap_key ( plainkey , iv ) \u00b6 Wrap a key using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default plainkey bytes the key to wrap required iv bytes the Initialisation Vector to use required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (wrapped_key, authentication_tag) Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 21 22 23 24 25 26 27 28 29 30 31 def wrap_key ( self , plainkey : bytes , iv : bytes ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a key using the given Initialisation Vector (`iv`). Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv , b \"\" ) unwrap_key ( cipherkey , tag , iv ) \u00b6 Unwrap a key and authenticates it with the authentication tag , using the given Initialisation Vector ( iv ). Parameters: Name Type Description Default cipherkey bytes the wrapped key required tag bytes the authentication tag required iv bytes the Initialisation Vector required Returns: Type Description BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 33 34 35 36 37 38 39 40 41 42 43 44 def unwrap_key ( self , cipherkey : bytes , tag : bytes , iv : bytes ) -> BinaPy : \"\"\"Unwrap a key and authenticates it with the authentication `tag`, using the given Initialisation Vector (`iv`). Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , tag , iv , b \"\" )","title":"BaseAesGcmKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.A128GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 47 48 49 50 51 52 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128","title":"A128GCMKW"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.A192GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 55 56 57 58 59 60 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192","title":"A192GCMKW"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.A256GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aesgcmkw.py 63 64 65 66 67 68 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256","title":"A256GCMKW"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw","text":"This module implements AES based Key Management algorithms.","title":"aeskw"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Base class for AES KW algorithms. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class BaseAesKeyWrap ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Base class for AES KW algorithms.\"\"\" key_size : int \"\"\"Required AES key size in bits.\"\"\" @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) key_size : int = None class-attribute \u00b6 Required AES key size in bits. check_key ( key ) \u00b6 Check that a key is valid for usage with this algorithm. To be valid, a key must be bytes and be of appropriate length (128, 192 or 256 bits). Parameters: Name Type Description Default key bytes a key to check required Raises: Type Description ValueError if the key is not appropriate Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits\" ) wrap_key ( plainkey ) \u00b6 Wrap a key. Parameters: Name Type Description Default plainkey bytes the key to wrap. required Returns: Name Type Description BinaPy BinaPy the wrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 30 31 32 33 34 35 36 37 38 39 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) unwrap_key ( cipherkey ) \u00b6 Unwrap a key. Parameters: Name Type Description Default cipherkey bytes the wrapped key. required Returns: Name Type Description BinaPy BinaPy the unwrapped key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 41 42 43 44 45 46 47 48 49 50 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey ))","title":"BaseAesKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.A128KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 53 54 55 56 57 58 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128","title":"A128KW"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.A192KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 61 62 63 64 65 66 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192","title":"A192KW"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.A256KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate\\jwa\\key_mgmt\\aeskw.py 69 70 71 72 73 74 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256","title":"A256KW"},{"location":"api/#jwskate.jwa.key_mgmt.dir","text":"This module implements direct use of a shared symmetric key as Key Management algorithm.","title":"dir"},{"location":"api/#jwskate.jwa.key_mgmt.dir.DirectKeyUse","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate\\jwa\\key_mgmt\\dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) direct_key ( aesalg ) \u00b6 Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate\\jwa\\key_mgmt\\dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"DirectKeyUse"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh","text":"This module implements Elliptic Curve Diffie-Hellman based Key Management algorithms.","title":"ecdh"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = asymmetric . ec . EllipticCurvePublicKey private_key_class = asymmetric . ec . EllipticCurvePrivateKey @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek otherinfo ( alg , apu , apv , keysize ) \u00b6 Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required keysize int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) ecdh ( private_key , public_key ) \u00b6 This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey a private EC key required public_key asymmetric . ec . EllipticCurvePublicKey a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def ecdh ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" shared_key = private_key . exchange ( asymmetric . ec . ECDH (), public_key ) return BinaPy ( shared_key ) derive ( private_key , public_key , otherinfo , keysize ) \u00b6 Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key asymmetric . ec . EllipticCurvePrivateKey the private key required public_key asymmetric . ec . EllipticCurvePublicKey the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required keysize int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @classmethod def derive ( cls , private_key : asymmetric . ec . EllipticCurvePrivateKey , public_key : asymmetric . ec . EllipticCurvePublicKey , otherinfo : bytes , keysize : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter keysize: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = keysize // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) generate_ephemeral_key () \u00b6 Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description asymmetric . ec . EllipticCurvePrivateKey a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 93 94 95 96 97 98 99 def generate_ephemeral_key ( self ) -> asymmetric . ec . EllipticCurvePrivateKey : \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" return asymmetric . ec . generate_private_key ( self . key . curve ) sender_key ( ephemeral_private_key , alg , key_size , ** headers ) \u00b6 Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def sender_key ( self , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( ephemeral_private_key , key , otherinfo , key_size ) return cek recipient_key ( ephemeral_public_key , alg , key_size , ** headers ) \u00b6 Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def recipient_key ( self , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( key , ephemeral_public_key , otherinfo , key_size ) return cek","title":"EcdhEs"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw","text":"Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) wrap_key_with_epk ( plainkey , ephemeral_private_key , ** headers ) \u00b6 Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key asymmetric . ec . EllipticCurvePrivateKey the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : asymmetric . ec . EllipticCurvePrivateKey , ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) unwrap_key_with_epk ( cipherkey , ephemeral_public_key , ** headers ) \u00b6 Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey bytes the wrapped key required ephemeral_public_key asymmetric . ec . EllipticCurvePublicKey the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : asymmetric . ec . EllipticCurvePublicKey , ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"BaseEcdhEs_AesKw"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs_A128KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 200 201 202 203 204 205 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW","title":"EcdhEs_A128KW"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs_A192KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 208 209 210 211 212 213 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW","title":"EcdhEs_A192KW"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs_A256KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\ecdh.py 216 217 218 219 220 221 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW","title":"EcdhEs_A256KW"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2","text":"This module implements password-based Key Management Algorithms relying on PBES2.","title":"pbes2"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2","text":"Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) __init__ ( password ) \u00b6 Initialize this alg with the given password. Parameters: Name Type Description Default password Union [ bytes , str ] the encryption/decryption password to use required Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 19 20 21 22 23 24 25 26 27 def __init__ ( self , password : Union [ bytes , str ]): \"\"\"Initialize this alg with the given password. Args: password: the encryption/decryption password to use \"\"\" if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password generate_salt ( size = 12 ) \u00b6 Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) derive ( salt , count ) \u00b6 Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def derive ( self , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) wrap_key ( plainkey , salt , count ) \u00b6 Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def wrap_key ( self , plainkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) unwrap_key ( cipherkey , salt , count ) \u00b6 Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 78 79 80 81 82 83 84 85 86 87 88 89 90 def unwrap_key ( self , cipherkey : bytes , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt , count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"BasePbes2"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.Pbes2_HS256_A128KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 93 94 95 96 97 98 99 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 ()","title":"Pbes2_HS256_A128KW"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.Pbes2_HS384_A192KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 102 103 104 105 106 107 108 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 ()","title":"Pbes2_HS384_A192KW"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.Pbes2_HS512_A256KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate\\jwa\\key_mgmt\\pbes2.py 111 112 113 114 115 116 117 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 ()","title":"Pbes2_HS512_A256KW"},{"location":"api/#jwskate.jwa.key_mgmt.rsa","text":"This module implements RSA based Key Management algorithms.","title":"rsa"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Source code in jwskate\\jwa\\key_mgmt\\rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms.\"\"\" padding : Any name = \"RSA1_5\" description = \"RSAES-PKCS1-v1_5\" private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) __init__ ( key ) \u00b6 Initialize an alg with a given RSA key. Parameters: Name Type Description Default key Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate\\jwa\\key_mgmt\\rsa.py 26 27 28 29 30 31 32 33 34 def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): \"\"\"Initialize an alg with a given RSA key. Args: key: the private or public key to use \"\"\" self . key = key wrap_key ( plainkey ) \u00b6 Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) unwrap_key ( cipherkey ) \u00b6 Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate\\jwa\\key_mgmt\\rsa.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"BaseRsaKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.RsaEsPcks1v1_5","text":"Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 66 67 68 69 70 71 72 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5\"\"\" name = \"RSA1_5\" description = __doc__ padding = padding . PKCS1v15 ()","title":"RsaEsPcks1v1_5"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.RsaEsOaep","text":"Bases: BaseRsaKeyWrap RSAES OAEP using default parameters Source code in jwskate\\jwa\\key_mgmt\\rsa.py 75 76 77 78 79 80 81 82 83 84 85 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , )","title":"RsaEsOaep"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.RsaEsOaepSha256","text":"Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 88 89 90 91 92 93 94 95 96 97 98 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , )","title":"RsaEsOaepSha256"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.RsaEsOaepSha384","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 101 102 103 104 105 106 107 108 109 110 111 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , )","title":"RsaEsOaepSha384"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.RsaEsOaepSha512","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\key_mgmt\\rsa.py 114 115 116 117 118 119 120 121 122 123 124 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , )","title":"RsaEsOaepSha512"},{"location":"api/#jwskate.jwa.signature","text":"This module exposes all the Signature algorithms available from jwskate .","title":"signature"},{"location":"api/#jwskate.jwa.signature.EdDsa","text":"Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate\\jwa\\signature\\eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False","title":"EdDsa"},{"location":"api/#jwskate.jwa.signature.HS256","text":"Bases: BaseHMACSigAlg HMAC using SHA-256 Source code in jwskate\\jwa\\signature\\hmac.py 31 32 33 34 35 36 37 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256\"\"\" name = \"HS256\" description = __doc__ hash_alg = hashes . SHA256 () min_key_size = 256","title":"HS256"},{"location":"api/#jwskate.jwa.signature.HS384","text":"Bases: BaseHMACSigAlg HMAC using SHA-384 Source code in jwskate\\jwa\\signature\\hmac.py 40 41 42 43 44 45 46 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384\"\"\" name = \"HS384\" description = __doc__ hash_alg = hashes . SHA384 () min_key_size = 384","title":"HS384"},{"location":"api/#jwskate.jwa.signature.HS512","text":"Bases: BaseHMACSigAlg HMAC using SHA-512 Source code in jwskate\\jwa\\signature\\hmac.py 49 50 51 52 53 54 55 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512\"\"\" name = \"HS512\" description = __doc__ hash_alg = hashes . SHA512 () min_key_size = 512","title":"HS512"},{"location":"api/#jwskate.jwa.signature.ES256","text":"Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 58 59 60 61 62 63 64 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 ()","title":"ES256"},{"location":"api/#jwskate.jwa.signature.RS256","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 65 66 67 68 69 70 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 ()","title":"RS256"},{"location":"api/#jwskate.jwa.signature.ES384","text":"Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384 Source code in jwskate\\jwa\\signature\\ec.py 67 68 69 70 71 72 73 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 ()","title":"ES384"},{"location":"api/#jwskate.jwa.signature.RS384","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 73 74 75 76 77 78 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 ()","title":"RS384"},{"location":"api/#jwskate.jwa.signature.ES512","text":"Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512 Source code in jwskate\\jwa\\signature\\ec.py 76 77 78 79 80 81 82 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 ()","title":"ES512"},{"location":"api/#jwskate.jwa.signature.RS512","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 81 82 83 84 85 86 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 ()","title":"RS512"},{"location":"api/#jwskate.jwa.signature.ES256K","text":"Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 85 86 87 88 89 90 91 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 ()","title":"ES256K"},{"location":"api/#jwskate.jwa.signature.PS256","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 89 90 91 92 93 94 95 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 )","title":"PS256"},{"location":"api/#jwskate.jwa.signature.PS384","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 98 99 100 101 102 103 104 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 )","title":"PS384"},{"location":"api/#jwskate.jwa.signature.PS512","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\signature\\rsa.py 107 108 109 110 111 112 113 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 )","title":"PS512"},{"location":"api/#jwskate.jwa.signature.ec","text":"This module implement Elliptic Curve signature algorithms.","title":"ec"},{"location":"api/#jwskate.jwa.signature.ec.BaseECSignatureAlg","text":"Bases: BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] , BaseSignatureAlg Base class for Elliptic Curve signature algorithms. Source code in jwskate\\jwa\\signature\\ec.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class BaseECSignatureAlg ( BaseAsymmetricAlg [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ], BaseSignatureAlg , ): \"\"\"Base class for Elliptic Curve signature algorithms.\"\"\" curve : EllipticCurve hashing_alg : hashes . HashAlgorithm public_key_class = asymmetric . ec . EllipticCurvePublicKey private_key_class = asymmetric . ec . EllipticCurvePrivateKey def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : dss_sig = key . sign ( data , asymmetric . ec . ECDSA ( self . hashing_alg )) r , s = asymmetric . utils . decode_dss_signature ( dss_sig ) return BinaPy . from_int ( r , self . curve . coordinate_size ) + BinaPy . from_int ( s , self . curve . coordinate_size ) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : if len ( signature ) != self . curve . coordinate_size * 2 : raise ValueError ( f \"Invalid signature length { len ( signature ) } bytes, expected { self . curve . coordinate_size * 2 } bytes\" ) r_bytes , s_bytes = ( signature [: self . curve . coordinate_size ], signature [ self . curve . coordinate_size :], ) r = int . from_bytes ( r_bytes , \"big\" , signed = False ) s = int . from_bytes ( s_bytes , \"big\" , signed = False ) dss_signature = asymmetric . utils . encode_dss_signature ( r , s ) try : key . verify ( dss_signature , data , asymmetric . ec . ECDSA ( self . hashing_alg ), ) return True except exceptions . InvalidSignature : return False","title":"BaseECSignatureAlg"},{"location":"api/#jwskate.jwa.signature.ec.ES256","text":"Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 58 59 60 61 62 63 64 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 ()","title":"ES256"},{"location":"api/#jwskate.jwa.signature.ec.ES384","text":"Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384 Source code in jwskate\\jwa\\signature\\ec.py 67 68 69 70 71 72 73 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 ()","title":"ES384"},{"location":"api/#jwskate.jwa.signature.ec.ES512","text":"Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512 Source code in jwskate\\jwa\\signature\\ec.py 76 77 78 79 80 81 82 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 ()","title":"ES512"},{"location":"api/#jwskate.jwa.signature.ec.ES256K","text":"Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256 Source code in jwskate\\jwa\\signature\\ec.py 85 86 87 88 89 90 91 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 ()","title":"ES256K"},{"location":"api/#jwskate.jwa.signature.eddsa","text":"This module implements the Edwards-curve Digital Signature Algorithm (EdDSA).","title":"eddsa"},{"location":"api/#jwskate.jwa.signature.eddsa.EdDsa","text":"Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate\\jwa\\signature\\eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False","title":"EdDsa"},{"location":"api/#jwskate.jwa.signature.hmac","text":"This module implements HMAC based signature algorithms.","title":"hmac"},{"location":"api/#jwskate.jwa.signature.hmac.BaseHMACSigAlg","text":"Bases: BaseSymmetricAlg , BaseSignatureAlg Base class for HMAC signature algorithms. Source code in jwskate\\jwa\\signature\\hmac.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BaseHMACSigAlg ( BaseSymmetricAlg , BaseSignatureAlg ): \"\"\"Base class for HMAC signature algorithms.\"\"\" mac : Type [ hmac . HMAC ] = hmac . HMAC hash_alg : hashes . HashAlgorithm min_key_size : int def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 if self . read_only : raise NotImplementedError m = self . mac ( self . key , self . hash_alg ) m . update ( data ) signature = m . finalize () return BinaPy ( signature ) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 candidate_signature = self . sign ( data ) return candidate_signature == signature","title":"BaseHMACSigAlg"},{"location":"api/#jwskate.jwa.signature.hmac.HS256","text":"Bases: BaseHMACSigAlg HMAC using SHA-256 Source code in jwskate\\jwa\\signature\\hmac.py 31 32 33 34 35 36 37 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256\"\"\" name = \"HS256\" description = __doc__ hash_alg = hashes . SHA256 () min_key_size = 256","title":"HS256"},{"location":"api/#jwskate.jwa.signature.hmac.HS384","text":"Bases: BaseHMACSigAlg HMAC using SHA-384 Source code in jwskate\\jwa\\signature\\hmac.py 40 41 42 43 44 45 46 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384\"\"\" name = \"HS384\" description = __doc__ hash_alg = hashes . SHA384 () min_key_size = 384","title":"HS384"},{"location":"api/#jwskate.jwa.signature.hmac.HS512","text":"Bases: BaseHMACSigAlg HMAC using SHA-512 Source code in jwskate\\jwa\\signature\\hmac.py 49 50 51 52 53 54 55 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512\"\"\" name = \"HS512\" description = __doc__ hash_alg = hashes . SHA512 () min_key_size = 512","title":"HS512"},{"location":"api/#jwskate.jwa.signature.hmac.HS1","text":"Bases: BaseHMACSigAlg HMAC using SHA-1 Source code in jwskate\\jwa\\signature\\hmac.py 58 59 60 61 62 63 64 65 class HS1 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-1\"\"\" name = \"HS1\" description = __doc__ read_only = True min_key_size = 160 hash_alg = hashes . SHA1 ()","title":"HS1"},{"location":"api/#jwskate.jwa.signature.rsa","text":"This module implements RSA signature algorithms.","title":"rsa"},{"location":"api/#jwskate.jwa.signature.rsa.BaseRSASigAlg","text":"Bases: BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] , BaseSignatureAlg Base class for RSA based signature algorithms. Source code in jwskate\\jwa\\signature\\rsa.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class BaseRSASigAlg ( BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], BaseSignatureAlg , ): \"\"\"Base class for RSA based signature algorithms.\"\"\" hashing_alg : hashes . HashAlgorithm padding_alg : padding . AsymmetricPadding = padding . PKCS1v15 () min_key_size : int = 2048 private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data. Args: data: the data to sign Returns: the generated signature Raises: NotImplementedError: for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired: if the configured key is not private \"\"\" if self . read_only : raise NotImplementedError with self . private_key_required () as key : return BinaPy ( key . sign ( data , self . padding_alg , self . hashing_alg )) def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the data to verify signature: the signature Returns: `True` if the signature is valid, `False` otherwise \"\"\" with self . public_key_required () as key : try : key . verify ( signature , data , self . padding_alg , self . hashing_alg , ) return True except exceptions . InvalidSignature : return False sign ( data ) \u00b6 Sign arbitrary data. Parameters: Name Type Description Default data bytes the data to sign required Returns: Type Description BinaPy the generated signature Raises: Type Description NotImplementedError for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired if the configured key is not private Source code in jwskate\\jwa\\signature\\rsa.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data. Args: data: the data to sign Returns: the generated signature Raises: NotImplementedError: for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired: if the configured key is not private \"\"\" if self . read_only : raise NotImplementedError with self . private_key_required () as key : return BinaPy ( key . sign ( data , self . padding_alg , self . hashing_alg )) verify ( data , signature ) \u00b6 Verify a signature against some data. Parameters: Name Type Description Default data bytes the data to verify required signature bytes the signature required Returns: Type Description bool True if the signature is valid, False otherwise Source code in jwskate\\jwa\\signature\\rsa.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the data to verify signature: the signature Returns: `True` if the signature is valid, `False` otherwise \"\"\" with self . public_key_required () as key : try : key . verify ( signature , data , self . padding_alg , self . hashing_alg , ) return True except exceptions . InvalidSignature : return False","title":"BaseRSASigAlg"},{"location":"api/#jwskate.jwa.signature.rsa.RS256","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 65 66 67 68 69 70 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 ()","title":"RS256"},{"location":"api/#jwskate.jwa.signature.rsa.RS384","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 73 74 75 76 77 78 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 ()","title":"RS384"},{"location":"api/#jwskate.jwa.signature.rsa.RS512","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 81 82 83 84 85 86 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 ()","title":"RS512"},{"location":"api/#jwskate.jwa.signature.rsa.PS256","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Source code in jwskate\\jwa\\signature\\rsa.py 89 90 91 92 93 94 95 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 )","title":"PS256"},{"location":"api/#jwskate.jwa.signature.rsa.PS384","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Source code in jwskate\\jwa\\signature\\rsa.py 98 99 100 101 102 103 104 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 )","title":"PS384"},{"location":"api/#jwskate.jwa.signature.rsa.PS512","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Source code in jwskate\\jwa\\signature\\rsa.py 107 108 109 110 111 112 113 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 )","title":"PS512"},{"location":"api/#jwskate.jwa.signature.rsa.RS1","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 with SHA-1 Source code in jwskate\\jwa\\signature\\rsa.py 116 117 118 119 120 121 122 class RS1 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 with SHA-1\"\"\" name = \"RS1\" description = __doc__ hashing_alg = hashes . SHA1 () read_only = True","title":"RS1"},{"location":"api/#jwskate.jwe","text":"This module implements Json Web Encryption RFC7516 .","title":"jwe"},{"location":"api/#jwskate.jwe.compact","text":"This module implements the JWE Compact format.","title":"compact"},{"location":"api/#jwskate.jwe.compact.InvalidJwe","text":"Bases: ValueError Raised when an invalid JWE token is parsed. Source code in jwskate\\jwe\\compact.py 19 20 class InvalidJwe ( ValueError ): \"\"\"Raised when an invalid JWE token is parsed.\"\"\"","title":"InvalidJwe"},{"location":"api/#jwskate.jwe.compact.JweCompact","text":"Bases: BaseCompactToken Represents a Json Web Encryption object, as defined in RFC7516. Source code in jwskate\\jwe\\compact.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 class JweCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Encryption object, as defined in RFC7516.\"\"\" def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize a Jwe based on its compact representation. Args: value: the compact representation for this Jwe \"\"\" super () . __init__ ( value ) if self . value . count ( b \".\" ) != 4 : raise InvalidJwe ( \"A JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots\" ) header , cek , iv , ciphertext , auth_tag = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) self . additional_authenticated_data = header except ValueError : raise InvalidJwe ( \"Invalid JWE header: it must be a Base64URL-encoded JSON object\" ) try : self . wrapped_cek = BinaPy ( cek ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE cek: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . initialization_vector = BinaPy ( iv ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE iv: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . ciphertext = BinaPy ( ciphertext ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . authentication_tag = BinaPy ( auth_tag ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def from_parts ( cls , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ), BinaPy ( cek ) . encode_to ( \"b64u\" ), BinaPy ( iv ) . encode_to ( \"b64u\" ), BinaPy ( ciphertext ) . encode_to ( \"b64u\" ), BinaPy ( tag ) . encode_to ( \"b64u\" ), ) ) ) @property def alg ( self ) -> str : \"\"\"Return the alg from the JWE header. The `alg` header contains the Key Management algorithm used to wrap or derive the CEK. Returns: the alg value Raises: AttributeError: if there is no alg header or it is not a str \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or not isinstance ( alg , str ): raise AttributeError ( \"This JWE doesn't have a valid 'alg' header\" ) return alg @property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" enc = self . get_header ( \"enc\" ) if enc is None or not isinstance ( enc , str ): raise AttributeError ( \"This JWE doesn't have a valid 'enc' header\" ) return enc @classmethod def encrypt ( cls , plaintext : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext and return the resulting JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use enc: the CEK encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" jwk = Jwk ( jwk ) extra_headers = extra_headers or {} cek_jwk , cek_headers , wrapped_cek = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) aad = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) ciphertext , tag , iv = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers , wrapped_cek , iv , ciphertext , tag ) PBES2_ALGORITHMS : Mapping [ str , Type [ BasePbes2 ]] = { alg . name : alg for alg in [ Pbes2_HS256_A128KW , Pbes2_HS384_A192KW , Pbes2_HS512_A256KW ] } def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> bytes : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: bytes: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext @classmethod def encrypt_with_password ( cls , plaintext : bytes , password : Union [ bytes , str ], alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000\" ) wrapped_cek = wrapper . wrap_key ( cek , salt , count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . encode_to ( \"b64u\" ) . decode (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) ciphertext , tag , iv = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers , wrapped_cek , iv , ciphertext , tag ) def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise AttributeError ( \"No 'p2s' in headers!\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise AttributeError ( \"No 'p2c' in headers!\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise AttributeError ( \"Invalid value for p2c, must be a positive integer\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt , p2c ) return SymmetricJwk . from_bytes ( cek ) def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"JweCompact"},{"location":"api/#jwskate.jwe.compact.JweCompact.__init__","text":"Initialize a Jwe based on its compact representation. Parameters: Name Type Description Default value Union [ bytes , str ] the compact representation for this Jwe required Source code in jwskate\\jwe\\compact.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize a Jwe based on its compact representation. Args: value: the compact representation for this Jwe \"\"\" super () . __init__ ( value ) if self . value . count ( b \".\" ) != 4 : raise InvalidJwe ( \"A JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots\" ) header , cek , iv , ciphertext , auth_tag = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) self . additional_authenticated_data = header except ValueError : raise InvalidJwe ( \"Invalid JWE header: it must be a Base64URL-encoded JSON object\" ) try : self . wrapped_cek = BinaPy ( cek ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE cek: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . initialization_vector = BinaPy ( iv ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE iv: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . ciphertext = BinaPy ( ciphertext ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . authentication_tag = BinaPy ( auth_tag ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data (bytes)\" )","title":"__init__()"},{"location":"api/#jwskate.jwe.compact.JweCompact.from_parts","text":"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Parameters: Name Type Description Default headers Mapping [ str , Any ] the headers (as a mapping of name: value) required cek bytes the raw cek required iv bytes the raw iv required ciphertext bytes the raw ciphertext required tag bytes the authentication tag required Returns: Type Description 'JweCompact' the initialized JweCompact instance Source code in jwskate\\jwe\\compact.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @classmethod def from_parts ( cls , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ), BinaPy ( cek ) . encode_to ( \"b64u\" ), BinaPy ( iv ) . encode_to ( \"b64u\" ), BinaPy ( ciphertext ) . encode_to ( \"b64u\" ), BinaPy ( tag ) . encode_to ( \"b64u\" ), ) ) )","title":"from_parts()"},{"location":"api/#jwskate.jwe.compact.JweCompact.alg","text":"Return the alg from the JWE header. The alg header contains the Key Management algorithm used to wrap or derive the CEK. Returns: Type Description str the alg value Raises: Type Description AttributeError if there is no alg header or it is not a str Source code in jwskate\\jwe\\compact.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @property def alg ( self ) -> str : \"\"\"Return the alg from the JWE header. The `alg` header contains the Key Management algorithm used to wrap or derive the CEK. Returns: the alg value Raises: AttributeError: if there is no alg header or it is not a str \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or not isinstance ( alg , str ): raise AttributeError ( \"This JWE doesn't have a valid 'alg' header\" ) return alg","title":"alg()"},{"location":"api/#jwskate.jwe.compact.JweCompact.enc","text":"Return the enc from the JWE header. The enc header contains the identifier of the CEK encryption algorithm. Returns: Type Description str the enc value Raises: Type Description AttributeError if there is no enc header or it is not a string Source code in jwskate\\jwe\\compact.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" enc = self . get_header ( \"enc\" ) if enc is None or not isinstance ( enc , str ): raise AttributeError ( \"This JWE doesn't have a valid 'enc' header\" ) return enc","title":"enc()"},{"location":"api/#jwskate.jwe.compact.JweCompact.encrypt","text":"Encrypt an arbitrary plaintext and return the resulting JweCompact. Parameters: Name Type Description Default plaintext bytes the raw plaintext to encrypt required jwk Union [ Jwk , Dict [ str , Any ]] the public or symmetric key to use required enc str the CEK encryption algorithm to use required alg Optional [ str ] the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the generated token None cek Optional [ bytes ] the CEK to force use, for algorithms relying on a random CEK. Leave None to have a safe value generated by jwskate . None iv Optional [ bytes ] the IV to force use. Leave None to have a safe value generated by jwskate . None epk Optional [ Jwk ] the EPK to force use. Leave None to have a safe value generated by jwskate . None Returns: Type Description 'JweCompact' the generated JweCompact instance Source code in jwskate\\jwe\\compact.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @classmethod def encrypt ( cls , plaintext : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext and return the resulting JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use enc: the CEK encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" jwk = Jwk ( jwk ) extra_headers = extra_headers or {} cek_jwk , cek_headers , wrapped_cek = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) aad = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) ciphertext , tag , iv = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers , wrapped_cek , iv , ciphertext , tag )","title":"encrypt()"},{"location":"api/#jwskate.jwe.compact.JweCompact.unwrap_cek","text":"Unwrap the CEK from this JWE token using the provided key or password. Parameters: Name Type Description Default jwk_or_password Union [ Jwk , Dict [ str , Any ], bytes , str ] the decryption JWK or password required Returns: Type Description Jwk the unwrapped CEK, as a SymmetricJwk Source code in jwskate\\jwe\\compact.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek","title":"unwrap_cek()"},{"location":"api/#jwskate.jwe.compact.JweCompact.decrypt","text":"Decrypts this Jwe payload using a JWK. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required Returns: Name Type Description bytes bytes the decrypted payload Source code in jwskate\\jwe\\compact.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> bytes : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: bytes: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"decrypt()"},{"location":"api/#jwskate.jwe.compact.JweCompact.encrypt_with_password","text":"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Parameters: Name Type Description Default plaintext bytes the data to encrypt required password Union [ bytes , str ] the password to use required alg str the Key Management alg to use required enc str the Payload Encryption alg to use required salt Optional [ bytes ] the salt to use. Leave None (default) to have jwskate generate a safe random value None count int the number of PBES2 iterations (recommended minimum 1000) 2000 cek Optional [ bytes ] the CEK to force use. Leave None (default) to have jwskate generate a safe random value None iv Optional [ bytes ] the IV to force use. Leave None (default) to have jwskate generate a safe random value None Returns: Type Description 'JweCompact' the resulting JweCompact Raises: Type Description UnsupportedAlg if the key management alg is not supported ValueError if the count parameter is not a positive integer Source code in jwskate\\jwe\\compact.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 @classmethod def encrypt_with_password ( cls , plaintext : bytes , password : Union [ bytes , str ], alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000\" ) wrapped_cek = wrapper . wrap_key ( cek , salt , count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . encode_to ( \"b64u\" ) . decode (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) ciphertext , tag , iv = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers , wrapped_cek , iv , ciphertext , tag )","title":"encrypt_with_password()"},{"location":"api/#jwskate.jwe.compact.JweCompact.unwrap_cek_with_password","text":"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Parameters: Name Type Description Default password Union [ bytes , str ] the decryption password required Returns: Type Description Jwk the CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the token key management algorithm is not supported AttributeError if the token misses the PBES2-related headers Source code in jwskate\\jwe\\compact.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise AttributeError ( \"No 'p2s' in headers!\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise AttributeError ( \"No 'p2c' in headers!\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise AttributeError ( \"Invalid value for p2c, must be a positive integer\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt , p2c ) return SymmetricJwk . from_bytes ( cek )","title":"unwrap_cek_with_password()"},{"location":"api/#jwskate.jwe.compact.JweCompact.decrypt_with_password","text":"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Parameters: Name Type Description Default password Union [ bytes , str ] the password to use required Returns: Type Description bytes the unencrypted payload Source code in jwskate\\jwe\\compact.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"decrypt_with_password()"},{"location":"api/#jwskate.jwk","text":"This module implements Json Web Key RFC7517 .","title":"jwk"},{"location":"api/#jwskate.jwk.alg","text":"This module contains several utilities for algorithmic agility.","title":"alg"},{"location":"api/#jwskate.jwk.alg.UnsupportedAlg","text":"Bases: ValueError Raised when an UnsupportedAlg is requested. Source code in jwskate\\jwk\\alg.py 9 10 class UnsupportedAlg ( ValueError ): \"\"\"Raised when an UnsupportedAlg is requested.\"\"\"","title":"UnsupportedAlg"},{"location":"api/#jwskate.jwk.alg.select_alg","text":"Given an alg parameter from a JWK, and/or a user-specified alg, return the alg to use. This checks the coherency between the user specified alg and the jwk_alg , and will emit a warning if the user specified alg is different from the jwk_alg . Parameters: Name Type Description Default jwk_alg Optional [ str ] the alg from the JWK, if any required alg Optional [ str ] a user specified alg required supported_algs Mapping [ str , T ] a mapping of supported alg names to alg wrapper required Returns: Type Description T the alg to use Raises: Type Description UnsupportedAlg if the requested alg is not supported Source code in jwskate\\jwk\\alg.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def select_alg ( jwk_alg : Optional [ str ], alg : Optional [ str ], supported_algs : Mapping [ str , T ] ) -> T : \"\"\"Given an alg parameter from a JWK, and/or a user-specified alg, return the alg to use. This checks the coherency between the user specified `alg` and the `jwk_alg`, and will emit a warning if the user specified alg is different from the `jwk_alg`. Args: jwk_alg: the alg from the JWK, if any alg: a user specified alg supported_algs: a mapping of supported alg names to alg wrapper Returns: the alg to use Raises: UnsupportedAlg: if the requested alg is not supported \"\"\" choosen_alg : str if jwk_alg is not None : if alg is not None : if jwk_alg != alg : warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) choosen_alg = alg else : choosen_alg = jwk_alg elif alg is not None : choosen_alg = alg try : return supported_algs [ choosen_alg ] except KeyError : raise UnsupportedAlg ( f \"Alg { choosen_alg } is not supported. Supported algs: { list ( supported_algs ) } .\" )","title":"select_alg()"},{"location":"api/#jwskate.jwk.alg.select_algs","text":"Given an alg parameter from a JWK, and/or a user-specified alg, and/or a user specified list of useable algs, return a list of algorithms. This method is typically used to get the list of possible algs when checking a signature. Parameters: Name Type Description Default jwk_alg Optional [ str ] the alg from the JWK, if any required alg Optional [ str ] a user specified alg to use required algs Optional [ Iterable [ str ]] a user specified list of algs to use, if several are allowed required supported_algs Mapping [ str , T ] a mapping of alg names to alg wrappers required Returns: Type Description List [ T ] a list of possible algs to check Raises: Type Description ValueError if both 'alg' and 'algs' parameters are used UnsupportedAlg if none of the requested alg are supported Warnings if the requested 'alg' is different that the 'jwk_alg', or the 'jwk_alg' is not in the 'algs' Source code in jwskate\\jwk\\alg.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def select_algs ( jwk_alg : Optional [ str ], alg : Optional [ str ], algs : Optional [ Iterable [ str ]], supported_algs : Mapping [ str , T ], ) -> List [ T ]: \"\"\"Given an alg parameter from a JWK, and/or a user-specified alg, and/or a user specified list of useable algs, return a list of algorithms. This method is typically used to get the list of possible algs when checking a signature. Args: jwk_alg: the alg from the JWK, if any alg: a user specified alg to use algs: a user specified list of algs to use, if several are allowed supported_algs: a mapping of alg names to alg wrappers Returns: a list of possible algs to check Raises: ValueError: if both 'alg' and 'algs' parameters are used UnsupportedAlg: if none of the requested alg are supported Warnings: if the requested 'alg' is different that the 'jwk_alg', or the 'jwk_alg' is not in the 'algs' \"\"\" if alg and algs : raise ValueError ( \"Please use either parameter 'alg' or 'algs', not both.\" ) if jwk_alg is not None : if alg and alg != jwk_alg : warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) if algs and jwk_alg not in algs : warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) possible_algs : List [ str ] = [] if alg : possible_algs = [ alg ] elif algs : possible_algs = list ( algs ) elif jwk_alg : possible_algs = [ jwk_alg ] if possible_algs : possible_supported_algs = [ supported_algs [ alg ] for alg in possible_algs if alg in supported_algs ] if possible_supported_algs : return possible_supported_algs else : raise UnsupportedAlg ( f \"None of the user-specified alg(s) are supported. { possible_algs } \" ) raise ValueError ( \"This key doesn't have an 'alg' parameter, you need to provide the signing alg for each operation.\" )","title":"select_algs()"},{"location":"api/#jwskate.jwk.base","text":"This module implements the Jwk base class, which provides most of the common features of all JWK types.","title":"base"},{"location":"api/#jwskate.jwk.base.UnsupportedKeyType","text":"Bases: ValueError Raised when an unsupported Key Type is requested. Source code in jwskate\\jwk\\base.py 46 47 class UnsupportedKeyType ( ValueError ): \"\"\"Raised when an unsupported Key Type is requested.\"\"\"","title":"UnsupportedKeyType"},{"location":"api/#jwskate.jwk.base.InvalidJwk","text":"Bases: ValueError Raised when an invalid JWK is encountered. Source code in jwskate\\jwk\\base.py 50 51 class InvalidJwk ( ValueError ): \"\"\"Raised when an invalid JWK is encountered.\"\"\"","title":"InvalidJwk"},{"location":"api/#jwskate.jwk.base.Jwk","text":"Bases: BaseJsonDict Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class: Jwk is a dict, so you can do with a Jwk anything you can do with a dict . In addition, all keys parameters are exposed as attributes. There are subclasses of Jwk for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Source code in jwskate\\jwk\\base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 class Jwk ( BaseJsonDict ): \"\"\"Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class:`Jwk` is a dict, so you can do with a Jwk anything you can do with a `dict`. In addition, all keys parameters are exposed as attributes. There are subclasses of `Jwk` for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. \"\"\" subclasses : Dict [ str , Type [ Jwk ]] = {} \"\"\"A dict of 'kty' values to subclasses implementing each specific Key Type\"\"\" cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} \"\"\"A dict of cryptography key classes to its specific 'kty' value\"\"\" PARAMS : Mapping [ str , JwkParameter ] \"\"\"A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)\"\"\" KTY : ClassVar [ str ] \"\"\"The Key Type associated with this JWK.\"\"\" CRYPTOGRAPHY_KEY_CLASSES : ClassVar [ Iterable [ Any ]] SIGNATURE_ALGORITHMS : Mapping [ str , Type [ BaseSignatureAlg ]] = {} KEY_MANAGEMENT_ALGORITHMS : Mapping [ str , Type [ BaseKeyManagementAlg ]] = {} ENCRYPTION_ALGORITHMS : Mapping [ str , Type [ BaseAESEncryptionAlg ]] = {} def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls def __new__ ( cls , jwk : Union [ Jwk , Dict [ str , Any ]], * args , ** kwargs ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: jwk: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key \"\"\" if cls == Jwk : if isinstance ( jwk , Jwk ): return jwk elif isinstance ( jwk , dict ): kty : Optional [ str ] = jwk . get ( \"kty\" ) if kty is None : raise ValueError ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise ValueError ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) else : # this will trigger double __init__ return cls . from_cryptography_key ( jwk , * args , ** kwargs ) return super () . __new__ ( cls , jwk , * args , ** jwk ) def __init__ ( self , params : Union [ Dict [ str , Any ], Any ], include_kid_thumbprint : bool = False ): \"\"\"Initialize a Jwk. This accepts a `dict` with the parsed Jwk contents, and an optional kid if it isn't already part of the dict. If no `kid` is supplied and `include_kid_thumbprint`, a default kid is generated based on the key thumbprint (defined in RFC7638). Args: params: a dict with the parsed Jwk parameters include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint \"\"\" if isinstance ( params , dict ): # this is to avoid double init due to the __new__ above super () . __init__ ( { key : val for key , val in params . items () if val is not None } ) self . is_private = False self . _validate () if self . get ( \"kid\" ) is None and include_kid_thumbprint : self [ \"kid\" ] = self . thumbprint () def __getattr__ ( self , item : str ) -> Any : \"\"\"Allows access to key parameters as attributes, like `jwk.kid`, `jwk.kty`, instead of `jwk['kid']`, `jwk['kty']`, etc. Args: item: the member to access Return: the member value Raises: AttributeError: if the member is not found \"\"\" value = self . get ( item ) if value is None : raise AttributeError ( item ) return value def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" digest = hashlib . new ( hashalg ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) intermediary = json . dumps ( t , separators = ( \",\" , \":\" ), sort_keys = True ) digest . update ( intermediary . encode ( \"utf8\" )) return BinaPy ( digest . digest ()) . encode_to ( \"b64u\" ) . decode () @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): raise TypeError ( f \"Invalid alg type { type ( str ) } \" , alg ) return alg def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"decrypt\" , \"unwrapKey\" ) and not jwk_is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) self . is_private = jwk_is_private def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } key_ops = self . get ( \"key_ops\" ) if key_ops : if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"decrypt\" in key_ops : key_ops . remove ( \"decrypt\" ) key_ops . append ( \"encrypt\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) def sign ( self , data : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" sigalg = select_alg ( self . alg , alg , self . SIGNATURE_ALGORITHMS ) wrapper : BaseSignatureAlg if issubclass ( sigalg , BaseAsymmetricAlg ): wrapper = sigalg ( self . to_cryptography_key ()) elif issubclass ( sigalg , BaseSymmetricAlg ): wrapper = sigalg ( self . key ) signature = wrapper . sign ( data ) return BinaPy ( signature ) def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" wrapper : BaseSignatureAlg for sigalg in select_algs ( self . alg , alg , algs , self . SIGNATURE_ALGORITHMS ): if issubclass ( sigalg , BaseAsymmetricAlg ): key = self . public_jwk () . to_cryptography_key () wrapper = sigalg ( key ) elif issubclass ( sigalg , BaseSymmetricAlg ): key = self . key wrapper = sigalg ( key ) if wrapper . verify ( data , signature ): return True return False def encrypt ( self , plaintext : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Authentication Tag and the used Initialization Vector. Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector that was used to encrypt the data. If `iv` is passed as parameter, this will return that same value. Otherwise, an IV is generated. Returns: a tuple (ciphertext, authentication_tag, iv), as raw data \"\"\" raise NotImplementedError # pragma: no cover def decrypt ( self , ciphertext : bytes , tag : bytes , iv : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt tag: the Authentication Tag that will be verified while decrypting data iv: the Initialization Vector (IV) that was used for encryption aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover def wrap_key ( self , key : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key using a Key Management Algorithm alg. Args: key: the symmetric key to wrap alg: the Key Management alg to use Returns: the wrapped key \"\"\" raise NotImplementedError def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None ) -> Jwk : \"\"\"Unwrap a symmetric key using a Key Management Algorithm alg. Args: cipherkey: the wrapped key alg: the Key Management alg to use Returns: the unwrapped key \"\"\" raise NotImplementedError def sender_key ( self , enc : str , alg : Optional [ str ], cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , Mapping [ str , Any ], BinaPy ]: \"\"\"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. For algorithms that rely on a random CEK, you can provide that value instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only use this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: Tuple[Jwk,Mapping[str,Any],BinaPy]: a tuple (CEK, additional_headers_map, wrapped_cek) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) cek_headers : Dict [ str , Any ] = {} if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . public_jwk () . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = rsa . wrap_key ( cek ) elif issubclass ( keyalg , EcdhEs ): ecdh : EcdhEs = keyalg ( self . public_jwk () . to_cryptography_key ()) epk = epk or Jwk . from_cryptography_key ( ecdh . generate_ephemeral_key ()) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( ecdh , BaseEcdhEs_AesKw ): if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = ecdh . wrap_key_with_epk ( cek , epk . to_cryptography_key (), alg = alg , ** headers ) else : cek = ecdh . sender_key ( epk . to_cryptography_key (), encalg . name , encalg . key_size , ** headers ) wrapped_cek = BinaPy ( b \"\" ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes : BaseAesKeyWrap = keyalg ( self . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = aes . wrap_key ( cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm : BaseAesGcmKeyWrap = keyalg ( self . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () iv = aesgcm . generate_iv () wrapped_cek , tag = aesgcm . wrap_key ( cek , iv ) cek_headers = { \"iv\" : iv . encode_to ( \"b64u\" ) . decode (), \"tag\" : tag . encode_to ( \"b64u\" ) . decode (), } elif issubclass ( keyalg , DirectKeyUse ): dir = keyalg ( self . key ) cek = dir . direct_key ( encalg ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ), cek_headers , wrapped_cek def recipient_key ( self , wrapped_cek : bytes , alg : str , enc : str , ** headers : Any ) -> Jwk : \"\"\"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Args: wrapped_cek: the wrapped CEK alg: the Key Management algorithm to use to unwrap the CEK enc: the encryption algorithm to use with the CEK **headers: Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . to_cryptography_key ()) cek = rsa . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , EcdhEs ): ecdh = keyalg ( self . to_cryptography_key ()) epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . to_cryptography_key () encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if isinstance ( ecdh , BaseEcdhEs_AesKw ): cek = ecdh . unwrap_key_with_epk ( wrapped_cek , epk , alg = alg ) else : cek = ecdh . recipient_key ( epk , alg = encalg . name , key_size = encalg . key_size , ** headers ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes = keyalg ( self . to_cryptography_key ()) cek = aes . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm = keyalg ( self . to_cryptography_key ()) iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = aesgcm . unwrap_key ( wrapped_cek , tag , iv ) elif issubclass ( keyalg , DirectKeyUse ): dir_ = keyalg ( self . key ) cek = dir_ . direct_key ( encalg ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) def to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError @classmethod def from_pem_key ( cls , data : bytes , password : Optional [ bytes ] = None ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required Returns: a Jwk instance from the loaded key \"\"\" try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) return cls . from_cryptography_key ( cryptography_key ) def to_pem_key ( self , password : Optional [ bytes ] = None ) -> str : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM encrypted key, as \"\"\" raise NotImplementedError @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs )","title":"Jwk"},{"location":"api/#jwskate.jwk.base.Jwk.subclasses","text":"A dict of 'kty' values to subclasses implementing each specific Key Type","title":"subclasses"},{"location":"api/#jwskate.jwk.base.Jwk.cryptography_key_types","text":"A dict of cryptography key classes to its specific 'kty' value","title":"cryptography_key_types"},{"location":"api/#jwskate.jwk.base.Jwk.PARAMS","text":"A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)","title":"PARAMS"},{"location":"api/#jwskate.jwk.base.Jwk.KTY","text":"The Key Type associated with this JWK.","title":"KTY"},{"location":"api/#jwskate.jwk.base.Jwk.__init_subclass__","text":"Automatically add subclasses to the registry. This allows new to pick the appropriate subclass when creating a Jwk Source code in jwskate\\jwk\\base.py 93 94 95 96 97 98 99 100 101 def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls","title":"__init_subclass__()"},{"location":"api/#jwskate.jwk.base.Jwk.__new__","text":"The Jwk constructor will accept a dict with the parsed Jwk content another Jwk, which will be used as-is instead of creating a copy an instance from a cryptography public or private key class Overridden __new__ to make the Jwk constructor smarter. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] a dict containing JWK parameters, or another Jwk instance, or a cryptography key required Source code in jwskate\\jwk\\base.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def __new__ ( cls , jwk : Union [ Jwk , Dict [ str , Any ]], * args , ** kwargs ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: jwk: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key \"\"\" if cls == Jwk : if isinstance ( jwk , Jwk ): return jwk elif isinstance ( jwk , dict ): kty : Optional [ str ] = jwk . get ( \"kty\" ) if kty is None : raise ValueError ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise ValueError ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) else : # this will trigger double __init__ return cls . from_cryptography_key ( jwk , * args , ** kwargs ) return super () . __new__ ( cls , jwk , * args , ** jwk )","title":"__new__()"},{"location":"api/#jwskate.jwk.base.Jwk.__init__","text":"Initialize a Jwk. This accepts a dict with the parsed Jwk contents, and an optional kid if it isn't already part of the dict. If no kid is supplied and include_kid_thumbprint , a default kid is generated based on the key thumbprint (defined in RFC7638). Parameters: Name Type Description Default params Union [ Dict [ str , Any ], Any ] a dict with the parsed Jwk parameters required include_kid_thumbprint bool if True (default), and there is no kid in the provided params, generate a kid based on the key thumbprint False Source code in jwskate\\jwk\\base.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , params : Union [ Dict [ str , Any ], Any ], include_kid_thumbprint : bool = False ): \"\"\"Initialize a Jwk. This accepts a `dict` with the parsed Jwk contents, and an optional kid if it isn't already part of the dict. If no `kid` is supplied and `include_kid_thumbprint`, a default kid is generated based on the key thumbprint (defined in RFC7638). Args: params: a dict with the parsed Jwk parameters include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint \"\"\" if isinstance ( params , dict ): # this is to avoid double init due to the __new__ above super () . __init__ ( { key : val for key , val in params . items () if val is not None } ) self . is_private = False self . _validate () if self . get ( \"kid\" ) is None and include_kid_thumbprint : self [ \"kid\" ] = self . thumbprint ()","title":"__init__()"},{"location":"api/#jwskate.jwk.base.Jwk.__getattr__","text":"Allows access to key parameters as attributes, like jwk.kid , jwk.kty , instead of jwk['kid'] , jwk['kty'] , etc. Parameters: Name Type Description Default item str the member to access required Return the member value Raises: Type Description AttributeError if the member is not found Source code in jwskate\\jwk\\base.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allows access to key parameters as attributes, like `jwk.kid`, `jwk.kty`, instead of `jwk['kid']`, `jwk['kty']`, etc. Args: item: the member to access Return: the member value Raises: AttributeError: if the member is not found \"\"\" value = self . get ( item ) if value is None : raise AttributeError ( item ) return value","title":"__getattr__()"},{"location":"api/#jwskate.jwk.base.Jwk.thumbprint","text":"Return the key thumbprint as specified by RFC 7638. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Returns: Type Description str the calculated thumbprint Source code in jwskate\\jwk\\base.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" digest = hashlib . new ( hashalg ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) intermediary = json . dumps ( t , separators = ( \",\" , \":\" ), sort_keys = True ) digest . update ( intermediary . encode ( \"utf8\" )) return BinaPy ( digest . digest ()) . encode_to ( \"b64u\" ) . decode ()","title":"thumbprint()"},{"location":"api/#jwskate.jwk.base.Jwk.kty","text":"Return the Key Type. Returns: Type Description str the key type Source code in jwskate\\jwk\\base.py 191 192 193 194 195 196 197 198 @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY","title":"kty()"},{"location":"api/#jwskate.jwk.base.Jwk.alg","text":"Return the configured key alg, if any. Returns: Type Description Optional [ str ] the key alg Source code in jwskate\\jwk\\base.py 200 201 202 203 204 205 206 207 208 209 210 @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): raise TypeError ( f \"Invalid alg type { type ( str ) } \" , alg ) return alg","title":"alg()"},{"location":"api/#jwskate.jwk.base.Jwk._validate","text":"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the is_private flag to True . Raises: Type Description TypeError if the key type doesn't match the subclass InvalidJwk if the JWK misses required members or has invalid members Source code in jwskate\\jwk\\base.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"decrypt\" , \"unwrapKey\" ) and not jwk_is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) self . is_private = jwk_is_private","title":"_validate()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_signing_algorithms","text":"Return the list of Signature algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate\\jwk\\base.py 274 275 276 277 278 279 280 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS )","title":"supported_signing_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_key_management_algorithms","text":"Return the list of Key Management algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate\\jwk\\base.py 282 283 284 285 286 287 288 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS )","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_encryption_algorithms","text":"Return the list of Encryption algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate\\jwk\\base.py 290 291 292 293 294 295 296 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS )","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.public_jwk","text":"Return the public Jwk associated with this key. Returns: Type Description Jwk a Jwk with the public key Source code in jwskate\\jwk\\base.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } key_ops = self . get ( \"key_ops\" ) if key_ops : if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"decrypt\" in key_ops : key_ops . remove ( \"decrypt\" ) key_ops . append ( \"encrypt\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) )","title":"public_jwk()"},{"location":"api/#jwskate.jwk.base.Jwk.as_jwks","text":"Return a JwkSet with this key as single element. Returns: Type Description JwkSet a JwsSet with this single key Source code in jwskate\\jwk\\base.py 336 337 338 339 340 341 342 343 344 def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,))","title":"as_jwks()"},{"location":"api/#jwskate.jwk.base.Jwk.sign","text":"Sign a data using this Jwk, and return the generated signature. Parameters: Name Type Description Default data bytes the data to sign required alg Optional [ str ] the alg to use (if this key doesn't have an alg parameter) None Returns: Type Description BinaPy the generated signature Source code in jwskate\\jwk\\base.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 def sign ( self , data : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" sigalg = select_alg ( self . alg , alg , self . SIGNATURE_ALGORITHMS ) wrapper : BaseSignatureAlg if issubclass ( sigalg , BaseAsymmetricAlg ): wrapper = sigalg ( self . to_cryptography_key ()) elif issubclass ( sigalg , BaseSymmetricAlg ): wrapper = sigalg ( self . key ) signature = wrapper . sign ( data ) return BinaPy ( signature )","title":"sign()"},{"location":"api/#jwskate.jwk.base.Jwk.verify","text":"Verify a signature using this Jwk, and return True if valid. Parameters: Name Type Description Default data bytes the data to verify required signature bytes the signature to verify required alg Optional [ str ] the allowed signature alg, if there is only one None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate\\jwk\\base.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" wrapper : BaseSignatureAlg for sigalg in select_algs ( self . alg , alg , algs , self . SIGNATURE_ALGORITHMS ): if issubclass ( sigalg , BaseAsymmetricAlg ): key = self . public_jwk () . to_cryptography_key () wrapper = sigalg ( key ) elif issubclass ( sigalg , BaseSymmetricAlg ): key = self . key wrapper = sigalg ( key ) if wrapper . verify ( data , signature ): return True return False","title":"verify()"},{"location":"api/#jwskate.jwk.base.Jwk.encrypt","text":"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Authentication Tag and the used Initialization Vector. Parameters: Name Type Description Default plaintext bytes the data to encrypt. required aad Optional [ bytes ] the Additional Authenticated Data (AAD) to include in the authentication tag None alg Optional [ str ] the alg to use to encrypt the data None iv Optional [ bytes ] the Initialization Vector that was used to encrypt the data. If iv is passed as parameter, this None will return that same value. Otherwise, an IV is generated. Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a tuple (ciphertext, authentication_tag, iv), as raw data Source code in jwskate\\jwk\\base.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 def encrypt ( self , plaintext : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Authentication Tag and the used Initialization Vector. Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector that was used to encrypt the data. If `iv` is passed as parameter, this will return that same value. Otherwise, an IV is generated. Returns: a tuple (ciphertext, authentication_tag, iv), as raw data \"\"\" raise NotImplementedError # pragma: no cover","title":"encrypt()"},{"location":"api/#jwskate.jwk.base.Jwk.decrypt","text":"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required tag bytes the Authentication Tag that will be verified while decrypting data required iv bytes the Initialization Vector (IV) that was used for encryption required aad Optional [ bytes ] the Additional Authentication Data (AAD) to verify the Tag against None alg Optional [ str ] the alg to use for decryption None Returns: Type Description BinaPy the clear-text data Source code in jwskate\\jwk\\base.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def decrypt ( self , ciphertext : bytes , tag : bytes , iv : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt tag: the Authentication Tag that will be verified while decrypting data iv: the Initialization Vector (IV) that was used for encryption aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover","title":"decrypt()"},{"location":"api/#jwskate.jwk.base.Jwk.wrap_key","text":"Wrap a symmetric key using a Key Management Algorithm alg. Parameters: Name Type Description Default key bytes the symmetric key to wrap required alg Optional [ str ] the Key Management alg to use None Returns: Type Description BinaPy the wrapped key Source code in jwskate\\jwk\\base.py 443 444 445 446 447 448 449 450 451 452 453 def wrap_key ( self , key : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key using a Key Management Algorithm alg. Args: key: the symmetric key to wrap alg: the Key Management alg to use Returns: the wrapped key \"\"\" raise NotImplementedError","title":"wrap_key()"},{"location":"api/#jwskate.jwk.base.Jwk.unwrap_key","text":"Unwrap a symmetric key using a Key Management Algorithm alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required alg Optional [ str ] the Key Management alg to use None Returns: Type Description Jwk the unwrapped key Source code in jwskate\\jwk\\base.py 455 456 457 458 459 460 461 462 463 464 465 def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None ) -> Jwk : \"\"\"Unwrap a symmetric key using a Key Management Algorithm alg. Args: cipherkey: the wrapped key alg: the Key Management alg to use Returns: the unwrapped key \"\"\" raise NotImplementedError","title":"unwrap_key()"},{"location":"api/#jwskate.jwk.base.Jwk.sender_key","text":"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. For algorithms that rely on a random CEK, you can provide that value instead of letting jwskate generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting jwskate generate an appropriate value for you. Only use this if you know what you are doing! Parameters: Name Type Description Default enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to produce the CEK required cek Optional [ bytes ] CEK to use (leave None to have an adequate random value generated automatically) None epk Optional [ Jwk ] EPK to use (leave None to have an adequate ephemeral key generated automatically) None **headers Any additional headers to include for the CEK derivation {} Returns: Type Description Tuple [ Jwk , Mapping [ str , Any ], BinaPy ] Tuple[Jwk,Mapping[str,Any],BinaPy]: a tuple (CEK, additional_headers_map, wrapped_cek) Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate\\jwk\\base.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 def sender_key ( self , enc : str , alg : Optional [ str ], cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , Mapping [ str , Any ], BinaPy ]: \"\"\"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. For algorithms that rely on a random CEK, you can provide that value instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only use this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: Tuple[Jwk,Mapping[str,Any],BinaPy]: a tuple (CEK, additional_headers_map, wrapped_cek) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) cek_headers : Dict [ str , Any ] = {} if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . public_jwk () . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = rsa . wrap_key ( cek ) elif issubclass ( keyalg , EcdhEs ): ecdh : EcdhEs = keyalg ( self . public_jwk () . to_cryptography_key ()) epk = epk or Jwk . from_cryptography_key ( ecdh . generate_ephemeral_key ()) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( ecdh , BaseEcdhEs_AesKw ): if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = ecdh . wrap_key_with_epk ( cek , epk . to_cryptography_key (), alg = alg , ** headers ) else : cek = ecdh . sender_key ( epk . to_cryptography_key (), encalg . name , encalg . key_size , ** headers ) wrapped_cek = BinaPy ( b \"\" ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes : BaseAesKeyWrap = keyalg ( self . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () wrapped_cek = aes . wrap_key ( cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm : BaseAesGcmKeyWrap = keyalg ( self . to_cryptography_key ()) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () iv = aesgcm . generate_iv () wrapped_cek , tag = aesgcm . wrap_key ( cek , iv ) cek_headers = { \"iv\" : iv . encode_to ( \"b64u\" ) . decode (), \"tag\" : tag . encode_to ( \"b64u\" ) . decode (), } elif issubclass ( keyalg , DirectKeyUse ): dir = keyalg ( self . key ) cek = dir . direct_key ( encalg ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ), cek_headers , wrapped_cek","title":"sender_key()"},{"location":"api/#jwskate.jwk.base.Jwk.recipient_key","text":"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Parameters: Name Type Description Default wrapped_cek bytes the wrapped CEK required alg str the Key Management algorithm to use to unwrap the CEK required enc str the encryption algorithm to use with the CEK required **headers Any {} Returns: Type Description Jwk the clear-text CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate\\jwk\\base.py 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 def recipient_key ( self , wrapped_cek : bytes , alg : str , enc : str , ** headers : Any ) -> Jwk : \"\"\"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Args: wrapped_cek: the wrapped CEK alg: the Key Management algorithm to use to unwrap the CEK enc: the encryption algorithm to use with the CEK **headers: Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . to_cryptography_key ()) cek = rsa . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , EcdhEs ): ecdh = keyalg ( self . to_cryptography_key ()) epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . to_cryptography_key () encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if isinstance ( ecdh , BaseEcdhEs_AesKw ): cek = ecdh . unwrap_key_with_epk ( wrapped_cek , epk , alg = alg ) else : cek = ecdh . recipient_key ( epk , alg = encalg . name , key_size = encalg . key_size , ** headers ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes = keyalg ( self . to_cryptography_key ()) cek = aes . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm = keyalg ( self . to_cryptography_key ()) iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = aesgcm . unwrap_key ( wrapped_cek , tag , iv ) elif issubclass ( keyalg , DirectKeyUse ): dir_ = keyalg ( self . key ) cek = dir_ . direct_key ( encalg ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek )","title":"recipient_key()"},{"location":"api/#jwskate.jwk.base.Jwk.from_cryptography_key","text":"Initialize a Jwk from a key from the cryptography library. The input key can be any private or public key supported by cryptography. Parameters: Name Type Description Default cryptography_key Any a cryptography key instance required Returns: Type Description Jwk the matching Jwk instance Raises: Type Description TypeError if the key type is not supported Source code in jwskate\\jwk\\base.py 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 @classmethod def from_cryptography_key ( cls , cryptography_key : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.base.Jwk.to_cryptography_key","text":"Return a key from the cryptography library that matches this Jwk. This is implemented by subclasses. Returns: Type Description Any a cryptography key instance initialized from the current key Source code in jwskate\\jwk\\base.py 646 647 648 649 650 651 652 653 654 def to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError","title":"to_cryptography_key()"},{"location":"api/#jwskate.jwk.base.Jwk.from_pem_key","text":"Load a Jwk from a PEM encoded private or public key. Parameters: Name Type Description Default data bytes the PEM encoded data to load required password Optional [ bytes ] the password to decrypt the PEM, if required None Returns: Type Description Jwk a Jwk instance from the loaded key Source code in jwskate\\jwk\\base.py 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 @classmethod def from_pem_key ( cls , data : bytes , password : Optional [ bytes ] = None ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required Returns: a Jwk instance from the loaded key \"\"\" try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) return cls . from_cryptography_key ( cryptography_key )","title":"from_pem_key()"},{"location":"api/#jwskate.jwk.base.Jwk.to_pem_key","text":"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Parameters: Name Type Description Default password Optional [ bytes ] password to use to encrypt the PEM None Returns: Type Description str the PEM encrypted key, as Source code in jwskate\\jwk\\base.py 684 685 686 687 688 689 690 691 692 693 694 695 def to_pem_key ( self , password : Optional [ bytes ] = None ) -> str : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM encrypted key, as \"\"\" raise NotImplementedError","title":"to_pem_key()"},{"location":"api/#jwskate.jwk.base.Jwk.generate","text":"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Parameters: Name Type Description Default **kwargs Any specific parameters depending on the type of key, or additional members to include in the Jwk {} Returns: Type Description Jwk a Jwk instance with a generated key Source code in jwskate\\jwk\\base.py 697 698 699 700 701 702 703 704 705 706 707 @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError","title":"generate()"},{"location":"api/#jwskate.jwk.base.Jwk.generate_for_kty","text":"Generate a key with a specific type and return the resulting Jwk. Parameters: Name Type Description Default kty str key type to generate required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Raises: Type Description UnsupportedKeyType if the key type is not supported Source code in jwskate\\jwk\\base.py 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs )","title":"generate_for_kty()"},{"location":"api/#jwskate.jwk.ec","text":"This module implements JWK representing Elliptic Curve keys.","title":"ec"},{"location":"api/#jwskate.jwk.ec.UnsupportedEllipticCurve","text":"Bases: KeyError Raised when an unsupported Elliptic curve is requested. Source code in jwskate\\jwk\\ec.py 29 30 class UnsupportedEllipticCurve ( KeyError ): \"\"\"Raised when an unsupported Elliptic curve is requested.\"\"\"","title":"UnsupportedEllipticCurve"},{"location":"api/#jwskate.jwk.ec.ECJwk","text":"Bases: Jwk Represent an Elliptic Curve Jwk, with kty=EC . Source code in jwskate\\jwk\\ec.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class ECJwk ( Jwk ): \"\"\"Represent an Elliptic Curve Jwk, with `kty=EC`.\"\"\" KTY = \"EC\" CRYPTOGRAPHY_KEY_CLASSES = ( asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ) PARAMS : Mapping [ str , JwkParameter ] = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"X Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"y\" : JwkParameter ( \"Y Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"ECC Private Key\" , is_private = True , is_required = True , kind = \"b64u\" ), } CURVES : Mapping [ str , EllipticCurve ] = { curve . name : curve for curve in [ P_256 , P_384 , P_521 , secp256k1 ] } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ ES256 , ES384 , ES512 , ES256K ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedEllipticCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . encode_to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . encode_to ( \"b64u\" ), ** params , ) ) @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . encode_to ( \"b64u\" ) . decode (), y = BinaPy . from_int ( y , coord_size ) . encode_to ( \"b64u\" ) . decode (), d = BinaPy . from_int ( d , coord_size ) . encode_to ( \"b64u\" ) . decode (), ** params , ) ) @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size @classmethod def from_cryptography_key ( cls , key : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: key: `cryptography` key Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_parameters ( key ) return cls ( parameters ) def to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key () @classmethod def generate ( cls , crv : str = \"P-256\" , ** params : str ) -> \"ECJwk\" : \"\"\"Generates a random ECJwk. Args: crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" curve = cls . get_curve ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = crv , x = x , y = y , d = d , ** params , ) @property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () @property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () @property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS )","title":"ECJwk"},{"location":"api/#jwskate.jwk.ec.ECJwk.get_curve","text":"Get the EllipticCurve instance for a given curve identifier. Parameters: Name Type Description Default crv str the curve identifier required Returns: Type Description EllipticCurve the matching EllipticCurve instance Raises: Type Description UnsupportedEllipticCurve if the curve identifier is not supported Source code in jwskate\\jwk\\ec.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve","title":"get_curve()"},{"location":"api/#jwskate.jwk.ec.ECJwk.curve","text":"Get the EllipticCurve instance for this key. Returns: Type Description EllipticCurve the EllipticCurve instance Source code in jwskate\\jwk\\ec.py 92 93 94 95 96 97 98 99 @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv )","title":"curve()"},{"location":"api/#jwskate.jwk.ec.ECJwk.public","text":"Initialize a public ECJwk from its public parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required **params str additional member to include in the Jwk {} Returns: Type Description 'ECJwk' an ECJwk initialized with the supplied parameters Source code in jwskate\\jwk\\ec.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . encode_to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . encode_to ( \"b64u\" ), ** params , ) )","title":"public()"},{"location":"api/#jwskate.jwk.ec.ECJwk.private","text":"Initialize a private ECJwk from its private parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required d int the elliptic curve private key required **params Any additional members to include in the JWK {} Returns: Type Description 'ECJwk' an ECJWk initialized with the supplied parameters Source code in jwskate\\jwk\\ec.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . encode_to ( \"b64u\" ) . decode (), y = BinaPy . from_int ( y , coord_size ) . encode_to ( \"b64u\" ) . decode (), d = BinaPy . from_int ( d , coord_size ) . encode_to ( \"b64u\" ) . decode (), ** params , ) )","title":"private()"},{"location":"api/#jwskate.jwk.ec.ECJwk.coordinate_size","text":"The coordinate size to use with the key curve. Returns: Type Description int 32, 48, or 66 (bits) Source code in jwskate\\jwk\\ec.py 151 152 153 154 155 156 157 158 @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size","title":"coordinate_size()"},{"location":"api/#jwskate.jwk.ec.ECJwk.from_cryptography_key","text":"Initialize an ECJwk from a cryptography key. Parameters: Name Type Description Default key Any cryptography key required Returns: Type Description ECJwk an ECJwk initialized from the provided cryptography key Source code in jwskate\\jwk\\ec.py 160 161 162 163 164 165 166 167 168 169 170 171 @classmethod def from_cryptography_key ( cls , key : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: key: `cryptography` key Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_parameters ( key ) return cls ( parameters )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk.to_cryptography_key","text":"Initialize a cryptography key based on this Jwk. Returns: Type Description Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] an EllipticCurvePublicKey or EllipticCurvePrivateKey Source code in jwskate\\jwk\\ec.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key ()","title":"to_cryptography_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk.generate","text":"Generates a random ECJwk. Parameters: Name Type Description Default crv str the curve to use 'P-256' **params str {} Returns: Type Description 'ECJwk' a generated ECJwk Raises: Type Description UnsupportedEllipticCurve if the provided curve identifier is not supported. Source code in jwskate\\jwk\\ec.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @classmethod def generate ( cls , crv : str = \"P-256\" , ** params : str ) -> \"ECJwk\" : \"\"\"Generates a random ECJwk. Args: crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" curve = cls . get_curve ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = crv , x = x , y = y , d = d , ** params , )","title":"generate()"},{"location":"api/#jwskate.jwk.ec.ECJwk.x_coordinate","text":"Return the x coordinate from this ECJwk. Returns: Type Description int the x coordinate (from parameter x ) Source code in jwskate\\jwk\\ec.py 226 227 228 229 230 231 232 233 @property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int ()","title":"x_coordinate()"},{"location":"api/#jwskate.jwk.ec.ECJwk.y_coordinate","text":"Return the y coordinate from this ECJwk. Returns: Type Description int the y coordinate (from parameter y ) Source code in jwskate\\jwk\\ec.py 235 236 237 238 239 240 241 242 @property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int ()","title":"y_coordinate()"},{"location":"api/#jwskate.jwk.ec.ECJwk.ecc_private_key","text":"Return the ECC private key from this ECJwk. Returns: Type Description int the ECC private key (from parameter d ) Source code in jwskate\\jwk\\ec.py 244 245 246 247 248 249 250 251 @property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int ()","title":"ecc_private_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_signing_algorithms","text":"Return the list of supported signature algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\ec.py 253 254 255 256 257 258 259 260 261 262 263 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ]","title":"supported_signing_algorithms()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_key_management_algorithms","text":"Return the list of supported Key Management algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\ec.py 265 266 267 268 269 270 271 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS )","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_encryption_algorithms","text":"Return the list of support Encryption algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\ec.py 273 274 275 276 277 278 279 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS )","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jwk.jwks","text":"This module implements Json Web Key Sets (JWKS).","title":"jwks"},{"location":"api/#jwskate.jwk.jwks.JwkSet","text":"Bases: BaseJsonDict A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. Source code in jwskate\\jwk\\jwks.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class JwkSet ( BaseJsonDict ): \"\"\"A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. \"\"\" def __init__ ( self , jwks : Optional [ Dict [ str , Any ]] = None , keys : Optional [ Iterable [ Jwk ]] = None , ): \"\"\"Intiialize a JwkSet. Multiple inputs can be provided. - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`) - a list of `Jwk` (in parameter `keys` - nothing, to initialize an empty JwkSet Args: jwks: a dict, containing the JwkSet, parsed as a JSON object. keys: a list of Jwk, that will be added to this JwkSet \"\"\" if jwks is None and keys is None : keys = [] if jwks is not None : keys = jwks . pop ( \"keys\" , []) super () . __init__ ( jwks ) # init the dict with all the dict content that is not keys else : super () . __init__ () if keys is not None : for jwk in keys : self . add_jwk ( jwk ) @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" if not isinstance ( jwk , Jwk ): jwk = Jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) # if one or several alg are provided, try only the keys that are compatible with one of the provided alg(s) if alg : for jwk in self . jwks : if jwk . get ( \"alg\" ) == alg : if jwk . verify ( data , signature , alg = alg ): return True if algs : for jwk in self . jwks : alg = jwk . get ( \"alg\" ) if alg is not None and alg in algs : if jwk . verify ( data , signature , algs = algs ): return True # if no kid and no alg are provided, try first the keys flagged for signature verification (`\"use\": \"verify\"`) for jwk in self . jwks : if jwk . get ( \"use\" ) == \"verify\" : if jwk . verify ( data , signature , alg ): return True # then with the keys that have no defined `use` for jwk in self . jwks : if jwk . get ( \"use\" ) is None and jwk . get ( \"alg\" ) is None : try : if jwk . verify ( data , signature , alg ): return True except UnsupportedAlg : continue # no key matches, so consider the signature invalid return False","title":"JwkSet"},{"location":"api/#jwskate.jwk.jwks.JwkSet.__init__","text":"Intiialize a JwkSet. Multiple inputs can be provided. a dict from the parsed JSON object representing this JwkSet (in paramter jwks ) a list of Jwk (in parameter keys nothing, to initialize an empty JwkSet Parameters: Name Type Description Default jwks Optional [ Dict [ str , Any ]] a dict, containing the JwkSet, parsed as a JSON object. None keys Optional [ Iterable [ Jwk ]] a list of Jwk, that will be added to this JwkSet None Source code in jwskate\\jwk\\jwks.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , jwks : Optional [ Dict [ str , Any ]] = None , keys : Optional [ Iterable [ Jwk ]] = None , ): \"\"\"Intiialize a JwkSet. Multiple inputs can be provided. - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`) - a list of `Jwk` (in parameter `keys` - nothing, to initialize an empty JwkSet Args: jwks: a dict, containing the JwkSet, parsed as a JSON object. keys: a list of Jwk, that will be added to this JwkSet \"\"\" if jwks is None and keys is None : keys = [] if jwks is not None : keys = jwks . pop ( \"keys\" , []) super () . __init__ ( jwks ) # init the dict with all the dict content that is not keys else : super () . __init__ () if keys is not None : for jwk in keys : self . add_jwk ( jwk )","title":"__init__()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.jwks","text":"Return the list of keys from this JwkSet, as Jwk instances. Returns: Type Description List [ Jwk ] a list of Jwk Source code in jwskate\\jwk\\jwks.py 48 49 50 51 52 53 54 55 @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , [])","title":"jwks()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.get_jwk_by_kid","text":"Return a Jwk from this JwkSet, based on its kid. Parameters: Name Type Description Default kid str the kid of the key to obtain required Returns: Type Description Jwk the key with the matching Key ID Raises: Type Description KeyError if no key matches Source code in jwskate\\jwk\\jwks.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid )","title":"get_jwk_by_kid()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.__len__","text":"Return the number of Jwk in this JwkSet. Returns: Type Description int the number of keys Source code in jwskate\\jwk\\jwks.py 74 75 76 77 78 79 80 def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks )","title":"__len__()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.add_jwk","text":"Add a Jwk in this JwkSet. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to add (either a Jwk instance, or a dict containing the Jwk parameters) required kid Optional [ str ] the kid to use, if jwk doesn't contain one None use Optional [ str ] the defined use for the added Jwk None Returns: Type Description str the kid from the added Jwk (it may be generated if no kid is provided) Source code in jwskate\\jwk\\jwks.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" if not isinstance ( jwk , Jwk ): jwk = Jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid","title":"add_jwk()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.remove_jwk","text":"Removes a Jwk from this JwkSet, based on a kid . Parameters: Name Type Description Default kid str the kid from the key to be removed. required Raises: Type Description KeyError if no key matches Source code in jwskate\\jwk\\jwks.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass","title":"remove_jwk()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.verify","text":"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a kid is provided, only the key with this kid will be tried. Otherwise, if an alg or several algs are provided, only keys that are compatible with the supplied alg will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Parameters: Name Type Description Default data bytes the signed data to verify required signature bytes the signature to verify against the signed data required alg Optional [ str ] alg to verify the signature, if there is only 1 None algs Optional [ Iterable [ str ]] list of allowed signature algs, if there are several None kid Optional [ str ] the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys None from this key set may be tried. Returns: Type Description bool True if the signature validates with any of the tried keys, False otherwise Source code in jwskate\\jwk\\jwks.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) # if one or several alg are provided, try only the keys that are compatible with one of the provided alg(s) if alg : for jwk in self . jwks : if jwk . get ( \"alg\" ) == alg : if jwk . verify ( data , signature , alg = alg ): return True if algs : for jwk in self . jwks : alg = jwk . get ( \"alg\" ) if alg is not None and alg in algs : if jwk . verify ( data , signature , algs = algs ): return True # if no kid and no alg are provided, try first the keys flagged for signature verification (`\"use\": \"verify\"`) for jwk in self . jwks : if jwk . get ( \"use\" ) == \"verify\" : if jwk . verify ( data , signature , alg ): return True # then with the keys that have no defined `use` for jwk in self . jwks : if jwk . get ( \"use\" ) is None and jwk . get ( \"alg\" ) is None : try : if jwk . verify ( data , signature , alg ): return True except UnsupportedAlg : continue # no key matches, so consider the signature invalid return False","title":"verify()"},{"location":"api/#jwskate.jwk.okp","text":"This module implements JWK representing Octet Key Pairs from RFC8037 .","title":"okp"},{"location":"api/#jwskate.jwk.okp.UnsupportedOKPCurve","text":"Bases: KeyError Raised when an unsupported OKP curve is requested. Source code in jwskate\\jwk\\okp.py 21 22 class UnsupportedOKPCurve ( KeyError ): \"\"\"Raised when an unsupported OKP curve is requested.\"\"\"","title":"UnsupportedOKPCurve"},{"location":"api/#jwskate.jwk.okp.OKPJwk","text":"Bases: Jwk Represent an OKP Jwk, with kty=OKP . Source code in jwskate\\jwk\\okp.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 class OKPJwk ( Jwk ): \"\"\"Represent an OKP Jwk, with `kty=OKP`.\"\"\" KTY = \"OKP\" CRYPTOGRAPHY_KEY_CLASSES = ( ed25519 . Ed25519PrivateKey , ed25519 . Ed25519PublicKey , ed448 . Ed448PrivateKey , ed448 . Ed448PublicKey , x25519 . X25519PrivateKey , x25519 . X25519PublicKey , x448 . X448PrivateKey , x448 . X448PublicKey , ) PARAMS = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"Public Key\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Key\" , is_private = True , is_required = False , kind = \"b64u\" ), } CURVES : Mapping [ str , OKPCurve ] = { curve . name : curve for curve in [ Ed25519 , Ed448 , X448 , X25519 ] } SIGNATURE_ALGORITHMS = { alg . name : alg for alg in ( EdDsa ,)} def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedOKPCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) @property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) @property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) @classmethod def from_cryptography_key ( cls , key : Any ) -> OKPJwk : \"\"\"Initialize a OKPJwk from a `cryptography` key. Args: key: Returns: the matching OKPJwk \"\"\" if isinstance ( key , ed25519 . Ed25519PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( key , ed25519 . Ed25519PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( key , ed448 . Ed448PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( key , ed448 . Ed448PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( key , x25519 . X25519PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( key , x25519 . X25519PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( key , x448 . X448PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( key , x448 . X448PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in cls . CRYPTOGRAPHY_KEY_CLASSES ) ) def to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . encode_to ( \"b64u\" ) . ascii (), ** params ) ) @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . encode_to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . encode_to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def generate ( cls , crv : str = \"Ed25519\" , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. Args: crv: the curve to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" curve = cls . get_curve ( crv ) x , d = curve . generate () return cls . private ( crv = crv , x = x , d = d , ** params )","title":"OKPJwk"},{"location":"api/#jwskate.jwk.okp.OKPJwk.get_curve","text":"Get the OKPCurve instance from a curve identifier. Parameters: Name Type Description Default crv str a crv identifier required Returns: Type Description OKPCurve the matching OKPCurve instance Raises: Type Description UnsupportedOKPCurve if the curve is not supported Source code in jwskate\\jwk\\okp.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve","title":"get_curve()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.curve","text":"Get the OKPCurve instance for this key. Returns: Type Description OKPCurve the OKPCurve for this key Source code in jwskate\\jwk\\okp.py 80 81 82 83 84 85 86 87 @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv )","title":"curve()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.public_key","text":"Get the public key from this Jwk. Returns: Type Description bytes the public key (from param x ) Source code in jwskate\\jwk\\okp.py 89 90 91 92 93 94 95 96 @property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" )","title":"public_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.private_key","text":"Get the private key from this Jwk. Returns: Type Description bytes the private key (from param d ) Source code in jwskate\\jwk\\okp.py 98 99 100 101 102 103 104 105 @property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" )","title":"private_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.from_cryptography_key","text":"Initialize a OKPJwk from a cryptography key. Parameters: Name Type Description Default key Any required Returns: Type Description OKPJwk the matching OKPJwk Source code in jwskate\\jwk\\okp.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 @classmethod def from_cryptography_key ( cls , key : Any ) -> OKPJwk : \"\"\"Initialize a OKPJwk from a `cryptography` key. Args: key: Returns: the matching OKPJwk \"\"\" if isinstance ( key , ed25519 . Ed25519PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( key , ed25519 . Ed25519PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( key , ed448 . Ed448PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( key , ed448 . Ed448PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( key , x25519 . X25519PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( key , x25519 . X25519PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( key , x448 . X448PrivateKey ): priv = key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( key , x448 . X448PublicKey ): pub = key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in cls . CRYPTOGRAPHY_KEY_CLASSES ) )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.to_cryptography_key","text":"Intialize a cryptography key based on this Jwk. Returns: Type Description Any a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: Type Description UnsupportedOKPCurve if this Jwk curve is not supported. Source code in jwskate\\jwk\\okp.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve )","title":"to_cryptography_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.public","text":"Initialize a public OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the key curve required x bytes the public key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate\\jwk\\okp.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . encode_to ( \"b64u\" ) . ascii (), ** params ) )","title":"public()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.private","text":"Initialize a private OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the OKP curve required x bytes the public key required d bytes the private key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate\\jwk\\okp.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . encode_to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . encode_to ( \"b64u\" ) . ascii (), ** params , ) )","title":"private()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.generate","text":"Generate a private OKPJwk on a given curve. Parameters: Name Type Description Default crv str the curve to use 'Ed25519' **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate\\jwk\\okp.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 @classmethod def generate ( cls , crv : str = \"Ed25519\" , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. Args: crv: the curve to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" curve = cls . get_curve ( crv ) x , d = curve . generate () return cls . private ( crv = crv , x = x , d = d , ** params )","title":"generate()"},{"location":"api/#jwskate.jwk.rsa","text":"This module implements JWK representing RSA keys.","title":"rsa"},{"location":"api/#jwskate.jwk.rsa.RSAJwk","text":"Bases: Jwk Represent a RSA Jwk, with kty=RSA . Source code in jwskate\\jwk\\rsa.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 class RSAJwk ( Jwk ): \"\"\"Represent a RSA Jwk, with `kty=RSA`.\"\"\" KTY = \"RSA\" CRYPTOGRAPHY_KEY_CLASSES = ( rsa . RSAPrivateKey , rsa . RSAPublicKey ) PARAMS = { \"n\" : JwkParameter ( \"Modulus\" , is_private = False , is_required = True , kind = \"b64u\" ), \"e\" : JwkParameter ( \"Exponent\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Exponent\" , is_private = True , is_required = True , kind = \"b64u\" ), \"p\" : JwkParameter ( \"First Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"q\" : JwkParameter ( \"Second Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dp\" : JwkParameter ( \"First Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dq\" : JwkParameter ( \"Second Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" , ), \"qi\" : JwkParameter ( \"First CRT Coefficient\" , is_private = True , is_required = False , kind = \"b64u\" ), \"oth\" : JwkParameter ( \"Other Primes Info\" , is_private = True , is_required = False , kind = \"unsupported\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ RS256 , RS384 , RS512 , PS256 , PS384 , PS512 ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ RsaEsPcks1v1_5 , RsaEsOaep , RsaEsOaepSha256 , RsaEsOaepSha384 , RsaEsOaepSha512 , ] } @classmethod def from_cryptography_key ( cls , key : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: key: a `cryptography` RSA key Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( key , rsa . RSAPrivateKey ): priv = key . private_numbers () # type: ignore[attr-defined] pub = key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( key , rsa . RSAPublicKey ): pub = key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) def to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key () @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public RsaJwk from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . encode_to ( \"b64u\" ) . decode (), e = BinaPy . from_int ( e ) . encode_to ( \"b64u\" ) . decode (), ** params , ) ) @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initializes a Private RsaJwk from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . encode_to ( \"b64u\" ) . decode (), e = BinaPy . from_int ( e ) . encode_to ( \"b64u\" ) . decode (), d = BinaPy . from_int ( d ) . encode_to ( \"b64u\" ) . decode (), p = BinaPy . from_int ( p ) . encode_to ( \"b64u\" ) . decode () if p is not None else None , q = BinaPy . from_int ( q ) . encode_to ( \"b64u\" ) . decode () if q is not None else None , dp = BinaPy . from_int ( dp ) . encode_to ( \"b64u\" ) . decode () if dp is not None else None , dq = BinaPy . from_int ( dq ) . encode_to ( \"b64u\" ) . decode () if dq is not None else None , qi = BinaPy . from_int ( qi ) . encode_to ( \"b64u\" ) . decode () if qi is not None else None , ** params , ) ) @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generates a new random private RSAJwk. Args: key_size: the key size to use for the generated key. (Default value = 4096) **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) @property def modulus ( self ) -> int : \"\"\"Returns the modulus from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () @property def exponent ( self ) -> int : \"\"\"Returns the exponent from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () @property def private_exponent ( self ) -> int : \"\"\"Returns the private exponent from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () @property def first_prime_factor ( self ) -> int : \"\"\"Returns the first prime factor from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int () @property def second_prime_factor ( self ) -> int : \"\"\"Returns the second prime factor from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int () @property def first_factor_crt_exponent ( self ) -> int : \"\"\"Returns the first factor CRT exponent from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () @property def second_factor_crt_exponent ( self ) -> int : \"\"\"Returns the second factor CRT exponent from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () @property def first_crt_coefficient ( self ) -> int : \"\"\"Returns the first CRT coefficient from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () def wrap_key ( self , plainkey : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key using this RSA key. Args: plainkey: the symmetric key to wrap alg: the Key Management alg to use Returns: the wrapped symmetric key \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . public_jwk () . to_cryptography_key ()) ciphertext = wrapper . wrap_key ( plainkey ) return BinaPy ( ciphertext ) def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None , ) -> Jwk : \"\"\"Unwrap a symmetric key using this RSA key. Args: cipherkey: the wrapped symmetric key alg: the Key Management alg to use Returns: the clear-text unwrapped key \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . to_cryptography_key ()) plaintext = wrapper . unwrap_key ( cipherkey ) return SymmetricJwk . from_bytes ( plaintext )","title":"RSAJwk"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.from_cryptography_key","text":"Initialize a Jwk from a cryptography RSA key. Parameters: Name Type Description Default key Any a cryptography RSA key required Returns: Type Description RSAJwk a RSAJwk initialized with the given key Raises: Type Description TypeError if the given key type is not supported Source code in jwskate\\jwk\\rsa.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @classmethod def from_cryptography_key ( cls , key : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: key: a `cryptography` RSA key Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( key , rsa . RSAPrivateKey ): priv = key . private_numbers () # type: ignore[attr-defined] pub = key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( key , rsa . RSAPublicKey ): pub = key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.to_cryptography_key","text":"Initialize a cryptography key based on this Jwk. Returns: Type Description Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ] a cryptography RSAPrivateKey or RSAPublicKey Source code in jwskate\\jwk\\rsa.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key ()","title":"to_cryptography_key()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.public","text":"Initialize a public RsaJwk from a modulus and an exponent. Parameters: Name Type Description Default n int the modulus required e int the exponent required **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RsaJwk initialized from the provided parameters Source code in jwskate\\jwk\\rsa.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public RsaJwk from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . encode_to ( \"b64u\" ) . decode (), e = BinaPy . from_int ( e ) . encode_to ( \"b64u\" ) . decode (), ** params , ) )","title":"public()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.private","text":"Initializes a Private RsaJwk from its required parameters. Parameters: Name Type Description Default n int the modulus required e int the exponent required d int the private exponent required p Optional [ int ] the first prime factor None q Optional [ int ] the second prime factor None dp Optional [ int ] the first factor CRT exponent None dq Optional [ int ] the second factor CRT exponent None qi Optional [ int ] the first CRT coefficient None **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized from the given parameters Source code in jwskate\\jwk\\rsa.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initializes a Private RsaJwk from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . encode_to ( \"b64u\" ) . decode (), e = BinaPy . from_int ( e ) . encode_to ( \"b64u\" ) . decode (), d = BinaPy . from_int ( d ) . encode_to ( \"b64u\" ) . decode (), p = BinaPy . from_int ( p ) . encode_to ( \"b64u\" ) . decode () if p is not None else None , q = BinaPy . from_int ( q ) . encode_to ( \"b64u\" ) . decode () if q is not None else None , dp = BinaPy . from_int ( dp ) . encode_to ( \"b64u\" ) . decode () if dp is not None else None , dq = BinaPy . from_int ( dq ) . encode_to ( \"b64u\" ) . decode () if dq is not None else None , qi = BinaPy . from_int ( qi ) . encode_to ( \"b64u\" ) . decode () if qi is not None else None , ** params , ) )","title":"private()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.generate","text":"Generates a new random private RSAJwk. Parameters: Name Type Description Default key_size int the key size to use for the generated key. (Default value = 4096) 4096 **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a generated RSAJwk Source code in jwskate\\jwk\\rsa.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generates a new random private RSAJwk. Args: key_size: the key size to use for the generated key. (Default value = 4096) **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , )","title":"generate()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.modulus","text":"Returns the modulus from this Jwk. Returns: Type Description int the key modulus (from parameter n ) Source code in jwskate\\jwk\\rsa.py 233 234 235 236 237 238 239 240 @property def modulus ( self ) -> int : \"\"\"Returns the modulus from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int ()","title":"modulus()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.exponent","text":"Returns the exponent from this Jwk. Returns: Type Description int the key exponent (from parameter e ) Source code in jwskate\\jwk\\rsa.py 242 243 244 245 246 247 248 249 @property def exponent ( self ) -> int : \"\"\"Returns the exponent from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int ()","title":"exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.private_exponent","text":"Returns the private exponent from this Jwk. Returns: Type Description int the key private exponent (from parameter d ) Source code in jwskate\\jwk\\rsa.py 251 252 253 254 255 256 257 258 @property def private_exponent ( self ) -> int : \"\"\"Returns the private exponent from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int ()","title":"private_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_prime_factor","text":"Returns the first prime factor from this Jwk. Returns: Type Description int the first prime factor (from parameter p ) Source code in jwskate\\jwk\\rsa.py 260 261 262 263 264 265 266 267 @property def first_prime_factor ( self ) -> int : \"\"\"Returns the first prime factor from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int ()","title":"first_prime_factor()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.second_prime_factor","text":"Returns the second prime factor from this Jwk. Returns: Type Description int the second prime factor (from parameter q ) Source code in jwskate\\jwk\\rsa.py 269 270 271 272 273 274 275 276 @property def second_prime_factor ( self ) -> int : \"\"\"Returns the second prime factor from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int ()","title":"second_prime_factor()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_factor_crt_exponent","text":"Returns the first factor CRT exponent from this Jwk. Returns: Type Description int the first factor CRT coefficient (from parameter dp ) Source code in jwskate\\jwk\\rsa.py 278 279 280 281 282 283 284 285 @property def first_factor_crt_exponent ( self ) -> int : \"\"\"Returns the first factor CRT exponent from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int ()","title":"first_factor_crt_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.second_factor_crt_exponent","text":"Returns the second factor CRT exponent from this Jwk. Returns: Type Description int the second factor CRT coefficient (from parameter dq ) Source code in jwskate\\jwk\\rsa.py 287 288 289 290 291 292 293 294 @property def second_factor_crt_exponent ( self ) -> int : \"\"\"Returns the second factor CRT exponent from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int ()","title":"second_factor_crt_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_crt_coefficient","text":"Returns the first CRT coefficient from this Jwk. Returns: Type Description int the first CRT coefficient (from parameter qi ) Source code in jwskate\\jwk\\rsa.py 296 297 298 299 300 301 302 303 @property def first_crt_coefficient ( self ) -> int : \"\"\"Returns the first CRT coefficient from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int ()","title":"first_crt_coefficient()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.wrap_key","text":"Wrap a symmetric key using this RSA key. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required alg Optional [ str ] the Key Management alg to use None Returns: Type Description BinaPy the wrapped symmetric key Source code in jwskate\\jwk\\rsa.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def wrap_key ( self , plainkey : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key using this RSA key. Args: plainkey: the symmetric key to wrap alg: the Key Management alg to use Returns: the wrapped symmetric key \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . public_jwk () . to_cryptography_key ()) ciphertext = wrapper . wrap_key ( plainkey ) return BinaPy ( ciphertext )","title":"wrap_key()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.unwrap_key","text":"Unwrap a symmetric key using this RSA key. Parameters: Name Type Description Default cipherkey bytes the wrapped symmetric key required alg Optional [ str ] the Key Management alg to use None Returns: Type Description Jwk the clear-text unwrapped key Source code in jwskate\\jwk\\rsa.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None , ) -> Jwk : \"\"\"Unwrap a symmetric key using this RSA key. Args: cipherkey: the wrapped symmetric key alg: the Key Management alg to use Returns: the clear-text unwrapped key \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . to_cryptography_key ()) plaintext = wrapper . unwrap_key ( cipherkey ) return SymmetricJwk . from_bytes ( plaintext )","title":"unwrap_key()"},{"location":"api/#jwskate.jwk.symetric","text":"This module implements JWK representing Symmetric keys.","title":"symetric"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk","text":"Bases: Jwk Implement Symetric keys, with kty=oct . Source code in jwskate\\jwk\\symetric.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class SymmetricJwk ( Jwk ): \"\"\"Implement Symetric keys, with `kty=oct`.\"\"\" KTY = \"oct\" CRYPTOGRAPHY_KEY_CLASSES = ( bytes ,) PARAMS = { \"k\" : JwkParameter ( \"Key Value\" , is_private = True , is_required = True , kind = \"b64u\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ HS256 , HS384 , HS512 ]} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ A128KW , A192KW , A256KW , A128GCMKW , A192GCMKW , A256GCMKW , DirectKeyUse , ] } ENCRYPTION_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ Aes128CbcHmacSha256 , Aes192CbcHmacSha384 , Aes256CbcHmacSha512 , A128GCM , A192GCM , A256GCM , ] } def public_jwk ( self ) -> \"Jwk\" : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> \"SymmetricJwk\" : \"\"\"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . encode_to ( \"b64u\" ) . decode (), ** params )) @classmethod def generate ( cls , size : int = 128 , ** params : str ) -> \"SymmetricJwk\" : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: size: the size of the generated key, in bytes **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( size ) return cls . from_bytes ( key , ** params ) @classmethod def generate_for_alg ( cls , alg : str , ** params : str ) -> \"SymmetricJwk\" : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the signing algorithm to use this key with **params: additional members to include in the Jwk Returns: the resulting Jwk Raises: ValueError: if the provided `alg` is not supported \"\"\" if alg in cls . SIGNATURE_ALGORITHMS : sigalg = cls . SIGNATURE_ALGORITHMS [ alg ] return cls . generate ( sigalg . min_key_size , alg = alg , ** params ) if alg in cls . ENCRYPTION_ALGORITHMS : encalg = cls . ENCRYPTION_ALGORITHMS [ alg ] return cls . generate ( encalg . key_size , alg = alg , ** params ) raise ValueError ( \"Unsupported alg\" , alg ) def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . encode_to ( \"sha256\" ) . encode_to ( \"b64u\" ) . ascii () ) def to_cryptography_key ( self ) -> Any : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return self . key @property def key ( self ) -> bytes : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" ) @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 def encrypt ( self , plaintext : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data (`aad`). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) if iv is None : iv = encalg . generate_iv () wrapper = encalg ( self . key ) ciphertext , tag = wrapper . encrypt ( plaintext , iv , aad ) return ciphertext , tag , BinaPy ( iv ) def decrypt ( self , ciphertext : bytes , tag : bytes , iv : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data tag: the authentication tag iv: the Initialization Vector (must be the same as used during encryption) aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) decryptor = encalg ( self . key ) plaintext : bytes = decryptor . decrypt ( ciphertext , tag , iv , aad ) return BinaPy ( plaintext ) def wrap_key ( self , plainkey : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key. Args: plainkey: the symmetric key to wrap alg: the encryption alg to use Returns: the wrapped key Raises: UnsupportedAlg: if the provided alg is not supported \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . to_cryptography_key ()) if isinstance ( wrapper , BaseAesKeyWrap ): cipherkey = wrapper . wrap_key ( plainkey ) else : raise UnsupportedAlg ( keyalg ) return BinaPy ( cipherkey ) def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None ) -> Jwk : \"\"\"Unwrap a symmetric key. Args: cipherkey: the wrapped key alg: the decryption alg Returns: the clear-text symmetric key Raises: UnsupportedAlg: if the provided alg is not supported \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . key ) if isinstance ( wrapper , BaseAesKeyWrap ): plaintext = wrapper . unwrap_key ( cipherkey ) else : raise UnsupportedAlg ( keyalg ) return SymmetricJwk . from_bytes ( plaintext ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . key ) # type: ignore ] def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . key ) ]","title":"SymmetricJwk"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.public_jwk","text":"This always raises a ValueError since SymmetricKeys are always private. Raises: Type Description ValueError symmetric keys are always private, it makes no sense to use them as public keys Source code in jwskate\\jwk\\symetric.py 67 68 69 70 71 72 73 def public_jwk ( self ) -> \"Jwk\" : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" )","title":"public_jwk()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.from_bytes","text":"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the k parameter for the returned SymetricKey. Parameters: Name Type Description Default k Union [ bytes , str ] the key to use required **params Any additional members to include in the Jwk {} Returns: Type Description 'SymmetricJwk' the resulting SymmetricJwk Source code in jwskate\\jwk\\symetric.py 75 76 77 78 79 80 81 82 83 84 85 86 @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> \"SymmetricJwk\" : \"\"\"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . encode_to ( \"b64u\" ) . decode (), ** params ))","title":"from_bytes()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.generate","text":"Generate a random SymmetricJwk, with a given key size. Parameters: Name Type Description Default size int the size of the generated key, in bytes 128 **params str additional members to include in the Jwk {} Returns: Type Description 'SymmetricJwk' a SymmetricJwk with a randomly generated key Source code in jwskate\\jwk\\symetric.py 88 89 90 91 92 93 94 95 96 97 98 99 100 @classmethod def generate ( cls , size : int = 128 , ** params : str ) -> \"SymmetricJwk\" : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: size: the size of the generated key, in bytes **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( size ) return cls . from_bytes ( key , ** params )","title":"generate()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.generate_for_alg","text":"Generate a SymmetricJwk that is suitable for use with the given alg. Parameters: Name Type Description Default alg str the signing algorithm to use this key with required **params str additional members to include in the Jwk {} Returns: Type Description 'SymmetricJwk' the resulting Jwk Raises: Type Description ValueError if the provided alg is not supported Source code in jwskate\\jwk\\symetric.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @classmethod def generate_for_alg ( cls , alg : str , ** params : str ) -> \"SymmetricJwk\" : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the signing algorithm to use this key with **params: additional members to include in the Jwk Returns: the resulting Jwk Raises: ValueError: if the provided `alg` is not supported \"\"\" if alg in cls . SIGNATURE_ALGORITHMS : sigalg = cls . SIGNATURE_ALGORITHMS [ alg ] return cls . generate ( sigalg . min_key_size , alg = alg , ** params ) if alg in cls . ENCRYPTION_ALGORITHMS : encalg = cls . ENCRYPTION_ALGORITHMS [ alg ] return cls . generate ( encalg . key_size , alg = alg , ** params ) raise ValueError ( \"Unsupported alg\" , alg )","title":"generate_for_alg()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.thumbprint","text":"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Returns: Type Description str the calculated thumbprint Source code in jwskate\\jwk\\symetric.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . encode_to ( \"sha256\" ) . encode_to ( \"b64u\" ) . ascii () )","title":"thumbprint()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.to_cryptography_key","text":"Converts this Jwk into a key usable with cryptography . For SymmetricJwk instances, those are just bytes values. Returns: Type Description Any the raw private key, as bytes Source code in jwskate\\jwk\\symetric.py 142 143 144 145 146 147 148 149 150 def to_cryptography_key ( self ) -> Any : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return self . key","title":"to_cryptography_key()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.key","text":"Returns the raw symmetric key. Returns: Type Description bytes the key from the k parameter, base64u-decoded Source code in jwskate\\jwk\\symetric.py 152 153 154 155 156 157 158 159 @property def key ( self ) -> bytes : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" )","title":"key()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.key_size","text":"The key size, in bits. Returns: Type Description int the key size in bits Source code in jwskate\\jwk\\symetric.py 161 162 163 164 165 166 167 168 @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8","title":"key_size()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.encrypt","text":"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data ( aad ). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the iv parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Parameters: Name Type Description Default plaintext bytes the plaintext to encrypt required aad Optional [ bytes ] the Additional Authentication Data, if any None alg Optional [ str ] the encryption alg to use None iv Optional [ bytes ] the IV to use, if you want a specific value None Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (ciphertext, authentication_tag, iv) tuple Source code in jwskate\\jwk\\symetric.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def encrypt ( self , plaintext : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data (`aad`). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) if iv is None : iv = encalg . generate_iv () wrapper = encalg ( self . key ) ciphertext , tag = wrapper . encrypt ( plaintext , iv , aad ) return ciphertext , tag , BinaPy ( iv )","title":"encrypt()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.decrypt","text":"Decrypt arbitrary data. Parameters: Name Type Description Default ciphertext bytes the encrypted data required tag bytes the authentication tag required iv bytes the Initialization Vector (must be the same as used during encryption) required aad Optional [ bytes ] the Additional Authenticated Data (must be the same as used during encryption) None alg Optional [ str ] the decryption alg (must be the same as used during encryption) None Returns: Type Description BinaPy the decrypted clear-text Source code in jwskate\\jwk\\symetric.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def decrypt ( self , ciphertext : bytes , tag : bytes , iv : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data tag: the authentication tag iv: the Initialization Vector (must be the same as used during encryption) aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) decryptor = encalg ( self . key ) plaintext : bytes = decryptor . decrypt ( ciphertext , tag , iv , aad ) return BinaPy ( plaintext )","title":"decrypt()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.wrap_key","text":"Wrap a symmetric key. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required alg Optional [ str ] the encryption alg to use None Returns: Type Description BinaPy the wrapped key Raises: Type Description UnsupportedAlg if the provided alg is not supported Source code in jwskate\\jwk\\symetric.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def wrap_key ( self , plainkey : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Wrap a symmetric key. Args: plainkey: the symmetric key to wrap alg: the encryption alg to use Returns: the wrapped key Raises: UnsupportedAlg: if the provided alg is not supported \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . to_cryptography_key ()) if isinstance ( wrapper , BaseAesKeyWrap ): cipherkey = wrapper . wrap_key ( plainkey ) else : raise UnsupportedAlg ( keyalg ) return BinaPy ( cipherkey )","title":"wrap_key()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.unwrap_key","text":"Unwrap a symmetric key. Parameters: Name Type Description Default cipherkey bytes the wrapped key required alg Optional [ str ] the decryption alg None Returns: Type Description Jwk the clear-text symmetric key Raises: Type Description UnsupportedAlg if the provided alg is not supported Source code in jwskate\\jwk\\symetric.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def unwrap_key ( self , cipherkey : bytes , alg : Optional [ str ] = None ) -> Jwk : \"\"\"Unwrap a symmetric key. Args: cipherkey: the wrapped key alg: the decryption alg Returns: the clear-text symmetric key Raises: UnsupportedAlg: if the provided alg is not supported \"\"\" keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) wrapper = keyalg ( self . key ) if isinstance ( wrapper , BaseAesKeyWrap ): plaintext = wrapper . unwrap_key ( cipherkey ) else : raise UnsupportedAlg ( keyalg ) return SymmetricJwk . from_bytes ( plaintext )","title":"unwrap_key()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.supported_key_management_algorithms","text":"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\symetric.py 265 266 267 268 269 270 271 272 273 274 275 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . key ) # type: ignore ]","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.symetric.SymmetricJwk.supported_encryption_algorithms","text":"Return the list of supported Encryption/Decryption algorithms with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate\\jwk\\symetric.py 277 278 279 280 281 282 283 284 285 286 287 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . key ) ]","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jws","text":"This module implements JWS token handling.","title":"jws"},{"location":"api/#jwskate.jws.compact","text":"This module implements the JWS Compact format.","title":"compact"},{"location":"api/#jwskate.jws.compact.InvalidJws","text":"Bases: ValueError Raised when an invalid Jws is parsed. Source code in jwskate\\jws\\compact.py 18 19 class InvalidJws ( ValueError ): \"\"\"Raised when an invalid Jws is parsed.\"\"\"","title":"InvalidJws"},{"location":"api/#jwskate.jws.compact.JwsCompact","text":"Bases: BaseCompactToken Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Source code in jwskate\\jws\\compact.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class JwsCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515.\"\"\" def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize a Jws, from its compact representation. Args: value: the JWS token value \"\"\" super () . __init__ ( value ) header , payload , signature = self . split ( self . value ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJws ( \"Invalid JWS header: it must be a Base64URL-encoded JSON object\" ) try : self . payload = BinaPy ( payload ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def split ( cls , value : bytes ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Splits a JWS token value into its (header, payload, signature) parts. Args: value: the JWS token value Returns: a (header, payload, signature) Raises: InvalidJws: if the provided value doesn't have 2 dots. \"\"\" if value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = value . split ( b \".\" ) return BinaPy ( header ), BinaPy ( payload ), BinaPy ( signature ) @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"JwsCompact\" : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) @classmethod def from_parts ( cls , signed_part : Union [ bytes , str ], signature : Union [ bytes , str ] ) -> \"JwsCompact\" : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if not isinstance ( signed_part , bytes ): signed_part = signed_part . encode ( \"ascii\" ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . encode_to ( \"b64u\" )))) @property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) @property def alg ( self ) -> str : \"\"\"Get the signature algorithm (alg) from this token headers. Returns: the `alg` value Raises: AttributeError: if the `alg` header value is not a string \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or not isinstance ( alg , str ): raise AttributeError ( \"This JWS doesn't have a valid 'alg' header\" ) return alg def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg , algs ) def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . split ( self . value ) content = { \"payload\" : payload . ascii (), \"protected\" : protected . ascii (), \"signature\" : signature . ascii (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize ()","title":"JwsCompact"},{"location":"api/#jwskate.jws.compact.JwsCompact.__init__","text":"Initialize a Jws, from its compact representation. Parameters: Name Type Description Default value Union [ bytes , str ] the JWS token value required Source code in jwskate\\jws\\compact.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize a Jws, from its compact representation. Args: value: the JWS token value \"\"\" super () . __init__ ( value ) header , payload , signature = self . split ( self . value ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJws ( \"Invalid JWS header: it must be a Base64URL-encoded JSON object\" ) try : self . payload = BinaPy ( payload ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\" )","title":"__init__()"},{"location":"api/#jwskate.jws.compact.JwsCompact.split","text":"Splits a JWS token value into its (header, payload, signature) parts. Parameters: Name Type Description Default value bytes the JWS token value required Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (header, payload, signature) Raises: Type Description InvalidJws if the provided value doesn't have 2 dots. Source code in jwskate\\jws\\compact.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @classmethod def split ( cls , value : bytes ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Splits a JWS token value into its (header, payload, signature) parts. Args: value: the JWS token value Returns: a (header, payload, signature) Raises: InvalidJws: if the provided value doesn't have 2 dots. \"\"\" if value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = value . split ( b \".\" ) return BinaPy ( header ), BinaPy ( payload ), BinaPy ( signature )","title":"split()"},{"location":"api/#jwskate.jws.compact.JwsCompact.sign","text":"Sign a payload and returns the resulting JwsCompact. Parameters: Name Type Description Default payload bytes the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the jwk to use to sign this payload required alg Optional [ str ] the alg to use None extra_headers Optional [ Dict [ str , Any ]] additional headers to add to the Jws Headers None Returns: Type Description 'JwsCompact' the resulting token Source code in jwskate\\jws\\compact.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"JwsCompact\" : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature )","title":"sign()"},{"location":"api/#jwskate.jws.compact.JwsCompact.from_parts","text":"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Parameters: Name Type Description Default signed_part Union [ bytes , str ] the signed part required signature Union [ bytes , str ] the signature value required Returns: Type Description 'JwsCompact' the resulting token Source code in jwskate\\jws\\compact.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @classmethod def from_parts ( cls , signed_part : Union [ bytes , str ], signature : Union [ bytes , str ] ) -> \"JwsCompact\" : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if not isinstance ( signed_part , bytes ): signed_part = signed_part . encode ( \"ascii\" ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . encode_to ( \"b64u\" ))))","title":"from_parts()"},{"location":"api/#jwskate.jws.compact.JwsCompact.signed_part","text":"Returns the signed part (header + payload) from this JwsCompact. Returns: Type Description bytes the signed part Source code in jwskate\\jws\\compact.py 127 128 129 130 131 132 133 134 @property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ])","title":"signed_part()"},{"location":"api/#jwskate.jws.compact.JwsCompact.alg","text":"Get the signature algorithm (alg) from this token headers. Returns: Type Description str the alg value Raises: Type Description AttributeError if the alg header value is not a string Source code in jwskate\\jws\\compact.py 136 137 138 139 140 141 142 143 144 145 146 147 148 @property def alg ( self ) -> str : \"\"\"Get the signature algorithm (alg) from this token headers. Returns: the `alg` value Raises: AttributeError: if the `alg` header value is not a string \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or not isinstance ( alg , str ): raise AttributeError ( \"This JWS doesn't have a valid 'alg' header\" ) return alg","title":"alg()"},{"location":"api/#jwskate.jws.compact.JwsCompact.verify_signature","text":"Verify the signature from this JwsCompact using a Jwk. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use to validate this signature required alg Optional [ str ] the alg to use, if there is only 1 allowed None algs Optional [ Iterable [ str ]] the allowed algs, if here are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate\\jws\\compact.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg , algs )","title":"verify_signature()"},{"location":"api/#jwskate.jws.compact.JwsCompact.flat_json","text":"Create a JWS in JSON flat format based on this Compact JWS. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonFlat the resulting token Source code in jwskate\\jws\\compact.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . split ( self . value ) content = { \"payload\" : payload . ascii (), \"protected\" : protected . ascii (), \"signature\" : signature . ascii (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content )","title":"flat_json()"},{"location":"api/#jwskate.jws.compact.JwsCompact.general_json","text":"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonGeneral the resulting token Source code in jwskate\\jws\\compact.py 190 191 192 193 194 195 196 197 198 199 200 201 202 def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize ()","title":"general_json()"},{"location":"api/#jwskate.jws.json","text":"This module implement the JWS JSON flat and general formats.","title":"json"},{"location":"api/#jwskate.jws.json.JwsJsonFlat","text":"Bases: JwsSignature Represent a JWS with a single signature in JSON flat format. Source code in jwskate\\jws\\json.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class JwsJsonFlat ( JwsSignature ): \"\"\"Represent a JWS with a single signature in JSON flat format.\"\"\" @property def payload ( self ) -> bytes : \"\"\"The JWS payload, decoded. Returns: The raw JWS payload. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) @property def jws_signature ( self ) -> JwsSignature : \"\"\"The JWS signature. Returns: The JWS signature. \"\"\" content = { \"protected\" : self [ \"protected\" ], \"signature\" : self [ \"signature\" ], } header = self . get ( \"header\" ) if header : content [ \"header\" ] = self . header return JwsSignature ( content ) @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> JwsJsonFlat : \"\"\"Signs a payload into a JWS in JSON flat format. Args: payload: the data to sign. jwk: the key to use alg: the signature alg to use extra_protected_headers: additional protected headers to include header: the unprotected header to include **kwargs: extra attributes to include in the JWS Returns: The JWS with the payload, signature, header and extra claims. \"\"\" signature = super () . sign ( payload , jwk , alg , extra_protected_headers , header , ** kwargs ) signature [ \"payload\" ] = BinaPy ( payload ) . encode_to ( \"b64u\" ) . ascii () return cls ( signature ) def generalize ( self ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON general format from this JWS in JSON flat. Returns: A JwsJsonGeneral with the same payload and signature. \"\"\" content = self . copy () protected = content . pop ( \"protected\" ) header = content . pop ( \"header\" , None ) signature = content . pop ( \"signature\" ) jws_signature = { \"protected\" : protected , \"signature\" : signature } if header is not None : jws_signature [ \"header\" ] = header content [ \"signatures\" ] = [ jws_signature ] return JwsJsonGeneral ( content ) def signed_part ( self ) -> bytes : \"\"\"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot (`.`). Returns: The signed data part. \"\"\" return JwsSignature . assemble_signed_part ( self . protected , self . payload ) def compact ( self ) -> JwsCompact : \"\"\"Create a JWS in compact format from this JWS JSON. Returns: A `JwsCompact` with the same payload and signature. \"\"\" return JwsCompact . from_parts ( self . signed_part (), self . signature ) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWS signature with a given key. Args: jwk: the key to use to validate this signature. alg: the signature alg, if only 1 is allowed. algs: the allowed signature algs, if there are several. Returns: `True` if the signature is verified, `False` otherwise. \"\"\" return self . jws_signature . verify ( self . payload , jwk , alg , algs )","title":"JwsJsonFlat"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.payload","text":"The JWS payload, decoded. Returns: Type Description bytes The raw JWS payload. Source code in jwskate\\jws\\json.py 18 19 20 21 22 23 24 25 26 27 28 @property def payload ( self ) -> bytes : \"\"\"The JWS payload, decoded. Returns: The raw JWS payload. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" )","title":"payload()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.jws_signature","text":"The JWS signature. Returns: Type Description JwsSignature The JWS signature. Source code in jwskate\\jws\\json.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @property def jws_signature ( self ) -> JwsSignature : \"\"\"The JWS signature. Returns: The JWS signature. \"\"\" content = { \"protected\" : self [ \"protected\" ], \"signature\" : self [ \"signature\" ], } header = self . get ( \"header\" ) if header : content [ \"header\" ] = self . header return JwsSignature ( content )","title":"jws_signature()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.sign","text":"Signs a payload into a JWS in JSON flat format. Parameters: Name Type Description Default payload bytes the data to sign. required jwk Union [ Jwk , Dict [ str , Any ]] the key to use required alg Optional [ str ] the signature alg to use None extra_protected_headers Optional [ Mapping [ str , Any ]] additional protected headers to include None header Optional [ Any ] the unprotected header to include None **kwargs Any extra attributes to include in the JWS {} Returns: Type Description JwsJsonFlat The JWS with the payload, signature, header and extra claims. Source code in jwskate\\jws\\json.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> JwsJsonFlat : \"\"\"Signs a payload into a JWS in JSON flat format. Args: payload: the data to sign. jwk: the key to use alg: the signature alg to use extra_protected_headers: additional protected headers to include header: the unprotected header to include **kwargs: extra attributes to include in the JWS Returns: The JWS with the payload, signature, header and extra claims. \"\"\" signature = super () . sign ( payload , jwk , alg , extra_protected_headers , header , ** kwargs ) signature [ \"payload\" ] = BinaPy ( payload ) . encode_to ( \"b64u\" ) . ascii () return cls ( signature )","title":"sign()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.generalize","text":"Create a JWS in JSON general format from this JWS in JSON flat. Returns: Type Description JwsJsonGeneral A JwsJsonGeneral with the same payload and signature. Source code in jwskate\\jws\\json.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def generalize ( self ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON general format from this JWS in JSON flat. Returns: A JwsJsonGeneral with the same payload and signature. \"\"\" content = self . copy () protected = content . pop ( \"protected\" ) header = content . pop ( \"header\" , None ) signature = content . pop ( \"signature\" ) jws_signature = { \"protected\" : protected , \"signature\" : signature } if header is not None : jws_signature [ \"header\" ] = header content [ \"signatures\" ] = [ jws_signature ] return JwsJsonGeneral ( content )","title":"generalize()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.signed_part","text":"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot ( . ). Returns: Type Description bytes The signed data part. Source code in jwskate\\jws\\json.py 91 92 93 94 95 96 97 98 99 def signed_part ( self ) -> bytes : \"\"\"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot (`.`). Returns: The signed data part. \"\"\" return JwsSignature . assemble_signed_part ( self . protected , self . payload )","title":"signed_part()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.compact","text":"Create a JWS in compact format from this JWS JSON. Returns: Type Description JwsCompact A JwsCompact with the same payload and signature. Source code in jwskate\\jws\\json.py 101 102 103 104 105 106 107 def compact ( self ) -> JwsCompact : \"\"\"Create a JWS in compact format from this JWS JSON. Returns: A `JwsCompact` with the same payload and signature. \"\"\" return JwsCompact . from_parts ( self . signed_part (), self . signature )","title":"compact()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.verify_signature","text":"Verify this JWS signature with a given key. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the key to use to validate this signature. required alg Optional [ str ] the signature alg, if only 1 is allowed. None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several. None Returns: Type Description bool True if the signature is verified, False otherwise. Source code in jwskate\\jws\\json.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWS signature with a given key. Args: jwk: the key to use to validate this signature. alg: the signature alg, if only 1 is allowed. algs: the allowed signature algs, if there are several. Returns: `True` if the signature is verified, `False` otherwise. \"\"\" return self . jws_signature . verify ( self . payload , jwk , alg , algs )","title":"verify_signature()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral","text":"Bases: BaseJsonDict Represents a JWS in JSON general format (possibly with multiple signatures). Source code in jwskate\\jws\\json.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 class JwsJsonGeneral ( BaseJsonDict ): \"\"\"Represents a JWS in JSON general format (possibly with multiple signatures).\"\"\" @property def payload ( self ) -> bytes : \"\"\"The raw signed data. Returns: The signed data. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) @classmethod def sign ( cls , payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , ], Union [ Jwk , Mapping [ str , Any ]], ], ) -> JwsJsonGeneral : \"\"\"Sign a payload with several keys and return the resulting JWS JSON in general format. Args: payload: the data to sign *signature_parameters: each of those parameter can be: - a `(jwk, alg, extra_protected_headers, header)` tuple - a `(jwk, alg, extra_protected_headers)` tuple, - a `(jwk, alg)` tuple, - a `jwk` with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. Returns: A JwsJsonGeneral with the generated signatures. \"\"\" jws = cls ({ \"payload\" : BinaPy ( payload ) . encode_to ( \"b64u\" ) . ascii ()}) for parameters in signature_parameters : jws . add_signature ( * parameters ) return jws @property def signatures ( self ) -> List [ JwsSignature ]: \"\"\"The list of `JwsSignature` from this JWS. Returns: The list of signatures from this JWS. \"\"\" signatures = self . get ( \"signatures\" ) if signatures is None : raise AttributeError ( \"This Jws JSON does not contain a 'signatures' member\" ) return [ JwsSignature ( sig ) for sig in signatures ] def add_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral : \"\"\"Add a new signature in this JWS. Args: jwk: the private key to use alg: the signature algorithm extra_protected_headers: additional headers to include, as a {key: value} mapping header: the raw unprotected header to include in the signature Returns: the same JWS with the new signature included. \"\"\" self . setdefault ( \"signatures\" , []) self [ \"signatures\" ] . append ( JwsSignature . sign ( self . payload , jwk , alg , extra_protected_headers , header ) ) return self def signed_part ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> bytes : \"\"\"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (`.`). You can select the specific signature with the `signature_chooser` parameter. By default, the first signature is selected. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: The raw signed part from the chosen signature. \"\"\" signature = signature_chooser ( self . signatures ) return JwsSignature . assemble_signed_part ( signature . protected , self . payload ) def compact ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsCompact : \"\"\"Create a compact JWS from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsCompact with the payload and the chosen signature from this JWS. \"\"\" return JwsCompact . from_parts ( self . signed_part ( signature_chooser ), self . payload ) def flatten ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsJsonFlat with the payload and the chosen signature from this JWS. \"\"\" signature = signature_chooser ( self . signatures ) return JwsJsonFlat . from_parts ( payload = self [ \"payload\" ], protected = signature . protected , header = signature . header , signature = signature . signature , ) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns `True` if at least one signature verifies. Args: jwk: the public key to use alg: the signature algorithm to use, if only 1 is allowed. algs: the allowed signature algorithms, if there are several. Returns: `True` if any of the signature verifies with the given key, `False` otherwise. \"\"\" for signature in self . signatures : if signature . verify ( self . payload , jwk , alg , algs ): return True return False","title":"JwsJsonGeneral"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.payload","text":"The raw signed data. Returns: Type Description bytes The signed data. Source code in jwskate\\jws\\json.py 131 132 133 134 135 136 137 138 139 140 141 @property def payload ( self ) -> bytes : \"\"\"The raw signed data. Returns: The signed data. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" )","title":"payload()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.sign","text":"Sign a payload with several keys and return the resulting JWS JSON in general format. Parameters: Name Type Description Default payload bytes the data to sign required *signature_parameters Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]]], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]]], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str ], Union [ Jwk , Mapping [ str , Any ]]] each of those parameter can be: - a (jwk, alg, extra_protected_headers, header) tuple - a (jwk, alg, extra_protected_headers) tuple, - a (jwk, alg) tuple, - a jwk with jwk being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. () Returns: Type Description JwsJsonGeneral A JwsJsonGeneral with the generated signatures. Source code in jwskate\\jws\\json.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @classmethod def sign ( cls , payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , ], Union [ Jwk , Mapping [ str , Any ]], ], ) -> JwsJsonGeneral : \"\"\"Sign a payload with several keys and return the resulting JWS JSON in general format. Args: payload: the data to sign *signature_parameters: each of those parameter can be: - a `(jwk, alg, extra_protected_headers, header)` tuple - a `(jwk, alg, extra_protected_headers)` tuple, - a `(jwk, alg)` tuple, - a `jwk` with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. Returns: A JwsJsonGeneral with the generated signatures. \"\"\" jws = cls ({ \"payload\" : BinaPy ( payload ) . encode_to ( \"b64u\" ) . ascii ()}) for parameters in signature_parameters : jws . add_signature ( * parameters ) return jws","title":"sign()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.signatures","text":"The list of JwsSignature from this JWS. Returns: Type Description List [ JwsSignature ] The list of signatures from this JWS. Source code in jwskate\\jws\\json.py 185 186 187 188 189 190 191 192 193 194 195 @property def signatures ( self ) -> List [ JwsSignature ]: \"\"\"The list of `JwsSignature` from this JWS. Returns: The list of signatures from this JWS. \"\"\" signatures = self . get ( \"signatures\" ) if signatures is None : raise AttributeError ( \"This Jws JSON does not contain a 'signatures' member\" ) return [ JwsSignature ( sig ) for sig in signatures ]","title":"signatures()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.add_signature","text":"Add a new signature in this JWS. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private key to use required alg Optional [ str ] the signature algorithm None extra_protected_headers Optional [ Mapping [ str , Any ]] additional headers to include, as a {key: value} mapping None header Optional [ Mapping [ str , Any ]] the raw unprotected header to include in the signature None Returns: Type Description JwsJsonGeneral the same JWS with the new signature included. Source code in jwskate\\jws\\json.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def add_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral : \"\"\"Add a new signature in this JWS. Args: jwk: the private key to use alg: the signature algorithm extra_protected_headers: additional headers to include, as a {key: value} mapping header: the raw unprotected header to include in the signature Returns: the same JWS with the new signature included. \"\"\" self . setdefault ( \"signatures\" , []) self [ \"signatures\" ] . append ( JwsSignature . sign ( self . payload , jwk , alg , extra_protected_headers , header ) ) return self","title":"add_signature()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.signed_part","text":"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot ( . ). You can select the specific signature with the signature_chooser parameter. By default, the first signature is selected. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description bytes The raw signed part from the chosen signature. Source code in jwskate\\jws\\json.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def signed_part ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> bytes : \"\"\"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (`.`). You can select the specific signature with the `signature_chooser` parameter. By default, the first signature is selected. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: The raw signed part from the chosen signature. \"\"\" signature = signature_chooser ( self . signatures ) return JwsSignature . assemble_signed_part ( signature . protected , self . payload )","title":"signed_part()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.compact","text":"Create a compact JWS from a specific signature from this JWS. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description JwsCompact A JwsCompact with the payload and the chosen signature from this JWS. Source code in jwskate\\jws\\json.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def compact ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsCompact : \"\"\"Create a compact JWS from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsCompact with the payload and the chosen signature from this JWS. \"\"\" return JwsCompact . from_parts ( self . signed_part ( signature_chooser ), self . payload )","title":"compact()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.flatten","text":"Create a JWS in JSON flat format from a specific signature from this JWS. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description JwsJsonFlat A JwsJsonFlat with the payload and the chosen signature from this JWS. Source code in jwskate\\jws\\json.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def flatten ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsJsonFlat with the payload and the chosen signature from this JWS. \"\"\" signature = signature_chooser ( self . signatures ) return JwsJsonFlat . from_parts ( payload = self [ \"payload\" ], protected = signature . protected , header = signature . header , signature = signature . signature , )","title":"flatten()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.verify_signature","text":"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns True if at least one signature verifies. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the public key to use required alg Optional [ str ] the signature algorithm to use, if only 1 is allowed. None algs Optional [ Iterable [ str ]] the allowed signature algorithms, if there are several. None Returns: Type Description bool True if any of the signature verifies with the given key, False otherwise. Source code in jwskate\\jws\\json.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns `True` if at least one signature verifies. Args: jwk: the public key to use alg: the signature algorithm to use, if only 1 is allowed. algs: the allowed signature algorithms, if there are several. Returns: `True` if any of the signature verifies with the given key, `False` otherwise. \"\"\" for signature in self . signatures : if signature . verify ( self . payload , jwk , alg , algs ): return True return False","title":"verify_signature()"},{"location":"api/#jwskate.jws.signature","text":"This module implement JWS signatures.","title":"signature"},{"location":"api/#jwskate.jws.signature.JwsSignature","text":"Bases: BaseJsonDict Represents a JWS Signature. A JWS Signature has a protected header (as a JSON object) a signature value (as raw data) an unprotected header (as arbitrary JSON data) optional extra JSON attributes Source code in jwskate\\jws\\signature.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class JwsSignature ( BaseJsonDict ): \"\"\"Represents a JWS Signature. A JWS Signature has - a protected header (as a JSON object) - a signature value (as raw data) - an unprotected header (as arbitrary JSON data) - optional extra JSON attributes \"\"\" @classmethod def from_parts ( cls : Type [ S ], protected : Mapping [ str , Any ], signature : bytes , header : Optional [ Any ], ** kwargs : Any , ) -> S : \"\"\"Initialize a JwsSignature based on the provided parts. Args: protected: the protected headers, as a key: value mapping signature: the raw signature value header: the unprotected header, if any **kwargs: extra attributes, if any Returns: A `JwsSignature` based on the provided parts. \"\"\" content = dict ( kwargs , protected = BinaPy . serialize_to ( \"json\" , protected ) . encode_to ( \"b64u\" ) . ascii (), signature = BinaPy ( signature ) . encode_to ( \"b64u\" ) . ascii (), ) if header is not None : content [ \"header\" ] = header return cls ( content ) @property def protected ( self ) -> Dict [ str , Any ]: \"\"\"The protected header. Returns: the protected headers, as a `dict`. Raises: AttributeError: if this signature doesn't have protected headers. \"\"\" protected = self . get ( \"protected\" ) if protected is None : raise AttributeError ( \"This Jws JSON does not contain a 'protected' member\" ) return BinaPy ( protected ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) # type: ignore @property def header ( self ) -> Any : \"\"\"The unprotected header, unaltered. Returns: The unprotected header \"\"\" return self . get ( \"header\" ) @property def signature ( self ) -> bytes : \"\"\"The raw signature. Returns: The raw signed data, unencoded Raises: AttributeError: if no 'signature' member is present \"\"\" signature = self . get ( \"signature\" ) if signature is None : raise AttributeError ( \"This Jws JSON does not contain a 'signature' member\" ) return BinaPy ( signature ) . decode_from ( \"b64u\" ) @classmethod def sign ( cls : Type [ S ], payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> S : \"\"\"Sign a payload and return the generated JWS signature. Args: payload: the raw data to sign jwk: the signature key to use alg: the signature algorithm to use extra_protected_headers: additional protected headers to include, if any header: the unprotected header, if any. **kwargs: additional members to include in this signature Returns: The generated signature. \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_protected_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( protected = headers , signature = signature , header = header , ** kwargs ) @classmethod def assemble_signed_part ( cls , headers : Dict [ str , Any ], payload : Union [ bytes , str ] ) -> bytes : \"\"\"Assemble the protected header and payload to sign, as specified in. [RFC7515 $5.1](https://datatracker.ietf.org/doc/html/rfc7515#section-5.1). Args: headers: the protected headers payload: the raw payload to sign Returns: the raw data to sign \"\"\" return b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ), BinaPy ( payload ) . encode_to ( \"b64u\" ), ) ) def verify ( self , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this signature against the given payload using the provided key. Args: payload: the raw payload jwk: the validation key to use alg: the signature alg t if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the signature is verifier, `False` otherwise \"\"\" jwk = Jwk ( jwk ) signed_part = self . assemble_signed_part ( self . protected , payload ) return jwk . verify ( signed_part , self . signature , alg , algs )","title":"JwsSignature"},{"location":"api/#jwskate.jws.signature.JwsSignature.from_parts","text":"Initialize a JwsSignature based on the provided parts. Parameters: Name Type Description Default protected Mapping [ str , Any ] the protected headers, as a key: value mapping required signature bytes the raw signature value required header Optional [ Any ] the unprotected header, if any required **kwargs Any extra attributes, if any {} Returns: Type Description S A JwsSignature based on the provided parts. Source code in jwskate\\jws\\signature.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @classmethod def from_parts ( cls : Type [ S ], protected : Mapping [ str , Any ], signature : bytes , header : Optional [ Any ], ** kwargs : Any , ) -> S : \"\"\"Initialize a JwsSignature based on the provided parts. Args: protected: the protected headers, as a key: value mapping signature: the raw signature value header: the unprotected header, if any **kwargs: extra attributes, if any Returns: A `JwsSignature` based on the provided parts. \"\"\" content = dict ( kwargs , protected = BinaPy . serialize_to ( \"json\" , protected ) . encode_to ( \"b64u\" ) . ascii (), signature = BinaPy ( signature ) . encode_to ( \"b64u\" ) . ascii (), ) if header is not None : content [ \"header\" ] = header return cls ( content )","title":"from_parts()"},{"location":"api/#jwskate.jws.signature.JwsSignature.protected","text":"The protected header. Returns: Type Description Dict [ str , Any ] the protected headers, as a dict . Raises: Type Description AttributeError if this signature doesn't have protected headers. Source code in jwskate\\jws\\signature.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @property def protected ( self ) -> Dict [ str , Any ]: \"\"\"The protected header. Returns: the protected headers, as a `dict`. Raises: AttributeError: if this signature doesn't have protected headers. \"\"\" protected = self . get ( \"protected\" ) if protected is None : raise AttributeError ( \"This Jws JSON does not contain a 'protected' member\" ) return BinaPy ( protected ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) # type: ignore","title":"protected()"},{"location":"api/#jwskate.jws.signature.JwsSignature.header","text":"The unprotected header, unaltered. Returns: Type Description Any The unprotected header Source code in jwskate\\jws\\signature.py 68 69 70 71 72 73 74 75 @property def header ( self ) -> Any : \"\"\"The unprotected header, unaltered. Returns: The unprotected header \"\"\" return self . get ( \"header\" )","title":"header()"},{"location":"api/#jwskate.jws.signature.JwsSignature.signature","text":"The raw signature. Returns: Type Description bytes The raw signed data, unencoded Raises: Type Description AttributeError if no 'signature' member is present Source code in jwskate\\jws\\signature.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @property def signature ( self ) -> bytes : \"\"\"The raw signature. Returns: The raw signed data, unencoded Raises: AttributeError: if no 'signature' member is present \"\"\" signature = self . get ( \"signature\" ) if signature is None : raise AttributeError ( \"This Jws JSON does not contain a 'signature' member\" ) return BinaPy ( signature ) . decode_from ( \"b64u\" )","title":"signature()"},{"location":"api/#jwskate.jws.signature.JwsSignature.sign","text":"Sign a payload and return the generated JWS signature. Parameters: Name Type Description Default payload bytes the raw data to sign required jwk Union [ Jwk , Dict [ str , Any ]] the signature key to use required alg Optional [ str ] the signature algorithm to use None extra_protected_headers Optional [ Mapping [ str , Any ]] additional protected headers to include, if any None header Optional [ Any ] the unprotected header, if any. None **kwargs Any additional members to include in this signature {} Returns: Type Description S The generated signature. Source code in jwskate\\jws\\signature.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 @classmethod def sign ( cls : Type [ S ], payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> S : \"\"\"Sign a payload and return the generated JWS signature. Args: payload: the raw data to sign jwk: the signature key to use alg: the signature algorithm to use extra_protected_headers: additional protected headers to include, if any header: the unprotected header, if any. **kwargs: additional members to include in this signature Returns: The generated signature. \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_protected_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( protected = headers , signature = signature , header = header , ** kwargs )","title":"sign()"},{"location":"api/#jwskate.jws.signature.JwsSignature.assemble_signed_part","text":"Assemble the protected header and payload to sign, as specified in. RFC7515 $5.1 . Parameters: Name Type Description Default headers Dict [ str , Any ] the protected headers required payload Union [ bytes , str ] the raw payload to sign required Returns: Type Description bytes the raw data to sign Source code in jwskate\\jws\\signature.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @classmethod def assemble_signed_part ( cls , headers : Dict [ str , Any ], payload : Union [ bytes , str ] ) -> bytes : \"\"\"Assemble the protected header and payload to sign, as specified in. [RFC7515 $5.1](https://datatracker.ietf.org/doc/html/rfc7515#section-5.1). Args: headers: the protected headers payload: the raw payload to sign Returns: the raw data to sign \"\"\" return b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ), BinaPy ( payload ) . encode_to ( \"b64u\" ), ) )","title":"assemble_signed_part()"},{"location":"api/#jwskate.jws.signature.JwsSignature.verify","text":"Verify this signature against the given payload using the provided key. Parameters: Name Type Description Default payload bytes the raw payload required jwk Union [ Jwk , Dict [ str , Any ]] the validation key to use required alg Optional [ str ] the signature alg t if only 1 is allowed None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the signature is verifier, False otherwise Source code in jwskate\\jws\\signature.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def verify ( self , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this signature against the given payload using the provided key. Args: payload: the raw payload jwk: the validation key to use alg: the signature alg t if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the signature is verifier, `False` otherwise \"\"\" jwk = Jwk ( jwk ) signed_part = self . assemble_signed_part ( self . protected , payload ) return jwk . verify ( signed_part , self . signature , alg , algs )","title":"verify()"},{"location":"api/#jwskate.jwt","text":"This module contains all Json Web Key (Jwk) related classes and utilities.","title":"jwt"},{"location":"api/#jwskate.jwt.base","text":"This modules contains the Jwt base class.","title":"base"},{"location":"api/#jwskate.jwt.base.InvalidJwt","text":"Bases: ValueError Raised when an invalid Jwt is parsed. Source code in jwskate\\jwt\\base.py 17 18 class InvalidJwt ( ValueError ): \"\"\"Raised when an invalid Jwt is parsed.\"\"\"","title":"InvalidJwt"},{"location":"api/#jwskate.jwt.base.Jwt","text":"Bases: BaseCompactToken Represents a Json Web Token. Source code in jwskate\\jwt\\base.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class Jwt ( BaseCompactToken ): \"\"\"Represents a Json Web Token.\"\"\" def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 3 : from .encrypted import EncryptedJwt return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls ) @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = Jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) kid = jwk . get ( \"kid\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) headers = dict ( extra_headers or {}, alg = alg ) if kid : headers [ \"kid\" ] = kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . encode_to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . encode_to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . encode_to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc_alg : Optional [ str ], enc : Optional [ str ], ) -> \"EncryptedJwt\" : \"\"\"Sign then encrypt a payload with a `Jwk` and returns the resulting `EncryptedJwt`. NOT IMPLEMENTED YET. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption Returns: the resulting token \"\"\" raise NotImplementedError","title":"Jwt"},{"location":"api/#jwskate.jwt.base.Jwt.__new__","text":"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Parameters: Name Type Description Default value Union [ bytes , str ] the token value required Source code in jwskate\\jwt\\base.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 3 : from .encrypted import EncryptedJwt return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls )","title":"__new__()"},{"location":"api/#jwskate.jwt.base.Jwt.sign","text":"Sign a JSON payload with a Jwk and returns the resulting SignedJwt . This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use .unprotected() instead. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signing required alg Optional [ str ] the alg to use for signing None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the Jwt None Returns: Type Description 'SignedJwt' the resulting token Source code in jwskate\\jwt\\base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = Jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) kid = jwk . get ( \"kid\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) headers = dict ( extra_headers or {}, alg = alg ) if kid : headers [ \"kid\" ] = kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . encode_to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . encode_to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature )))","title":"sign()"},{"location":"api/#jwskate.jwt.base.Jwt.unprotected","text":"Generate a JWT that is not signed and not encrypted (with alg=none). Parameters: Name Type Description Default claims Dict [ str , Any ] the claims to set in the token. required extra_headers Optional [ Dict [ str , Any ]] additional headers to insert in the token. None Returns: Type Description 'SignedJwt' the resulting token Source code in jwskate\\jwt\\base.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . encode_to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . encode_to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature )))","title":"unprotected()"},{"location":"api/#jwskate.jwt.base.Jwt.sign_and_encrypt","text":"Sign then encrypt a payload with a Jwk and returns the resulting EncryptedJwt . NOT IMPLEMENTED YET. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to encrypt required sign_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signature required sign_alg Optional [ str ] the alg to use for signature required enc_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for encryption required enc_alg Optional [ str ] the alg to use for CEK encryption required enc Optional [ str ] the alg to use for payload encryption required Returns: Type Description 'EncryptedJwt' the resulting token Source code in jwskate\\jwt\\base.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc_alg : Optional [ str ], enc : Optional [ str ], ) -> \"EncryptedJwt\" : \"\"\"Sign then encrypt a payload with a `Jwk` and returns the resulting `EncryptedJwt`. NOT IMPLEMENTED YET. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption Returns: the resulting token \"\"\" raise NotImplementedError","title":"sign_and_encrypt()"},{"location":"api/#jwskate.jwt.encrypted","text":"This module implements Encrypted JWT token handling.","title":"encrypted"},{"location":"api/#jwskate.jwt.encrypted.EncryptedJwt","text":"Bases: Jwt Represent an encrypted JWT. Source code in jwskate\\jwt\\encrypted.py 8 9 10 11 12 13 class EncryptedJwt ( Jwt ): \"\"\"Represent an encrypted JWT.\"\"\" def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize an EncryptedJwt based on its serialized value.\"\"\" raise NotImplementedError","title":"EncryptedJwt"},{"location":"api/#jwskate.jwt.encrypted.EncryptedJwt.__init__","text":"Initialize an EncryptedJwt based on its serialized value. Source code in jwskate\\jwt\\encrypted.py 11 12 13 def __init__ ( self , value : Union [ bytes , str ]): \"\"\"Initialize an EncryptedJwt based on its serialized value.\"\"\" raise NotImplementedError","title":"__init__()"},{"location":"api/#jwskate.jwt.signed","text":"This modules contains classes and utilities to generate and validate signed JWT.","title":"signed"},{"location":"api/#jwskate.jwt.signed.ExpiredJwt","text":"Bases: ValueError Raised when trying to validate an expired JWT token. Source code in jwskate\\jwt\\signed.py 13 14 class ExpiredJwt ( ValueError ): \"\"\"Raised when trying to validate an expired JWT token.\"\"\"","title":"ExpiredJwt"},{"location":"api/#jwskate.jwt.signed.InvalidSignature","text":"Bases: ValueError Raised when trying to validate a JWT with an invalid signature. Source code in jwskate\\jwt\\signed.py 17 18 class InvalidSignature ( ValueError ): \"\"\"Raised when trying to validate a JWT with an invalid signature.\"\"\"","title":"InvalidSignature"},{"location":"api/#jwskate.jwt.signed.InvalidClaim","text":"Bases: ValueError Raised when trying to validate a JWT with unexpected claims. Source code in jwskate\\jwt\\signed.py 21 22 class InvalidClaim ( ValueError ): \"\"\"Raised when trying to validate a JWT with unexpected claims.\"\"\"","title":"InvalidClaim"},{"location":"api/#jwskate.jwt.signed.SignedJwt","text":"Bases: Jwt Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use Jwt.sign . Source code in jwskate\\jwt\\signed.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 class SignedJwt ( Jwt ): \"\"\"Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use [Jwt.sign][jwskate.jwt.Jwt.sign]. \"\"\" def __init__ ( self , value : Union [ bytes , str ]) -> None : \"\"\"Initialize a `SignedJwt`, from its compact serialized value. Args: value: the token value. \"\"\" super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJwt ( \"A JWT must contain a header, a payload and a signature, separated by dots\" , value , ) header , payload , signature = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT header: it must be a Base64URL-encoded JSON object\" ) try : self . claims = BinaPy ( payload ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\" ) @property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) def is_expired ( self ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < datetime . now () @property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = datetime . fromtimestamp ( exp ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) @property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = datetime . fromtimestamp ( iat ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) @property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = datetime . fromtimestamp ( nbf ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) @property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) @property def audiences ( self ) -> Optional [ List [ str ]]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return None if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) @property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) @property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) @property def alg ( self ) -> Optional [ str ]: \"\"\"Get the signature algorithm from the header. Returns: the token signing alg, from the `alg` header Raises: AttributeError: if the alg is not a string \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or isinstance ( alg , str ): return alg raise AttributeError ( \"alg has an unexpected type\" , type ( alg )) @property def kid ( self ) -> Optional [ str ]: \"\"\"Get the Key ID (kid) from the JWT header. Returns: the token signing key id, from the `kid` header Raises: AttributeError: if the kid is present but is not a string \"\"\" kid = self . get_header ( \"kid\" ) if kid is None or isinstance ( kid , str ): return kid raise AttributeError ( \"kid has an unexpected type\" , type ( kid )) def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signing alg to use to verify the signature. (Default value = None) issuer: the expected issuer for this token. (Default value = None) audience: the expected audience for this token. (Default value = None) check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audience ) if check_exp : if self . is_expired (): raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim )","title":"SignedJwt"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__init__","text":"Initialize a SignedJwt , from its compact serialized value. Parameters: Name Type Description Default value Union [ bytes , str ] the token value. required Source code in jwskate\\jwt\\signed.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , value : Union [ bytes , str ]) -> None : \"\"\"Initialize a `SignedJwt`, from its compact serialized value. Args: value: the token value. \"\"\" super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJwt ( \"A JWT must contain a header, a payload and a signature, separated by dots\" , value , ) header , payload , signature = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT header: it must be a Base64URL-encoded JSON object\" ) try : self . claims = BinaPy ( payload ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\" )","title":"__init__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.signed_part","text":"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: Type Description bytes the signed part as bytes Source code in jwskate\\jwt\\signed.py 69 70 71 72 73 74 75 76 77 78 @property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ])","title":"signed_part()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.verify_signature","text":"Verify this JWT signature using a given key and algorithm(s). Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private Jwk to use to verify the signature required alg Optional [ str ] the alg to use to verify the signature, if only 1 is allowed None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the token signature is verified, False otherwise Source code in jwskate\\jwt\\signed.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs )","title":"verify_signature()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.is_expired","text":"Check if this token is expired, based on its exp claim. Returns: Type Description Optional [ bool ] True if the token is expired, False if it's not, None if there is no exp claim. Source code in jwskate\\jwt\\signed.py 102 103 104 105 106 107 108 109 110 111 def is_expired ( self ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < datetime . now ()","title":"is_expired()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.expires_at","text":"Get the \"Expires At\" (exp) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the exp claim, or None if there is no exp claim Raises: Type Description AttributeError if the exp claim cannot be parsed to a date Source code in jwskate\\jwt\\signed.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 @property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = datetime . fromtimestamp ( exp ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp )","title":"expires_at()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.issued_at","text":"Get the \"Issued At\" (iat) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the iat claim, or None if there is no iat claim Raises: Type Description AttributeError if the iss claim cannot be parsed to a date Source code in jwskate\\jwt\\signed.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = datetime . fromtimestamp ( iat ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat )","title":"issued_at()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.not_before","text":"Get the \"Not Before\" (nbf) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the nbf claim, or None if there is no nbf claim Raises: Type Description AttributeError if the nbf claim cannot be parsed to a date Source code in jwskate\\jwt\\signed.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = datetime . fromtimestamp ( nbf ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf )","title":"not_before()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.issuer","text":"Get the Issuer (iss) claim from this token. Returns: Type Description Optional [ str ] the issuer, as str , or None if there is no \u00ecss claim Raises: Type Description AttributeError if the \u00ecss claim value is not a string Source code in jwskate\\jwt\\signed.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss ))","title":"issuer()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.audiences","text":"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a list anyway. Returns: Type Description Optional [ List [ str ]] the list of audiences from this token, from the aud claim. Raises: Type Description AttributeError if the audience is an unexpected type Source code in jwskate\\jwt\\signed.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 @property def audiences ( self ) -> Optional [ List [ str ]]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return None if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud ))","title":"audiences()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.subject","text":"Get the Subject (sub) from this token claims. Returns: Type Description Optional [ str ] the subject, as str , or None if there is no sub claim Raises: Type Description AttributeError if the sub value is not a string Source code in jwskate\\jwt\\signed.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 @property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub ))","title":"subject()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.jwt_token_id","text":"Get the JWT Token ID (jti) from this token claims. Returns: Type Description Optional [ str ] the token identifier, as str , or None if there is no jti claim Raises: Type Description AttributeError if the jti value is not a string Source code in jwskate\\jwt\\signed.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 @property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti ))","title":"jwt_token_id()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.alg","text":"Get the signature algorithm from the header. Returns: Type Description Optional [ str ] the token signing alg, from the alg header Raises: Type Description AttributeError if the alg is not a string Source code in jwskate\\jwt\\signed.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 @property def alg ( self ) -> Optional [ str ]: \"\"\"Get the signature algorithm from the header. Returns: the token signing alg, from the `alg` header Raises: AttributeError: if the alg is not a string \"\"\" alg = self . get_header ( \"alg\" ) if alg is None or isinstance ( alg , str ): return alg raise AttributeError ( \"alg has an unexpected type\" , type ( alg ))","title":"alg()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.kid","text":"Get the Key ID (kid) from the JWT header. Returns: Type Description Optional [ str ] the token signing key id, from the kid header Raises: Type Description AttributeError if the kid is present but is not a string Source code in jwskate\\jwt\\signed.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 @property def kid ( self ) -> Optional [ str ]: \"\"\"Get the Key ID (kid) from the JWT header. Returns: the token signing key id, from the `kid` header Raises: AttributeError: if the kid is present but is not a string \"\"\" kid = self . get_header ( \"kid\" ) if kid is None or isinstance ( kid , str ): return kid raise AttributeError ( \"kid has an unexpected type\" , type ( kid ))","title":"kid()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.get_claim","text":"Get a claim from this Jwt. Parameters: Name Type Description Default key str the claim name. required default Any a default value if the claim is not found None Returns: Type Description Any the claim value if found, or default if not found Source code in jwskate\\jwt\\signed.py 266 267 268 269 270 271 272 273 274 275 276 def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default )","title":"get_claim()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__getitem__","text":"Allow claim access with subscription. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate\\jwt\\signed.py 278 279 280 281 282 283 284 285 286 287 288 289 290 def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value","title":"__getitem__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__getattr__","text":"Allow claim access as attributes. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate\\jwt\\signed.py 292 293 294 295 296 297 298 299 300 301 302 303 304 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value","title":"__getattr__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__str__","text":"Return the Jwt serialized value, as str . Returns: Type Description str the serialized token value. Source code in jwskate\\jwt\\signed.py 306 307 308 309 310 311 312 def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode ()","title":"__str__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__bytes__","text":"Return the Jwt serialized value, as bytes . Returns: Type Description bytes the serialized token value. Source code in jwskate\\jwt\\signed.py 314 315 316 317 318 319 320 def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value","title":"__bytes__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.validate","text":"Validate a SignedJwt signature and expected claims. This verifies the signature using the provided jwk and alg , then checks the token issuer, audience and expiration date. This can also check custom claims using extra kwargs , whose values can be: a static value ( str , int , etc.): the value from the token will be compared \"as-is\" a callable, taking the claim value as parameter: if that callable returns True , the claim is considered as valid Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the signing key to use to verify the signature. required alg Optional [ str ] the signing alg to use to verify the signature. (Default value = None) None issuer Optional [ str ] the expected issuer for this token. (Default value = None) None audience Union [None, str ] the expected audience for this token. (Default value = None) None check_exp bool \u00ecf True (default), check that the token is not expired. True **kwargs Any additional claims to check {} Returns: Type Description None Raises exceptions if any validation check fails. Raises: Type Description InvalidSignature if the signature is not valid InvalidClaim if a claim doesn't validate ExpiredJwt if the expiration date is passed Source code in jwskate\\jwt\\signed.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signing alg to use to verify the signature. (Default value = None) issuer: the expected issuer for this token. (Default value = None) audience: the expected audience for this token. (Default value = None) check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audience ) if check_exp : if self . is_expired (): raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim )","title":"validate()"},{"location":"api/#jwskate.jwt.signer","text":"This module contains the JwtSigner class.","title":"signer"},{"location":"api/#jwskate.jwt.signer.JwtSigner","text":"The standardised claims include \u00ecat : issued at date exp : expiration date nbf : not before date: iss : issuer identifier sub : subject identifier aud : audience identifier jti : JWT token ID A helper class to easily sign JWTs with standardised claims. The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling JwtSigner.sign() . This can be used as an alternative to Jwt.sign() when a single issuer issues multiple tokens. Source code in jwskate\\jwt\\signer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class JwtSigner : \"\"\"A helper class to easily sign JWTs with standardised claims. The standardised claims include: - `\u00ecat`: issued at date - `exp`: expiration date - `nbf`: not before date: - `iss`: issuer identifier - `sub`: subject identifier - `aud`: audience identifier - `jti`: JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling `JwtSigner.sign()`. This can be used as an alternative to `Jwt.sign()` when a single issuer issues multiple tokens. \"\"\" def __init__ ( self , issuer : str , jwk : Jwk , alg : Optional [ str ] = None , default_lifetime : int = 60 , default_leeway : Optional [ int ] = None , ): \"\"\"Initialize a `JwtSigner`. Args: issuer: the issuer string to use as `\u00ecss` claim for signed tokens. jwk: the private Jwk to use to sign tokens. alg: the signing alg to use to sign tokens. default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden when calling `.sign()` default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is included. This can be overridden when calling `.sign()` \"\"\" self . issuer = issuer self . jwk = jwk self . alg = jwk . alg or alg self . default_lifetime = default_lifetime self . default_leeway = default_leeway def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = int ( datetime . now () . timestamp ()) lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ())","title":"JwtSigner"},{"location":"api/#jwskate.jwt.signer.JwtSigner.__init__","text":"Initialize a JwtSigner . Parameters: Name Type Description Default issuer str the issuer string to use as \u00ecss claim for signed tokens. required jwk Jwk the private Jwk to use to sign tokens. required alg Optional [ str ] the signing alg to use to sign tokens. None default_lifetime int the default lifetime, in seconds, to use for claim exp . This can be overridden 60 when calling .sign() default_leeway: the default leeway, in seconds, to use for claim nbf . If None, no nbf claim is included. This can be overridden when calling .sign() Source code in jwskate\\jwt\\signer.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , issuer : str , jwk : Jwk , alg : Optional [ str ] = None , default_lifetime : int = 60 , default_leeway : Optional [ int ] = None , ): \"\"\"Initialize a `JwtSigner`. Args: issuer: the issuer string to use as `\u00ecss` claim for signed tokens. jwk: the private Jwk to use to sign tokens. alg: the signing alg to use to sign tokens. default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden when calling `.sign()` default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is included. This can be overridden when calling `.sign()` \"\"\" self . issuer = issuer self . jwk = jwk self . alg = jwk . alg or alg self . default_lifetime = default_lifetime self . default_leeway = default_leeway","title":"__init__()"},{"location":"api/#jwskate.jwt.signer.JwtSigner.sign","text":"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim iat , nbf and exp will reflect the current time when the token is signed. exp includes lifetime seconds in the future, and nbf includes leeway seconds in the past. Parameters: Name Type Description Default subject Optional [ str ] the subject to include in claim sub . (Default value = None) None audience Union [ str , Iterable [ str ], None] the audience identifier(s) to include in claim aud . None extra_claims Optional [ Dict [ str , Any ]] additional claims to include in the signed token. (Default value = None) None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the header part. (Default value = None) None lifetime Optional [ int ] lifetime, in seconds, to use for the exp claim. If None, use the default_lifetime defined at initialization time. None leeway Optional [ int ] leeway, in seconds, to use for the nbf claim. If None, use the default_leeway defined at initialization time. None Returns: Type Description SignedJwt the resulting signed token. Source code in jwskate\\jwt\\signer.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = int ( datetime . now () . timestamp ()) lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers )","title":"sign()"},{"location":"api/#jwskate.jwt.signer.JwtSigner.generate_jti","text":"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: Type Description str A unique value suitable for use as JWT Token ID (jti) claim. Source code in jwskate\\jwt\\signer.py 107 108 109 110 111 112 113 114 115 def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ())","title":"generate_jti()"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Guillaume Pujol guill.p.linux@gmail.com Contributors \u00b6 None yet. Why not be the first?","title":"Authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Guillaume Pujol guill.p.linux@gmail.com","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/guillp/jwskate/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 JsonWebSkate could always use more documentation, whether as part of the official JsonWebSkate docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/guillp/jwskate/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up jwskate for local development. Fork the jwskate repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/jwskate.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/jwskate/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_jwskate ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/guillp/jwskate/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"JsonWebSkate could always use more documentation, whether as part of the official JsonWebSkate docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/guillp/jwskate/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up jwskate for local development. Fork the jwskate repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/jwskate.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/jwskate/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_jwskate ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history/","text":"History \u00b6 0.1.0 (2021-11-15) \u00b6 First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2021-11-15","text":"First release on PyPI.","title":"0.1.0 (2021-11-15)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install jwskate , run this command in your terminal: 1 $ pip install jwskate This is the preferred method to install jwskate , as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for jwskate can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/jwskate Or download the tarball : 1 $ curl -OJL https://github.com/guillp/jwskate/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install jwskate , run this command in your terminal: 1 $ pip install jwskate This is the preferred method to install jwskate , as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for jwskate can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/jwskate Or download the tarball : 1 $ curl -OJL https://github.com/guillp/jwskate/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use jwskate in a project 1 from jwskate import *","title":"usage"},{"location":"usage/#usage","text":"To use jwskate in a project 1 from jwskate import *","title":"Usage"}]}