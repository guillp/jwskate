{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JwSkate \u00b6 A Pythonic implementation of Json Web Signature, Keys, Algorithms, Tokens and Encryption (RFC7514 to 7519), and their extensions ECDH Signatures (RFC8037), and JWK Thumbprints (RFC7638). Free software: MIT Documentation: https://guillp.github.io/jwskate/ A quick usage example, generating an RSA private key, signing some data, then validating that signature: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwk # generate a RSA Jwk and sign a plaintext with it rsa_private_jwk = Jwk . generate_for_kty ( \"RSA\" , key_size = 2048 , kid = \"my_key\" , alg = \"RS256\" ) data = b \"Signing is easy!\" signature = rsa_private_jwk . sign ( data ) # extract the public key, and verify the signature with it rsa_public_jwk = rsa_private_jwk . public_jwk () assert rsa_public_jwk . verify ( data , signature ) # let's see what a Jwk looks like: assert isinstance ( rsa_private_jwk , dict ) # Jwk are dict print ( rsa_private_jwk ) The result of this print JWK will look like this: 1 2 3 4 5 6 7 8 9 10 11 12 { 'kty': 'RSA', 'n': '...', 'e': 'AQAB', 'd': '...', 'p': '...', 'q': '...', 'dp': '...', 'dq': '...', 'qi': '...', 'kid': 'my_key', 'alg': 'RS256', } Now let's sign a JWT containing arbitrary claims: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwk , Jwt private_jwk = Jwk . generate_for_kty ( \"EC\" , kid = \"my_key\" ) claims = { \"sub\" : \"some_sub\" , \"claim1\" : \"value1\" } sign_alg = \"ES256\" jwt = Jwt . sign ( claims , private_jwk , sign_alg ) # that's it! we have a signed JWT assert jwt . claims == claims # claims can be accessed as a dict assert jwt . sub == \"some_sub\" # or individual claims can be accessed as attributes assert jwt [ \"claim1\" ] == \"value1\" # or as dict items assert jwt . alg == sign_alg # alg and kid headers are also accessible as attributes assert jwt . kid == private_jwk . kid assert jwt . verify_signature ( private_jwk . public_jwk (), sign_alg ) print ( jwt ) This will output the full JWT compact representation. You can inspect it for example at https://jwt.io 1 eyJhbGciOiJFUzI1NiIsImtpZCI6Im15a2V5In0.eyJzdWIiOiJzb21lX3N1YiIsImNsYWltMSI6InZhbHVlMSJ9.C1KcDyDT8qXwUqcWzPKkQD7f6xai-gCgaRFMdKPe80Vk7XeYNa8ovuLwvdXgGW4ZZ_lL73QIyncY7tHGXUthag Or let's sign a JWT with the standardised lifetime, subject, audience and ID claims: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk , JwtSigner private_jwk = Jwk . generate_for_kty ( \"EC\" ) signer = JwtSigner ( issuer = \"https://myissuer.com\" , jwk = private_jwk , alg = \"ES256\" ) jwt = signer . sign ( subject = \"some_sub\" , audience = \"some_aud\" , extra_claims = { \"custom_claim1\" : \"value1\" , \"custom_claim2\" : \"value2\" }, ) print ( jwt . claims ) The generated JWT claims will include the standardised claims: 1 2 3 4 5 6 7 8 9 {'custom_claim1': 'value1', 'custom_claim2': 'value2', 'iss': 'https://myissuer.com', 'aud': 'some_aud', 'sub': 'some_sub', 'iat': 1648823184, 'exp': 1648823244, 'jti': '3b400e27-c111-4013-84e0-714acd76bf3a' } Features \u00b6 Simple, Clean, Pythonic interface Convenience wrappers around cryptography for all algorithms described in JWA Json Web Keys (JWK) loading and generation Arbitrary data signature and verification using Json Web Keys Json Web Signatures (JWS) signing and verification Json Web Encryption (JWE) encryption and decryption Json Web Tokens (JWT) signing, verification and validation 100% type annotated nearly 100% code coverage Relies on cryptography for all cryptographic operations Relies on BinaPy for binary data manipulations Supported Signature algorithms \u00b6 jwskate supports the following signature algorithms: Signature Alg Description Key Type Reference Note HS256 HMAC using SHA-256 oct RFC7518, Section 3.2 HS384 HMAC using SHA-384 oct RFC7518, Section 3.2 HS512 HMAC using SHA-512 oct RFC7518, Section 3.2 RS256 RSASSA-PKCS1-v1_5 using SHA-256 RSA RFC7518, Section 3.3 RS384 RSASSA-PKCS1-v1_5 using SHA-384 RSA RFC7518, Section 3.3 RS512 RSASSA-PKCS1-v1_5 using SHA-512 RSA RFC7518, Section 3.3 ES256 ECDSA using P-256 and SHA-256 EC RFC7518, Section 3.4 ES384 ECDSA using P-384 and SHA-384 EC RFC7518, Section 3.4 ES512 ECDSA using P-521 and SHA-512 EC RFC7518, Section 3.4 PS256 RSASSA-PSS using SHA-256 and MGF1 with SHA-256 RSA RFC7518, Section 3.5 PS384 RSASSA-PSS using SHA-384 and MGF1 with SHA-384 RSA RFC7518, Section 3.5 PS512 RSASSA-PSS using SHA-512 and MGF1 with SHA-512 RSA RFC7518, Section 3.5 EdDSA EdDSA signature algorithms OKP RFC8037, Section 3.1 ES256K ECDSA using secp256k1 curve and SHA-256 EC RFC8812, Section 3.2 HS1 HMAC using SHA-1 oct https://www.w3.org/TR/WebCryptoAPI Validation Only RS1 RSASSA-PKCS1-v1_5 with SHA-1 oct https://www.w3.org/TR/WebCryptoAPI Validation Only none No digital signature or MAC performed RFC7518, Section 3.6 Not usable by mistake Supported Key Management algorithms \u00b6 jwskate supports the following key management algorithms: Signature Alg Description Key Type Reference Note RSA1_5 RSAES-PKCS1-v1_5 RSA RFC7518, Section 4.2 Unwrap Only RSA-OAEP RSAES OAEP using default parameters RSA RFC7518, Section 4.3 RSA-OAEP-256 RSAES OAEP using SHA-256 and MGF1 with SHA-256 RSA RFC7518, Section 4.3 RSA-OAEP-384 RSA-OAEP using SHA-384 and MGF1 with SHA-384 RSA https://www.w3.org/TR/WebCryptoAPI RSA-OAEP-512 RSA-OAEP using SHA-512 and MGF1 with SHA-512 RSA https://www.w3.org/TR/WebCryptoAPI A128KW AES Key Wrap using 128-bit key oct RFC7518, Section 4.4 A192KW AES Key Wrap using 192-bit key oct RFC7518, Section 4.4 A256KW AES Key Wrap using 256-bit key oct RFC7518, Section 4.4 dir Direct use of a shared symmetric key oct RFC7518, Section 4.5 ECDH-ES ECDH-ES using Concat KDF EC RFC7518, Section 4.6 ECDH-ES+A128KW ECDH-ES using Concat KDF and \"A128KW\" wrapping EC RFC7518, Section 4.6 ECDH-ES+A192KW ECDH-ES using Concat KDF and \"A192KW\" wrapping EC RFC7518, Section 4.6 ECDH-ES+A256KW ECDH-ES using Concat KDF and \"A256KW\" wrapping EC RFC7518, Section 4.6 A128GCMKW Key wrapping with AES GCM using 128-bit key oct RFC7518, Section 4.7 A192GCMKW Key wrapping with AES GCM using 192-bit key oct RFC7518, Section 4.7 A256GCMKW Key wrapping with AES GCM using 256-bit key oct RFC7518, Section 4.7 PBES2-HS256+A128KW PBES2 with HMAC SHA-256 and \"A128KW\" wrapping password RFC7518, Section 4.8 PBES2-HS384+A192KW PBES2 with HMAC SHA-384 and \"A192KW\" wrapping password RFC7518, Section 4.8 PBES2-HS512+A256KW PBES2 with HMAC SHA-512 and \"A256KW\" wrapping password RFC7518, Section 4.8 Supported Encryption algorithms \u00b6 jwskate supports the following encryption algorithms: Signature Alg Description Reference A128CBC-HS256 AES_128_CBC_HMAC_SHA_256 authenticated encryption algorithm RFC7518, Section 5.2.3 A192CBC-HS384 AES_192_CBC_HMAC_SHA_384 authenticated encryption algorithm RFC7518, Section 5.2.4 A256CBC-HS512 AES_256_CBC_HMAC_SHA_512 authenticated encryption algorithm RFC7518, Section 5.2.5 A128GCM AES GCM using 128-bit key RFC7518, Section 5.3 A192GCM AES GCM using 192-bit key RFC7518, Section 5.3 A256GCM AES GCM using 256-bit key RFC7518, Section 5.3 Supported Elliptic Curves \u00b6 jwskate supports the following Elliptic Curves: Curve Description Key Type Usage Reference P-256 P-256 Curve EC signature, encryption RFC7518, Section 6.2.1.1 P-384 P-384 Curve EC signature, encryption RFC7518, Section 6.2.1.1 P-521 P-521 Curve EC signature, encryption RFC7518, Section 6.2.1.1 secp256k1 SECG secp256k1 curve EC signature, encryption RFC8812, Section 3.1 Ed25519 Ed25519 signature algorithm key pairs OKP signature RFC8037, Section 3.1 Ed448 Ed448 signature algorithm key pairs OKP signature RFC8037, Section 3.1 X25519 X25519 function key pairs OKP encryption RFC8037, Section 3.2 X448 X448 function key pairs OKP encryption RFC8037, Section 3.2 Why a new lib ? \u00b6 There are already multiple implementations of JOSE and Json Web Crypto related specifications in Python. However, I have been dissatisfied by all of them so far, so I decided to come up with my own module. PyJWT : lacks support for JWK, JWE, JWS, requires keys in PEM format. JWCrypto : very inconsistent and complex API. Python-JOSE : lacks easy support for JWT validation (checking the standard claims like iss, exp, etc.), lacks easy access to claims Not to say that those are bad libs (I actually use jwcrypto myself for jwskate unit tests), but they either don't support some important features, or they just don't feel easy-enough, Pythonic-enough to use. Design \u00b6 JWK are dicts \u00b6 JWK are specified as JSON objects, which are parsed as dict in Python. The Jwk class in jwskate is actually a dict subclass, so you can use it exactly like you would use a dict: you can access its members, dump it back as JSON, etc. The same is true for Json Web tokens in JSON format. JWA Wrappers \u00b6 While you can directly use cryptography to do the cryptographic operations that are described in JWA , its usage is not straightforward and gives you plenty of options to carefully select, leaving room for errors. To work around this, jwskate comes with a set of wrappers that implement the exact JWA specification, with minimum risk of mistakes. Safe Signature Verification \u00b6 For every signature verification method in jwskate , you have to provide the expected signature(s) algorithm(s). That is to avoid a security flaw where your application accepts tokens with a weaker encryption scheme than what your security policy mandates; or even worse, where it accepts unsigned tokens, or tokens that are symmetrically signed with an improperly used public key, leaving your application exposed to exploitation by attackers. Each signature verification accepts 2 args alg and algs . If you always expect to verify tokens signed with a single signature algorithm, pass that algorithm ID to alg. If you accept multiple algs (for example, any asymmetric alg that you consider strong enough), you can instead pass an iterable of allowed algorithms with algs . The signature will be validated as long as it is signed with one of the provided algs. For verification methods that accept a Jwk key, you don't have to provide an alg or algs if that Jwk has the appropriate alg member that define which algorithm is supposed to be used with that key. Credits \u00b6 All cryptographic operations are handled by cryptography .","title":"home"},{"location":"#jwskate","text":"A Pythonic implementation of Json Web Signature, Keys, Algorithms, Tokens and Encryption (RFC7514 to 7519), and their extensions ECDH Signatures (RFC8037), and JWK Thumbprints (RFC7638). Free software: MIT Documentation: https://guillp.github.io/jwskate/ A quick usage example, generating an RSA private key, signing some data, then validating that signature: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwk # generate a RSA Jwk and sign a plaintext with it rsa_private_jwk = Jwk . generate_for_kty ( \"RSA\" , key_size = 2048 , kid = \"my_key\" , alg = \"RS256\" ) data = b \"Signing is easy!\" signature = rsa_private_jwk . sign ( data ) # extract the public key, and verify the signature with it rsa_public_jwk = rsa_private_jwk . public_jwk () assert rsa_public_jwk . verify ( data , signature ) # let's see what a Jwk looks like: assert isinstance ( rsa_private_jwk , dict ) # Jwk are dict print ( rsa_private_jwk ) The result of this print JWK will look like this: 1 2 3 4 5 6 7 8 9 10 11 12 { 'kty': 'RSA', 'n': '...', 'e': 'AQAB', 'd': '...', 'p': '...', 'q': '...', 'dp': '...', 'dq': '...', 'qi': '...', 'kid': 'my_key', 'alg': 'RS256', } Now let's sign a JWT containing arbitrary claims: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwk , Jwt private_jwk = Jwk . generate_for_kty ( \"EC\" , kid = \"my_key\" ) claims = { \"sub\" : \"some_sub\" , \"claim1\" : \"value1\" } sign_alg = \"ES256\" jwt = Jwt . sign ( claims , private_jwk , sign_alg ) # that's it! we have a signed JWT assert jwt . claims == claims # claims can be accessed as a dict assert jwt . sub == \"some_sub\" # or individual claims can be accessed as attributes assert jwt [ \"claim1\" ] == \"value1\" # or as dict items assert jwt . alg == sign_alg # alg and kid headers are also accessible as attributes assert jwt . kid == private_jwk . kid assert jwt . verify_signature ( private_jwk . public_jwk (), sign_alg ) print ( jwt ) This will output the full JWT compact representation. You can inspect it for example at https://jwt.io 1 eyJhbGciOiJFUzI1NiIsImtpZCI6Im15a2V5In0.eyJzdWIiOiJzb21lX3N1YiIsImNsYWltMSI6InZhbHVlMSJ9.C1KcDyDT8qXwUqcWzPKkQD7f6xai-gCgaRFMdKPe80Vk7XeYNa8ovuLwvdXgGW4ZZ_lL73QIyncY7tHGXUthag Or let's sign a JWT with the standardised lifetime, subject, audience and ID claims: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk , JwtSigner private_jwk = Jwk . generate_for_kty ( \"EC\" ) signer = JwtSigner ( issuer = \"https://myissuer.com\" , jwk = private_jwk , alg = \"ES256\" ) jwt = signer . sign ( subject = \"some_sub\" , audience = \"some_aud\" , extra_claims = { \"custom_claim1\" : \"value1\" , \"custom_claim2\" : \"value2\" }, ) print ( jwt . claims ) The generated JWT claims will include the standardised claims: 1 2 3 4 5 6 7 8 9 {'custom_claim1': 'value1', 'custom_claim2': 'value2', 'iss': 'https://myissuer.com', 'aud': 'some_aud', 'sub': 'some_sub', 'iat': 1648823184, 'exp': 1648823244, 'jti': '3b400e27-c111-4013-84e0-714acd76bf3a' }","title":"JwSkate"},{"location":"#features","text":"Simple, Clean, Pythonic interface Convenience wrappers around cryptography for all algorithms described in JWA Json Web Keys (JWK) loading and generation Arbitrary data signature and verification using Json Web Keys Json Web Signatures (JWS) signing and verification Json Web Encryption (JWE) encryption and decryption Json Web Tokens (JWT) signing, verification and validation 100% type annotated nearly 100% code coverage Relies on cryptography for all cryptographic operations Relies on BinaPy for binary data manipulations","title":"Features"},{"location":"#supported-signature-algorithms","text":"jwskate supports the following signature algorithms: Signature Alg Description Key Type Reference Note HS256 HMAC using SHA-256 oct RFC7518, Section 3.2 HS384 HMAC using SHA-384 oct RFC7518, Section 3.2 HS512 HMAC using SHA-512 oct RFC7518, Section 3.2 RS256 RSASSA-PKCS1-v1_5 using SHA-256 RSA RFC7518, Section 3.3 RS384 RSASSA-PKCS1-v1_5 using SHA-384 RSA RFC7518, Section 3.3 RS512 RSASSA-PKCS1-v1_5 using SHA-512 RSA RFC7518, Section 3.3 ES256 ECDSA using P-256 and SHA-256 EC RFC7518, Section 3.4 ES384 ECDSA using P-384 and SHA-384 EC RFC7518, Section 3.4 ES512 ECDSA using P-521 and SHA-512 EC RFC7518, Section 3.4 PS256 RSASSA-PSS using SHA-256 and MGF1 with SHA-256 RSA RFC7518, Section 3.5 PS384 RSASSA-PSS using SHA-384 and MGF1 with SHA-384 RSA RFC7518, Section 3.5 PS512 RSASSA-PSS using SHA-512 and MGF1 with SHA-512 RSA RFC7518, Section 3.5 EdDSA EdDSA signature algorithms OKP RFC8037, Section 3.1 ES256K ECDSA using secp256k1 curve and SHA-256 EC RFC8812, Section 3.2 HS1 HMAC using SHA-1 oct https://www.w3.org/TR/WebCryptoAPI Validation Only RS1 RSASSA-PKCS1-v1_5 with SHA-1 oct https://www.w3.org/TR/WebCryptoAPI Validation Only none No digital signature or MAC performed RFC7518, Section 3.6 Not usable by mistake","title":"Supported Signature algorithms"},{"location":"#supported-key-management-algorithms","text":"jwskate supports the following key management algorithms: Signature Alg Description Key Type Reference Note RSA1_5 RSAES-PKCS1-v1_5 RSA RFC7518, Section 4.2 Unwrap Only RSA-OAEP RSAES OAEP using default parameters RSA RFC7518, Section 4.3 RSA-OAEP-256 RSAES OAEP using SHA-256 and MGF1 with SHA-256 RSA RFC7518, Section 4.3 RSA-OAEP-384 RSA-OAEP using SHA-384 and MGF1 with SHA-384 RSA https://www.w3.org/TR/WebCryptoAPI RSA-OAEP-512 RSA-OAEP using SHA-512 and MGF1 with SHA-512 RSA https://www.w3.org/TR/WebCryptoAPI A128KW AES Key Wrap using 128-bit key oct RFC7518, Section 4.4 A192KW AES Key Wrap using 192-bit key oct RFC7518, Section 4.4 A256KW AES Key Wrap using 256-bit key oct RFC7518, Section 4.4 dir Direct use of a shared symmetric key oct RFC7518, Section 4.5 ECDH-ES ECDH-ES using Concat KDF EC RFC7518, Section 4.6 ECDH-ES+A128KW ECDH-ES using Concat KDF and \"A128KW\" wrapping EC RFC7518, Section 4.6 ECDH-ES+A192KW ECDH-ES using Concat KDF and \"A192KW\" wrapping EC RFC7518, Section 4.6 ECDH-ES+A256KW ECDH-ES using Concat KDF and \"A256KW\" wrapping EC RFC7518, Section 4.6 A128GCMKW Key wrapping with AES GCM using 128-bit key oct RFC7518, Section 4.7 A192GCMKW Key wrapping with AES GCM using 192-bit key oct RFC7518, Section 4.7 A256GCMKW Key wrapping with AES GCM using 256-bit key oct RFC7518, Section 4.7 PBES2-HS256+A128KW PBES2 with HMAC SHA-256 and \"A128KW\" wrapping password RFC7518, Section 4.8 PBES2-HS384+A192KW PBES2 with HMAC SHA-384 and \"A192KW\" wrapping password RFC7518, Section 4.8 PBES2-HS512+A256KW PBES2 with HMAC SHA-512 and \"A256KW\" wrapping password RFC7518, Section 4.8","title":"Supported Key Management algorithms"},{"location":"#supported-encryption-algorithms","text":"jwskate supports the following encryption algorithms: Signature Alg Description Reference A128CBC-HS256 AES_128_CBC_HMAC_SHA_256 authenticated encryption algorithm RFC7518, Section 5.2.3 A192CBC-HS384 AES_192_CBC_HMAC_SHA_384 authenticated encryption algorithm RFC7518, Section 5.2.4 A256CBC-HS512 AES_256_CBC_HMAC_SHA_512 authenticated encryption algorithm RFC7518, Section 5.2.5 A128GCM AES GCM using 128-bit key RFC7518, Section 5.3 A192GCM AES GCM using 192-bit key RFC7518, Section 5.3 A256GCM AES GCM using 256-bit key RFC7518, Section 5.3","title":"Supported Encryption algorithms"},{"location":"#supported-elliptic-curves","text":"jwskate supports the following Elliptic Curves: Curve Description Key Type Usage Reference P-256 P-256 Curve EC signature, encryption RFC7518, Section 6.2.1.1 P-384 P-384 Curve EC signature, encryption RFC7518, Section 6.2.1.1 P-521 P-521 Curve EC signature, encryption RFC7518, Section 6.2.1.1 secp256k1 SECG secp256k1 curve EC signature, encryption RFC8812, Section 3.1 Ed25519 Ed25519 signature algorithm key pairs OKP signature RFC8037, Section 3.1 Ed448 Ed448 signature algorithm key pairs OKP signature RFC8037, Section 3.1 X25519 X25519 function key pairs OKP encryption RFC8037, Section 3.2 X448 X448 function key pairs OKP encryption RFC8037, Section 3.2","title":"Supported Elliptic Curves"},{"location":"#why-a-new-lib-","text":"There are already multiple implementations of JOSE and Json Web Crypto related specifications in Python. However, I have been dissatisfied by all of them so far, so I decided to come up with my own module. PyJWT : lacks support for JWK, JWE, JWS, requires keys in PEM format. JWCrypto : very inconsistent and complex API. Python-JOSE : lacks easy support for JWT validation (checking the standard claims like iss, exp, etc.), lacks easy access to claims Not to say that those are bad libs (I actually use jwcrypto myself for jwskate unit tests), but they either don't support some important features, or they just don't feel easy-enough, Pythonic-enough to use.","title":"Why a new lib ?"},{"location":"#design","text":"","title":"Design"},{"location":"#jwk-are-dicts","text":"JWK are specified as JSON objects, which are parsed as dict in Python. The Jwk class in jwskate is actually a dict subclass, so you can use it exactly like you would use a dict: you can access its members, dump it back as JSON, etc. The same is true for Json Web tokens in JSON format.","title":"JWK are dicts"},{"location":"#jwa-wrappers","text":"While you can directly use cryptography to do the cryptographic operations that are described in JWA , its usage is not straightforward and gives you plenty of options to carefully select, leaving room for errors. To work around this, jwskate comes with a set of wrappers that implement the exact JWA specification, with minimum risk of mistakes.","title":"JWA Wrappers"},{"location":"#safe-signature-verification","text":"For every signature verification method in jwskate , you have to provide the expected signature(s) algorithm(s). That is to avoid a security flaw where your application accepts tokens with a weaker encryption scheme than what your security policy mandates; or even worse, where it accepts unsigned tokens, or tokens that are symmetrically signed with an improperly used public key, leaving your application exposed to exploitation by attackers. Each signature verification accepts 2 args alg and algs . If you always expect to verify tokens signed with a single signature algorithm, pass that algorithm ID to alg. If you accept multiple algs (for example, any asymmetric alg that you consider strong enough), you can instead pass an iterable of allowed algorithms with algs . The signature will be validated as long as it is signed with one of the provided algs. For verification methods that accept a Jwk key, you don't have to provide an alg or algs if that Jwk has the appropriate alg member that define which algorithm is supposed to be used with that key.","title":"Safe Signature Verification"},{"location":"#credits","text":"All cryptographic operations are handled by cryptography .","title":"Credits"},{"location":"api/","text":"Main module for jwskate . The jwskate module implements the various Json Web Crypto-related standards: JWA, JWK, JWKS, JWE, JWT. Each standard has its own submodule, but for convenience, you can import any class or component directly from the root jwskate module. jwskate doesn't implement any actual cryptographic operation, it just provides a set of convenient wrappers around the cryptography module. Ed25519 = OKPCurve ( name = 'Ed25519' , description = 'Ed25519 signature algorithm key pairs' , cryptography_private_key_class = ed25519 . Ed25519PrivateKey , cryptography_public_key_class = ed25519 . Ed25519PublicKey , use = 'sig' ) module-attribute \u00b6 Ed25519 curve. Ed448 = OKPCurve ( name = 'Ed448' , description = 'Ed448 signature algorithm key pairs' , cryptography_private_key_class = ed448 . Ed448PrivateKey , cryptography_public_key_class = ed448 . Ed448PublicKey , use = 'sig' ) module-attribute \u00b6 Ed448 curve. P_256 = EllipticCurve ( name = 'P-256' , cryptography_curve = ec . SECP256R1 (), coordinate_size = 32 ) module-attribute \u00b6 P-256 curve P_384 = EllipticCurve ( name = 'P-384' , cryptography_curve = ec . SECP384R1 (), coordinate_size = 48 ) module-attribute \u00b6 P-384 curve P_521 = EllipticCurve ( name = 'P-521' , cryptography_curve = ec . SECP521R1 (), coordinate_size = 66 ) module-attribute \u00b6 P-521 curve X25519 = OKPCurve ( name = 'X25519' , description = 'X25519 function key pairs' , cryptography_private_key_class = x25519 . X25519PrivateKey , cryptography_public_key_class = x25519 . X25519PublicKey , use = 'enc' ) module-attribute \u00b6 X25519 curve. X448 = OKPCurve ( name = 'X448' , description = 'X448 function key pairs' , cryptography_private_key_class = x448 . X448PrivateKey , cryptography_public_key_class = x448 . X448PublicKey , use = 'enc' ) module-attribute \u00b6 X448 curve. secp256k1 = EllipticCurve ( name = 'secp256k1' , cryptography_curve = ec . SECP256K1 (), coordinate_size = 32 ) module-attribute \u00b6 secp256k1 curve A128GCM \u00b6 Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 62 63 64 65 66 67 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128 A128GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 47 48 49 50 51 52 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128 A128KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 53 54 55 56 57 58 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128 A192GCM \u00b6 Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 70 71 72 73 74 75 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192 A192GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 55 56 57 58 59 60 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192 A192KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 61 62 63 64 65 66 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192 A256GCM \u00b6 Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 78 79 80 81 82 83 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256 A256GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 63 64 65 66 67 68 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256 A256KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 69 70 71 72 73 74 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256 Aes128CbcHmacSha256 \u00b6 Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate/jwa/encryption/aescbchmac.py 110 111 112 113 114 115 116 117 118 class Aes128CbcHmacSha256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 () Aes192CbcHmacSha384 \u00b6 Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate/jwa/encryption/aescbchmac.py 121 122 123 124 125 126 127 128 129 class Aes192CbcHmacSha384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 () Aes256CbcHmacSha512 \u00b6 Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate/jwa/encryption/aescbchmac.py 132 133 134 135 136 137 138 139 140 141 class Aes256CbcHmacSha512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 () BaseAESEncryptionAlg \u00b6 Bases: BaseSymmetricAlg Base class for AES encryption algorithms. Source code in jwskate/jwa/base.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 class BaseAESEncryptionAlg ( BaseSymmetricAlg ): \"\"\"Base class for AES encryption algorithms.\"\"\" key_size : int tag_size : int iv_size : int @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) def encrypt ( self , plaintext : bytes , * , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError def decrypt ( self , ciphertext : bytes , * , iv : bytes , auth_tag : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt iv: the Initialisation Vector to use. Must be the same one used during encryption auth_tag: the authentication tag aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError @classmethod def init_random_key ( cls ) -> BaseAESEncryptionAlg : \"\"\"Initialize this alg with a random key. Returns: a subclass of BaseAESEncryptionAlg initialized with a randomly generated key \"\"\" return cls ( cls . generate_key ()) check_key ( key ) classmethod \u00b6 Check that a key is suitable for this algorithm. Parameters: Name Type Description Default key bytes the key to check required Raises: Type Description ValueError if the key is not suitable Source code in jwskate/jwa/base.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) decrypt ( ciphertext , * , iv , auth_tag , aad ) \u00b6 Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required iv bytes the Initialisation Vector to use. Must be the same one used during encryption required auth_tag bytes the authentication tag required aad Optional [ bytes ] the Additional Authentication Data. Must be the same one used during encryption required Returns: Type Description BinaPy the deciphered data Source code in jwskate/jwa/base.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def decrypt ( self , ciphertext : bytes , * , iv : bytes , auth_tag : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt iv: the Initialisation Vector to use. Must be the same one used during encryption auth_tag: the authentication tag aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError encrypt ( plaintext , * , iv , aad ) \u00b6 Encrypt arbitrary data ( plaintext ) with the given Initialisation Vector ( iv ) and optional Additional Authentication Data ( aad ), return the ciphered text and authentication tag. Parameters: Name Type Description Default plaintext bytes the data to encrypt required iv bytes the Initialisation Vector to use required aad Optional [ bytes ] the Additional Authentication Data required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple of ciphered data and authentication tag Source code in jwskate/jwa/base.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def encrypt ( self , plaintext : bytes , * , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError generate_iv () classmethod \u00b6 Generate an Initialisation Vector of the appropriate size. Returns: Type Description BinaPy a random IV Source code in jwskate/jwa/base.py 224 225 226 227 228 229 230 231 @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) generate_key () classmethod \u00b6 Generate a key of an appropriate size for this AES alg subclass. Returns: Type Description BinaPy a random AES key Source code in jwskate/jwa/base.py 215 216 217 218 219 220 221 222 @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) init_random_key () classmethod \u00b6 Initialize this alg with a random key. Returns: Type Description BaseAESEncryptionAlg a subclass of BaseAESEncryptionAlg initialized with a randomly generated key Source code in jwskate/jwa/base.py 264 265 266 267 268 269 270 271 @classmethod def init_random_key ( cls ) -> BaseAESEncryptionAlg : \"\"\"Initialize this alg with a random key. Returns: a subclass of BaseAESEncryptionAlg initialized with a randomly generated key \"\"\" return cls ( cls . generate_key ()) BaseAlg \u00b6 Base class for all algorithms. An algorithm has a name and a description , whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms Source code in jwskate/jwa/base.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class BaseAlg : \"\"\"Base class for all algorithms. An algorithm has a `name` and a `description`, whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms \"\"\" name : str \"\"\"Technical name of the algorithm\"\"\" description : str \"\"\"Description of the algorithm (human readable)\"\"\" read_only : bool = False \"\"\"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.\"\"\" def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name description : str class-attribute \u00b6 Description of the algorithm (human readable) name : str class-attribute \u00b6 Technical name of the algorithm read_only : bool = False class-attribute \u00b6 For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions. __repr__ () \u00b6 Use the name of the alg as repr. Source code in jwskate/jwa/base.py 32 33 34 def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name BaseAsymmetricAlg \u00b6 Bases: Generic [ Kpriv , Kpub ] , BaseAlg Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Source code in jwskate/jwa/base.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class BaseAsymmetricAlg ( Generic [ Kpriv , Kpub ], BaseAlg ): \"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Args: key: the key to use. \"\"\" private_key_class : Union [ Type [ Kpriv ], Tuple [ Type [ Kpriv ], ... ]] public_key_class : Union [ Type [ Kpub ], Tuple [ Type [ Kpub ], ... ]] def __init__ ( self , key : Union [ Kpriv , Kpub ]): self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore check_key ( key ) classmethod \u00b6 Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Returns: Type Description None Returns None. Raises an exception if the key is not suitable. Raises: Type Description Exception if the key is not suitable for use with this alg class Source code in jwskate/jwa/base.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" private_key_required () \u00b6 A context manager that checks if this alg is initialised with a private key. Yields: Type Description Iterator [ Kpriv ] the private key Raises: Type Description PrivateKeyRequired if the configured key is not private Source code in jwskate/jwa/base.py 137 138 139 140 141 142 143 144 145 146 147 148 149 @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore public_key_required () \u00b6 A context manager that checks if this alg is initialised with a public key. Yields: Type Description Iterator [ Kpub ] The public key Raises: Type Description PublicKeyRequired if the configured key is private Source code in jwskate/jwa/base.py 151 152 153 154 155 156 157 158 159 160 161 162 163 @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore supports_key ( key ) classmethod \u00b6 Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate/jwa/base.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False BaseEcdhEs_AesKw \u00b6 Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate/jwa/key_mgmt/ecdh.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) unwrap_key_with_epk ( cipherkey , ephemeral_public_key , ** headers ) \u00b6 Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey bytes the wrapped key required ephemeral_public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate/jwa/key_mgmt/ecdh.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) wrap_key_with_epk ( plainkey , ephemeral_private_key , ** headers ) \u00b6 Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate/jwa/key_mgmt/ecdh.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) BaseKeyManagementAlg \u00b6 Bases: BaseAlg Base class for Key Management algorithms. Source code in jwskate/jwa/base.py 274 275 class BaseKeyManagementAlg ( BaseAlg ): \"\"\"Base class for Key Management algorithms.\"\"\" BasePbes2 \u00b6 Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. PBES2 derives a cryptographic key from a human-provided password. Parameters: Name Type Description Default password Union [ bytes , str ] the encryption/decryption password to use required Source code in jwskate/jwa/key_mgmt/pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms. PBES2 derives a cryptographic key from a human-provided password. Args: password: the encryption/decryption password to use \"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ bytes , str ]): if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) derive ( * , salt , count ) \u00b6 Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate/jwa/key_mgmt/pbes2.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def derive ( self , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) generate_salt ( size = 12 ) \u00b6 Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate/jwa/key_mgmt/pbes2.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) unwrap_key ( cipherkey , * , salt , count ) \u00b6 Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate/jwa/key_mgmt/pbes2.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def unwrap_key ( self , cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) wrap_key ( plainkey , * , salt , count ) \u00b6 Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate/jwa/key_mgmt/pbes2.py 65 66 67 68 69 70 71 72 73 74 75 76 77 def wrap_key ( self , plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) BaseRsaKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Parameters: Name Type Description Default key Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate/jwa/key_mgmt/rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms. Args: key: the private or public key to use \"\"\" padding : Any name : str description : str private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" if self . read_only : raise NotImplementedError with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) unwrap_key ( cipherkey ) \u00b6 Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate/jwa/key_mgmt/rsa.py 52 53 54 55 56 57 58 59 60 61 62 63 64 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) wrap_key ( plainkey ) \u00b6 Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate/jwa/key_mgmt/rsa.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" if self . read_only : raise NotImplementedError with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) BaseSignatureAlg \u00b6 Bases: BaseAlg Base class for signature algorithms. Source code in jwskate/jwa/base.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 class BaseSignatureAlg ( BaseAlg ): \"\"\"Base class for signature algorithms.\"\"\" def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError sign ( data ) \u00b6 Sign arbitrary data, return the signature. Parameters: Name Type Description Default data bytes raw data to sign required Returns: Type Description BinaPy the raw signature Source code in jwskate/jwa/base.py 169 170 171 172 173 174 175 176 177 178 def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError verify ( data , signature ) \u00b6 Verify a signature against some data. Parameters: Name Type Description Default data bytes the raw data to verify required signature bytes the raw signature required Returns: Type Description bool True if the signature matches, False otherwise. Source code in jwskate/jwa/base.py 180 181 182 183 184 185 186 187 188 189 190 def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError BaseSymmetricAlg \u00b6 Bases: BaseAlg Base class for Symmetric algorithms (using a raw bytes key). Parameters: Name Type Description Default key bytes the key to use for cryptographic operations required Source code in jwskate/jwa/base.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class BaseSymmetricAlg ( BaseAlg ): \"\"\"Base class for Symmetric algorithms (using a raw bytes key). Args: key: the key to use for cryptographic operations \"\"\" def __init__ ( self , key : bytes ): self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False check_key ( key ) classmethod \u00b6 Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description None Returns None . Raises an exception if the key is not suitable Source code in jwskate/jwa/base.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass supports_key ( key ) classmethod \u00b6 Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate/jwa/base.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False DirectKeyUse \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate/jwa/key_mgmt/dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) direct_key ( aesalg ) \u00b6 Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate/jwa/key_mgmt/dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) ECJwk \u00b6 Bases: Jwk Represent an Elliptic Curve Jwk, with kty=EC . Source code in jwskate/jwk/ec.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 class ECJwk ( Jwk ): \"\"\"Represent an Elliptic Curve Jwk, with `kty=EC`.\"\"\" KTY = \"EC\" CRYPTOGRAPHY_KEY_CLASSES = ( asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ) PARAMS : Mapping [ str , JwkParameter ] = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"X Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"y\" : JwkParameter ( \"Y Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"ECC Private Key\" , is_private = True , is_required = True , kind = \"b64u\" ), } CURVES : Mapping [ str , EllipticCurve ] = { curve . name : curve for curve in [ P_256 , P_384 , P_521 , secp256k1 ] } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ ES256 , ES384 , ES512 , ES256K ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedEllipticCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . to ( \"b64u\" ), ** params , ) ) @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . to ( \"b64u\" ) . ascii (), y = BinaPy . from_int ( y , coord_size ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d , coord_size ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: cryptography_key: `cryptography` key **kwargs: additional members to include in the Jwk Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_jwk_parameters ( cryptography_key ) return cls ( parameters ) def _to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key () @classmethod def generate ( cls , crv : str = \"P-256\" , ** params : str ) -> \"ECJwk\" : \"\"\"Generates a random ECJwk. Args: crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" curve = cls . get_curve ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = crv , x = x , y = y , d = d , ** params , ) @cached_property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () @cached_property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () @cached_property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) def to_pem_key ( self , password : Optional [ bytes ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM encrypted key \"\"\" if self . is_private : assert isinstance ( self . cryptography_key , ec . EllipticCurvePrivateKey ) encryption : serialization . KeySerializationEncryption if password : encryption = serialization . BestAvailableEncryption ( password ) else : encryption = serialization . NoEncryption () return self . cryptography_key . private_bytes ( # type: ignore[no-any-return, attr-defined] serialization . Encoding . PEM , serialization . PrivateFormat . PKCS8 , encryption , ) else : assert isinstance ( self . cryptography_key , ec . EllipticCurvePublicKey ) if password : raise ValueError ( \"Public keys cannot be encrypted when serialized in PEM format.\" ) return self . cryptography_key . public_bytes ( serialization . Encoding . PEM , serialization . PublicFormat . SubjectPublicKeyInfo , ) coordinate_size () property \u00b6 The coordinate size to use with the key curve. Returns: Type Description int 32, 48, or 66 (bits) Source code in jwskate/jwk/ec.py 157 158 159 160 161 162 163 164 @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size curve () property \u00b6 Get the EllipticCurve instance for this key. Returns: Type Description EllipticCurve the EllipticCurve instance Source code in jwskate/jwk/ec.py 98 99 100 101 102 103 104 105 @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) ecc_private_key () \u00b6 Return the ECC private key from this ECJwk. Returns: Type Description int the ECC private key (from parameter d ) Source code in jwskate/jwk/ec.py 251 252 253 254 255 256 257 258 @cached_property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () from_cryptography_key ( cryptography_key , ** kwargs ) classmethod \u00b6 Initialize an ECJwk from a cryptography key. Parameters: Name Type Description Default cryptography_key Any cryptography key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description ECJwk an ECJwk initialized from the provided cryptography key Source code in jwskate/jwk/ec.py 166 167 168 169 170 171 172 173 174 175 176 177 178 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: cryptography_key: `cryptography` key **kwargs: additional members to include in the Jwk Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_jwk_parameters ( cryptography_key ) return cls ( parameters ) generate ( crv = 'P-256' , ** params ) classmethod \u00b6 Generates a random ECJwk. Parameters: Name Type Description Default crv str the curve to use 'P-256' **params str {} Returns: Type Description ECJwk a generated ECJwk Raises: Type Description UnsupportedEllipticCurve if the provided curve identifier is not supported. Source code in jwskate/jwk/ec.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @classmethod def generate ( cls , crv : str = \"P-256\" , ** params : str ) -> \"ECJwk\" : \"\"\"Generates a random ECJwk. Args: crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" curve = cls . get_curve ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = crv , x = x , y = y , d = d , ** params , ) get_curve ( crv ) classmethod \u00b6 Get the EllipticCurve instance for a given curve identifier. Parameters: Name Type Description Default crv str the curve identifier required Returns: Type Description EllipticCurve the matching EllipticCurve instance Raises: Type Description UnsupportedEllipticCurve if the curve identifier is not supported Source code in jwskate/jwk/ec.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve private ( crv , x , y , d , ** params ) classmethod \u00b6 Initialize a private ECJwk from its private parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required d int the elliptic curve private key required **params Any additional members to include in the JWK {} Returns: Type Description ECJwk an ECJWk initialized with the supplied parameters Source code in jwskate/jwk/ec.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . to ( \"b64u\" ) . ascii (), y = BinaPy . from_int ( y , coord_size ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d , coord_size ) . to ( \"b64u\" ) . ascii (), ** params , ) ) public ( crv , x , y , ** params ) classmethod \u00b6 Initialize a public ECJwk from its public parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required **params str additional member to include in the Jwk {} Returns: Type Description ECJwk an ECJwk initialized with the supplied parameters Source code in jwskate/jwk/ec.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . to ( \"b64u\" ), ** params , ) ) supported_encryption_algorithms () \u00b6 Return the list of support Encryption algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 280 281 282 283 284 285 286 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) supported_key_management_algorithms () \u00b6 Return the list of supported Key Management algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 272 273 274 275 276 277 278 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) supported_signing_algorithms () \u00b6 Return the list of supported signature algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 260 261 262 263 264 265 266 267 268 269 270 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] to_pem_key ( password = None ) \u00b6 Serialize this key to PEM format. For private keys, you can provide a password for encryption. Parameters: Name Type Description Default password Optional [ bytes ] password to use to encrypt the PEM None Returns: Type Description bytes the PEM encrypted key Source code in jwskate/jwk/ec.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def to_pem_key ( self , password : Optional [ bytes ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM encrypted key \"\"\" if self . is_private : assert isinstance ( self . cryptography_key , ec . EllipticCurvePrivateKey ) encryption : serialization . KeySerializationEncryption if password : encryption = serialization . BestAvailableEncryption ( password ) else : encryption = serialization . NoEncryption () return self . cryptography_key . private_bytes ( # type: ignore[no-any-return, attr-defined] serialization . Encoding . PEM , serialization . PrivateFormat . PKCS8 , encryption , ) else : assert isinstance ( self . cryptography_key , ec . EllipticCurvePublicKey ) if password : raise ValueError ( \"Public keys cannot be encrypted when serialized in PEM format.\" ) return self . cryptography_key . public_bytes ( serialization . Encoding . PEM , serialization . PublicFormat . SubjectPublicKeyInfo , ) x_coordinate () \u00b6 Return the x coordinate from this ECJwk. Returns: Type Description int the x coordinate (from parameter x ) Source code in jwskate/jwk/ec.py 233 234 235 236 237 238 239 240 @cached_property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () y_coordinate () \u00b6 Return the y coordinate from this ECJwk. Returns: Type Description int the y coordinate (from parameter y ) Source code in jwskate/jwk/ec.py 242 243 244 245 246 247 248 249 @cached_property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () ES256 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256 Source code in jwskate/jwa/signature/ec.py 57 58 59 60 61 62 63 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 () ES256K \u00b6 Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256 Source code in jwskate/jwa/signature/ec.py 84 85 86 87 88 89 90 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 () ES384 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384 Source code in jwskate/jwa/signature/ec.py 66 67 68 69 70 71 72 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 () ES512 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512 Source code in jwskate/jwa/signature/ec.py 75 76 77 78 79 80 81 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 () EcdhEs \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ]] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate/jwa/key_mgmt/ecdh.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = ( ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ) private_key_class = ( ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ) @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" if isinstance ( private_key , ec . EllipticCurvePrivateKey ) and isinstance ( public_key , ec . EllipticCurvePublicKey ): shared_key = private_key . exchange ( ec . ECDH (), public_key ) elif isinstance ( private_key , x25519 . X25519PrivateKey ) and isinstance ( public_key , x25519 . X25519PublicKey ): shared_key = private_key . exchange ( public_key ) elif isinstance ( private_key , x448 . X448PrivateKey ) and isinstance ( public_key , x448 . X448PublicKey ): shared_key = private_key . exchange ( public_key ) else : raise ValueError ( \"Invalid or unsupported private/public key combination for ECDH\" , private_key , public_key , ) return BinaPy ( shared_key ) @classmethod def derive ( cls , * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], otherinfo : bytes , key_size : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter key_size: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = key_size // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self , ) -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ]: \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" if isinstance ( self . key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ) ): return ec . generate_private_key ( self . key . curve ) elif isinstance ( self . key , ( x25519 . X25519PrivateKey , x25519 . X25519PublicKey )): return x25519 . X25519PrivateKey . generate () elif isinstance ( self . key , ( x448 . X448PublicKey , x448 . X448PrivateKey )): return x448 . X448PrivateKey . generate () def sender_key ( self , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = ephemeral_private_key , public_key = key , otherinfo = otherinfo , key_size = key_size , ) return cek def recipient_key ( self , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = key , public_key = ephemeral_public_key , otherinfo = otherinfo , key_size = key_size , ) return cek derive ( * , private_key , public_key , otherinfo , key_size ) classmethod \u00b6 Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the private key required public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required key_size int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate/jwa/key_mgmt/ecdh.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 @classmethod def derive ( cls , * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], otherinfo : bytes , key_size : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter key_size: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = key_size // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) ecdh ( private_key , public_key ) classmethod \u00b6 This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] a private EC key required public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate/jwa/key_mgmt/ecdh.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @classmethod def ecdh ( cls , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" if isinstance ( private_key , ec . EllipticCurvePrivateKey ) and isinstance ( public_key , ec . EllipticCurvePublicKey ): shared_key = private_key . exchange ( ec . ECDH (), public_key ) elif isinstance ( private_key , x25519 . X25519PrivateKey ) and isinstance ( public_key , x25519 . X25519PublicKey ): shared_key = private_key . exchange ( public_key ) elif isinstance ( private_key , x448 . X448PrivateKey ) and isinstance ( public_key , x448 . X448PublicKey ): shared_key = private_key . exchange ( public_key ) else : raise ValueError ( \"Invalid or unsupported private/public key combination for ECDH\" , private_key , public_key , ) return BinaPy ( shared_key ) generate_ephemeral_key () \u00b6 Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate/jwa/key_mgmt/ecdh.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_ephemeral_key ( self , ) -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ]: \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" if isinstance ( self . key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ) ): return ec . generate_private_key ( self . key . curve ) elif isinstance ( self . key , ( x25519 . X25519PrivateKey , x25519 . X25519PublicKey )): return x25519 . X25519PrivateKey . generate () elif isinstance ( self . key , ( x448 . X448PublicKey , x448 . X448PrivateKey )): return x448 . X448PrivateKey . generate () otherinfo ( alg , apu , apv , keysize ) classmethod \u00b6 Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required keysize int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate/jwa/key_mgmt/ecdh.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) recipient_key ( ephemeral_public_key , * , alg , key_size , ** headers ) \u00b6 Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate/jwa/key_mgmt/ecdh.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def recipient_key ( self , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = key , public_key = ephemeral_public_key , otherinfo = otherinfo , key_size = key_size , ) return cek sender_key ( ephemeral_private_key , * , alg , key_size , ** headers ) \u00b6 Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate/jwa/key_mgmt/ecdh.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def sender_key ( self , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = ephemeral_private_key , public_key = key , otherinfo = otherinfo , key_size = key_size , ) return cek EcdhEs_A128KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 267 268 269 270 271 272 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW EcdhEs_A192KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 275 276 277 278 279 280 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW EcdhEs_A256KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 283 284 285 286 287 288 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW EdDsa \u00b6 Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate/jwa/signature/eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False EllipticCurve dataclass \u00b6 A descriptive class for Elliptic Curves. Elliptic Curves have a name, a cryptography.ec.EllipticCurve , and a coordinate size. Source code in jwskate/jwa/ec.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @dataclass class EllipticCurve : \"\"\"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size. \"\"\" name : str \"\"\" Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` or `enc` fields in JOSE headers.\"\"\" cryptography_curve : ec . EllipticCurve \"\"\"`cryptography` curve instance.\"\"\" coordinate_size : int \"\"\"Coordinate size, in bytes.\"\"\" instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key: an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) @classmethod def get_jwk_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a dict of JWK parameters matching that key Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) public_numbers : ec . EllipticCurvePublicNumbers if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () y = BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters coordinate_size : int class-attribute \u00b6 Coordinate size, in bytes. cryptography_curve : ec . EllipticCurve class-attribute \u00b6 cryptography curve instance. instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} class-attribute \u00b6 Registry of subclasses, in a {name: instance} mapping. name : str class-attribute \u00b6 Curve name as defined in IANA JOSE . This name will appear in alg or enc fields in JOSE headers. __post_init__ () \u00b6 Automatically register subclasses in the instance registry. Source code in jwskate/jwa/ec.py 34 35 36 def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self generate () \u00b6 Generate a new EC key on this curve. Returns: Type Description Tuple [ int , int , int ] a tuple of 4 int s: x and y coordinates (public key) and d (private key) Source code in jwskate/jwa/ec.py 38 39 40 41 42 43 44 45 46 47 48 49 def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d get_curve ( key ) classmethod \u00b6 Get the appropriate EllipticCurve instance for a given cryptography EllipticCurvePublicKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] an Elliptic Curve private or public key from cryptography . required Returns: Type Description EllipticCurve the appropriate instance of EllipticCurve for the given key. Raises: Type Description NotImplementedError if the curve is not supported Source code in jwskate/jwa/ec.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key: an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) get_jwk_parameters ( key ) classmethod \u00b6 Extract all private and public parameters from a given cryptography EllipticCurvePrivateKey or EllipticCurvePublicKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] an Elliptic Curve public or private key from cryptography . required Returns: Type Description Dict [ str , Any ] a dict of JWK parameters matching that key Raises: Type Description TypeError if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey Source code in jwskate/jwa/ec.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @classmethod def get_jwk_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a dict of JWK parameters matching that key Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) public_numbers : ec . EllipticCurvePublicNumbers if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () y = BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters EncryptedJwt \u00b6 Bases: Jwt Represent an encrypted JWT. Parameters: Name Type Description Default value Union [ bytes , str ] the serialized JWT value required Source code in jwskate/jwt/encrypted.py 8 9 10 11 12 13 14 15 16 class EncryptedJwt ( Jwt ): \"\"\"Represent an encrypted JWT. Args: value: the serialized JWT value \"\"\" def __init__ ( self , value : Union [ bytes , str ]): raise NotImplementedError EncryptionAlgs \u00b6 Identifiers for Encryption algorithms. Source code in jwskate/enums.py 40 41 42 43 44 45 46 47 48 49 50 class EncryptionAlgs : \"\"\"Identifiers for Encryption algorithms.\"\"\" A128CBC_HS256 = \"A128CBC-HS256\" A192CBC_HS384 = \"A192CBC-HS384\" A256CBC_HS512 = \"A256CBC-HS512\" A128GCM = \"A128GCM\" A192GCM = \"A192GCM\" A256GCM = \"A256GCM\" ALL = [ A128CBC_HS256 , A192CBC_HS384 , A256CBC_HS512 , A128GCM , A192GCM , A256GCM ] ExpectedAlgRequired \u00b6 Bases: ValueError Raised when the expected signature alg(s) must be provided. Source code in jwskate/jwk/alg.py 13 14 class ExpectedAlgRequired ( ValueError ): \"\"\"Raised when the expected signature alg(s) must be provided.\"\"\" ExpiredJwt \u00b6 Bases: ValueError Raised when trying to validate an expired JWT token. Source code in jwskate/jwt/signed.py 14 15 class ExpiredJwt ( ValueError ): \"\"\"Raised when trying to validate an expired JWT token.\"\"\" HS256 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-256 Source code in jwskate/jwa/signature/hmac.py 31 32 33 34 35 36 37 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256\"\"\" name = \"HS256\" description = __doc__ hash_alg = hashes . SHA256 () min_key_size = 256 HS384 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-384 Source code in jwskate/jwa/signature/hmac.py 40 41 42 43 44 45 46 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384\"\"\" name = \"HS384\" description = __doc__ hash_alg = hashes . SHA384 () min_key_size = 384 HS512 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-512 Source code in jwskate/jwa/signature/hmac.py 49 50 51 52 53 54 55 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512\"\"\" name = \"HS512\" description = __doc__ hash_alg = hashes . SHA512 () min_key_size = 512 InvalidClaim \u00b6 Bases: ValueError Raised when trying to validate a JWT with unexpected claims. Source code in jwskate/jwt/signed.py 22 23 class InvalidClaim ( ValueError ): \"\"\"Raised when trying to validate a JWT with unexpected claims.\"\"\" InvalidJwe \u00b6 Bases: ValueError Raised when an invalid JWE token is parsed. Source code in jwskate/jwe/compact.py 20 21 class InvalidJwe ( ValueError ): \"\"\"Raised when an invalid JWE token is parsed.\"\"\" InvalidJwk \u00b6 Bases: ValueError Raised when an invalid JWK is encountered. Source code in jwskate/jwk/base.py 48 49 class InvalidJwk ( ValueError ): \"\"\"Raised when an invalid JWK is encountered.\"\"\" InvalidJws \u00b6 Bases: ValueError Raised when an invalid Jws is parsed. Source code in jwskate/jws/compact.py 19 20 class InvalidJws ( ValueError ): \"\"\"Raised when an invalid Jws is parsed.\"\"\" InvalidJwt \u00b6 Bases: ValueError Raised when an invalid Jwt is parsed. Source code in jwskate/jwt/base.py 17 18 class InvalidJwt ( ValueError ): \"\"\"Raised when an invalid Jwt is parsed.\"\"\" InvalidSignature \u00b6 Bases: ValueError Raised when trying to validate a JWT with an invalid signature. Source code in jwskate/jwt/signed.py 18 19 class InvalidSignature ( ValueError ): \"\"\"Raised when trying to validate a JWT with an invalid signature.\"\"\" JweCompact \u00b6 Bases: BaseCompactToken Represents a Json Web Encryption object, in compact representation, as defined in RFC7516. Parameters: Name Type Description Default value Union [ bytes , str ] the compact representation for this Jwe required Source code in jwskate/jwe/compact.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 class JweCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Encryption object, in compact representation, as defined in RFC7516. Args: value: the compact representation for this Jwe \"\"\" def __init__ ( self , value : Union [ bytes , str ]): super () . __init__ ( value ) if self . value . count ( b \".\" ) != 4 : raise InvalidJwe ( \"Invalid JWE: a JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots.\" ) header , cek , iv , ciphertext , auth_tag = self . value . split ( b \".\" ) try : headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) enc = headers . get ( \"enc\" ) if enc is None or not isinstance ( enc , str ): raise InvalidJwe ( \"Invalid JWE header: this JWE doesn't have a valid 'enc' header.\" ) self . headers = headers self . additional_authenticated_data = header except ValueError : raise InvalidJwe ( \"Invalid JWE header: it must be a Base64URL-encoded JSON object.\" ) try : self . wrapped_cek = BinaPy ( cek ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE CEK: it must be a Base64URL-encoded binary data (bytes).\" ) try : self . initialization_vector = BinaPy ( iv ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE IV: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . ciphertext = BinaPy ( ciphertext ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . authentication_tag = BinaPy ( auth_tag ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def from_parts ( cls , * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ), BinaPy ( cek ) . to ( \"b64u\" ), BinaPy ( iv ) . to ( \"b64u\" ), BinaPy ( ciphertext ) . to ( \"b64u\" ), BinaPy ( tag ) . to ( \"b64u\" ), ) ) ) @cached_property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" return self . get_header ( \"enc\" ) # type: ignore[no-any-return] # header has been checked at init time @classmethod def encrypt ( cls , plaintext : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext and return the resulting JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use enc: the CEK encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" jwk = Jwk ( jwk ) extra_headers = extra_headers or {} cek_jwk , wrapped_cek , cek_headers = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) PBES2_ALGORITHMS : Mapping [ str , Type [ BasePbes2 ]] = { alg . name : alg for alg in [ Pbes2_HS256_A128KW , Pbes2_HS384_A192KW , Pbes2_HS512_A256KW ] } def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> bytes : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: bytes: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext @classmethod def encrypt_with_password ( cls , plaintext : bytes , password : Union [ bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '. \" f \"Value must be one of { list ( cls . PBES2_ALGORITHMS . keys ()) } .\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000.\" ) wrapped_cek = wrapper . wrap_key ( cek , salt = salt , count = count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . to ( \"b64u\" ) . ascii (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '. \" f \"Value must be one of { list ( self . PBES2_ALGORITHMS . keys ()) } .\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2s' header is missing.\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2c' header is missing.\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise InvalidJwe ( \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt = salt , count = p2c ) return SymmetricJwk . from_bytes ( cek ) def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext decrypt ( jwk ) \u00b6 Decrypts this Jwe payload using a JWK. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required Returns: Name Type Description bytes bytes the decrypted payload Source code in jwskate/jwe/compact.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> bytes : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: bytes: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext decrypt_with_password ( password ) \u00b6 Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Parameters: Name Type Description Default password Union [ bytes , str ] the password to use required Returns: Type Description bytes the unencrypted payload Source code in jwskate/jwe/compact.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext enc () \u00b6 Return the enc from the JWE header. The enc header contains the identifier of the CEK encryption algorithm. Returns: Type Description str the enc value Raises: Type Description AttributeError if there is no enc header or it is not a string Source code in jwskate/jwe/compact.py 116 117 118 119 120 121 122 123 124 125 126 127 128 @cached_property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" return self . get_header ( \"enc\" ) # type: ignore[no-any-return] encrypt ( plaintext , jwk , * , enc , alg = None , extra_headers = None , cek = None , iv = None , epk = None ) classmethod \u00b6 Encrypt an arbitrary plaintext and return the resulting JweCompact. Parameters: Name Type Description Default plaintext bytes the raw plaintext to encrypt required jwk Union [ Jwk , Dict [ str , Any ]] the public or symmetric key to use required enc str the CEK encryption algorithm to use required alg Optional [ str ] the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the generated token None cek Optional [ bytes ] the CEK to force use, for algorithms relying on a random CEK. Leave None to have a safe value generated by jwskate . None iv Optional [ bytes ] the IV to force use. Leave None to have a safe value generated by jwskate . None epk Optional [ Jwk ] the EPK to force use. Leave None to have a safe value generated by jwskate . None Returns: Type Description JweCompact the generated JweCompact instance Source code in jwskate/jwe/compact.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 @classmethod def encrypt ( cls , plaintext : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext and return the resulting JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use enc: the CEK encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" jwk = Jwk ( jwk ) extra_headers = extra_headers or {} cek_jwk , wrapped_cek , cek_headers = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) encrypt_with_password ( plaintext , password , * , alg , enc , salt = None , count = 2000 , cek = None , iv = None ) classmethod \u00b6 Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Parameters: Name Type Description Default plaintext bytes the data to encrypt required password Union [ bytes , str ] the password to use required alg str the Key Management alg to use required enc str the Payload Encryption alg to use required salt Optional [ bytes ] the salt to use. Leave None (default) to have jwskate generate a safe random value None count int the number of PBES2 iterations (recommended minimum 1000) 2000 cek Optional [ bytes ] the CEK to force use. Leave None (default) to have jwskate generate a safe random value None iv Optional [ bytes ] the IV to force use. Leave None (default) to have jwskate generate a safe random value None Returns: Type Description JweCompact the resulting JweCompact Raises: Type Description UnsupportedAlg if the key management alg is not supported ValueError if the count parameter is not a positive integer Source code in jwskate/jwe/compact.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 @classmethod def encrypt_with_password ( cls , plaintext : bytes , password : Union [ bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '. \" f \"Value must be one of { list ( cls . PBES2_ALGORITHMS . keys ()) } .\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000.\" ) wrapped_cek = wrapper . wrap_key ( cek , salt = salt , count = count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . to ( \"b64u\" ) . ascii (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) from_parts ( * , headers , cek , iv , ciphertext , tag ) classmethod \u00b6 Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Parameters: Name Type Description Default headers Mapping [ str , Any ] the headers (as a mapping of name: value) required cek bytes the raw cek required iv bytes the raw iv required ciphertext bytes the raw ciphertext required tag bytes the authentication tag required Returns: Type Description JweCompact the initialized JweCompact instance Source code in jwskate/jwe/compact.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @classmethod def from_parts ( cls , * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ), BinaPy ( cek ) . to ( \"b64u\" ), BinaPy ( iv ) . to ( \"b64u\" ), BinaPy ( ciphertext ) . to ( \"b64u\" ), BinaPy ( tag ) . to ( \"b64u\" ), ) ) ) unwrap_cek ( jwk_or_password ) \u00b6 Unwrap the CEK from this JWE token using the provided key or password. Parameters: Name Type Description Default jwk_or_password Union [ Jwk , Dict [ str , Any ], bytes , str ] the decryption JWK or password required Returns: Type Description Jwk the unwrapped CEK, as a SymmetricJwk Source code in jwskate/jwe/compact.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek unwrap_cek_with_password ( password ) \u00b6 Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Parameters: Name Type Description Default password Union [ bytes , str ] the decryption password required Returns: Type Description Jwk the CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the token key management algorithm is not supported AttributeError if the token misses the PBES2-related headers Source code in jwskate/jwe/compact.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '. \" f \"Value must be one of { list ( self . PBES2_ALGORITHMS . keys ()) } .\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2s' header is missing.\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2c' header is missing.\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise InvalidJwe ( \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt = salt , count = p2c ) return SymmetricJwk . from_bytes ( cek ) Jwk \u00b6 Bases: BaseJsonDict Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class: Jwk is a dict, so you can do with a Jwk anything you can do with a dict . In addition, all keys parameters are exposed as attributes. There are subclasses of Jwk for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Parameters: Name Type Description Default params Union [ Dict [ str , Any ], Any ] a dict with the parsed Jwk parameters, or a cryptography key , or another Jwk required include_kid_thumbprint bool if True (default), and there is no kid in the provided params, generate a kid based on the key thumbprint False Source code in jwskate/jwk/base.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 class Jwk ( BaseJsonDict ): \"\"\"Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class:`Jwk` is a dict, so you can do with a Jwk anything you can do with a `dict`. In addition, all keys parameters are exposed as attributes. There are subclasses of `Jwk` for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Args: params: a dict with the parsed Jwk parameters, or a `cryptography key`, or another `Jwk` include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint \"\"\" subclasses : Dict [ str , Type [ Jwk ]] = {} \"\"\"A dict of 'kty' values to subclasses implementing each specific Key Type\"\"\" cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} \"\"\"A dict of cryptography key classes to its specific 'kty' value\"\"\" PARAMS : Mapping [ str , JwkParameter ] \"\"\"A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)\"\"\" KTY : ClassVar [ str ] \"\"\"The Key Type associated with this JWK.\"\"\" CRYPTOGRAPHY_KEY_CLASSES : ClassVar [ Iterable [ Any ]] SIGNATURE_ALGORITHMS : Mapping [ str , Type [ BaseSignatureAlg ]] = {} KEY_MANAGEMENT_ALGORITHMS : Mapping [ str , Type [ BaseKeyManagementAlg ]] = {} ENCRYPTION_ALGORITHMS : Mapping [ str , Type [ BaseAESEncryptionAlg ]] = {} IANA_HASH_FUNCTION_NAMES : Mapping [ str , str ] = { # IANA registered names to binapy hash name \"sha-1\" : \"sha1\" , \"sha-224\" : \"sha224\" , \"sha-256\" : \"sha256\" , \"sha-384\" : \"sha384\" , \"sha-512\" : \"sha512\" , \"shake128\" : \"shake128\" , \"shake256\" : \"shake256\" , } def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls def __new__ ( cls , key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key **kwargs: additional members to include in the Jwk \"\"\" if cls == Jwk : if isinstance ( key , Jwk ): return cls . from_cryptography_key ( key . cryptography_key , ** kwargs ) if isinstance ( key , dict ): kty : Optional [ str ] = key . get ( \"kty\" ) if kty is None : raise InvalidJwk ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise InvalidJwk ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) elif isinstance ( key , str ): return cls . from_json ( key ) else : return cls . from_cryptography_key ( key , ** kwargs ) return super () . __new__ ( cls , key , ** kwargs ) def __init__ ( self , params : Union [ Dict [ str , Any ], Any ], include_kid_thumbprint : bool = False ): if isinstance ( params , dict ): # this is to avoid double init due to the __new__ above super () . __init__ ( { key : val for key , val in params . items () if val is not None } ) self . _validate () if self . get ( \"kid\" ) is None and include_kid_thumbprint : self [ \"kid\" ] = self . thumbprint () try : self . cryptography_key = self . _to_cryptography_key () except AttributeError as exc : raise InvalidJwk () from exc @property def is_private ( self ) -> bool : \"\"\"Return `True` if the key is private, `False` otherwise. Returns: `True` if the key is private, `False` otherwise \"\"\" return True def __getattr__ ( self , item : str ) -> Any : \"\"\"Allows access to key parameters as attributes, like `jwk.kid`, `jwk.kty`, instead of `jwk['kid']`, `jwk['kty']`, etc. Args: item: the member to access Return: the member value Raises: AttributeError: if the member is not found \"\"\" value = self . get ( item ) if value is None : raise AttributeError ( item ) return value def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Override base method to avoid modifying cryptographic key attributes. Args: key: name of the attribute to set value: value to set Raises: RuntimeError: when trying to modify cryptographic attributes \"\"\" if key in self . PARAMS : raise RuntimeError ( \"JWK key attributes cannot be modified.\" ) super () . __setitem__ ( key , value ) def thumbprint ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" alg = self . IANA_HASH_FUNCTION_NAMES . get ( hashalg ) if not alg : raise ValueError ( f \"Unsupported hash alg { hashalg } \" ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) return ( BinaPy . serialize_to ( \"json\" , t , separators = ( \",\" , \":\" ), sort_keys = True ) . to ( alg ) . to ( \"b64u\" ) . ascii () ) def thumbprint_uri ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Returns the JWK thumbprint URI for this key. Args: hashalg: the IANA registered name for the hash alg to use Returns: the JWK thumbprint uri for this Jwk \"\"\" return ( f \"urn:ietf:params:oauth:jwk-thumbprint: { hashalg } : { self . thumbprint ( hashalg ) } \" ) @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): raise TypeError ( f \"Invalid alg type { type ( str ) } \" , alg ) return alg def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : # pragma: no cover raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"decrypt\" , \"unwrapKey\" ) and not self . is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } key_ops = self . get ( \"key_ops\" ) if key_ops : if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"decrypt\" in key_ops : key_ops . remove ( \"decrypt\" ) key_ops . append ( \"encrypt\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) def sign ( self , data : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" sigalg = select_alg ( self . alg , alg , self . SIGNATURE_ALGORITHMS ) wrapper : BaseSignatureAlg if issubclass ( sigalg , BaseAsymmetricAlg ): wrapper = sigalg ( self . cryptography_key ) elif issubclass ( sigalg , BaseSymmetricAlg ): wrapper = sigalg ( self . key ) signature = wrapper . sign ( data ) return BinaPy ( signature ) def verify ( self , data : bytes , signature : bytes , * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" wrapper : BaseSignatureAlg for sigalg in select_algs ( self . alg , alg , algs , self . SIGNATURE_ALGORITHMS ): if issubclass ( sigalg , BaseAsymmetricAlg ): key = self . public_jwk () . cryptography_key wrapper = sigalg ( key ) elif issubclass ( sigalg , BaseSymmetricAlg ): key = self . key wrapper = sigalg ( key ) if wrapper . verify ( data , signature ): return True return False def encrypt ( self , plaintext : bytes , * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Initialization Vector and the Authentication Tag. Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector that was used to encrypt the data. If `iv` is passed as parameter, this will return that same value. Otherwise, an IV is generated. Returns: a tuple (ciphertext, iv, authentication_tag), as raw data \"\"\" raise NotImplementedError # pragma: no cover def decrypt ( self , ciphertext : bytes , * , iv : bytes , tag : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt iv: the Initialization Vector (IV) that was used for encryption tag: the Authentication Tag that will be verified while decrypting data aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover def sender_key ( self , enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]]: \"\"\"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. Returns a tuple with 3 items: - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key! - the encrypted CEK, as bytes. You must send this to your recipient. This may be empty for algs which derive a CEK instead of generating one. - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send this to your recipient as well. For algorithms that rely on a randomly generated CEK, you can provide that value instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only use this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: Tuple[Jwk,BinaPy,Mapping[str,Any]]: a tuple (cek, wrapped_cek, additional_headers_map) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) cek_headers : Dict [ str , Any ] = {} if issubclass ( keyalg , BaseRsaKeyWrap ): rsa : BaseRsaKeyWrap = keyalg ( self . public_jwk () . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = rsa . wrap_key ( cek ) elif issubclass ( keyalg , EcdhEs ): ecdh : EcdhEs = keyalg ( self . public_jwk () . cryptography_key ) epk = epk or Jwk . from_cryptography_key ( ecdh . generate_ephemeral_key ()) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( ecdh , BaseEcdhEs_AesKw ): if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = ecdh . wrap_key_with_epk ( cek , epk . cryptography_key , alg = keyalg . name , ** headers ) else : cek = ecdh . sender_key ( epk . cryptography_key , alg = encalg . name , key_size = encalg . key_size , ** headers , ) wrapped_cek = BinaPy ( b \"\" ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes : BaseAesKeyWrap = keyalg ( self . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = aes . wrap_key ( cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm : BaseAesGcmKeyWrap = keyalg ( self . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek iv = aesgcm . generate_iv () wrapped_cek , tag = aesgcm . wrap_key ( cek , iv = iv ) cek_headers = { \"iv\" : iv . to ( \"b64u\" ) . ascii (), \"tag\" : tag . to ( \"b64u\" ) . ascii (), } elif issubclass ( keyalg , DirectKeyUse ): dir : DirectKeyUse = keyalg ( self . key ) cek = dir . direct_key ( encalg ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ), wrapped_cek , cek_headers def recipient_key ( self , wrapped_cek : bytes , enc : str , * , alg : Optional [ str ] = None , ** headers : Any ) -> Jwk : \"\"\"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Args: wrapped_cek: the wrapped CEK enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to unwrap the CEK **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . cryptography_key ) cek = rsa . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , EcdhEs ): ecdh = keyalg ( self . cryptography_key ) epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . cryptography_key encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if isinstance ( ecdh , BaseEcdhEs_AesKw ): cek = ecdh . unwrap_key_with_epk ( wrapped_cek , epk , alg = keyalg . name ) else : cek = ecdh . recipient_key ( epk , alg = encalg . name , key_size = encalg . key_size , ** headers ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes = keyalg ( self . cryptography_key ) cek = aes . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm = keyalg ( self . cryptography_key ) iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = aesgcm . unwrap_key ( wrapped_cek , tag = tag , iv = iv ) elif issubclass ( keyalg , DirectKeyUse ): dir_ = keyalg ( self . key ) cek = dir_ . direct_key ( encalg ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key , ** kwargs ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) def _to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError @classmethod def from_pem_key ( cls , data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any , ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: a Jwk instance from the loaded key \"\"\" if isinstance ( data , str ): data = data . encode () if isinstance ( password , str ): password = password . encode () try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception as private_exc : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) from private_exc return cls . from_cryptography_key ( cryptography_key , ** kwargs ) def to_pem_key ( self , password : Optional [ bytes ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM serialized key \"\"\" raise NotImplementedError @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs ) @classmethod def generate_for_alg ( cls , alg : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key for usage with a specific alg and return the resuting Jwk. Args: alg: a signature or key management alg **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk \"\"\" raise NotImplementedError def copy ( self ) -> Jwk : \"\"\"Creates a copy of this key. Returns: a copy of this key, with the same value \"\"\" return Jwk ( super () . copy ()) def include_kid_thumbprint ( self , force : bool = False ) -> Jwk : \"\"\"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if `force` is `True`, this erases the previous \"kid\". - if `force` is `False` (default), do nothing. Args: force: whether to overwrite a previously existing kid Returns: a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`). \"\"\" jwk = self . copy () if self . kid is None or force : jwk [ \"kid\" ] = self . thumbprint () return jwk KTY : ClassVar [ str ] class-attribute \u00b6 The Key Type associated with this JWK. PARAMS : Mapping [ str , JwkParameter ] class-attribute \u00b6 A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind) cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} class-attribute \u00b6 A dict of cryptography key classes to its specific 'kty' value subclasses : Dict [ str , Type [ Jwk ]] = {} class-attribute \u00b6 A dict of 'kty' values to subclasses implementing each specific Key Type __getattr__ ( item ) \u00b6 Allows access to key parameters as attributes, like jwk.kid , jwk.kty , instead of jwk['kid'] , jwk['kty'] , etc. Parameters: Name Type Description Default item str the member to access required Return the member value Raises: Type Description AttributeError if the member is not found Source code in jwskate/jwk/base.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allows access to key parameters as attributes, like `jwk.kid`, `jwk.kty`, instead of `jwk['kid']`, `jwk['kty']`, etc. Args: item: the member to access Return: the member value Raises: AttributeError: if the member is not found \"\"\" value = self . get ( item ) if value is None : raise AttributeError ( item ) return value __init_subclass__ () \u00b6 Automatically add subclasses to the registry. This allows new to pick the appropriate subclass when creating a Jwk Source code in jwskate/jwk/base.py 106 107 108 109 110 111 112 113 114 def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls __new__ ( key , ** kwargs ) \u00b6 Overridden __new__ to make the Jwk constructor smarter. The Jwk constructor will accept a dict with the parsed Jwk content another Jwk, which will be used as-is instead of creating a copy an instance from a cryptography public or private key class Parameters: Name Type Description Default key Union [ Jwk , Dict [ str , Any ], Any ] a dict containing JWK parameters, or another Jwk instance, or a cryptography key required **kwargs Any additional members to include in the Jwk {} Source code in jwskate/jwk/base.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def __new__ ( cls , key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key **kwargs: additional members to include in the Jwk \"\"\" if cls == Jwk : if isinstance ( key , Jwk ): return cls . from_cryptography_key ( key . cryptography_key , ** kwargs ) if isinstance ( key , dict ): kty : Optional [ str ] = key . get ( \"kty\" ) if kty is None : raise InvalidJwk ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise InvalidJwk ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) elif isinstance ( key , str ): return cls . from_json ( key ) else : return cls . from_cryptography_key ( key , ** kwargs ) return super () . __new__ ( cls , key , ** kwargs ) __setitem__ ( key , value ) \u00b6 Override base method to avoid modifying cryptographic key attributes. Parameters: Name Type Description Default key str name of the attribute to set required value Any value to set required Raises: Type Description RuntimeError when trying to modify cryptographic attributes Source code in jwskate/jwk/base.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Override base method to avoid modifying cryptographic key attributes. Args: key: name of the attribute to set value: value to set Raises: RuntimeError: when trying to modify cryptographic attributes \"\"\" if key in self . PARAMS : raise RuntimeError ( \"JWK key attributes cannot be modified.\" ) super () . __setitem__ ( key , value ) alg () property \u00b6 Return the configured key alg, if any. Returns: Type Description Optional [ str ] the key alg Source code in jwskate/jwk/base.py 253 254 255 256 257 258 259 260 261 262 263 @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): raise TypeError ( f \"Invalid alg type { type ( str ) } \" , alg ) return alg as_jwks () \u00b6 Return a JwkSet with this key as single element. Returns: Type Description JwkSet a JwsSet with this single key Source code in jwskate/jwk/base.py 387 388 389 390 391 392 393 394 395 def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) copy () \u00b6 Creates a copy of this key. Returns: Type Description Jwk a copy of this key, with the same value Source code in jwskate/jwk/base.py 798 799 800 801 802 803 804 def copy ( self ) -> Jwk : \"\"\"Creates a copy of this key. Returns: a copy of this key, with the same value \"\"\" return Jwk ( super () . copy ()) decrypt ( ciphertext , * , iv , tag , aad = None , alg = None ) \u00b6 Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required iv bytes the Initialization Vector (IV) that was used for encryption required tag bytes the Authentication Tag that will be verified while decrypting data required aad Optional [ bytes ] the Additional Authentication Data (AAD) to verify the Tag against None alg Optional [ str ] the alg to use for decryption None Returns: Type Description BinaPy the clear-text data Source code in jwskate/jwk/base.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def decrypt ( self , ciphertext : bytes , * , iv : bytes , tag : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt iv: the Initialization Vector (IV) that was used for encryption tag: the Authentication Tag that will be verified while decrypting data aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover encrypt ( plaintext , * , aad = None , alg = None , iv = None ) \u00b6 Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Initialization Vector and the Authentication Tag. Parameters: Name Type Description Default plaintext bytes the data to encrypt. required aad Optional [ bytes ] the Additional Authenticated Data (AAD) to include in the authentication tag None alg Optional [ str ] the alg to use to encrypt the data None iv Optional [ bytes ] the Initialization Vector that was used to encrypt the data. If iv is passed as parameter, this None will return that same value. Otherwise, an IV is generated. Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a tuple (ciphertext, iv, authentication_tag), as raw data Source code in jwskate/jwk/base.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def encrypt ( self , plaintext : bytes , * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Initialization Vector and the Authentication Tag. Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector that was used to encrypt the data. If `iv` is passed as parameter, this will return that same value. Otherwise, an IV is generated. Returns: a tuple (ciphertext, iv, authentication_tag), as raw data \"\"\" raise NotImplementedError # pragma: no cover from_cryptography_key ( cryptography_key , ** kwargs ) classmethod \u00b6 Initialize a Jwk from a key from the cryptography library. The input key can be any private or public key supported by cryptography. Parameters: Name Type Description Default cryptography_key Any a cryptography key instance required **kwargs Any additional members to include in the Jwk (e.g. kid, use) {} Returns: Type Description Jwk the matching Jwk instance Raises: Type Description TypeError if the key type is not supported Source code in jwskate/jwk/base.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key , ** kwargs ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) from_pem_key ( data , password = None , ** kwargs ) classmethod \u00b6 Load a Jwk from a PEM encoded private or public key. Parameters: Name Type Description Default data Union [ bytes , str ] the PEM encoded data to load required password Union [ bytes , str , None] the password to decrypt the PEM, if required None **kwargs Any additional members to include in the Jwk (e.g. kid, use) {} Returns: Type Description Jwk a Jwk instance from the loaded key Source code in jwskate/jwk/base.py 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 @classmethod def from_pem_key ( cls , data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any , ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: a Jwk instance from the loaded key \"\"\" if isinstance ( data , str ): data = data . encode () if isinstance ( password , str ): password = password . encode () try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception as private_exc : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) from private_exc return cls . from_cryptography_key ( cryptography_key , ** kwargs ) generate ( ** kwargs ) classmethod \u00b6 Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Parameters: Name Type Description Default **kwargs Any specific parameters depending on the type of key, or additional members to include in the Jwk {} Returns: Type Description Jwk a Jwk instance with a generated key Source code in jwskate/jwk/base.py 754 755 756 757 758 759 760 761 762 763 764 @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError generate_for_alg ( alg , ** kwargs ) classmethod \u00b6 Generate a key for usage with a specific alg and return the resuting Jwk. Parameters: Name Type Description Default alg str a signature or key management alg required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Source code in jwskate/jwk/base.py 785 786 787 788 789 790 791 792 793 794 795 796 @classmethod def generate_for_alg ( cls , alg : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key for usage with a specific alg and return the resuting Jwk. Args: alg: a signature or key management alg **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk \"\"\" raise NotImplementedError generate_for_kty ( kty , ** kwargs ) classmethod \u00b6 Generate a key with a specific type and return the resulting Jwk. Parameters: Name Type Description Default kty str key type to generate required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Raises: Type Description UnsupportedKeyType if the key type is not supported Source code in jwskate/jwk/base.py 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs ) include_kid_thumbprint ( force = False ) \u00b6 Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if force is True , this erases the previous \"kid\". - if force is False (default), do nothing. Parameters: Name Type Description Default force bool whether to overwrite a previously existing kid False Returns: Type Description Jwk a copy of this key with a \"kid\" (either the previous one or the existing one, depending on force ). Source code in jwskate/jwk/base.py 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 def include_kid_thumbprint ( self , force : bool = False ) -> Jwk : \"\"\"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if `force` is `True`, this erases the previous \"kid\". - if `force` is `False` (default), do nothing. Args: force: whether to overwrite a previously existing kid Returns: a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`). \"\"\" jwk = self . copy () if self . kid is None or force : jwk [ \"kid\" ] = self . thumbprint () return jwk is_private () property \u00b6 Return True if the key is private, False otherwise. Returns: Type Description bool True if the key is private, False otherwise Source code in jwskate/jwk/base.py 165 166 167 168 169 170 171 172 @property def is_private ( self ) -> bool : \"\"\"Return `True` if the key is private, `False` otherwise. Returns: `True` if the key is private, `False` otherwise \"\"\" return True kty () property \u00b6 Return the Key Type. Returns: Type Description str the key type Source code in jwskate/jwk/base.py 244 245 246 247 248 249 250 251 @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY public_jwk () \u00b6 Return the public Jwk associated with this key. Returns: Type Description Jwk a Jwk with the public key Source code in jwskate/jwk/base.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } key_ops = self . get ( \"key_ops\" ) if key_ops : if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"decrypt\" in key_ops : key_ops . remove ( \"decrypt\" ) key_ops . append ( \"encrypt\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) recipient_key ( wrapped_cek , enc , * , alg = None , ** headers ) \u00b6 For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Parameters: Name Type Description Default wrapped_cek bytes the wrapped CEK required enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to unwrap the CEK None **headers Any additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) {} Returns: Type Description Jwk the clear-text CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate/jwk/base.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 def recipient_key ( self , wrapped_cek : bytes , enc : str , * , alg : Optional [ str ] = None , ** headers : Any ) -> Jwk : \"\"\"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Args: wrapped_cek: the wrapped CEK enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to unwrap the CEK **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . cryptography_key ) cek = rsa . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , EcdhEs ): ecdh = keyalg ( self . cryptography_key ) epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . cryptography_key encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if isinstance ( ecdh , BaseEcdhEs_AesKw ): cek = ecdh . unwrap_key_with_epk ( wrapped_cek , epk , alg = keyalg . name ) else : cek = ecdh . recipient_key ( epk , alg = encalg . name , key_size = encalg . key_size , ** headers ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes = keyalg ( self . cryptography_key ) cek = aes . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm = keyalg ( self . cryptography_key ) iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = aesgcm . unwrap_key ( wrapped_cek , tag = tag , iv = iv ) elif issubclass ( keyalg , DirectKeyUse ): dir_ = keyalg ( self . key ) cek = dir_ . direct_key ( encalg ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ) sender_key ( enc , * , alg = None , cek = None , epk = None , ** headers ) \u00b6 For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. Returns a tuple with 3 items: the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key! the encrypted CEK, as bytes. You must send this to your recipient. This may be empty for algs which derive a CEK instead of generating one. extra headers depending on the Key Management algorithm, as a dict of name to values: you must send this to your recipient as well. For algorithms that rely on a randomly generated CEK, you can provide that value instead of letting jwskate generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting jwskate generate an appropriate value for you. Only use this if you know what you are doing! Parameters: Name Type Description Default enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to produce the CEK None cek Optional [ bytes ] CEK to use (leave None to have an adequate random value generated automatically) None epk Optional [ Jwk ] EPK to use (leave None to have an adequate ephemeral key generated automatically) None **headers Any additional headers to include for the CEK derivation {} Returns: Type Description Tuple [ Jwk , BinaPy , Mapping [ str , Any ]] Tuple[Jwk,BinaPy,Mapping[str,Any]]: a tuple (cek, wrapped_cek, additional_headers_map) Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate/jwk/base.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 def sender_key ( self , enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]]: \"\"\"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. Returns a tuple with 3 items: - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key! - the encrypted CEK, as bytes. You must send this to your recipient. This may be empty for algs which derive a CEK instead of generating one. - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send this to your recipient as well. For algorithms that rely on a randomly generated CEK, you can provide that value instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only use this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: Tuple[Jwk,BinaPy,Mapping[str,Any]]: a tuple (cek, wrapped_cek, additional_headers_map) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) cek_headers : Dict [ str , Any ] = {} if issubclass ( keyalg , BaseRsaKeyWrap ): rsa : BaseRsaKeyWrap = keyalg ( self . public_jwk () . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = rsa . wrap_key ( cek ) elif issubclass ( keyalg , EcdhEs ): ecdh : EcdhEs = keyalg ( self . public_jwk () . cryptography_key ) epk = epk or Jwk . from_cryptography_key ( ecdh . generate_ephemeral_key ()) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( ecdh , BaseEcdhEs_AesKw ): if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = ecdh . wrap_key_with_epk ( cek , epk . cryptography_key , alg = keyalg . name , ** headers ) else : cek = ecdh . sender_key ( epk . cryptography_key , alg = encalg . name , key_size = encalg . key_size , ** headers , ) wrapped_cek = BinaPy ( b \"\" ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes : BaseAesKeyWrap = keyalg ( self . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = aes . wrap_key ( cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm : BaseAesGcmKeyWrap = keyalg ( self . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek iv = aesgcm . generate_iv () wrapped_cek , tag = aesgcm . wrap_key ( cek , iv = iv ) cek_headers = { \"iv\" : iv . to ( \"b64u\" ) . ascii (), \"tag\" : tag . to ( \"b64u\" ) . ascii (), } elif issubclass ( keyalg , DirectKeyUse ): dir : DirectKeyUse = keyalg ( self . key ) cek = dir . direct_key ( encalg ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ), wrapped_cek , cek_headers sign ( data , alg = None ) \u00b6 Sign a data using this Jwk, and return the generated signature. Parameters: Name Type Description Default data bytes the data to sign required alg Optional [ str ] the alg to use (if this key doesn't have an alg parameter) None Returns: Type Description BinaPy the generated signature Source code in jwskate/jwk/base.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def sign ( self , data : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" sigalg = select_alg ( self . alg , alg , self . SIGNATURE_ALGORITHMS ) wrapper : BaseSignatureAlg if issubclass ( sigalg , BaseAsymmetricAlg ): wrapper = sigalg ( self . cryptography_key ) elif issubclass ( sigalg , BaseSymmetricAlg ): wrapper = sigalg ( self . key ) signature = wrapper . sign ( data ) return BinaPy ( signature ) supported_encryption_algorithms () \u00b6 Return the list of Encryption algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 341 342 343 344 345 346 347 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) supported_key_management_algorithms () \u00b6 Return the list of Key Management algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 333 334 335 336 337 338 339 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) supported_signing_algorithms () \u00b6 Return the list of Signature algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 325 326 327 328 329 330 331 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) thumbprint ( hashalg = 'sha-256' ) \u00b6 Return the key thumbprint as specified by RFC 7638. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'sha-256' Returns: Type Description str the calculated thumbprint Source code in jwskate/jwk/base.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def thumbprint ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" alg = self . IANA_HASH_FUNCTION_NAMES . get ( hashalg ) if not alg : raise ValueError ( f \"Unsupported hash alg { hashalg } \" ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) return ( BinaPy . serialize_to ( \"json\" , t , separators = ( \",\" , \":\" ), sort_keys = True ) . to ( alg ) . to ( \"b64u\" ) . ascii () ) thumbprint_uri ( hashalg = 'sha-256' ) \u00b6 Returns the JWK thumbprint URI for this key. Parameters: Name Type Description Default hashalg str the IANA registered name for the hash alg to use 'sha-256' Returns: Type Description str the JWK thumbprint uri for this Jwk Source code in jwskate/jwk/base.py 231 232 233 234 235 236 237 238 239 240 241 242 def thumbprint_uri ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Returns the JWK thumbprint URI for this key. Args: hashalg: the IANA registered name for the hash alg to use Returns: the JWK thumbprint uri for this Jwk \"\"\" return ( f \"urn:ietf:params:oauth:jwk-thumbprint: { hashalg } : { self . thumbprint ( hashalg ) } \" ) to_pem_key ( password = None ) \u00b6 Serialize this key to PEM format. For private keys, you can provide a password for encryption. Parameters: Name Type Description Default password Optional [ bytes ] password to use to encrypt the PEM None Returns: Type Description bytes the PEM serialized key Source code in jwskate/jwk/base.py 741 742 743 744 745 746 747 748 749 750 751 752 def to_pem_key ( self , password : Optional [ bytes ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM serialized key \"\"\" raise NotImplementedError verify ( data , signature , * , alg = None , algs = None ) \u00b6 Verify a signature using this Jwk, and return True if valid. Parameters: Name Type Description Default data bytes the data to verify required signature bytes the signature to verify required alg Optional [ str ] the allowed signature alg, if there is only one None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate/jwk/base.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def verify ( self , data : bytes , signature : bytes , * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" wrapper : BaseSignatureAlg for sigalg in select_algs ( self . alg , alg , algs , self . SIGNATURE_ALGORITHMS ): if issubclass ( sigalg , BaseAsymmetricAlg ): key = self . public_jwk () . cryptography_key wrapper = sigalg ( key ) elif issubclass ( sigalg , BaseSymmetricAlg ): key = self . key wrapper = sigalg ( key ) if wrapper . verify ( data , signature ): return True return False JwkSet \u00b6 Bases: BaseJsonDict A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. a dict from the parsed JSON object representing this JwkSet (in paramter jwks ) a list of Jwk (in parameter keys nothing, to initialize an empty JwkSet Parameters: Name Type Description Default jwks Optional [ Dict [ str , Any ]] a dict, containing the JwkSet, parsed as a JSON object. None keys Optional [ Iterable [ Jwk ]] a list of Jwk , that will be added to this JwkSet None Source code in jwskate/jwk/jwks.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 class JwkSet ( BaseJsonDict ): \"\"\"A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`) - a list of `Jwk` (in parameter `keys` - nothing, to initialize an empty JwkSet Args: jwks: a dict, containing the JwkSet, parsed as a JSON object. keys: a list of `Jwk`, that will be added to this JwkSet \"\"\" def __init__ ( self , jwks : Optional [ Dict [ str , Any ]] = None , keys : Optional [ Iterable [ Jwk ]] = None , ): if jwks is None and keys is None : keys = [] if jwks is not None : keys = jwks . pop ( \"keys\" , []) super () . __init__ ( jwks ) # init the dict with all the dict content that is not keys else : super () . __init__ () if keys is not None : for jwk in keys : self . add_jwk ( jwk ) @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" if not isinstance ( jwk , Jwk ): jwk = Jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass @property def is_private ( self ) -> bool : \"\"\"True if the JwkSet contains at least one private key. Returns: `True` if this JwkSet contains at least one private key \"\"\" return any ( key . is_private for key in self . jwks ) def public_jwks ( self ) -> \"JwkSet\" : \"\"\"Return another JwkSet with the public keys associated with the current keys. Returns: a public JwkSet \"\"\" return JwkSet ( keys = ( key . public_jwk () for key in self . jwks )) def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) # if one or several alg are provided, try only the keys that are compatible with one of the provided alg(s) if alg : for jwk in self . jwks : if jwk . get ( \"alg\" ) == alg : if jwk . verify ( data , signature , alg = alg ): return True if algs : for jwk in self . jwks : alg = jwk . get ( \"alg\" ) if alg is not None and alg in algs : if jwk . verify ( data , signature , algs = algs ): return True # if no kid and no alg are provided, try first the keys flagged for signature verification (`\"use\": \"verify\"`) for jwk in self . jwks : if jwk . get ( \"use\" ) == \"verify\" : if jwk . verify ( data , signature , alg = alg ): return True # then with the keys that have no defined `use` for jwk in self . jwks : if jwk . get ( \"use\" ) is None and jwk . get ( \"alg\" ) is None : try : if jwk . verify ( data , signature , alg = alg ): return True except UnsupportedAlg : continue # no key matches, so consider the signature invalid return False __len__ () \u00b6 Return the number of Jwk in this JwkSet. Returns: Type Description int the number of keys Source code in jwskate/jwk/jwks.py 73 74 75 76 77 78 79 def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) add_jwk ( jwk , kid = None , use = None ) \u00b6 Add a Jwk in this JwkSet. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to add (either a Jwk instance, or a dict containing the Jwk parameters) required kid Optional [ str ] the kid to use, if jwk doesn't contain one None use Optional [ str ] the defined use for the added Jwk None Returns: Type Description str the kid from the added Jwk (it may be generated if no kid is provided) Source code in jwskate/jwk/jwks.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" if not isinstance ( jwk , Jwk ): jwk = Jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid get_jwk_by_kid ( kid ) \u00b6 Return a Jwk from this JwkSet, based on its kid. Parameters: Name Type Description Default kid str the kid of the key to obtain required Returns: Type Description Jwk the key with the matching Key ID Raises: Type Description KeyError if no key matches Source code in jwskate/jwk/jwks.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) is_private () property \u00b6 True if the JwkSet contains at least one private key. Returns: Type Description bool True if this JwkSet contains at least one private key Source code in jwskate/jwk/jwks.py 129 130 131 132 133 134 135 136 137 @property def is_private ( self ) -> bool : \"\"\"True if the JwkSet contains at least one private key. Returns: `True` if this JwkSet contains at least one private key \"\"\" return any ( key . is_private for key in self . jwks ) jwks () property \u00b6 Return the list of keys from this JwkSet, as Jwk instances. Returns: Type Description List [ Jwk ] a list of Jwk Source code in jwskate/jwk/jwks.py 47 48 49 50 51 52 53 54 @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) public_jwks () \u00b6 Return another JwkSet with the public keys associated with the current keys. Returns: Type Description JwkSet a public JwkSet Source code in jwskate/jwk/jwks.py 139 140 141 142 143 144 145 def public_jwks ( self ) -> \"JwkSet\" : \"\"\"Return another JwkSet with the public keys associated with the current keys. Returns: a public JwkSet \"\"\" return JwkSet ( keys = ( key . public_jwk () for key in self . jwks )) remove_jwk ( kid ) \u00b6 Removes a Jwk from this JwkSet, based on a kid . Parameters: Name Type Description Default kid str the kid from the key to be removed. required Raises: Type Description KeyError if no key matches Source code in jwskate/jwk/jwks.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass verify ( data , signature , alg = None , algs = None , kid = None ) \u00b6 Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a kid is provided, only the key with this kid will be tried. Otherwise, if an alg or several algs are provided, only keys that are compatible with the supplied alg will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Parameters: Name Type Description Default data bytes the signed data to verify required signature bytes the signature to verify against the signed data required alg Optional [ str ] alg to verify the signature, if there is only 1 None algs Optional [ Iterable [ str ]] list of allowed signature algs, if there are several None kid Optional [ str ] the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys None from this key set may be tried. Returns: Type Description bool True if the signature validates with any of the tried keys, False otherwise Source code in jwskate/jwk/jwks.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) # if one or several alg are provided, try only the keys that are compatible with one of the provided alg(s) if alg : for jwk in self . jwks : if jwk . get ( \"alg\" ) == alg : if jwk . verify ( data , signature , alg = alg ): return True if algs : for jwk in self . jwks : alg = jwk . get ( \"alg\" ) if alg is not None and alg in algs : if jwk . verify ( data , signature , algs = algs ): return True # if no kid and no alg are provided, try first the keys flagged for signature verification (`\"use\": \"verify\"`) for jwk in self . jwks : if jwk . get ( \"use\" ) == \"verify\" : if jwk . verify ( data , signature , alg = alg ): return True # then with the keys that have no defined `use` for jwk in self . jwks : if jwk . get ( \"use\" ) is None and jwk . get ( \"alg\" ) is None : try : if jwk . verify ( data , signature , alg = alg ): return True except UnsupportedAlg : continue # no key matches, so consider the signature invalid return False JwsCompact \u00b6 Bases: BaseCompactToken Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Parameters: Name Type Description Default value Union [ bytes , str ] the JWS token value required Source code in jwskate/jws/compact.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class JwsCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Args: value: the JWS token value \"\"\" def __init__ ( self , value : Union [ bytes , str ]): super () . __init__ ( value ) header , payload , signature = self . split ( self . value ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJws ( \"Invalid JWS header: it must be a Base64URL-encoded JSON object\" ) try : self . payload = BinaPy ( payload ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def split ( cls , value : bytes ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Splits a JWS token value into its (header, payload, signature) parts. Args: value: the JWS token value Returns: a (header, payload, signature) Raises: InvalidJws: if the provided value doesn't have 2 dots. \"\"\" if value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = value . split ( b \".\" ) return BinaPy ( header ), BinaPy ( payload ), BinaPy ( signature ) @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"JwsCompact\" : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) @classmethod def from_parts ( cls , signed_part : Union [ bytes , str ], signature : Union [ bytes , str ] ) -> \"JwsCompact\" : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if not isinstance ( signed_part , bytes ): signed_part = signed_part . encode ( \"ascii\" ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . to ( \"b64u\" )))) @cached_property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg = alg , algs = algs ) def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . split ( self . value ) content = { \"payload\" : payload . ascii (), \"protected\" : protected . ascii (), \"signature\" : signature . ascii (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize () flat_json ( unprotected_header = None ) \u00b6 Create a JWS in JSON flat format based on this Compact JWS. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonFlat the resulting token Source code in jwskate/jws/compact.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . split ( self . value ) content = { \"payload\" : payload . ascii (), \"protected\" : protected . ascii (), \"signature\" : signature . ascii (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) from_parts ( signed_part , signature ) classmethod \u00b6 Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Parameters: Name Type Description Default signed_part Union [ bytes , str ] the signed part required signature Union [ bytes , str ] the signature value required Returns: Type Description JwsCompact the resulting token Source code in jwskate/jws/compact.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @classmethod def from_parts ( cls , signed_part : Union [ bytes , str ], signature : Union [ bytes , str ] ) -> \"JwsCompact\" : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if not isinstance ( signed_part , bytes ): signed_part = signed_part . encode ( \"ascii\" ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . to ( \"b64u\" )))) general_json ( unprotected_header = None ) \u00b6 Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonGeneral the resulting token Source code in jwskate/jws/compact.py 177 178 179 180 181 182 183 184 185 186 187 188 189 def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize () sign ( payload , jwk , alg = None , extra_headers = None ) classmethod \u00b6 Sign a payload and returns the resulting JwsCompact. Parameters: Name Type Description Default payload bytes the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the jwk to use to sign this payload required alg Optional [ str ] the alg to use None extra_headers Optional [ Dict [ str , Any ]] additional headers to add to the Jws Headers None Returns: Type Description JwsCompact the resulting token Source code in jwskate/jws/compact.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"JwsCompact\" : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) signed_part () \u00b6 Returns the signed part (header + payload) from this JwsCompact. Returns: Type Description bytes the signed part Source code in jwskate/jws/compact.py 127 128 129 130 131 132 133 134 @cached_property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) split ( value ) classmethod \u00b6 Splits a JWS token value into its (header, payload, signature) parts. Parameters: Name Type Description Default value bytes the JWS token value required Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (header, payload, signature) Raises: Type Description InvalidJws if the provided value doesn't have 2 dots. Source code in jwskate/jws/compact.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @classmethod def split ( cls , value : bytes ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Splits a JWS token value into its (header, payload, signature) parts. Args: value: the JWS token value Returns: a (header, payload, signature) Raises: InvalidJws: if the provided value doesn't have 2 dots. \"\"\" if value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = value . split ( b \".\" ) return BinaPy ( header ), BinaPy ( payload ), BinaPy ( signature ) verify_signature ( jwk , * , alg = None , algs = None ) \u00b6 Verify the signature from this JwsCompact using a Jwk. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use to validate this signature required alg Optional [ str ] the alg to use, if there is only 1 allowed None algs Optional [ Iterable [ str ]] the allowed algs, if here are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate/jws/compact.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg = alg , algs = algs ) Jwt \u00b6 Bases: BaseCompactToken Represents a Json Web Token. Source code in jwskate/jwt/base.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class Jwt ( BaseCompactToken ): \"\"\"Represents a Json Web Token.\"\"\" def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 3 : from .encrypted import EncryptedJwt return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls ) @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = Jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) kid = jwk . get ( \"kid\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) extra_headers = extra_headers or {} headers = dict ( alg = alg , ** extra_headers ) if kid : headers [ \"kid\" ] = kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc_alg : Optional [ str ], enc : Optional [ str ], ) -> \"EncryptedJwt\" : \"\"\"Sign then encrypt a payload with a `Jwk` and returns the resulting `EncryptedJwt`. NOT IMPLEMENTED YET. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption Returns: the resulting JWE token, with signed JWT as payload \"\"\" raise NotImplementedError __new__ ( value ) \u00b6 Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Parameters: Name Type Description Default value Union [ bytes , str ] the token value required Source code in jwskate/jwt/base.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 3 : from .encrypted import EncryptedJwt return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls ) sign ( claims , jwk , alg = None , extra_headers = None ) classmethod \u00b6 Sign a JSON payload with a Jwk and returns the resulting SignedJwt . This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use .unprotected() instead. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signing required alg Optional [ str ] the alg to use for signing None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the Jwt None Returns: Type Description SignedJwt the resulting token Source code in jwskate/jwt/base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = Jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) kid = jwk . get ( \"kid\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) extra_headers = extra_headers or {} headers = dict ( alg = alg , ** extra_headers ) if kid : headers [ \"kid\" ] = kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) sign_and_encrypt ( claims , sign_jwk , sign_alg , enc_jwk , enc_alg , enc ) classmethod \u00b6 Sign then encrypt a payload with a Jwk and returns the resulting EncryptedJwt . NOT IMPLEMENTED YET. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to encrypt required sign_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signature required sign_alg Optional [ str ] the alg to use for signature required enc_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for encryption required enc_alg Optional [ str ] the alg to use for CEK encryption required enc Optional [ str ] the alg to use for payload encryption required Returns: Type Description EncryptedJwt the resulting JWE token, with signed JWT as payload Source code in jwskate/jwt/base.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc_alg : Optional [ str ], enc : Optional [ str ], ) -> \"EncryptedJwt\" : \"\"\"Sign then encrypt a payload with a `Jwk` and returns the resulting `EncryptedJwt`. NOT IMPLEMENTED YET. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption Returns: the resulting JWE token, with signed JWT as payload \"\"\" raise NotImplementedError unprotected ( claims , extra_headers = None ) classmethod \u00b6 Generate a JWT that is not signed and not encrypted (with alg=none). Parameters: Name Type Description Default claims Dict [ str , Any ] the claims to set in the token. required extra_headers Optional [ Dict [ str , Any ]] additional headers to insert in the token. None Returns: Type Description SignedJwt the resulting token Source code in jwskate/jwt/base.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) JwtSigner \u00b6 A helper class to easily sign JWTs with standardised claims. The standardised claims include \u00ecat : issued at date exp : expiration date nbf : not before date: iss : issuer identifier sub : subject identifier aud : audience identifier jti : JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling JwtSigner.sign() . This can be used as an alternative to Jwt.sign() when a single issuer issues multiple tokens. Parameters: Name Type Description Default issuer str the issuer string to use as \u00ecss claim for signed tokens. required jwk Jwk the private Jwk to use to sign tokens. required alg Optional [ str ] the signing alg to use to sign tokens. None default_lifetime int the default lifetime, in seconds, to use for claim exp . This can be overridden when calling .sign() 60 default_leeway Optional [ int ] the default leeway, in seconds, to use for claim nbf . If None, no nbf claim is included. This can be overridden when calling .sign() None Source code in jwskate/jwt/signer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class JwtSigner : \"\"\"A helper class to easily sign JWTs with standardised claims. The standardised claims include: - `\u00ecat`: issued at date - `exp`: expiration date - `nbf`: not before date: - `iss`: issuer identifier - `sub`: subject identifier - `aud`: audience identifier - `jti`: JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling `JwtSigner.sign()`. This can be used as an alternative to `Jwt.sign()` when a single issuer issues multiple tokens. Args: issuer: the issuer string to use as `\u00ecss` claim for signed tokens. jwk: the private Jwk to use to sign tokens. alg: the signing alg to use to sign tokens. default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden when calling `.sign()` default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is included. This can be overridden when calling `.sign()` \"\"\" def __init__ ( self , issuer : str , jwk : Jwk , alg : Optional [ str ] = None , default_lifetime : int = 60 , default_leeway : Optional [ int ] = None , ): self . issuer = issuer self . jwk = jwk self . alg = jwk . alg or alg self . default_lifetime = default_lifetime self . default_leeway = default_leeway def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = int ( datetime . now () . timestamp ()) lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ()) generate_jti () \u00b6 Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: Type Description str A unique value suitable for use as JWT Token ID (jti) claim. Source code in jwskate/jwt/signer.py 105 106 107 108 109 110 111 112 113 def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ()) sign ( subject = None , audience = None , extra_claims = None , extra_headers = None , lifetime = None , leeway = None ) \u00b6 Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim iat , nbf and exp will reflect the current time when the token is signed. exp includes lifetime seconds in the future, and nbf includes leeway seconds in the past. Parameters: Name Type Description Default subject Optional [ str ] the subject to include in claim sub . (Default value = None) None audience Union [ str , Iterable [ str ], None] the audience identifier(s) to include in claim aud . None extra_claims Optional [ Dict [ str , Any ]] additional claims to include in the signed token. (Default value = None) None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the header part. (Default value = None) None lifetime Optional [ int ] lifetime, in seconds, to use for the exp claim. If None, use the default_lifetime defined at initialization time. None leeway Optional [ int ] leeway, in seconds, to use for the nbf claim. If None, use the default_leeway defined at initialization time. None Returns: Type Description SignedJwt the resulting signed token. Source code in jwskate/jwt/signer.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = int ( datetime . now () . timestamp ()) lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) KeyManagementAlgs \u00b6 Identifiers for Key Management algorithms. Source code in jwskate/enums.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class KeyManagementAlgs : \"\"\"Identifiers for Key Management algorithms.\"\"\" RSA1_5 = \"RSA1_5\" RSA_OAEP = \"RSA-OAEP\" RSA_OAEP_256 = \"RSA-OAEP-256\" RSA_OAEP_384 = \"RSA-OAEP-384\" RSA_OAEP_512 = \"RSA-OAEP-512\" ECDH_ES = \"ECDH-ES\" ECDH_ES_A128KW = \"ECDH-ES+A128KW\" ECDH_ES_A192KW = \"ECDH-ES+A192KW\" ECDH_ES_A256KW = \"ECDH-ES+A256KW\" A128KW = \"A128KW\" A192KW = \"A192KW\" A256KW = \"A256KW\" A128GCMKW = \"A128GCMKW\" A192GCMKW = \"A192GCMKW\" A256GCMKW = \"A256GCMKW\" dir = \"dir\" PBES2_HS256_A128KW = \"PBES2-HS256+A128KW\" PBES2_HS384_A192KW = \"PBES2-HS384+A192KW\" PBES2_HS512_A256KW = \"PBES2-HS512+A256KW\" ALL_SYMMETRIC = [ A128KW , A192KW , A256KW , A128GCMKW , A192GCMKW , A256GCMKW , dir , PBES2_HS256_A128KW , PBES2_HS384_A192KW , PBES2_HS512_A256KW , ] ALL_ASYMMETRIC = [ RSA1_5 , RSA_OAEP , RSA_OAEP_256 , RSA_OAEP_384 , RSA_OAEP_512 , ECDH_ES , ECDH_ES_A128KW , ECDH_ES_A192KW , ECDH_ES_A256KW , ] OKPCurve dataclass \u00b6 Represent an Octet Key Pair (OKP) Curve. Source code in jwskate/jwa/okp.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @dataclass class OKPCurve : \"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\" name : str \"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` headers.\"\"\" description : str \"\"\"Curve description (human readable).\"\"\" cryptography_private_key_class : Type [ Any ] \"\"\"`cryptography` private key class.\"\"\" cryptography_public_key_class : Type [ Any ] \"\"\"`cryptography` public key class.\"\"\" use : str \"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\" instances : ClassVar [ Dict [ str , OKPCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key: `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" ) cryptography_private_key_class : Type [ Any ] class-attribute \u00b6 cryptography private key class. cryptography_public_key_class : Type [ Any ] class-attribute \u00b6 cryptography public key class. description : str class-attribute \u00b6 Curve description (human readable). instances : ClassVar [ Dict [ str , OKPCurve ]] = {} class-attribute \u00b6 Registry of subclasses, in a {name: instance} mapping. name : str class-attribute \u00b6 Curve name as defined in IANA JOSE . This name will appear in alg headers. use : str class-attribute \u00b6 Curve usage ( 'sig' or ' enc' ). __post_init__ () \u00b6 Automatically registers subclasses in the instance registry. Source code in jwskate/jwa/okp.py 66 67 68 def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self generate () \u00b6 Generate a new private key on this curve. Returns: Type Description Tuple [ bytes , bytes ] a tuple of x (public part), and d (private part), as bytes Source code in jwskate/jwa/okp.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d get_curve ( key ) classmethod \u00b6 Return the appropriate OKPCurve instance for a given cryptography private or public key. Parameters: Name Type Description Default key Union [ PublicKeyProtocol , PrivateKeyProtocol ] cryptography private or public OKP key. required Returns: Name Type Description OKPCurve OKPCurve the appropriate OKPCurve for the given key Raises: Type Description NotImplementedError if the required OKP curve is not supported Source code in jwskate/jwa/okp.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key: `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" ) OKPJwk \u00b6 Bases: Jwk Represent an OKP Jwk, with kty=OKP . Source code in jwskate/jwk/okp.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 class OKPJwk ( Jwk ): \"\"\"Represent an OKP Jwk, with `kty=OKP`.\"\"\" KTY = \"OKP\" CRYPTOGRAPHY_KEY_CLASSES = ( ed25519 . Ed25519PrivateKey , ed25519 . Ed25519PublicKey , ed448 . Ed448PrivateKey , ed448 . Ed448PublicKey , x25519 . X25519PrivateKey , x25519 . X25519PublicKey , x448 . X448PrivateKey , x448 . X448PublicKey , ) PARAMS = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"Public Key\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Key\" , is_private = True , is_required = False , kind = \"b64u\" ), } CURVES : Mapping [ str , OKPCurve ] = { curve . name : curve for curve in [ Ed25519 , Ed448 , X448 , X25519 ] } SIGNATURE_ALGORITHMS = { alg . name : alg for alg in ( EdDsa ,)} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedOKPCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) @cached_property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) @cached_property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> OKPJwk : \"\"\"Initialize a OKPJwk from a `cryptography` key. Args: cryptography_key: a `cryptography` key **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if isinstance ( cryptography_key , ed25519 . Ed25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed25519 . Ed25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( cryptography_key , ed448 . Ed448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed448 . Ed448PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( cryptography_key , x25519 . X25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x25519 . X25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( cryptography_key , x448 . X448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x448 . X448PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in cls . CRYPTOGRAPHY_KEY_CLASSES ) ) def _to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), ** params )) @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def generate ( cls , crv : str = \"Ed25519\" , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. Args: crv: the curve to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" curve = cls . get_curve ( crv ) x , d = curve . generate () return cls . private ( crv = crv , x = x , d = d , ** params ) curve () property \u00b6 Get the OKPCurve instance for this key. Returns: Type Description OKPCurve the OKPCurve for this key Source code in jwskate/jwk/okp.py 91 92 93 94 95 96 97 98 @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) from_cryptography_key ( cryptography_key , ** kwargs ) classmethod \u00b6 Initialize a OKPJwk from a cryptography key. Parameters: Name Type Description Default cryptography_key Any a cryptography key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the matching OKPJwk Source code in jwskate/jwk/okp.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> OKPJwk : \"\"\"Initialize a OKPJwk from a `cryptography` key. Args: cryptography_key: a `cryptography` key **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if isinstance ( cryptography_key , ed25519 . Ed25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed25519 . Ed25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( cryptography_key , ed448 . Ed448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed448 . Ed448PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( cryptography_key , x25519 . X25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x25519 . X25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( cryptography_key , x448 . X448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x448 . X448PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in cls . CRYPTOGRAPHY_KEY_CLASSES ) ) generate ( crv = 'Ed25519' , ** params ) classmethod \u00b6 Generate a private OKPJwk on a given curve. Parameters: Name Type Description Default crv str the curve to use 'Ed25519' **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 @classmethod def generate ( cls , crv : str = \"Ed25519\" , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. Args: crv: the curve to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" curve = cls . get_curve ( crv ) x , d = curve . generate () return cls . private ( crv = crv , x = x , d = d , ** params ) get_curve ( crv ) classmethod \u00b6 Get the OKPCurve instance from a curve identifier. Parameters: Name Type Description Default crv str a crv identifier required Returns: Type Description OKPCurve the matching OKPCurve instance Raises: Type Description UnsupportedOKPCurve if the curve is not supported Source code in jwskate/jwk/okp.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve private ( crv , x , d , ** params ) classmethod \u00b6 Initialize a private OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the OKP curve required x bytes the public key required d bytes the private key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . to ( \"b64u\" ) . ascii (), ** params , ) ) private_key () \u00b6 Get the private key from this Jwk. Returns: Type Description bytes the private key (from param d ) Source code in jwskate/jwk/okp.py 109 110 111 112 113 114 115 116 @cached_property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) public ( crv , x , ** params ) classmethod \u00b6 Initialize a public OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the key curve required x bytes the public key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 246 247 248 249 250 251 252 253 254 255 256 257 258 @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), ** params )) public_key () \u00b6 Get the public key from this Jwk. Returns: Type Description bytes the public key (from param x ) Source code in jwskate/jwk/okp.py 100 101 102 103 104 105 106 107 @cached_property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) PS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Source code in jwskate/jwa/signature/rsa.py 89 90 91 92 93 94 95 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 ) PS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Source code in jwskate/jwa/signature/rsa.py 98 99 100 101 102 103 104 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 ) PS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Source code in jwskate/jwa/signature/rsa.py 107 108 109 110 111 112 113 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 ) Pbes2_HS256_A128KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 94 95 96 97 98 99 100 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 () Pbes2_HS384_A192KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 103 104 105 106 107 108 109 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 () Pbes2_HS512_A256KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 112 113 114 115 116 117 118 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 () PrivateKeyRequired \u00b6 Bases: AttributeError Raised when a cryptographic operation requires a private key, and a public key has been provided instead. Source code in jwskate/jwa/base.py 11 12 class PrivateKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a private key, and a public key has been provided instead.\"\"\" PublicKeyRequired \u00b6 Bases: AttributeError Raised when a cryptographic operation requires a public key, and a private key has been provided instead. Source code in jwskate/jwa/base.py 15 16 class PublicKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a public key, and a private key has been provided instead.\"\"\" RS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate/jwa/signature/rsa.py 65 66 67 68 69 70 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 () RS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384 Source code in jwskate/jwa/signature/rsa.py 73 74 75 76 77 78 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 () RS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate/jwa/signature/rsa.py 81 82 83 84 85 86 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 () RSAJwk \u00b6 Bases: Jwk Represent a RSA Jwk, with kty=RSA . Source code in jwskate/jwk/rsa.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class RSAJwk ( Jwk ): \"\"\"Represent a RSA Jwk, with `kty=RSA`.\"\"\" KTY = \"RSA\" CRYPTOGRAPHY_KEY_CLASSES = ( rsa . RSAPrivateKey , rsa . RSAPublicKey ) PARAMS = { \"n\" : JwkParameter ( \"Modulus\" , is_private = False , is_required = True , kind = \"b64u\" ), \"e\" : JwkParameter ( \"Exponent\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Exponent\" , is_private = True , is_required = True , kind = \"b64u\" ), \"p\" : JwkParameter ( \"First Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"q\" : JwkParameter ( \"Second Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dp\" : JwkParameter ( \"First Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dq\" : JwkParameter ( \"Second Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" , ), \"qi\" : JwkParameter ( \"First CRT Coefficient\" , is_private = True , is_required = False , kind = \"b64u\" ), \"oth\" : JwkParameter ( \"Other Primes Info\" , is_private = True , is_required = False , kind = \"unsupported\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ RS256 , RS384 , RS512 , PS256 , PS384 , PS512 ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ RsaEsPcks1v1_5 , RsaEsOaep , RsaEsOaepSha256 , RsaEsOaepSha384 , RsaEsOaepSha512 , ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: cryptography_key: a `cryptography` RSA key **kwargs: additional members to include in the Jwk Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( cryptography_key , rsa . RSAPrivateKey ): priv = cryptography_key . private_numbers () # type: ignore[attr-defined] pub = cryptography_key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( cryptography_key , rsa . RSAPublicKey ): pub = cryptography_key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) def _to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key () @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public RsaJwk from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initializes a Private RsaJwk from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d ) . to ( \"b64u\" ) . ascii (), p = BinaPy . from_int ( p ) . to ( \"b64u\" ) . ascii () if p is not None else None , q = BinaPy . from_int ( q ) . to ( \"b64u\" ) . ascii () if q is not None else None , dp = BinaPy . from_int ( dp ) . to ( \"b64u\" ) . ascii () if dp is not None else None , dq = BinaPy . from_int ( dq ) . to ( \"b64u\" ) . ascii () if dq is not None else None , qi = BinaPy . from_int ( qi ) . to ( \"b64u\" ) . ascii () if qi is not None else None , ** params , ) ) @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generates a new random private RSAJwk. Args: key_size: the key size to use for the generated key, in bits **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) @cached_property def modulus ( self ) -> int : \"\"\"Returns the modulus from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () @cached_property def exponent ( self ) -> int : \"\"\"Returns the exponent from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () @cached_property def private_exponent ( self ) -> int : \"\"\"Returns the private exponent from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () @cached_property def first_prime_factor ( self ) -> int : \"\"\"Returns the first prime factor from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int () @cached_property def second_prime_factor ( self ) -> int : \"\"\"Returns the second prime factor from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int () @cached_property def first_factor_crt_exponent ( self ) -> int : \"\"\"Returns the first factor CRT exponent from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () @cached_property def second_factor_crt_exponent ( self ) -> int : \"\"\"Returns the second factor CRT exponent from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () @cached_property def first_crt_coefficient ( self ) -> int : \"\"\"Returns the first CRT coefficient from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () exponent () \u00b6 Returns the exponent from this Jwk. Returns: Type Description int the key exponent (from parameter e ) Source code in jwskate/jwk/rsa.py 236 237 238 239 240 241 242 243 @cached_property def exponent ( self ) -> int : \"\"\"Returns the exponent from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () first_crt_coefficient () \u00b6 Returns the first CRT coefficient from this Jwk. Returns: Type Description int the first CRT coefficient (from parameter qi ) Source code in jwskate/jwk/rsa.py 290 291 292 293 294 295 296 297 @cached_property def first_crt_coefficient ( self ) -> int : \"\"\"Returns the first CRT coefficient from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () first_factor_crt_exponent () \u00b6 Returns the first factor CRT exponent from this Jwk. Returns: Type Description int the first factor CRT coefficient (from parameter dp ) Source code in jwskate/jwk/rsa.py 272 273 274 275 276 277 278 279 @cached_property def first_factor_crt_exponent ( self ) -> int : \"\"\"Returns the first factor CRT exponent from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () first_prime_factor () \u00b6 Returns the first prime factor from this Jwk. Returns: Type Description int the first prime factor (from parameter p ) Source code in jwskate/jwk/rsa.py 254 255 256 257 258 259 260 261 @cached_property def first_prime_factor ( self ) -> int : \"\"\"Returns the first prime factor from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int () from_cryptography_key ( cryptography_key , ** kwargs ) classmethod \u00b6 Initialize a Jwk from a cryptography RSA key. Parameters: Name Type Description Default cryptography_key Any a cryptography RSA key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized with the given key Raises: Type Description TypeError if the given key type is not supported Source code in jwskate/jwk/rsa.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: cryptography_key: a `cryptography` RSA key **kwargs: additional members to include in the Jwk Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( cryptography_key , rsa . RSAPrivateKey ): priv = cryptography_key . private_numbers () # type: ignore[attr-defined] pub = cryptography_key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( cryptography_key , rsa . RSAPublicKey ): pub = cryptography_key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) generate ( key_size = 4096 , ** params ) classmethod \u00b6 Generates a new random private RSAJwk. Parameters: Name Type Description Default key_size int the key size to use for the generated key, in bits 4096 **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a generated RSAJwk Source code in jwskate/jwk/rsa.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generates a new random private RSAJwk. Args: key_size: the key size to use for the generated key, in bits **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) modulus () \u00b6 Returns the modulus from this Jwk. Returns: Type Description int the key modulus (from parameter n ) Source code in jwskate/jwk/rsa.py 227 228 229 230 231 232 233 234 @cached_property def modulus ( self ) -> int : \"\"\"Returns the modulus from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () private ( n , e , d , p = None , q = None , dp = None , dq = None , qi = None , ** params ) classmethod \u00b6 Initializes a Private RsaJwk from its required parameters. Parameters: Name Type Description Default n int the modulus required e int the exponent required d int the private exponent required p Optional [ int ] the first prime factor None q Optional [ int ] the second prime factor None dp Optional [ int ] the first factor CRT exponent None dq Optional [ int ] the second factor CRT exponent None qi Optional [ int ] the first CRT coefficient None **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized from the given parameters Source code in jwskate/jwk/rsa.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initializes a Private RsaJwk from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d ) . to ( \"b64u\" ) . ascii (), p = BinaPy . from_int ( p ) . to ( \"b64u\" ) . ascii () if p is not None else None , q = BinaPy . from_int ( q ) . to ( \"b64u\" ) . ascii () if q is not None else None , dp = BinaPy . from_int ( dp ) . to ( \"b64u\" ) . ascii () if dp is not None else None , dq = BinaPy . from_int ( dq ) . to ( \"b64u\" ) . ascii () if dq is not None else None , qi = BinaPy . from_int ( qi ) . to ( \"b64u\" ) . ascii () if qi is not None else None , ** params , ) ) private_exponent () \u00b6 Returns the private exponent from this Jwk. Returns: Type Description int the key private exponent (from parameter d ) Source code in jwskate/jwk/rsa.py 245 246 247 248 249 250 251 252 @cached_property def private_exponent ( self ) -> int : \"\"\"Returns the private exponent from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () public ( n , e , ** params ) classmethod \u00b6 Initialize a public RsaJwk from a modulus and an exponent. Parameters: Name Type Description Default n int the modulus required e int the exponent required **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RsaJwk initialized from the provided parameters Source code in jwskate/jwk/rsa.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public RsaJwk from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), ** params , ) ) second_factor_crt_exponent () \u00b6 Returns the second factor CRT exponent from this Jwk. Returns: Type Description int the second factor CRT coefficient (from parameter dq ) Source code in jwskate/jwk/rsa.py 281 282 283 284 285 286 287 288 @cached_property def second_factor_crt_exponent ( self ) -> int : \"\"\"Returns the second factor CRT exponent from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () second_prime_factor () \u00b6 Returns the second prime factor from this Jwk. Returns: Type Description int the second prime factor (from parameter q ) Source code in jwskate/jwk/rsa.py 263 264 265 266 267 268 269 270 @cached_property def second_prime_factor ( self ) -> int : \"\"\"Returns the second prime factor from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int () RsaEsOaep \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using default parameters Source code in jwskate/jwa/key_mgmt/rsa.py 77 78 79 80 81 82 83 84 85 86 87 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , ) RsaEsOaepSha256 \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256 Source code in jwskate/jwa/key_mgmt/rsa.py 90 91 92 93 94 95 96 97 98 99 100 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , ) RsaEsOaepSha384 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384 Source code in jwskate/jwa/key_mgmt/rsa.py 103 104 105 106 107 108 109 110 111 112 113 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , ) RsaEsOaepSha512 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512 Source code in jwskate/jwa/key_mgmt/rsa.py 116 117 118 119 120 121 122 123 124 125 126 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , ) RsaEsPcks1v1_5 \u00b6 Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5 Source code in jwskate/jwa/key_mgmt/rsa.py 67 68 69 70 71 72 73 74 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5\"\"\" name = \"RSA1_5\" description = __doc__ read_only = True padding = padding . PKCS1v15 () SignatureAlgs \u00b6 Identifiers for Signature algorithms. Source code in jwskate/enums.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SignatureAlgs : \"\"\"Identifiers for Signature algorithms.\"\"\" RS256 = \"RS256\" RS384 = \"RS384\" RS512 = \"RS512\" ES256 = \"ES256\" ES384 = \"ES384\" ES512 = \"ES512\" PS256 = \"PS256\" PS384 = \"PS384\" PS512 = \"PS512\" EdDSA = \"EdDSA\" HS256 = \"HS256\" HS384 = \"HS384\" HS512 = \"HS512\" ALL_SYMMETRIC = [ HS256 , HS384 , HS512 ] ALL_ASYMMETRIC = [ RS256 , RS384 , RS512 , ES256 , ES384 , ES512 , PS256 , PS384 , PS512 , EdDSA , ] SignedJwt \u00b6 Bases: Jwt Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use Jwt.sign . Parameters: Name Type Description Default value Union [ bytes , str ] the token value. required Source code in jwskate/jwt/signed.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 class SignedJwt ( Jwt ): \"\"\"Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use [Jwt.sign][jwskate.jwt.Jwt.sign]. Args: value: the token value. \"\"\" def __init__ ( self , value : Union [ bytes , str ]) -> None : super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJwt ( \"A JWT must contain a header, a payload and a signature, separated by dots\" , value , ) header , payload , signature = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT header: it must be a Base64URL-encoded JSON object\" ) try : self . claims = BinaPy ( payload ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\" ) @cached_property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Args: leeway: additional number of seconds for leeway. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < ( datetime . now ( timezone . utc ) + timedelta ( seconds = leeway )) @cached_property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = datetime . fromtimestamp ( exp , tz = timezone . utc ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) @cached_property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = datetime . fromtimestamp ( iat , tz = timezone . utc ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) @cached_property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = datetime . fromtimestamp ( nbf , tz = timezone . utc ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) @cached_property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) @cached_property def audiences ( self ) -> Optional [ List [ str ]]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return None if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) @cached_property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) @cached_property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signature alg to use to verify the signature. algs: allowed signature algs, if several issuer: the expected issuer for this token. audience: the expected audience for this token. check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg , algs ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audiences ) if check_exp : expired = self . is_expired () if expired is True : raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) elif expired is None : raise InvalidClaim ( \"exp\" , \"This token misses a 'exp' claim.\" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim ) __bytes__ () \u00b6 Return the Jwt serialized value, as bytes . Returns: Type Description bytes the serialized token value. Source code in jwskate/jwt/signed.py 286 287 288 289 290 291 292 def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value __getattr__ ( item ) \u00b6 Allow claim access as attributes. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate/jwt/signed.py 264 265 266 267 268 269 270 271 272 273 274 275 276 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value __getitem__ ( item ) \u00b6 Allow claim access with subscription. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate/jwt/signed.py 250 251 252 253 254 255 256 257 258 259 260 261 262 def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value __str__ () \u00b6 Return the Jwt serialized value, as str . Returns: Type Description str the serialized token value. Source code in jwskate/jwt/signed.py 278 279 280 281 282 283 284 def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () audiences () \u00b6 Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a list anyway. Returns: Type Description Optional [ List [ str ]] the list of audiences from this token, from the aud claim. Raises: Type Description AttributeError if the audience is an unexpected type Source code in jwskate/jwt/signed.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 @cached_property def audiences ( self ) -> Optional [ List [ str ]]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return None if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) expires_at () \u00b6 Get the \"Expires At\" (exp) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the exp claim, or None if there is no exp claim Raises: Type Description AttributeError if the exp claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @cached_property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = datetime . fromtimestamp ( exp , tz = timezone . utc ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) get_claim ( key , default = None ) \u00b6 Get a claim from this Jwt. Parameters: Name Type Description Default key str the claim name. required default Any a default value if the claim is not found None Returns: Type Description Any the claim value if found, or default if not found Source code in jwskate/jwt/signed.py 238 239 240 241 242 243 244 245 246 247 248 def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) is_expired ( leeway = 0 ) \u00b6 Check if this token is expired, based on its exp claim. Parameters: Name Type Description Default leeway int additional number of seconds for leeway. 0 Returns: Type Description Optional [ bool ] True if the token is expired, False if it's not, None if there is no exp claim. Source code in jwskate/jwt/signed.py 101 102 103 104 105 106 107 108 109 110 111 112 113 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Args: leeway: additional number of seconds for leeway. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < ( datetime . now ( timezone . utc ) + timedelta ( seconds = leeway )) issued_at () \u00b6 Get the \"Issued At\" (iat) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the iat claim, or None if there is no iat claim Raises: Type Description AttributeError if the iss claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 @cached_property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = datetime . fromtimestamp ( iat , tz = timezone . utc ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) issuer () \u00b6 Get the Issuer (iss) claim from this token. Returns: Type Description Optional [ str ] the issuer, as str , or None if there is no \u00ecss claim Raises: Type Description AttributeError if the \u00ecss claim value is not a string Source code in jwskate/jwt/signed.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 @cached_property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) jwt_token_id () \u00b6 Get the JWT Token ID (jti) from this token claims. Returns: Type Description Optional [ str ] the token identifier, as str , or None if there is no jti claim Raises: Type Description AttributeError if the jti value is not a string Source code in jwskate/jwt/signed.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @cached_property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) not_before () \u00b6 Get the \"Not Before\" (nbf) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the nbf claim, or None if there is no nbf claim Raises: Type Description AttributeError if the nbf claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 @cached_property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = datetime . fromtimestamp ( nbf , tz = timezone . utc ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) signed_part () \u00b6 Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: Type Description bytes the signed part as bytes Source code in jwskate/jwt/signed.py 68 69 70 71 72 73 74 75 76 77 @cached_property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) subject () \u00b6 Get the Subject (sub) from this token claims. Returns: Type Description Optional [ str ] the subject, as str , or None if there is no sub claim Raises: Type Description AttributeError if the sub value is not a string Source code in jwskate/jwt/signed.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @cached_property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) validate ( jwk , * , alg = None , algs = None , issuer = None , audience = None , check_exp = True , ** kwargs ) \u00b6 Validate a SignedJwt signature and expected claims. This verifies the signature using the provided jwk and alg , then checks the token issuer, audience and expiration date. This can also check custom claims using extra kwargs , whose values can be: a static value ( str , int , etc.): the value from the token will be compared \"as-is\" a callable, taking the claim value as parameter: if that callable returns True , the claim is considered as valid Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the signing key to use to verify the signature. required alg Optional [ str ] the signature alg to use to verify the signature. None algs Optional [ Iterable [ str ]] allowed signature algs, if several None issuer Optional [ str ] the expected issuer for this token. None audience Union [None, str ] the expected audience for this token. None check_exp bool \u00ecf True (default), check that the token is not expired. True **kwargs Any additional claims to check {} Returns: Type Description None Raises exceptions if any validation check fails. Raises: Type Description InvalidSignature if the signature is not valid InvalidClaim if a claim doesn't validate ExpiredJwt if the expiration date is passed Source code in jwskate/jwt/signed.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signature alg to use to verify the signature. algs: allowed signature algs, if several issuer: the expected issuer for this token. audience: the expected audience for this token. check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg , algs ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audiences ) if check_exp : expired = self . is_expired () if expired is True : raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) elif expired is None : raise InvalidClaim ( \"exp\" , \"This token misses a 'exp' claim.\" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim ) verify_signature ( jwk , alg = None , algs = None ) \u00b6 Verify this JWT signature using a given key and algorithm(s). Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private Jwk to use to verify the signature required alg Optional [ str ] the alg to use to verify the signature, if only 1 is allowed None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the token signature is verified, False otherwise Source code in jwskate/jwt/signed.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) SymmetricJwk \u00b6 Bases: Jwk Implement Symetric keys, with kty=oct . Source code in jwskate/jwk/oct.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 class SymmetricJwk ( Jwk ): \"\"\"Implement Symetric keys, with `kty=oct`.\"\"\" KTY = \"oct\" CRYPTOGRAPHY_KEY_CLASSES = ( bytes ,) PARAMS = { \"k\" : JwkParameter ( \"Key Value\" , is_private = True , is_required = True , kind = \"b64u\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ HS256 , HS384 , HS512 ]} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ A128KW , A192KW , A256KW , A128GCMKW , A192GCMKW , A256GCMKW , DirectKeyUse , ] } ENCRYPTION_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ Aes128CbcHmacSha256 , Aes192CbcHmacSha384 , Aes256CbcHmacSha512 , A128GCM , A192GCM , A256GCM , ] } def public_jwk ( self ) -> Jwk : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk : \"\"\"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . to ( \"b64u\" ) . ascii (), ** params )) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> SymmetricJwk : \"\"\"Alias for `from_bytes()` since symmetric keys are simply bytes. Args: cryptography_key: the key to use **kwargs: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls . from_bytes ( cryptography_key , ** kwargs ) @classmethod def generate ( cls , key_size : int = 128 , ** params : str ) -> SymmetricJwk : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: key_size: the size of the generated key, in bits **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( key_size ) return cls . from_bytes ( key , ** params ) @classmethod def generate_for_alg ( cls , alg : str , ** params : str ) -> SymmetricJwk : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the signing algorithm to use this key with **params: additional members to include in the Jwk Returns: the resulting Jwk Raises: ValueError: if the provided `alg` is not supported \"\"\" if alg in cls . SIGNATURE_ALGORITHMS : sigalg = cls . SIGNATURE_ALGORITHMS [ alg ] return cls . generate ( sigalg . min_key_size , alg = alg , ** params ) if alg in cls . ENCRYPTION_ALGORITHMS : encalg = cls . ENCRYPTION_ALGORITHMS [ alg ] return cls . generate ( encalg . key_size , alg = alg , ** params ) raise ValueError ( \"Unsupported alg\" , alg ) def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () ) def _to_cryptography_key ( self ) -> BinaPy : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" ) @property def key ( self ) -> BinaPy : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return self . cryptography_key # type: ignore def encrypt ( self , plaintext : bytes , * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data (`aad`). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) if iv is None : iv = encalg . generate_iv () wrapper : BaseAESEncryptionAlg = encalg ( self . cryptography_key ) ciphertext , tag = wrapper . encrypt ( plaintext , iv = iv , aad = aad ) return ciphertext , BinaPy ( iv ), tag @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 def decrypt ( self , ciphertext : bytes , * , iv : bytes , tag : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data iv: the Initialization Vector (must be the same as used during encryption) tag: the authentication tag aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) decryptor : BaseAESEncryptionAlg = encalg ( self . cryptography_key ) plaintext : bytes = decryptor . decrypt ( ciphertext , auth_tag = tag , iv = iv , aad = aad ) return BinaPy ( plaintext ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) # type: ignore ] def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) ] decrypt ( ciphertext , * , iv , tag , aad = None , alg = None ) \u00b6 Decrypt arbitrary data. Parameters: Name Type Description Default ciphertext bytes the encrypted data required iv bytes the Initialization Vector (must be the same as used during encryption) required tag bytes the authentication tag required aad Optional [ bytes ] the Additional Authenticated Data (must be the same as used during encryption) None alg Optional [ str ] the decryption alg (must be the same as used during encryption) None Returns: Type Description BinaPy the decrypted clear-text Source code in jwskate/jwk/oct.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def decrypt ( self , ciphertext : bytes , * , iv : bytes , tag : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data iv: the Initialization Vector (must be the same as used during encryption) tag: the authentication tag aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) decryptor : BaseAESEncryptionAlg = encalg ( self . cryptography_key ) plaintext : bytes = decryptor . decrypt ( ciphertext , auth_tag = tag , iv = iv , aad = aad ) return BinaPy ( plaintext ) encrypt ( plaintext , * , aad = None , alg = None , iv = None ) \u00b6 Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data ( aad ). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the iv parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Parameters: Name Type Description Default plaintext bytes the plaintext to encrypt required aad Optional [ bytes ] the Additional Authentication Data, if any None alg Optional [ str ] the encryption alg to use None iv Optional [ bytes ] the IV to use, if you want a specific value None Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (ciphertext, authentication_tag, iv) tuple Source code in jwskate/jwk/oct.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def encrypt ( self , plaintext : bytes , * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data (`aad`). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) if iv is None : iv = encalg . generate_iv () wrapper : BaseAESEncryptionAlg = encalg ( self . cryptography_key ) ciphertext , tag = wrapper . encrypt ( plaintext , iv = iv , aad = aad ) return ciphertext , BinaPy ( iv ), tag from_bytes ( k , ** params ) classmethod \u00b6 Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the k parameter for the returned SymetricKey. Parameters: Name Type Description Default k Union [ bytes , str ] the key to use required **params Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the resulting SymmetricJwk Source code in jwskate/jwk/oct.py 78 79 80 81 82 83 84 85 86 87 88 89 @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk : \"\"\"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . to ( \"b64u\" ) . ascii (), ** params )) from_cryptography_key ( cryptography_key , ** kwargs ) classmethod \u00b6 Alias for from_bytes() since symmetric keys are simply bytes. Parameters: Name Type Description Default cryptography_key Any the key to use required **kwargs Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the resulting SymmetricJwk Source code in jwskate/jwk/oct.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> SymmetricJwk : \"\"\"Alias for `from_bytes()` since symmetric keys are simply bytes. Args: cryptography_key: the key to use **kwargs: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls . from_bytes ( cryptography_key , ** kwargs ) generate ( key_size = 128 , ** params ) classmethod \u00b6 Generate a random SymmetricJwk, with a given key size. Parameters: Name Type Description Default key_size int the size of the generated key, in bits 128 **params str additional members to include in the Jwk {} Returns: Type Description SymmetricJwk a SymmetricJwk with a randomly generated key Source code in jwskate/jwk/oct.py 106 107 108 109 110 111 112 113 114 115 116 117 118 @classmethod def generate ( cls , key_size : int = 128 , ** params : str ) -> SymmetricJwk : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: key_size: the size of the generated key, in bits **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( key_size ) return cls . from_bytes ( key , ** params ) generate_for_alg ( alg , ** params ) classmethod \u00b6 Generate a SymmetricJwk that is suitable for use with the given alg. Parameters: Name Type Description Default alg str the signing algorithm to use this key with required **params str additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the resulting Jwk Raises: Type Description ValueError if the provided alg is not supported Source code in jwskate/jwk/oct.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 @classmethod def generate_for_alg ( cls , alg : str , ** params : str ) -> SymmetricJwk : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the signing algorithm to use this key with **params: additional members to include in the Jwk Returns: the resulting Jwk Raises: ValueError: if the provided `alg` is not supported \"\"\" if alg in cls . SIGNATURE_ALGORITHMS : sigalg = cls . SIGNATURE_ALGORITHMS [ alg ] return cls . generate ( sigalg . min_key_size , alg = alg , ** params ) if alg in cls . ENCRYPTION_ALGORITHMS : encalg = cls . ENCRYPTION_ALGORITHMS [ alg ] return cls . generate ( encalg . key_size , alg = alg , ** params ) raise ValueError ( \"Unsupported alg\" , alg ) key () property \u00b6 Returns the raw symmetric key. Returns: Type Description BinaPy the key from the k parameter, base64u-decoded Source code in jwskate/jwk/oct.py 170 171 172 173 174 175 176 177 @property def key ( self ) -> BinaPy : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return self . cryptography_key # type: ignore key_size () property \u00b6 The key size, in bits. Returns: Type Description int the key size in bits Source code in jwskate/jwk/oct.py 209 210 211 212 213 214 215 216 @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 public_jwk () \u00b6 This always raises a ValueError since SymmetricKeys are always private. Raises: Type Description ValueError symmetric keys are always private, it makes no sense to use them as public keys Source code in jwskate/jwk/oct.py 70 71 72 73 74 75 76 def public_jwk ( self ) -> Jwk : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) supported_encryption_algorithms () \u00b6 Return the list of supported Encryption/Decryption algorithms with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/oct.py 257 258 259 260 261 262 263 264 265 266 267 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) ] supported_key_management_algorithms () \u00b6 Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/oct.py 245 246 247 248 249 250 251 252 253 254 255 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) # type: ignore ] thumbprint ( hashalg = 'SHA256' ) \u00b6 Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Returns: Type Description str the calculated thumbprint Source code in jwskate/jwk/oct.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () ) UnsupportedAlg \u00b6 Bases: ValueError Raised when an UnsupportedAlg is requested. Source code in jwskate/jwk/alg.py 9 10 class UnsupportedAlg ( ValueError ): \"\"\"Raised when an UnsupportedAlg is requested.\"\"\" UnsupportedEllipticCurve \u00b6 Bases: KeyError Raised when an unsupported Elliptic curve is requested. Source code in jwskate/jwk/ec.py 31 32 class UnsupportedEllipticCurve ( KeyError ): \"\"\"Raised when an unsupported Elliptic curve is requested.\"\"\" UnsupportedOKPCurve \u00b6 Bases: KeyError Raised when an unsupported OKP curve is requested. Source code in jwskate/jwk/okp.py 23 24 class UnsupportedOKPCurve ( KeyError ): \"\"\"Raised when an unsupported OKP curve is requested.\"\"\" selection: docstring_style: google filters: - \"!^_\" - \"^ init \" rendering: members_order: source show_root_heading: true heading_level: 2","title":"API"},{"location":"api/#jwskate.Ed25519","text":"Ed25519 curve.","title":"Ed25519"},{"location":"api/#jwskate.Ed448","text":"Ed448 curve.","title":"Ed448"},{"location":"api/#jwskate.P_256","text":"P-256 curve","title":"P_256"},{"location":"api/#jwskate.P_384","text":"P-384 curve","title":"P_384"},{"location":"api/#jwskate.P_521","text":"P-521 curve","title":"P_521"},{"location":"api/#jwskate.X25519","text":"X25519 curve.","title":"X25519"},{"location":"api/#jwskate.X448","text":"X448 curve.","title":"X448"},{"location":"api/#jwskate.secp256k1","text":"secp256k1 curve","title":"secp256k1"},{"location":"api/#jwskate.A128GCM","text":"Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 62 63 64 65 66 67 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128","title":"A128GCM"},{"location":"api/#jwskate.A128GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 47 48 49 50 51 52 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128","title":"A128GCMKW"},{"location":"api/#jwskate.A128KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 53 54 55 56 57 58 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128","title":"A128KW"},{"location":"api/#jwskate.A192GCM","text":"Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 70 71 72 73 74 75 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192","title":"A192GCM"},{"location":"api/#jwskate.A192GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 55 56 57 58 59 60 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192","title":"A192GCMKW"},{"location":"api/#jwskate.A192KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 61 62 63 64 65 66 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192","title":"A192KW"},{"location":"api/#jwskate.A256GCM","text":"Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 78 79 80 81 82 83 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256","title":"A256GCM"},{"location":"api/#jwskate.A256GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 63 64 65 66 67 68 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256","title":"A256GCMKW"},{"location":"api/#jwskate.A256KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 69 70 71 72 73 74 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256","title":"A256KW"},{"location":"api/#jwskate.Aes128CbcHmacSha256","text":"Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate/jwa/encryption/aescbchmac.py 110 111 112 113 114 115 116 117 118 class Aes128CbcHmacSha256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 ()","title":"Aes128CbcHmacSha256"},{"location":"api/#jwskate.Aes192CbcHmacSha384","text":"Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate/jwa/encryption/aescbchmac.py 121 122 123 124 125 126 127 128 129 class Aes192CbcHmacSha384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 ()","title":"Aes192CbcHmacSha384"},{"location":"api/#jwskate.Aes256CbcHmacSha512","text":"Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate/jwa/encryption/aescbchmac.py 132 133 134 135 136 137 138 139 140 141 class Aes256CbcHmacSha512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 ()","title":"Aes256CbcHmacSha512"},{"location":"api/#jwskate.BaseAESEncryptionAlg","text":"Bases: BaseSymmetricAlg Base class for AES encryption algorithms. Source code in jwskate/jwa/base.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 class BaseAESEncryptionAlg ( BaseSymmetricAlg ): \"\"\"Base class for AES encryption algorithms.\"\"\" key_size : int tag_size : int iv_size : int @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" ) @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) def encrypt ( self , plaintext : bytes , * , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError def decrypt ( self , ciphertext : bytes , * , iv : bytes , auth_tag : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt iv: the Initialisation Vector to use. Must be the same one used during encryption auth_tag: the authentication tag aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError @classmethod def init_random_key ( cls ) -> BaseAESEncryptionAlg : \"\"\"Initialize this alg with a random key. Returns: a subclass of BaseAESEncryptionAlg initialized with a randomly generated key \"\"\" return cls ( cls . generate_key ())","title":"BaseAESEncryptionAlg"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.check_key","text":"Check that a key is suitable for this algorithm. Parameters: Name Type Description Default key bytes the key to check required Raises: Type Description ValueError if the key is not suitable Source code in jwskate/jwa/base.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected keysize of { cls . key_size } bits\" )","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.decrypt","text":"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required iv bytes the Initialisation Vector to use. Must be the same one used during encryption required auth_tag bytes the authentication tag required aad Optional [ bytes ] the Additional Authentication Data. Must be the same one used during encryption required Returns: Type Description BinaPy the deciphered data Source code in jwskate/jwa/base.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def decrypt ( self , ciphertext : bytes , * , iv : bytes , auth_tag : bytes , aad : Optional [ bytes ] ) -> BinaPy : \"\"\"Decrypt a ciphertext with a given Initialisation Vector (iv) and optional Additional Authentication Data (aad), returns the resulting clear text. Args: ciphertext: the data to decrypt iv: the Initialisation Vector to use. Must be the same one used during encryption auth_tag: the authentication tag aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError","title":"decrypt()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.encrypt","text":"Encrypt arbitrary data ( plaintext ) with the given Initialisation Vector ( iv ) and optional Additional Authentication Data ( aad ), return the ciphered text and authentication tag. Parameters: Name Type Description Default plaintext bytes the data to encrypt required iv bytes the Initialisation Vector to use required aad Optional [ bytes ] the Additional Authentication Data required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple of ciphered data and authentication tag Source code in jwskate/jwa/base.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def encrypt ( self , plaintext : bytes , * , iv : bytes , aad : Optional [ bytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data (`plaintext`) with the given Initialisation Vector (`iv`) and optional Additional Authentication Data (`aad`), return the ciphered text and authentication tag. Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag \"\"\" raise NotImplementedError","title":"encrypt()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_iv","text":"Generate an Initialisation Vector of the appropriate size. Returns: Type Description BinaPy a random IV Source code in jwskate/jwa/base.py 224 225 226 227 228 229 230 231 @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size )","title":"generate_iv()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_key","text":"Generate a key of an appropriate size for this AES alg subclass. Returns: Type Description BinaPy a random AES key Source code in jwskate/jwa/base.py 215 216 217 218 219 220 221 222 @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size )","title":"generate_key()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.init_random_key","text":"Initialize this alg with a random key. Returns: Type Description BaseAESEncryptionAlg a subclass of BaseAESEncryptionAlg initialized with a randomly generated key Source code in jwskate/jwa/base.py 264 265 266 267 268 269 270 271 @classmethod def init_random_key ( cls ) -> BaseAESEncryptionAlg : \"\"\"Initialize this alg with a random key. Returns: a subclass of BaseAESEncryptionAlg initialized with a randomly generated key \"\"\" return cls ( cls . generate_key ())","title":"init_random_key()"},{"location":"api/#jwskate.BaseAlg","text":"Base class for all algorithms. An algorithm has a name and a description , whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms Source code in jwskate/jwa/base.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class BaseAlg : \"\"\"Base class for all algorithms. An algorithm has a `name` and a `description`, whose reference is here: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms \"\"\" name : str \"\"\"Technical name of the algorithm\"\"\" description : str \"\"\"Description of the algorithm (human readable)\"\"\" read_only : bool = False \"\"\"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.\"\"\" def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name","title":"BaseAlg"},{"location":"api/#jwskate.jwa.base.BaseAlg.description","text":"Description of the algorithm (human readable)","title":"description"},{"location":"api/#jwskate.jwa.base.BaseAlg.name","text":"Technical name of the algorithm","title":"name"},{"location":"api/#jwskate.jwa.base.BaseAlg.read_only","text":"For algs that are considered insecure, allow only signature verification or decryption of existing data, but don't allow new signatures or new encryptions.","title":"read_only"},{"location":"api/#jwskate.jwa.base.BaseAlg.__repr__","text":"Use the name of the alg as repr. Source code in jwskate/jwa/base.py 32 33 34 def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name","title":"__repr__()"},{"location":"api/#jwskate.BaseAsymmetricAlg","text":"Bases: Generic [ Kpriv , Kpub ] , BaseAlg Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Source code in jwskate/jwa/base.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class BaseAsymmetricAlg ( Generic [ Kpriv , Kpub ], BaseAlg ): \"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Args: key: the key to use. \"\"\" private_key_class : Union [ Type [ Kpriv ], Tuple [ Type [ Kpriv ], ... ]] public_key_class : Union [ Type [ Kpub ], Tuple [ Type [ Kpub ], ... ]] def __init__ ( self , key : Union [ Kpriv , Kpub ]): self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore","title":"BaseAsymmetricAlg"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.check_key","text":"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Returns: Type Description None Returns None. Raises an exception if the key is not suitable. Raises: Type Description Exception if the key is not suitable for use with this alg class Source code in jwskate/jwa/base.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\"","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.private_key_required","text":"A context manager that checks if this alg is initialised with a private key. Yields: Type Description Iterator [ Kpriv ] the private key Raises: Type Description PrivateKeyRequired if the configured key is not private Source code in jwskate/jwa/base.py 137 138 139 140 141 142 143 144 145 146 147 148 149 @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore","title":"private_key_required()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.public_key_required","text":"A context manager that checks if this alg is initialised with a public key. Yields: Type Description Iterator [ Kpub ] The public key Raises: Type Description PublicKeyRequired if the configured key is private Source code in jwskate/jwa/base.py 151 152 153 154 155 156 157 158 159 160 161 162 163 @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore","title":"public_key_required()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.supports_key","text":"Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate/jwa/base.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @classmethod def supports_key ( cls , key : Union [ Kpriv , Kpub ]) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"supports_key()"},{"location":"api/#jwskate.BaseEcdhEs_AesKw","text":"Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate/jwa/key_mgmt/ecdh.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"BaseEcdhEs_AesKw"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.unwrap_key_with_epk","text":"Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey bytes the wrapped key required ephemeral_public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate/jwa/key_mgmt/ecdh.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def unwrap_key_with_epk ( self , cipherkey : bytes , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"unwrap_key_with_epk()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.wrap_key_with_epk","text":"Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate/jwa/key_mgmt/ecdh.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey )","title":"wrap_key_with_epk()"},{"location":"api/#jwskate.BaseKeyManagementAlg","text":"Bases: BaseAlg Base class for Key Management algorithms. Source code in jwskate/jwa/base.py 274 275 class BaseKeyManagementAlg ( BaseAlg ): \"\"\"Base class for Key Management algorithms.\"\"\"","title":"BaseKeyManagementAlg"},{"location":"api/#jwskate.BasePbes2","text":"Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. PBES2 derives a cryptographic key from a human-provided password. Parameters: Name Type Description Default password Union [ bytes , str ] the encryption/decryption password to use required Source code in jwskate/jwa/key_mgmt/pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms. PBES2 derives a cryptographic key from a human-provided password. Args: password: the encryption/decryption password to use \"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ bytes , str ]): if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"BasePbes2"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.derive","text":"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate/jwa/key_mgmt/pbes2.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def derive ( self , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive the encryption key based on the configured password, the given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password ))","title":"derive()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.generate_salt","text":"Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate/jwa/key_mgmt/pbes2.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size )","title":"generate_salt()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.unwrap_key","text":"Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate/jwa/key_mgmt/pbes2.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def unwrap_key ( self , cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.wrap_key","text":"Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate/jwa/key_mgmt/pbes2.py 65 66 67 68 69 70 71 72 73 74 75 76 77 def wrap_key ( self , plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey ))","title":"wrap_key()"},{"location":"api/#jwskate.BaseRsaKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Parameters: Name Type Description Default key Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate/jwa/key_mgmt/rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms. Args: key: the private or public key to use \"\"\" padding : Any name : str description : str private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def __init__ ( self , key : Union [ asymmetric . rsa . RSAPublicKey , asymmetric . rsa . RSAPrivateKey ] ): self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" if self . read_only : raise NotImplementedError with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"BaseRsaKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.unwrap_key","text":"Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate/jwa/key_mgmt/rsa.py 52 53 54 55 56 57 58 59 60 61 62 63 64 def unwrap_key ( self , cipherkey : bytes ) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.wrap_key","text":"Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate/jwa/key_mgmt/rsa.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" if self . read_only : raise NotImplementedError with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding ))","title":"wrap_key()"},{"location":"api/#jwskate.BaseSignatureAlg","text":"Bases: BaseAlg Base class for signature algorithms. Source code in jwskate/jwa/base.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 class BaseSignatureAlg ( BaseAlg ): \"\"\"Base class for signature algorithms.\"\"\" def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError","title":"BaseSignatureAlg"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.sign","text":"Sign arbitrary data, return the signature. Parameters: Name Type Description Default data bytes raw data to sign required Returns: Type Description BinaPy the raw signature Source code in jwskate/jwa/base.py 169 170 171 172 173 174 175 176 177 178 def sign ( self , data : bytes ) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError","title":"sign()"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.verify","text":"Verify a signature against some data. Parameters: Name Type Description Default data bytes the raw data to verify required signature bytes the raw signature required Returns: Type Description bool True if the signature matches, False otherwise. Source code in jwskate/jwa/base.py 180 181 182 183 184 185 186 187 188 189 190 def verify ( self , data : bytes , signature : bytes ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError","title":"verify()"},{"location":"api/#jwskate.BaseSymmetricAlg","text":"Bases: BaseAlg Base class for Symmetric algorithms (using a raw bytes key). Parameters: Name Type Description Default key bytes the key to use for cryptographic operations required Source code in jwskate/jwa/base.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class BaseSymmetricAlg ( BaseAlg ): \"\"\"Base class for Symmetric algorithms (using a raw bytes key). Args: key: the key to use for cryptographic operations \"\"\" def __init__ ( self , key : bytes ): self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"BaseSymmetricAlg"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.check_key","text":"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description None Returns None . Raises an exception if the key is not suitable Source code in jwskate/jwa/base.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.supports_key","text":"Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate/jwa/base.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"supports_key()"},{"location":"api/#jwskate.DirectKeyUse","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate/jwa/key_mgmt/dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"DirectKeyUse"},{"location":"api/#jwskate.jwa.key_mgmt.dir.DirectKeyUse.direct_key","text":"Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate/jwa/key_mgmt/dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"direct_key()"},{"location":"api/#jwskate.ECJwk","text":"Bases: Jwk Represent an Elliptic Curve Jwk, with kty=EC . Source code in jwskate/jwk/ec.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 class ECJwk ( Jwk ): \"\"\"Represent an Elliptic Curve Jwk, with `kty=EC`.\"\"\" KTY = \"EC\" CRYPTOGRAPHY_KEY_CLASSES = ( asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ) PARAMS : Mapping [ str , JwkParameter ] = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"X Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"y\" : JwkParameter ( \"Y Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"ECC Private Key\" , is_private = True , is_required = True , kind = \"b64u\" ), } CURVES : Mapping [ str , EllipticCurve ] = { curve . name : curve for curve in [ P_256 , P_384 , P_521 , secp256k1 ] } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ ES256 , ES384 , ES512 , ES256K ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedEllipticCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . to ( \"b64u\" ), ** params , ) ) @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . to ( \"b64u\" ) . ascii (), y = BinaPy . from_int ( y , coord_size ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d , coord_size ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: cryptography_key: `cryptography` key **kwargs: additional members to include in the Jwk Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_jwk_parameters ( cryptography_key ) return cls ( parameters ) def _to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key () @classmethod def generate ( cls , crv : str = \"P-256\" , ** params : str ) -> \"ECJwk\" : \"\"\"Generates a random ECJwk. Args: crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" curve = cls . get_curve ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = crv , x = x , y = y , d = d , ** params , ) @cached_property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () @cached_property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () @cached_property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) def to_pem_key ( self , password : Optional [ bytes ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM encrypted key \"\"\" if self . is_private : assert isinstance ( self . cryptography_key , ec . EllipticCurvePrivateKey ) encryption : serialization . KeySerializationEncryption if password : encryption = serialization . BestAvailableEncryption ( password ) else : encryption = serialization . NoEncryption () return self . cryptography_key . private_bytes ( # type: ignore[no-any-return, attr-defined] serialization . Encoding . PEM , serialization . PrivateFormat . PKCS8 , encryption , ) else : assert isinstance ( self . cryptography_key , ec . EllipticCurvePublicKey ) if password : raise ValueError ( \"Public keys cannot be encrypted when serialized in PEM format.\" ) return self . cryptography_key . public_bytes ( serialization . Encoding . PEM , serialization . PublicFormat . SubjectPublicKeyInfo , )","title":"ECJwk"},{"location":"api/#jwskate.jwk.ec.ECJwk.coordinate_size","text":"The coordinate size to use with the key curve. Returns: Type Description int 32, 48, or 66 (bits) Source code in jwskate/jwk/ec.py 157 158 159 160 161 162 163 164 @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size","title":"coordinate_size()"},{"location":"api/#jwskate.jwk.ec.ECJwk.curve","text":"Get the EllipticCurve instance for this key. Returns: Type Description EllipticCurve the EllipticCurve instance Source code in jwskate/jwk/ec.py 98 99 100 101 102 103 104 105 @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv )","title":"curve()"},{"location":"api/#jwskate.jwk.ec.ECJwk.ecc_private_key","text":"Return the ECC private key from this ECJwk. Returns: Type Description int the ECC private key (from parameter d ) Source code in jwskate/jwk/ec.py 251 252 253 254 255 256 257 258 @cached_property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int ()","title":"ecc_private_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk.from_cryptography_key","text":"Initialize an ECJwk from a cryptography key. Parameters: Name Type Description Default cryptography_key Any cryptography key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description ECJwk an ECJwk initialized from the provided cryptography key Source code in jwskate/jwk/ec.py 166 167 168 169 170 171 172 173 174 175 176 177 178 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: cryptography_key: `cryptography` key **kwargs: additional members to include in the Jwk Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_jwk_parameters ( cryptography_key ) return cls ( parameters )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk.generate","text":"Generates a random ECJwk. Parameters: Name Type Description Default crv str the curve to use 'P-256' **params str {} Returns: Type Description ECJwk a generated ECJwk Raises: Type Description UnsupportedEllipticCurve if the provided curve identifier is not supported. Source code in jwskate/jwk/ec.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @classmethod def generate ( cls , crv : str = \"P-256\" , ** params : str ) -> \"ECJwk\" : \"\"\"Generates a random ECJwk. Args: crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" curve = cls . get_curve ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = crv , x = x , y = y , d = d , ** params , )","title":"generate()"},{"location":"api/#jwskate.jwk.ec.ECJwk.get_curve","text":"Get the EllipticCurve instance for a given curve identifier. Parameters: Name Type Description Default crv str the curve identifier required Returns: Type Description EllipticCurve the matching EllipticCurve instance Raises: Type Description UnsupportedEllipticCurve if the curve identifier is not supported Source code in jwskate/jwk/ec.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve","title":"get_curve()"},{"location":"api/#jwskate.jwk.ec.ECJwk.private","text":"Initialize a private ECJwk from its private parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required d int the elliptic curve private key required **params Any additional members to include in the JWK {} Returns: Type Description ECJwk an ECJWk initialized with the supplied parameters Source code in jwskate/jwk/ec.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . to ( \"b64u\" ) . ascii (), y = BinaPy . from_int ( y , coord_size ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d , coord_size ) . to ( \"b64u\" ) . ascii (), ** params , ) )","title":"private()"},{"location":"api/#jwskate.jwk.ec.ECJwk.public","text":"Initialize a public ECJwk from its public parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required **params str additional member to include in the Jwk {} Returns: Type Description ECJwk an ECJwk initialized with the supplied parameters Source code in jwskate/jwk/ec.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . to ( \"b64u\" ), ** params , ) )","title":"public()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_encryption_algorithms","text":"Return the list of support Encryption algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 280 281 282 283 284 285 286 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS )","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_key_management_algorithms","text":"Return the list of supported Key Management algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 272 273 274 275 276 277 278 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS )","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_signing_algorithms","text":"Return the list of supported signature algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 260 261 262 263 264 265 266 267 268 269 270 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ]","title":"supported_signing_algorithms()"},{"location":"api/#jwskate.jwk.ec.ECJwk.to_pem_key","text":"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Parameters: Name Type Description Default password Optional [ bytes ] password to use to encrypt the PEM None Returns: Type Description bytes the PEM encrypted key Source code in jwskate/jwk/ec.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def to_pem_key ( self , password : Optional [ bytes ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM encrypted key \"\"\" if self . is_private : assert isinstance ( self . cryptography_key , ec . EllipticCurvePrivateKey ) encryption : serialization . KeySerializationEncryption if password : encryption = serialization . BestAvailableEncryption ( password ) else : encryption = serialization . NoEncryption () return self . cryptography_key . private_bytes ( # type: ignore[no-any-return, attr-defined] serialization . Encoding . PEM , serialization . PrivateFormat . PKCS8 , encryption , ) else : assert isinstance ( self . cryptography_key , ec . EllipticCurvePublicKey ) if password : raise ValueError ( \"Public keys cannot be encrypted when serialized in PEM format.\" ) return self . cryptography_key . public_bytes ( serialization . Encoding . PEM , serialization . PublicFormat . SubjectPublicKeyInfo , )","title":"to_pem_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk.x_coordinate","text":"Return the x coordinate from this ECJwk. Returns: Type Description int the x coordinate (from parameter x ) Source code in jwskate/jwk/ec.py 233 234 235 236 237 238 239 240 @cached_property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int ()","title":"x_coordinate()"},{"location":"api/#jwskate.jwk.ec.ECJwk.y_coordinate","text":"Return the y coordinate from this ECJwk. Returns: Type Description int the y coordinate (from parameter y ) Source code in jwskate/jwk/ec.py 242 243 244 245 246 247 248 249 @cached_property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int ()","title":"y_coordinate()"},{"location":"api/#jwskate.ES256","text":"Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256 Source code in jwskate/jwa/signature/ec.py 57 58 59 60 61 62 63 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 ()","title":"ES256"},{"location":"api/#jwskate.ES256K","text":"Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256 Source code in jwskate/jwa/signature/ec.py 84 85 86 87 88 89 90 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 ()","title":"ES256K"},{"location":"api/#jwskate.ES384","text":"Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384 Source code in jwskate/jwa/signature/ec.py 66 67 68 69 70 71 72 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 ()","title":"ES384"},{"location":"api/#jwskate.ES512","text":"Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512 Source code in jwskate/jwa/signature/ec.py 75 76 77 78 79 80 81 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 ()","title":"ES512"},{"location":"api/#jwskate.EcdhEs","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ]] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate/jwa/key_mgmt/ecdh.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = ( ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ) private_key_class = ( ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ) @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" if isinstance ( private_key , ec . EllipticCurvePrivateKey ) and isinstance ( public_key , ec . EllipticCurvePublicKey ): shared_key = private_key . exchange ( ec . ECDH (), public_key ) elif isinstance ( private_key , x25519 . X25519PrivateKey ) and isinstance ( public_key , x25519 . X25519PublicKey ): shared_key = private_key . exchange ( public_key ) elif isinstance ( private_key , x448 . X448PrivateKey ) and isinstance ( public_key , x448 . X448PublicKey ): shared_key = private_key . exchange ( public_key ) else : raise ValueError ( \"Invalid or unsupported private/public key combination for ECDH\" , private_key , public_key , ) return BinaPy ( shared_key ) @classmethod def derive ( cls , * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], otherinfo : bytes , key_size : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter key_size: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = key_size // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self , ) -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ]: \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" if isinstance ( self . key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ) ): return ec . generate_private_key ( self . key . curve ) elif isinstance ( self . key , ( x25519 . X25519PrivateKey , x25519 . X25519PublicKey )): return x25519 . X25519PrivateKey . generate () elif isinstance ( self . key , ( x448 . X448PublicKey , x448 . X448PrivateKey )): return x448 . X448PrivateKey . generate () def sender_key ( self , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = ephemeral_private_key , public_key = key , otherinfo = otherinfo , key_size = key_size , ) return cek def recipient_key ( self , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = key , public_key = ephemeral_public_key , otherinfo = otherinfo , key_size = key_size , ) return cek","title":"EcdhEs"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.derive","text":"Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the private key required public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required key_size int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate/jwa/key_mgmt/ecdh.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 @classmethod def derive ( cls , * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], otherinfo : bytes , key_size : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter key_size: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = key_size // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key ))","title":"derive()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.ecdh","text":"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] a private EC key required public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate/jwa/key_mgmt/ecdh.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @classmethod def ecdh ( cls , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" if isinstance ( private_key , ec . EllipticCurvePrivateKey ) and isinstance ( public_key , ec . EllipticCurvePublicKey ): shared_key = private_key . exchange ( ec . ECDH (), public_key ) elif isinstance ( private_key , x25519 . X25519PrivateKey ) and isinstance ( public_key , x25519 . X25519PublicKey ): shared_key = private_key . exchange ( public_key ) elif isinstance ( private_key , x448 . X448PrivateKey ) and isinstance ( public_key , x448 . X448PublicKey ): shared_key = private_key . exchange ( public_key ) else : raise ValueError ( \"Invalid or unsupported private/public key combination for ECDH\" , private_key , public_key , ) return BinaPy ( shared_key )","title":"ecdh()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.generate_ephemeral_key","text":"Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate/jwa/key_mgmt/ecdh.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_ephemeral_key ( self , ) -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ]: \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" if isinstance ( self . key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ) ): return ec . generate_private_key ( self . key . curve ) elif isinstance ( self . key , ( x25519 . X25519PrivateKey , x25519 . X25519PublicKey )): return x25519 . X25519PrivateKey . generate () elif isinstance ( self . key , ( x448 . X448PublicKey , x448 . X448PrivateKey )): return x448 . X448PrivateKey . generate ()","title":"generate_ephemeral_key()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.otherinfo","text":"Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required keysize int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate/jwa/key_mgmt/ecdh.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , keysize : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo keysize: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( keysize or keysize , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo )","title":"otherinfo()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.recipient_key","text":"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate/jwa/key_mgmt/ecdh.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def recipient_key ( self , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = key , public_key = ephemeral_public_key , otherinfo = otherinfo , key_size = key_size , ) return cek","title":"recipient_key()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.sender_key","text":"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate/jwa/key_mgmt/ecdh.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def sender_key ( self , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = ephemeral_private_key , public_key = key , otherinfo = otherinfo , key_size = key_size , ) return cek","title":"sender_key()"},{"location":"api/#jwskate.EcdhEs_A128KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 267 268 269 270 271 272 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW","title":"EcdhEs_A128KW"},{"location":"api/#jwskate.EcdhEs_A192KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 275 276 277 278 279 280 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW","title":"EcdhEs_A192KW"},{"location":"api/#jwskate.EcdhEs_A256KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 283 284 285 286 287 288 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW","title":"EcdhEs_A256KW"},{"location":"api/#jwskate.EdDsa","text":"Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate/jwa/signature/eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : bytes ) -> BinaPy : # noqa: D102 with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : bytes , signature : bytes ) -> bool : # noqa: D102 with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False","title":"EdDsa"},{"location":"api/#jwskate.EllipticCurve","text":"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a cryptography.ec.EllipticCurve , and a coordinate size. Source code in jwskate/jwa/ec.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @dataclass class EllipticCurve : \"\"\"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size. \"\"\" name : str \"\"\" Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` or `enc` fields in JOSE headers.\"\"\" cryptography_curve : ec . EllipticCurve \"\"\"`cryptography` curve instance.\"\"\" coordinate_size : int \"\"\"Coordinate size, in bytes.\"\"\" instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key: an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) @classmethod def get_jwk_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a dict of JWK parameters matching that key Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) public_numbers : ec . EllipticCurvePublicNumbers if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () y = BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters","title":"EllipticCurve"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.coordinate_size","text":"Coordinate size, in bytes.","title":"coordinate_size"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.cryptography_curve","text":"cryptography curve instance.","title":"cryptography_curve"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.instances","text":"Registry of subclasses, in a {name: instance} mapping.","title":"instances"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.name","text":"Curve name as defined in IANA JOSE . This name will appear in alg or enc fields in JOSE headers.","title":"name"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.__post_init__","text":"Automatically register subclasses in the instance registry. Source code in jwskate/jwa/ec.py 34 35 36 def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self","title":"__post_init__()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.generate","text":"Generate a new EC key on this curve. Returns: Type Description Tuple [ int , int , int ] a tuple of 4 int s: x and y coordinates (public key) and d (private key) Source code in jwskate/jwa/ec.py 38 39 40 41 42 43 44 45 46 47 48 49 def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d","title":"generate()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_curve","text":"Get the appropriate EllipticCurve instance for a given cryptography EllipticCurvePublicKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] an Elliptic Curve private or public key from cryptography . required Returns: Type Description EllipticCurve the appropriate instance of EllipticCurve for the given key. Raises: Type Description NotImplementedError if the curve is not supported Source code in jwskate/jwa/ec.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key: an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" )","title":"get_curve()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_jwk_parameters","text":"Extract all private and public parameters from a given cryptography EllipticCurvePrivateKey or EllipticCurvePublicKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] an Elliptic Curve public or private key from cryptography . required Returns: Type Description Dict [ str , Any ] a dict of JWK parameters matching that key Raises: Type Description TypeError if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey Source code in jwskate/jwa/ec.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @classmethod def get_jwk_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from a given `cryptography` `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a dict of JWK parameters matching that key Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) public_numbers : ec . EllipticCurvePublicNumbers if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () y = BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters","title":"get_jwk_parameters()"},{"location":"api/#jwskate.EncryptedJwt","text":"Bases: Jwt Represent an encrypted JWT. Parameters: Name Type Description Default value Union [ bytes , str ] the serialized JWT value required Source code in jwskate/jwt/encrypted.py 8 9 10 11 12 13 14 15 16 class EncryptedJwt ( Jwt ): \"\"\"Represent an encrypted JWT. Args: value: the serialized JWT value \"\"\" def __init__ ( self , value : Union [ bytes , str ]): raise NotImplementedError","title":"EncryptedJwt"},{"location":"api/#jwskate.EncryptionAlgs","text":"Identifiers for Encryption algorithms. Source code in jwskate/enums.py 40 41 42 43 44 45 46 47 48 49 50 class EncryptionAlgs : \"\"\"Identifiers for Encryption algorithms.\"\"\" A128CBC_HS256 = \"A128CBC-HS256\" A192CBC_HS384 = \"A192CBC-HS384\" A256CBC_HS512 = \"A256CBC-HS512\" A128GCM = \"A128GCM\" A192GCM = \"A192GCM\" A256GCM = \"A256GCM\" ALL = [ A128CBC_HS256 , A192CBC_HS384 , A256CBC_HS512 , A128GCM , A192GCM , A256GCM ]","title":"EncryptionAlgs"},{"location":"api/#jwskate.ExpectedAlgRequired","text":"Bases: ValueError Raised when the expected signature alg(s) must be provided. Source code in jwskate/jwk/alg.py 13 14 class ExpectedAlgRequired ( ValueError ): \"\"\"Raised when the expected signature alg(s) must be provided.\"\"\"","title":"ExpectedAlgRequired"},{"location":"api/#jwskate.ExpiredJwt","text":"Bases: ValueError Raised when trying to validate an expired JWT token. Source code in jwskate/jwt/signed.py 14 15 class ExpiredJwt ( ValueError ): \"\"\"Raised when trying to validate an expired JWT token.\"\"\"","title":"ExpiredJwt"},{"location":"api/#jwskate.HS256","text":"Bases: BaseHMACSigAlg HMAC using SHA-256 Source code in jwskate/jwa/signature/hmac.py 31 32 33 34 35 36 37 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256\"\"\" name = \"HS256\" description = __doc__ hash_alg = hashes . SHA256 () min_key_size = 256","title":"HS256"},{"location":"api/#jwskate.HS384","text":"Bases: BaseHMACSigAlg HMAC using SHA-384 Source code in jwskate/jwa/signature/hmac.py 40 41 42 43 44 45 46 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384\"\"\" name = \"HS384\" description = __doc__ hash_alg = hashes . SHA384 () min_key_size = 384","title":"HS384"},{"location":"api/#jwskate.HS512","text":"Bases: BaseHMACSigAlg HMAC using SHA-512 Source code in jwskate/jwa/signature/hmac.py 49 50 51 52 53 54 55 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512\"\"\" name = \"HS512\" description = __doc__ hash_alg = hashes . SHA512 () min_key_size = 512","title":"HS512"},{"location":"api/#jwskate.InvalidClaim","text":"Bases: ValueError Raised when trying to validate a JWT with unexpected claims. Source code in jwskate/jwt/signed.py 22 23 class InvalidClaim ( ValueError ): \"\"\"Raised when trying to validate a JWT with unexpected claims.\"\"\"","title":"InvalidClaim"},{"location":"api/#jwskate.InvalidJwe","text":"Bases: ValueError Raised when an invalid JWE token is parsed. Source code in jwskate/jwe/compact.py 20 21 class InvalidJwe ( ValueError ): \"\"\"Raised when an invalid JWE token is parsed.\"\"\"","title":"InvalidJwe"},{"location":"api/#jwskate.InvalidJwk","text":"Bases: ValueError Raised when an invalid JWK is encountered. Source code in jwskate/jwk/base.py 48 49 class InvalidJwk ( ValueError ): \"\"\"Raised when an invalid JWK is encountered.\"\"\"","title":"InvalidJwk"},{"location":"api/#jwskate.InvalidJws","text":"Bases: ValueError Raised when an invalid Jws is parsed. Source code in jwskate/jws/compact.py 19 20 class InvalidJws ( ValueError ): \"\"\"Raised when an invalid Jws is parsed.\"\"\"","title":"InvalidJws"},{"location":"api/#jwskate.InvalidJwt","text":"Bases: ValueError Raised when an invalid Jwt is parsed. Source code in jwskate/jwt/base.py 17 18 class InvalidJwt ( ValueError ): \"\"\"Raised when an invalid Jwt is parsed.\"\"\"","title":"InvalidJwt"},{"location":"api/#jwskate.InvalidSignature","text":"Bases: ValueError Raised when trying to validate a JWT with an invalid signature. Source code in jwskate/jwt/signed.py 18 19 class InvalidSignature ( ValueError ): \"\"\"Raised when trying to validate a JWT with an invalid signature.\"\"\"","title":"InvalidSignature"},{"location":"api/#jwskate.JweCompact","text":"Bases: BaseCompactToken Represents a Json Web Encryption object, in compact representation, as defined in RFC7516. Parameters: Name Type Description Default value Union [ bytes , str ] the compact representation for this Jwe required Source code in jwskate/jwe/compact.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 class JweCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Encryption object, in compact representation, as defined in RFC7516. Args: value: the compact representation for this Jwe \"\"\" def __init__ ( self , value : Union [ bytes , str ]): super () . __init__ ( value ) if self . value . count ( b \".\" ) != 4 : raise InvalidJwe ( \"Invalid JWE: a JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots.\" ) header , cek , iv , ciphertext , auth_tag = self . value . split ( b \".\" ) try : headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) enc = headers . get ( \"enc\" ) if enc is None or not isinstance ( enc , str ): raise InvalidJwe ( \"Invalid JWE header: this JWE doesn't have a valid 'enc' header.\" ) self . headers = headers self . additional_authenticated_data = header except ValueError : raise InvalidJwe ( \"Invalid JWE header: it must be a Base64URL-encoded JSON object.\" ) try : self . wrapped_cek = BinaPy ( cek ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE CEK: it must be a Base64URL-encoded binary data (bytes).\" ) try : self . initialization_vector = BinaPy ( iv ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE IV: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . ciphertext = BinaPy ( ciphertext ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . authentication_tag = BinaPy ( auth_tag ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def from_parts ( cls , * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ), BinaPy ( cek ) . to ( \"b64u\" ), BinaPy ( iv ) . to ( \"b64u\" ), BinaPy ( ciphertext ) . to ( \"b64u\" ), BinaPy ( tag ) . to ( \"b64u\" ), ) ) ) @cached_property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" return self . get_header ( \"enc\" ) # type: ignore[no-any-return] # header has been checked at init time @classmethod def encrypt ( cls , plaintext : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext and return the resulting JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use enc: the CEK encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" jwk = Jwk ( jwk ) extra_headers = extra_headers or {} cek_jwk , wrapped_cek , cek_headers = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) PBES2_ALGORITHMS : Mapping [ str , Type [ BasePbes2 ]] = { alg . name : alg for alg in [ Pbes2_HS256_A128KW , Pbes2_HS384_A192KW , Pbes2_HS512_A256KW ] } def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> bytes : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: bytes: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext @classmethod def encrypt_with_password ( cls , plaintext : bytes , password : Union [ bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '. \" f \"Value must be one of { list ( cls . PBES2_ALGORITHMS . keys ()) } .\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000.\" ) wrapped_cek = wrapper . wrap_key ( cek , salt = salt , count = count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . to ( \"b64u\" ) . ascii (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '. \" f \"Value must be one of { list ( self . PBES2_ALGORITHMS . keys ()) } .\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2s' header is missing.\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2c' header is missing.\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise InvalidJwe ( \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt = salt , count = p2c ) return SymmetricJwk . from_bytes ( cek ) def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"JweCompact"},{"location":"api/#jwskate.jwe.compact.JweCompact.decrypt","text":"Decrypts this Jwe payload using a JWK. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required Returns: Name Type Description bytes bytes the decrypted payload Source code in jwskate/jwe/compact.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> bytes : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: bytes: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"decrypt()"},{"location":"api/#jwskate.jwe.compact.JweCompact.decrypt_with_password","text":"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Parameters: Name Type Description Default password Union [ bytes , str ] the password to use required Returns: Type Description bytes the unencrypted payload Source code in jwskate/jwe/compact.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"decrypt_with_password()"},{"location":"api/#jwskate.jwe.compact.JweCompact.enc","text":"Return the enc from the JWE header. The enc header contains the identifier of the CEK encryption algorithm. Returns: Type Description str the enc value Raises: Type Description AttributeError if there is no enc header or it is not a string Source code in jwskate/jwe/compact.py 116 117 118 119 120 121 122 123 124 125 126 127 128 @cached_property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" return self . get_header ( \"enc\" ) # type: ignore[no-any-return]","title":"enc()"},{"location":"api/#jwskate.jwe.compact.JweCompact.encrypt","text":"Encrypt an arbitrary plaintext and return the resulting JweCompact. Parameters: Name Type Description Default plaintext bytes the raw plaintext to encrypt required jwk Union [ Jwk , Dict [ str , Any ]] the public or symmetric key to use required enc str the CEK encryption algorithm to use required alg Optional [ str ] the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the generated token None cek Optional [ bytes ] the CEK to force use, for algorithms relying on a random CEK. Leave None to have a safe value generated by jwskate . None iv Optional [ bytes ] the IV to force use. Leave None to have a safe value generated by jwskate . None epk Optional [ Jwk ] the EPK to force use. Leave None to have a safe value generated by jwskate . None Returns: Type Description JweCompact the generated JweCompact instance Source code in jwskate/jwe/compact.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 @classmethod def encrypt ( cls , plaintext : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext and return the resulting JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use enc: the CEK encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" jwk = Jwk ( jwk ) extra_headers = extra_headers or {} cek_jwk , wrapped_cek , cek_headers = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag )","title":"encrypt()"},{"location":"api/#jwskate.jwe.compact.JweCompact.encrypt_with_password","text":"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Parameters: Name Type Description Default plaintext bytes the data to encrypt required password Union [ bytes , str ] the password to use required alg str the Key Management alg to use required enc str the Payload Encryption alg to use required salt Optional [ bytes ] the salt to use. Leave None (default) to have jwskate generate a safe random value None count int the number of PBES2 iterations (recommended minimum 1000) 2000 cek Optional [ bytes ] the CEK to force use. Leave None (default) to have jwskate generate a safe random value None iv Optional [ bytes ] the IV to force use. Leave None (default) to have jwskate generate a safe random value None Returns: Type Description JweCompact the resulting JweCompact Raises: Type Description UnsupportedAlg if the key management alg is not supported ValueError if the count parameter is not a positive integer Source code in jwskate/jwe/compact.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 @classmethod def encrypt_with_password ( cls , plaintext : bytes , password : Union [ bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '. \" f \"Value must be one of { list ( cls . PBES2_ALGORITHMS . keys ()) } .\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000.\" ) wrapped_cek = wrapper . wrap_key ( cek , salt = salt , count = count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . to ( \"b64u\" ) . ascii (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag )","title":"encrypt_with_password()"},{"location":"api/#jwskate.jwe.compact.JweCompact.from_parts","text":"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Parameters: Name Type Description Default headers Mapping [ str , Any ] the headers (as a mapping of name: value) required cek bytes the raw cek required iv bytes the raw iv required ciphertext bytes the raw ciphertext required tag bytes the authentication tag required Returns: Type Description JweCompact the initialized JweCompact instance Source code in jwskate/jwe/compact.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @classmethod def from_parts ( cls , * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ), BinaPy ( cek ) . to ( \"b64u\" ), BinaPy ( iv ) . to ( \"b64u\" ), BinaPy ( ciphertext ) . to ( \"b64u\" ), BinaPy ( tag ) . to ( \"b64u\" ), ) ) )","title":"from_parts()"},{"location":"api/#jwskate.jwe.compact.JweCompact.unwrap_cek","text":"Unwrap the CEK from this JWE token using the provided key or password. Parameters: Name Type Description Default jwk_or_password Union [ Jwk , Dict [ str , Any ], bytes , str ] the decryption JWK or password required Returns: Type Description Jwk the unwrapped CEK, as a SymmetricJwk Source code in jwskate/jwe/compact.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek","title":"unwrap_cek()"},{"location":"api/#jwskate.jwe.compact.JweCompact.unwrap_cek_with_password","text":"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Parameters: Name Type Description Default password Union [ bytes , str ] the decryption password required Returns: Type Description Jwk the CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the token key management algorithm is not supported AttributeError if the token misses the PBES2-related headers Source code in jwskate/jwe/compact.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '. \" f \"Value must be one of { list ( self . PBES2_ALGORITHMS . keys ()) } .\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2s' header is missing.\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2c' header is missing.\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise InvalidJwe ( \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt = salt , count = p2c ) return SymmetricJwk . from_bytes ( cek )","title":"unwrap_cek_with_password()"},{"location":"api/#jwskate.Jwk","text":"Bases: BaseJsonDict Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class: Jwk is a dict, so you can do with a Jwk anything you can do with a dict . In addition, all keys parameters are exposed as attributes. There are subclasses of Jwk for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Parameters: Name Type Description Default params Union [ Dict [ str , Any ], Any ] a dict with the parsed Jwk parameters, or a cryptography key , or another Jwk required include_kid_thumbprint bool if True (default), and there is no kid in the provided params, generate a kid based on the key thumbprint False Source code in jwskate/jwk/base.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 class Jwk ( BaseJsonDict ): \"\"\"Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class:`Jwk` is a dict, so you can do with a Jwk anything you can do with a `dict`. In addition, all keys parameters are exposed as attributes. There are subclasses of `Jwk` for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Args: params: a dict with the parsed Jwk parameters, or a `cryptography key`, or another `Jwk` include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint \"\"\" subclasses : Dict [ str , Type [ Jwk ]] = {} \"\"\"A dict of 'kty' values to subclasses implementing each specific Key Type\"\"\" cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} \"\"\"A dict of cryptography key classes to its specific 'kty' value\"\"\" PARAMS : Mapping [ str , JwkParameter ] \"\"\"A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)\"\"\" KTY : ClassVar [ str ] \"\"\"The Key Type associated with this JWK.\"\"\" CRYPTOGRAPHY_KEY_CLASSES : ClassVar [ Iterable [ Any ]] SIGNATURE_ALGORITHMS : Mapping [ str , Type [ BaseSignatureAlg ]] = {} KEY_MANAGEMENT_ALGORITHMS : Mapping [ str , Type [ BaseKeyManagementAlg ]] = {} ENCRYPTION_ALGORITHMS : Mapping [ str , Type [ BaseAESEncryptionAlg ]] = {} IANA_HASH_FUNCTION_NAMES : Mapping [ str , str ] = { # IANA registered names to binapy hash name \"sha-1\" : \"sha1\" , \"sha-224\" : \"sha224\" , \"sha-256\" : \"sha256\" , \"sha-384\" : \"sha384\" , \"sha-512\" : \"sha512\" , \"shake128\" : \"shake128\" , \"shake256\" : \"shake256\" , } def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls def __new__ ( cls , key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key **kwargs: additional members to include in the Jwk \"\"\" if cls == Jwk : if isinstance ( key , Jwk ): return cls . from_cryptography_key ( key . cryptography_key , ** kwargs ) if isinstance ( key , dict ): kty : Optional [ str ] = key . get ( \"kty\" ) if kty is None : raise InvalidJwk ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise InvalidJwk ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) elif isinstance ( key , str ): return cls . from_json ( key ) else : return cls . from_cryptography_key ( key , ** kwargs ) return super () . __new__ ( cls , key , ** kwargs ) def __init__ ( self , params : Union [ Dict [ str , Any ], Any ], include_kid_thumbprint : bool = False ): if isinstance ( params , dict ): # this is to avoid double init due to the __new__ above super () . __init__ ( { key : val for key , val in params . items () if val is not None } ) self . _validate () if self . get ( \"kid\" ) is None and include_kid_thumbprint : self [ \"kid\" ] = self . thumbprint () try : self . cryptography_key = self . _to_cryptography_key () except AttributeError as exc : raise InvalidJwk () from exc @property def is_private ( self ) -> bool : \"\"\"Return `True` if the key is private, `False` otherwise. Returns: `True` if the key is private, `False` otherwise \"\"\" return True def __getattr__ ( self , item : str ) -> Any : \"\"\"Allows access to key parameters as attributes, like `jwk.kid`, `jwk.kty`, instead of `jwk['kid']`, `jwk['kty']`, etc. Args: item: the member to access Return: the member value Raises: AttributeError: if the member is not found \"\"\" value = self . get ( item ) if value is None : raise AttributeError ( item ) return value def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Override base method to avoid modifying cryptographic key attributes. Args: key: name of the attribute to set value: value to set Raises: RuntimeError: when trying to modify cryptographic attributes \"\"\" if key in self . PARAMS : raise RuntimeError ( \"JWK key attributes cannot be modified.\" ) super () . __setitem__ ( key , value ) def thumbprint ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" alg = self . IANA_HASH_FUNCTION_NAMES . get ( hashalg ) if not alg : raise ValueError ( f \"Unsupported hash alg { hashalg } \" ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) return ( BinaPy . serialize_to ( \"json\" , t , separators = ( \",\" , \":\" ), sort_keys = True ) . to ( alg ) . to ( \"b64u\" ) . ascii () ) def thumbprint_uri ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Returns the JWK thumbprint URI for this key. Args: hashalg: the IANA registered name for the hash alg to use Returns: the JWK thumbprint uri for this Jwk \"\"\" return ( f \"urn:ietf:params:oauth:jwk-thumbprint: { hashalg } : { self . thumbprint ( hashalg ) } \" ) @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): raise TypeError ( f \"Invalid alg type { type ( str ) } \" , alg ) return alg def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : # pragma: no cover raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"decrypt\" , \"unwrapKey\" ) and not self . is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } key_ops = self . get ( \"key_ops\" ) if key_ops : if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"decrypt\" in key_ops : key_ops . remove ( \"decrypt\" ) key_ops . append ( \"encrypt\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) def sign ( self , data : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" sigalg = select_alg ( self . alg , alg , self . SIGNATURE_ALGORITHMS ) wrapper : BaseSignatureAlg if issubclass ( sigalg , BaseAsymmetricAlg ): wrapper = sigalg ( self . cryptography_key ) elif issubclass ( sigalg , BaseSymmetricAlg ): wrapper = sigalg ( self . key ) signature = wrapper . sign ( data ) return BinaPy ( signature ) def verify ( self , data : bytes , signature : bytes , * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" wrapper : BaseSignatureAlg for sigalg in select_algs ( self . alg , alg , algs , self . SIGNATURE_ALGORITHMS ): if issubclass ( sigalg , BaseAsymmetricAlg ): key = self . public_jwk () . cryptography_key wrapper = sigalg ( key ) elif issubclass ( sigalg , BaseSymmetricAlg ): key = self . key wrapper = sigalg ( key ) if wrapper . verify ( data , signature ): return True return False def encrypt ( self , plaintext : bytes , * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Initialization Vector and the Authentication Tag. Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector that was used to encrypt the data. If `iv` is passed as parameter, this will return that same value. Otherwise, an IV is generated. Returns: a tuple (ciphertext, iv, authentication_tag), as raw data \"\"\" raise NotImplementedError # pragma: no cover def decrypt ( self , ciphertext : bytes , * , iv : bytes , tag : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt iv: the Initialization Vector (IV) that was used for encryption tag: the Authentication Tag that will be verified while decrypting data aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover def sender_key ( self , enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]]: \"\"\"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. Returns a tuple with 3 items: - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key! - the encrypted CEK, as bytes. You must send this to your recipient. This may be empty for algs which derive a CEK instead of generating one. - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send this to your recipient as well. For algorithms that rely on a randomly generated CEK, you can provide that value instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only use this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: Tuple[Jwk,BinaPy,Mapping[str,Any]]: a tuple (cek, wrapped_cek, additional_headers_map) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) cek_headers : Dict [ str , Any ] = {} if issubclass ( keyalg , BaseRsaKeyWrap ): rsa : BaseRsaKeyWrap = keyalg ( self . public_jwk () . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = rsa . wrap_key ( cek ) elif issubclass ( keyalg , EcdhEs ): ecdh : EcdhEs = keyalg ( self . public_jwk () . cryptography_key ) epk = epk or Jwk . from_cryptography_key ( ecdh . generate_ephemeral_key ()) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( ecdh , BaseEcdhEs_AesKw ): if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = ecdh . wrap_key_with_epk ( cek , epk . cryptography_key , alg = keyalg . name , ** headers ) else : cek = ecdh . sender_key ( epk . cryptography_key , alg = encalg . name , key_size = encalg . key_size , ** headers , ) wrapped_cek = BinaPy ( b \"\" ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes : BaseAesKeyWrap = keyalg ( self . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = aes . wrap_key ( cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm : BaseAesGcmKeyWrap = keyalg ( self . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek iv = aesgcm . generate_iv () wrapped_cek , tag = aesgcm . wrap_key ( cek , iv = iv ) cek_headers = { \"iv\" : iv . to ( \"b64u\" ) . ascii (), \"tag\" : tag . to ( \"b64u\" ) . ascii (), } elif issubclass ( keyalg , DirectKeyUse ): dir : DirectKeyUse = keyalg ( self . key ) cek = dir . direct_key ( encalg ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ), wrapped_cek , cek_headers def recipient_key ( self , wrapped_cek : bytes , enc : str , * , alg : Optional [ str ] = None , ** headers : Any ) -> Jwk : \"\"\"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Args: wrapped_cek: the wrapped CEK enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to unwrap the CEK **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . cryptography_key ) cek = rsa . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , EcdhEs ): ecdh = keyalg ( self . cryptography_key ) epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . cryptography_key encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if isinstance ( ecdh , BaseEcdhEs_AesKw ): cek = ecdh . unwrap_key_with_epk ( wrapped_cek , epk , alg = keyalg . name ) else : cek = ecdh . recipient_key ( epk , alg = encalg . name , key_size = encalg . key_size , ** headers ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes = keyalg ( self . cryptography_key ) cek = aes . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm = keyalg ( self . cryptography_key ) iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = aesgcm . unwrap_key ( wrapped_cek , tag = tag , iv = iv ) elif issubclass ( keyalg , DirectKeyUse ): dir_ = keyalg ( self . key ) cek = dir_ . direct_key ( encalg ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key , ** kwargs ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) def _to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError @classmethod def from_pem_key ( cls , data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any , ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: a Jwk instance from the loaded key \"\"\" if isinstance ( data , str ): data = data . encode () if isinstance ( password , str ): password = password . encode () try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception as private_exc : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) from private_exc return cls . from_cryptography_key ( cryptography_key , ** kwargs ) def to_pem_key ( self , password : Optional [ bytes ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM serialized key \"\"\" raise NotImplementedError @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs ) @classmethod def generate_for_alg ( cls , alg : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key for usage with a specific alg and return the resuting Jwk. Args: alg: a signature or key management alg **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk \"\"\" raise NotImplementedError def copy ( self ) -> Jwk : \"\"\"Creates a copy of this key. Returns: a copy of this key, with the same value \"\"\" return Jwk ( super () . copy ()) def include_kid_thumbprint ( self , force : bool = False ) -> Jwk : \"\"\"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if `force` is `True`, this erases the previous \"kid\". - if `force` is `False` (default), do nothing. Args: force: whether to overwrite a previously existing kid Returns: a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`). \"\"\" jwk = self . copy () if self . kid is None or force : jwk [ \"kid\" ] = self . thumbprint () return jwk","title":"Jwk"},{"location":"api/#jwskate.jwk.base.Jwk.KTY","text":"The Key Type associated with this JWK.","title":"KTY"},{"location":"api/#jwskate.jwk.base.Jwk.PARAMS","text":"A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)","title":"PARAMS"},{"location":"api/#jwskate.jwk.base.Jwk.cryptography_key_types","text":"A dict of cryptography key classes to its specific 'kty' value","title":"cryptography_key_types"},{"location":"api/#jwskate.jwk.base.Jwk.subclasses","text":"A dict of 'kty' values to subclasses implementing each specific Key Type","title":"subclasses"},{"location":"api/#jwskate.jwk.base.Jwk.__getattr__","text":"Allows access to key parameters as attributes, like jwk.kid , jwk.kty , instead of jwk['kid'] , jwk['kty'] , etc. Parameters: Name Type Description Default item str the member to access required Return the member value Raises: Type Description AttributeError if the member is not found Source code in jwskate/jwk/base.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allows access to key parameters as attributes, like `jwk.kid`, `jwk.kty`, instead of `jwk['kid']`, `jwk['kty']`, etc. Args: item: the member to access Return: the member value Raises: AttributeError: if the member is not found \"\"\" value = self . get ( item ) if value is None : raise AttributeError ( item ) return value","title":"__getattr__()"},{"location":"api/#jwskate.jwk.base.Jwk.__init_subclass__","text":"Automatically add subclasses to the registry. This allows new to pick the appropriate subclass when creating a Jwk Source code in jwskate/jwk/base.py 106 107 108 109 110 111 112 113 114 def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls","title":"__init_subclass__()"},{"location":"api/#jwskate.jwk.base.Jwk.__new__","text":"Overridden __new__ to make the Jwk constructor smarter. The Jwk constructor will accept a dict with the parsed Jwk content another Jwk, which will be used as-is instead of creating a copy an instance from a cryptography public or private key class Parameters: Name Type Description Default key Union [ Jwk , Dict [ str , Any ], Any ] a dict containing JWK parameters, or another Jwk instance, or a cryptography key required **kwargs Any additional members to include in the Jwk {} Source code in jwskate/jwk/base.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def __new__ ( cls , key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key **kwargs: additional members to include in the Jwk \"\"\" if cls == Jwk : if isinstance ( key , Jwk ): return cls . from_cryptography_key ( key . cryptography_key , ** kwargs ) if isinstance ( key , dict ): kty : Optional [ str ] = key . get ( \"kty\" ) if kty is None : raise InvalidJwk ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise InvalidJwk ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) elif isinstance ( key , str ): return cls . from_json ( key ) else : return cls . from_cryptography_key ( key , ** kwargs ) return super () . __new__ ( cls , key , ** kwargs )","title":"__new__()"},{"location":"api/#jwskate.jwk.base.Jwk.__setitem__","text":"Override base method to avoid modifying cryptographic key attributes. Parameters: Name Type Description Default key str name of the attribute to set required value Any value to set required Raises: Type Description RuntimeError when trying to modify cryptographic attributes Source code in jwskate/jwk/base.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Override base method to avoid modifying cryptographic key attributes. Args: key: name of the attribute to set value: value to set Raises: RuntimeError: when trying to modify cryptographic attributes \"\"\" if key in self . PARAMS : raise RuntimeError ( \"JWK key attributes cannot be modified.\" ) super () . __setitem__ ( key , value )","title":"__setitem__()"},{"location":"api/#jwskate.jwk.base.Jwk.alg","text":"Return the configured key alg, if any. Returns: Type Description Optional [ str ] the key alg Source code in jwskate/jwk/base.py 253 254 255 256 257 258 259 260 261 262 263 @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): raise TypeError ( f \"Invalid alg type { type ( str ) } \" , alg ) return alg","title":"alg()"},{"location":"api/#jwskate.jwk.base.Jwk.as_jwks","text":"Return a JwkSet with this key as single element. Returns: Type Description JwkSet a JwsSet with this single key Source code in jwskate/jwk/base.py 387 388 389 390 391 392 393 394 395 def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,))","title":"as_jwks()"},{"location":"api/#jwskate.jwk.base.Jwk.copy","text":"Creates a copy of this key. Returns: Type Description Jwk a copy of this key, with the same value Source code in jwskate/jwk/base.py 798 799 800 801 802 803 804 def copy ( self ) -> Jwk : \"\"\"Creates a copy of this key. Returns: a copy of this key, with the same value \"\"\" return Jwk ( super () . copy ())","title":"copy()"},{"location":"api/#jwskate.jwk.base.Jwk.decrypt","text":"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Parameters: Name Type Description Default ciphertext bytes the data to decrypt required iv bytes the Initialization Vector (IV) that was used for encryption required tag bytes the Authentication Tag that will be verified while decrypting data required aad Optional [ bytes ] the Additional Authentication Data (AAD) to verify the Tag against None alg Optional [ str ] the alg to use for decryption None Returns: Type Description BinaPy the clear-text data Source code in jwskate/jwk/base.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def decrypt ( self , ciphertext : bytes , * , iv : bytes , tag : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt iv: the Initialization Vector (IV) that was used for encryption tag: the Authentication Tag that will be verified while decrypting data aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover","title":"decrypt()"},{"location":"api/#jwskate.jwk.base.Jwk.encrypt","text":"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Initialization Vector and the Authentication Tag. Parameters: Name Type Description Default plaintext bytes the data to encrypt. required aad Optional [ bytes ] the Additional Authenticated Data (AAD) to include in the authentication tag None alg Optional [ str ] the alg to use to encrypt the data None iv Optional [ bytes ] the Initialization Vector that was used to encrypt the data. If iv is passed as parameter, this None will return that same value. Otherwise, an IV is generated. Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a tuple (ciphertext, iv, authentication_tag), as raw data Source code in jwskate/jwk/base.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def encrypt ( self , plaintext : bytes , * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext, with an optional Additional Authenticated Data (AAD) using this JWK, and return the Encrypted Data, the Initialization Vector and the Authentication Tag. Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector that was used to encrypt the data. If `iv` is passed as parameter, this will return that same value. Otherwise, an IV is generated. Returns: a tuple (ciphertext, iv, authentication_tag), as raw data \"\"\" raise NotImplementedError # pragma: no cover","title":"encrypt()"},{"location":"api/#jwskate.jwk.base.Jwk.from_cryptography_key","text":"Initialize a Jwk from a key from the cryptography library. The input key can be any private or public key supported by cryptography. Parameters: Name Type Description Default cryptography_key Any a cryptography key instance required **kwargs Any additional members to include in the Jwk (e.g. kid, use) {} Returns: Type Description Jwk the matching Jwk instance Raises: Type Description TypeError if the key type is not supported Source code in jwskate/jwk/base.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key , ** kwargs ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.base.Jwk.from_pem_key","text":"Load a Jwk from a PEM encoded private or public key. Parameters: Name Type Description Default data Union [ bytes , str ] the PEM encoded data to load required password Union [ bytes , str , None] the password to decrypt the PEM, if required None **kwargs Any additional members to include in the Jwk (e.g. kid, use) {} Returns: Type Description Jwk a Jwk instance from the loaded key Source code in jwskate/jwk/base.py 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 @classmethod def from_pem_key ( cls , data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any , ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: a Jwk instance from the loaded key \"\"\" if isinstance ( data , str ): data = data . encode () if isinstance ( password , str ): password = password . encode () try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception as private_exc : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) from private_exc return cls . from_cryptography_key ( cryptography_key , ** kwargs )","title":"from_pem_key()"},{"location":"api/#jwskate.jwk.base.Jwk.generate","text":"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Parameters: Name Type Description Default **kwargs Any specific parameters depending on the type of key, or additional members to include in the Jwk {} Returns: Type Description Jwk a Jwk instance with a generated key Source code in jwskate/jwk/base.py 754 755 756 757 758 759 760 761 762 763 764 @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generates a Private Key. This method is implemented by subclasses for specific Key Types and returns an instance of that specific subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError","title":"generate()"},{"location":"api/#jwskate.jwk.base.Jwk.generate_for_alg","text":"Generate a key for usage with a specific alg and return the resuting Jwk. Parameters: Name Type Description Default alg str a signature or key management alg required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Source code in jwskate/jwk/base.py 785 786 787 788 789 790 791 792 793 794 795 796 @classmethod def generate_for_alg ( cls , alg : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key for usage with a specific alg and return the resuting Jwk. Args: alg: a signature or key management alg **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk \"\"\" raise NotImplementedError","title":"generate_for_alg()"},{"location":"api/#jwskate.jwk.base.Jwk.generate_for_kty","text":"Generate a key with a specific type and return the resulting Jwk. Parameters: Name Type Description Default kty str key type to generate required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Raises: Type Description UnsupportedKeyType if the key type is not supported Source code in jwskate/jwk/base.py 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs )","title":"generate_for_kty()"},{"location":"api/#jwskate.jwk.base.Jwk.include_kid_thumbprint","text":"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if force is True , this erases the previous \"kid\". - if force is False (default), do nothing. Parameters: Name Type Description Default force bool whether to overwrite a previously existing kid False Returns: Type Description Jwk a copy of this key with a \"kid\" (either the previous one or the existing one, depending on force ). Source code in jwskate/jwk/base.py 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 def include_kid_thumbprint ( self , force : bool = False ) -> Jwk : \"\"\"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if `force` is `True`, this erases the previous \"kid\". - if `force` is `False` (default), do nothing. Args: force: whether to overwrite a previously existing kid Returns: a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`). \"\"\" jwk = self . copy () if self . kid is None or force : jwk [ \"kid\" ] = self . thumbprint () return jwk","title":"include_kid_thumbprint()"},{"location":"api/#jwskate.jwk.base.Jwk.is_private","text":"Return True if the key is private, False otherwise. Returns: Type Description bool True if the key is private, False otherwise Source code in jwskate/jwk/base.py 165 166 167 168 169 170 171 172 @property def is_private ( self ) -> bool : \"\"\"Return `True` if the key is private, `False` otherwise. Returns: `True` if the key is private, `False` otherwise \"\"\" return True","title":"is_private()"},{"location":"api/#jwskate.jwk.base.Jwk.kty","text":"Return the Key Type. Returns: Type Description str the key type Source code in jwskate/jwk/base.py 244 245 246 247 248 249 250 251 @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY","title":"kty()"},{"location":"api/#jwskate.jwk.base.Jwk.public_jwk","text":"Return the public Jwk associated with this key. Returns: Type Description Jwk a Jwk with the public key Source code in jwskate/jwk/base.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } key_ops = self . get ( \"key_ops\" ) if key_ops : if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"decrypt\" in key_ops : key_ops . remove ( \"decrypt\" ) key_ops . append ( \"encrypt\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) )","title":"public_jwk()"},{"location":"api/#jwskate.jwk.base.Jwk.recipient_key","text":"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Parameters: Name Type Description Default wrapped_cek bytes the wrapped CEK required enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to unwrap the CEK None **headers Any additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) {} Returns: Type Description Jwk the clear-text CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate/jwk/base.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 def recipient_key ( self , wrapped_cek : bytes , enc : str , * , alg : Optional [ str ] = None , ** headers : Any ) -> Jwk : \"\"\"For DH-based algs. As a token recipient, derive the same CEK that was used for encryption, based on the recipient private key and the sender ephemeral public key. Args: wrapped_cek: the wrapped CEK enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to unwrap the CEK **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if issubclass ( keyalg , BaseRsaKeyWrap ): rsa = keyalg ( self . cryptography_key ) cek = rsa . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , EcdhEs ): ecdh = keyalg ( self . cryptography_key ) epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . cryptography_key encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) if isinstance ( ecdh , BaseEcdhEs_AesKw ): cek = ecdh . unwrap_key_with_epk ( wrapped_cek , epk , alg = keyalg . name ) else : cek = ecdh . recipient_key ( epk , alg = encalg . name , key_size = encalg . key_size , ** headers ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes = keyalg ( self . cryptography_key ) cek = aes . unwrap_key ( wrapped_cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm = keyalg ( self . cryptography_key ) iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = aesgcm . unwrap_key ( wrapped_cek , tag = tag , iv = iv ) elif issubclass ( keyalg , DirectKeyUse ): dir_ = keyalg ( self . key ) cek = dir_ . direct_key ( encalg ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek )","title":"recipient_key()"},{"location":"api/#jwskate.jwk.base.Jwk.sender_key","text":"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. Returns a tuple with 3 items: the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key! the encrypted CEK, as bytes. You must send this to your recipient. This may be empty for algs which derive a CEK instead of generating one. extra headers depending on the Key Management algorithm, as a dict of name to values: you must send this to your recipient as well. For algorithms that rely on a randomly generated CEK, you can provide that value instead of letting jwskate generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting jwskate generate an appropriate value for you. Only use this if you know what you are doing! Parameters: Name Type Description Default enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to produce the CEK None cek Optional [ bytes ] CEK to use (leave None to have an adequate random value generated automatically) None epk Optional [ Jwk ] EPK to use (leave None to have an adequate ephemeral key generated automatically) None **headers Any additional headers to include for the CEK derivation {} Returns: Type Description Tuple [ Jwk , BinaPy , Mapping [ str , Any ]] Tuple[Jwk,BinaPy,Mapping[str,Any]]: a tuple (cek, wrapped_cek, additional_headers_map) Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate/jwk/base.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 def sender_key ( self , enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]]: \"\"\"For DH-based algs. As a token issuer, derive a EPK and CEK from the recipient public key. Returns a tuple with 3 items: - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key! - the encrypted CEK, as bytes. You must send this to your recipient. This may be empty for algs which derive a CEK instead of generating one. - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send this to your recipient as well. For algorithms that rely on a randomly generated CEK, you can provide that value instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only use this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: Tuple[Jwk,BinaPy,Mapping[str,Any]]: a tuple (cek, wrapped_cek, additional_headers_map) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk keyalg = select_alg ( self . alg , alg , self . KEY_MANAGEMENT_ALGORITHMS ) encalg = select_alg ( None , enc , SymmetricJwk . ENCRYPTION_ALGORITHMS ) cek_headers : Dict [ str , Any ] = {} if issubclass ( keyalg , BaseRsaKeyWrap ): rsa : BaseRsaKeyWrap = keyalg ( self . public_jwk () . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = rsa . wrap_key ( cek ) elif issubclass ( keyalg , EcdhEs ): ecdh : EcdhEs = keyalg ( self . public_jwk () . cryptography_key ) epk = epk or Jwk . from_cryptography_key ( ecdh . generate_ephemeral_key ()) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( ecdh , BaseEcdhEs_AesKw ): if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = ecdh . wrap_key_with_epk ( cek , epk . cryptography_key , alg = keyalg . name , ** headers ) else : cek = ecdh . sender_key ( epk . cryptography_key , alg = encalg . name , key_size = encalg . key_size , ** headers , ) wrapped_cek = BinaPy ( b \"\" ) elif issubclass ( keyalg , BaseAesKeyWrap ): aes : BaseAesKeyWrap = keyalg ( self . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek wrapped_cek = aes . wrap_key ( cek ) elif issubclass ( keyalg , BaseAesGcmKeyWrap ): aesgcm : BaseAesGcmKeyWrap = keyalg ( self . cryptography_key ) if cek : encalg . check_key ( cek ) else : cek = encalg . generate_key () assert cek iv = aesgcm . generate_iv () wrapped_cek , tag = aesgcm . wrap_key ( cek , iv = iv ) cek_headers = { \"iv\" : iv . to ( \"b64u\" ) . ascii (), \"tag\" : tag . to ( \"b64u\" ) . ascii (), } elif issubclass ( keyalg , DirectKeyUse ): dir : DirectKeyUse = keyalg ( self . key ) cek = dir . direct_key ( encalg ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { keyalg } \" ) return SymmetricJwk . from_bytes ( cek ), wrapped_cek , cek_headers","title":"sender_key()"},{"location":"api/#jwskate.jwk.base.Jwk.sign","text":"Sign a data using this Jwk, and return the generated signature. Parameters: Name Type Description Default data bytes the data to sign required alg Optional [ str ] the alg to use (if this key doesn't have an alg parameter) None Returns: Type Description BinaPy the generated signature Source code in jwskate/jwk/base.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def sign ( self , data : bytes , alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" sigalg = select_alg ( self . alg , alg , self . SIGNATURE_ALGORITHMS ) wrapper : BaseSignatureAlg if issubclass ( sigalg , BaseAsymmetricAlg ): wrapper = sigalg ( self . cryptography_key ) elif issubclass ( sigalg , BaseSymmetricAlg ): wrapper = sigalg ( self . key ) signature = wrapper . sign ( data ) return BinaPy ( signature )","title":"sign()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_encryption_algorithms","text":"Return the list of Encryption algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 341 342 343 344 345 346 347 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS )","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_key_management_algorithms","text":"Return the list of Key Management algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 333 334 335 336 337 338 339 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS )","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_signing_algorithms","text":"Return the list of Signature algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 325 326 327 328 329 330 331 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS )","title":"supported_signing_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.thumbprint","text":"Return the key thumbprint as specified by RFC 7638. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'sha-256' Returns: Type Description str the calculated thumbprint Source code in jwskate/jwk/base.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def thumbprint ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" alg = self . IANA_HASH_FUNCTION_NAMES . get ( hashalg ) if not alg : raise ValueError ( f \"Unsupported hash alg { hashalg } \" ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) return ( BinaPy . serialize_to ( \"json\" , t , separators = ( \",\" , \":\" ), sort_keys = True ) . to ( alg ) . to ( \"b64u\" ) . ascii () )","title":"thumbprint()"},{"location":"api/#jwskate.jwk.base.Jwk.thumbprint_uri","text":"Returns the JWK thumbprint URI for this key. Parameters: Name Type Description Default hashalg str the IANA registered name for the hash alg to use 'sha-256' Returns: Type Description str the JWK thumbprint uri for this Jwk Source code in jwskate/jwk/base.py 231 232 233 234 235 236 237 238 239 240 241 242 def thumbprint_uri ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Returns the JWK thumbprint URI for this key. Args: hashalg: the IANA registered name for the hash alg to use Returns: the JWK thumbprint uri for this Jwk \"\"\" return ( f \"urn:ietf:params:oauth:jwk-thumbprint: { hashalg } : { self . thumbprint ( hashalg ) } \" )","title":"thumbprint_uri()"},{"location":"api/#jwskate.jwk.base.Jwk.to_pem_key","text":"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Parameters: Name Type Description Default password Optional [ bytes ] password to use to encrypt the PEM None Returns: Type Description bytes the PEM serialized key Source code in jwskate/jwk/base.py 741 742 743 744 745 746 747 748 749 750 751 752 def to_pem_key ( self , password : Optional [ bytes ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. Args: password: password to use to encrypt the PEM Returns: the PEM serialized key \"\"\" raise NotImplementedError","title":"to_pem_key()"},{"location":"api/#jwskate.jwk.base.Jwk.verify","text":"Verify a signature using this Jwk, and return True if valid. Parameters: Name Type Description Default data bytes the data to verify required signature bytes the signature to verify required alg Optional [ str ] the allowed signature alg, if there is only one None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate/jwk/base.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def verify ( self , data : bytes , signature : bytes , * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" wrapper : BaseSignatureAlg for sigalg in select_algs ( self . alg , alg , algs , self . SIGNATURE_ALGORITHMS ): if issubclass ( sigalg , BaseAsymmetricAlg ): key = self . public_jwk () . cryptography_key wrapper = sigalg ( key ) elif issubclass ( sigalg , BaseSymmetricAlg ): key = self . key wrapper = sigalg ( key ) if wrapper . verify ( data , signature ): return True return False","title":"verify()"},{"location":"api/#jwskate.JwkSet","text":"Bases: BaseJsonDict A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. a dict from the parsed JSON object representing this JwkSet (in paramter jwks ) a list of Jwk (in parameter keys nothing, to initialize an empty JwkSet Parameters: Name Type Description Default jwks Optional [ Dict [ str , Any ]] a dict, containing the JwkSet, parsed as a JSON object. None keys Optional [ Iterable [ Jwk ]] a list of Jwk , that will be added to this JwkSet None Source code in jwskate/jwk/jwks.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 class JwkSet ( BaseJsonDict ): \"\"\"A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`) - a list of `Jwk` (in parameter `keys` - nothing, to initialize an empty JwkSet Args: jwks: a dict, containing the JwkSet, parsed as a JSON object. keys: a list of `Jwk`, that will be added to this JwkSet \"\"\" def __init__ ( self , jwks : Optional [ Dict [ str , Any ]] = None , keys : Optional [ Iterable [ Jwk ]] = None , ): if jwks is None and keys is None : keys = [] if jwks is not None : keys = jwks . pop ( \"keys\" , []) super () . __init__ ( jwks ) # init the dict with all the dict content that is not keys else : super () . __init__ () if keys is not None : for jwk in keys : self . add_jwk ( jwk ) @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" if not isinstance ( jwk , Jwk ): jwk = Jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass @property def is_private ( self ) -> bool : \"\"\"True if the JwkSet contains at least one private key. Returns: `True` if this JwkSet contains at least one private key \"\"\" return any ( key . is_private for key in self . jwks ) def public_jwks ( self ) -> \"JwkSet\" : \"\"\"Return another JwkSet with the public keys associated with the current keys. Returns: a public JwkSet \"\"\" return JwkSet ( keys = ( key . public_jwk () for key in self . jwks )) def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) # if one or several alg are provided, try only the keys that are compatible with one of the provided alg(s) if alg : for jwk in self . jwks : if jwk . get ( \"alg\" ) == alg : if jwk . verify ( data , signature , alg = alg ): return True if algs : for jwk in self . jwks : alg = jwk . get ( \"alg\" ) if alg is not None and alg in algs : if jwk . verify ( data , signature , algs = algs ): return True # if no kid and no alg are provided, try first the keys flagged for signature verification (`\"use\": \"verify\"`) for jwk in self . jwks : if jwk . get ( \"use\" ) == \"verify\" : if jwk . verify ( data , signature , alg = alg ): return True # then with the keys that have no defined `use` for jwk in self . jwks : if jwk . get ( \"use\" ) is None and jwk . get ( \"alg\" ) is None : try : if jwk . verify ( data , signature , alg = alg ): return True except UnsupportedAlg : continue # no key matches, so consider the signature invalid return False","title":"JwkSet"},{"location":"api/#jwskate.jwk.jwks.JwkSet.__len__","text":"Return the number of Jwk in this JwkSet. Returns: Type Description int the number of keys Source code in jwskate/jwk/jwks.py 73 74 75 76 77 78 79 def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks )","title":"__len__()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.add_jwk","text":"Add a Jwk in this JwkSet. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to add (either a Jwk instance, or a dict containing the Jwk parameters) required kid Optional [ str ] the kid to use, if jwk doesn't contain one None use Optional [ str ] the defined use for the added Jwk None Returns: Type Description str the kid from the added Jwk (it may be generated if no kid is provided) Source code in jwskate/jwk/jwks.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" if not isinstance ( jwk , Jwk ): jwk = Jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid","title":"add_jwk()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.get_jwk_by_kid","text":"Return a Jwk from this JwkSet, based on its kid. Parameters: Name Type Description Default kid str the kid of the key to obtain required Returns: Type Description Jwk the key with the matching Key ID Raises: Type Description KeyError if no key matches Source code in jwskate/jwk/jwks.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid )","title":"get_jwk_by_kid()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.is_private","text":"True if the JwkSet contains at least one private key. Returns: Type Description bool True if this JwkSet contains at least one private key Source code in jwskate/jwk/jwks.py 129 130 131 132 133 134 135 136 137 @property def is_private ( self ) -> bool : \"\"\"True if the JwkSet contains at least one private key. Returns: `True` if this JwkSet contains at least one private key \"\"\" return any ( key . is_private for key in self . jwks )","title":"is_private()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.jwks","text":"Return the list of keys from this JwkSet, as Jwk instances. Returns: Type Description List [ Jwk ] a list of Jwk Source code in jwskate/jwk/jwks.py 47 48 49 50 51 52 53 54 @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , [])","title":"jwks()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.public_jwks","text":"Return another JwkSet with the public keys associated with the current keys. Returns: Type Description JwkSet a public JwkSet Source code in jwskate/jwk/jwks.py 139 140 141 142 143 144 145 def public_jwks ( self ) -> \"JwkSet\" : \"\"\"Return another JwkSet with the public keys associated with the current keys. Returns: a public JwkSet \"\"\" return JwkSet ( keys = ( key . public_jwk () for key in self . jwks ))","title":"public_jwks()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.remove_jwk","text":"Removes a Jwk from this JwkSet, based on a kid . Parameters: Name Type Description Default kid str the kid from the key to be removed. required Raises: Type Description KeyError if no key matches Source code in jwskate/jwk/jwks.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass","title":"remove_jwk()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.verify","text":"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a kid is provided, only the key with this kid will be tried. Otherwise, if an alg or several algs are provided, only keys that are compatible with the supplied alg will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Parameters: Name Type Description Default data bytes the signed data to verify required signature bytes the signature to verify against the signed data required alg Optional [ str ] alg to verify the signature, if there is only 1 None algs Optional [ Iterable [ str ]] list of allowed signature algs, if there are several None kid Optional [ str ] the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys None from this key set may be tried. Returns: Type Description bool True if the signature validates with any of the tried keys, False otherwise Source code in jwskate/jwk/jwks.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) # if one or several alg are provided, try only the keys that are compatible with one of the provided alg(s) if alg : for jwk in self . jwks : if jwk . get ( \"alg\" ) == alg : if jwk . verify ( data , signature , alg = alg ): return True if algs : for jwk in self . jwks : alg = jwk . get ( \"alg\" ) if alg is not None and alg in algs : if jwk . verify ( data , signature , algs = algs ): return True # if no kid and no alg are provided, try first the keys flagged for signature verification (`\"use\": \"verify\"`) for jwk in self . jwks : if jwk . get ( \"use\" ) == \"verify\" : if jwk . verify ( data , signature , alg = alg ): return True # then with the keys that have no defined `use` for jwk in self . jwks : if jwk . get ( \"use\" ) is None and jwk . get ( \"alg\" ) is None : try : if jwk . verify ( data , signature , alg = alg ): return True except UnsupportedAlg : continue # no key matches, so consider the signature invalid return False","title":"verify()"},{"location":"api/#jwskate.JwsCompact","text":"Bases: BaseCompactToken Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Parameters: Name Type Description Default value Union [ bytes , str ] the JWS token value required Source code in jwskate/jws/compact.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class JwsCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Args: value: the JWS token value \"\"\" def __init__ ( self , value : Union [ bytes , str ]): super () . __init__ ( value ) header , payload , signature = self . split ( self . value ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJws ( \"Invalid JWS header: it must be a Base64URL-encoded JSON object\" ) try : self . payload = BinaPy ( payload ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def split ( cls , value : bytes ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Splits a JWS token value into its (header, payload, signature) parts. Args: value: the JWS token value Returns: a (header, payload, signature) Raises: InvalidJws: if the provided value doesn't have 2 dots. \"\"\" if value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = value . split ( b \".\" ) return BinaPy ( header ), BinaPy ( payload ), BinaPy ( signature ) @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"JwsCompact\" : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) @classmethod def from_parts ( cls , signed_part : Union [ bytes , str ], signature : Union [ bytes , str ] ) -> \"JwsCompact\" : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if not isinstance ( signed_part , bytes ): signed_part = signed_part . encode ( \"ascii\" ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . to ( \"b64u\" )))) @cached_property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg = alg , algs = algs ) def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . split ( self . value ) content = { \"payload\" : payload . ascii (), \"protected\" : protected . ascii (), \"signature\" : signature . ascii (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize ()","title":"JwsCompact"},{"location":"api/#jwskate.jws.compact.JwsCompact.flat_json","text":"Create a JWS in JSON flat format based on this Compact JWS. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonFlat the resulting token Source code in jwskate/jws/compact.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . split ( self . value ) content = { \"payload\" : payload . ascii (), \"protected\" : protected . ascii (), \"signature\" : signature . ascii (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content )","title":"flat_json()"},{"location":"api/#jwskate.jws.compact.JwsCompact.from_parts","text":"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Parameters: Name Type Description Default signed_part Union [ bytes , str ] the signed part required signature Union [ bytes , str ] the signature value required Returns: Type Description JwsCompact the resulting token Source code in jwskate/jws/compact.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @classmethod def from_parts ( cls , signed_part : Union [ bytes , str ], signature : Union [ bytes , str ] ) -> \"JwsCompact\" : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if not isinstance ( signed_part , bytes ): signed_part = signed_part . encode ( \"ascii\" ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . to ( \"b64u\" ))))","title":"from_parts()"},{"location":"api/#jwskate.jws.compact.JwsCompact.general_json","text":"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonGeneral the resulting token Source code in jwskate/jws/compact.py 177 178 179 180 181 182 183 184 185 186 187 188 189 def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize ()","title":"general_json()"},{"location":"api/#jwskate.jws.compact.JwsCompact.sign","text":"Sign a payload and returns the resulting JwsCompact. Parameters: Name Type Description Default payload bytes the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the jwk to use to sign this payload required alg Optional [ str ] the alg to use None extra_headers Optional [ Dict [ str , Any ]] additional headers to add to the Jws Headers None Returns: Type Description JwsCompact the resulting token Source code in jwskate/jws/compact.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"JwsCompact\" : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = Jwk ( jwk ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature )","title":"sign()"},{"location":"api/#jwskate.jws.compact.JwsCompact.signed_part","text":"Returns the signed part (header + payload) from this JwsCompact. Returns: Type Description bytes the signed part Source code in jwskate/jws/compact.py 127 128 129 130 131 132 133 134 @cached_property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ])","title":"signed_part()"},{"location":"api/#jwskate.jws.compact.JwsCompact.split","text":"Splits a JWS token value into its (header, payload, signature) parts. Parameters: Name Type Description Default value bytes the JWS token value required Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (header, payload, signature) Raises: Type Description InvalidJws if the provided value doesn't have 2 dots. Source code in jwskate/jws/compact.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @classmethod def split ( cls , value : bytes ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Splits a JWS token value into its (header, payload, signature) parts. Args: value: the JWS token value Returns: a (header, payload, signature) Raises: InvalidJws: if the provided value doesn't have 2 dots. \"\"\" if value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = value . split ( b \".\" ) return BinaPy ( header ), BinaPy ( payload ), BinaPy ( signature )","title":"split()"},{"location":"api/#jwskate.jws.compact.JwsCompact.verify_signature","text":"Verify the signature from this JwsCompact using a Jwk. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use to validate this signature required alg Optional [ str ] the alg to use, if there is only 1 allowed None algs Optional [ Iterable [ str ]] the allowed algs, if here are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate/jws/compact.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg = alg , algs = algs )","title":"verify_signature()"},{"location":"api/#jwskate.Jwt","text":"Bases: BaseCompactToken Represents a Json Web Token. Source code in jwskate/jwt/base.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class Jwt ( BaseCompactToken ): \"\"\"Represents a Json Web Token.\"\"\" def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 3 : from .encrypted import EncryptedJwt return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls ) @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = Jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) kid = jwk . get ( \"kid\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) extra_headers = extra_headers or {} headers = dict ( alg = alg , ** extra_headers ) if kid : headers [ \"kid\" ] = kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc_alg : Optional [ str ], enc : Optional [ str ], ) -> \"EncryptedJwt\" : \"\"\"Sign then encrypt a payload with a `Jwk` and returns the resulting `EncryptedJwt`. NOT IMPLEMENTED YET. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption Returns: the resulting JWE token, with signed JWT as payload \"\"\" raise NotImplementedError","title":"Jwt"},{"location":"api/#jwskate.jwt.base.Jwt.__new__","text":"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Parameters: Name Type Description Default value Union [ bytes , str ] the token value required Source code in jwskate/jwt/base.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. Returns the appropriate subclass instance. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 3 : from .encrypted import EncryptedJwt return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls )","title":"__new__()"},{"location":"api/#jwskate.jwt.base.Jwt.sign","text":"Sign a JSON payload with a Jwk and returns the resulting SignedJwt . This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use .unprotected() instead. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signing required alg Optional [ str ] the alg to use for signing None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the Jwt None Returns: Type Description SignedJwt the resulting token Source code in jwskate/jwt/base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = Jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) kid = jwk . get ( \"kid\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) extra_headers = extra_headers or {} headers = dict ( alg = alg , ** extra_headers ) if kid : headers [ \"kid\" ] = kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature )))","title":"sign()"},{"location":"api/#jwskate.jwt.base.Jwt.sign_and_encrypt","text":"Sign then encrypt a payload with a Jwk and returns the resulting EncryptedJwt . NOT IMPLEMENTED YET. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to encrypt required sign_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signature required sign_alg Optional [ str ] the alg to use for signature required enc_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for encryption required enc_alg Optional [ str ] the alg to use for CEK encryption required enc Optional [ str ] the alg to use for payload encryption required Returns: Type Description EncryptedJwt the resulting JWE token, with signed JWT as payload Source code in jwskate/jwt/base.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc_alg : Optional [ str ], enc : Optional [ str ], ) -> \"EncryptedJwt\" : \"\"\"Sign then encrypt a payload with a `Jwk` and returns the resulting `EncryptedJwt`. NOT IMPLEMENTED YET. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption Returns: the resulting JWE token, with signed JWT as payload \"\"\" raise NotImplementedError","title":"sign_and_encrypt()"},{"location":"api/#jwskate.jwt.base.Jwt.unprotected","text":"Generate a JWT that is not signed and not encrypted (with alg=none). Parameters: Name Type Description Default claims Dict [ str , Any ] the claims to set in the token. required extra_headers Optional [ Dict [ str , Any ]] additional headers to insert in the token. None Returns: Type Description SignedJwt the resulting token Source code in jwskate/jwt/base.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature )))","title":"unprotected()"},{"location":"api/#jwskate.JwtSigner","text":"A helper class to easily sign JWTs with standardised claims. The standardised claims include \u00ecat : issued at date exp : expiration date nbf : not before date: iss : issuer identifier sub : subject identifier aud : audience identifier jti : JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling JwtSigner.sign() . This can be used as an alternative to Jwt.sign() when a single issuer issues multiple tokens. Parameters: Name Type Description Default issuer str the issuer string to use as \u00ecss claim for signed tokens. required jwk Jwk the private Jwk to use to sign tokens. required alg Optional [ str ] the signing alg to use to sign tokens. None default_lifetime int the default lifetime, in seconds, to use for claim exp . This can be overridden when calling .sign() 60 default_leeway Optional [ int ] the default leeway, in seconds, to use for claim nbf . If None, no nbf claim is included. This can be overridden when calling .sign() None Source code in jwskate/jwt/signer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class JwtSigner : \"\"\"A helper class to easily sign JWTs with standardised claims. The standardised claims include: - `\u00ecat`: issued at date - `exp`: expiration date - `nbf`: not before date: - `iss`: issuer identifier - `sub`: subject identifier - `aud`: audience identifier - `jti`: JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling `JwtSigner.sign()`. This can be used as an alternative to `Jwt.sign()` when a single issuer issues multiple tokens. Args: issuer: the issuer string to use as `\u00ecss` claim for signed tokens. jwk: the private Jwk to use to sign tokens. alg: the signing alg to use to sign tokens. default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden when calling `.sign()` default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is included. This can be overridden when calling `.sign()` \"\"\" def __init__ ( self , issuer : str , jwk : Jwk , alg : Optional [ str ] = None , default_lifetime : int = 60 , default_leeway : Optional [ int ] = None , ): self . issuer = issuer self . jwk = jwk self . alg = jwk . alg or alg self . default_lifetime = default_lifetime self . default_leeway = default_leeway def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = int ( datetime . now () . timestamp ()) lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ())","title":"JwtSigner"},{"location":"api/#jwskate.jwt.signer.JwtSigner.generate_jti","text":"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: Type Description str A unique value suitable for use as JWT Token ID (jti) claim. Source code in jwskate/jwt/signer.py 105 106 107 108 109 110 111 112 113 def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ())","title":"generate_jti()"},{"location":"api/#jwskate.jwt.signer.JwtSigner.sign","text":"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim iat , nbf and exp will reflect the current time when the token is signed. exp includes lifetime seconds in the future, and nbf includes leeway seconds in the past. Parameters: Name Type Description Default subject Optional [ str ] the subject to include in claim sub . (Default value = None) None audience Union [ str , Iterable [ str ], None] the audience identifier(s) to include in claim aud . None extra_claims Optional [ Dict [ str , Any ]] additional claims to include in the signed token. (Default value = None) None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the header part. (Default value = None) None lifetime Optional [ int ] lifetime, in seconds, to use for the exp claim. If None, use the default_lifetime defined at initialization time. None leeway Optional [ int ] leeway, in seconds, to use for the nbf claim. If None, use the default_leeway defined at initialization time. None Returns: Type Description SignedJwt the resulting signed token. Source code in jwskate/jwt/signer.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = int ( datetime . now () . timestamp ()) lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers )","title":"sign()"},{"location":"api/#jwskate.KeyManagementAlgs","text":"Identifiers for Key Management algorithms. Source code in jwskate/enums.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class KeyManagementAlgs : \"\"\"Identifiers for Key Management algorithms.\"\"\" RSA1_5 = \"RSA1_5\" RSA_OAEP = \"RSA-OAEP\" RSA_OAEP_256 = \"RSA-OAEP-256\" RSA_OAEP_384 = \"RSA-OAEP-384\" RSA_OAEP_512 = \"RSA-OAEP-512\" ECDH_ES = \"ECDH-ES\" ECDH_ES_A128KW = \"ECDH-ES+A128KW\" ECDH_ES_A192KW = \"ECDH-ES+A192KW\" ECDH_ES_A256KW = \"ECDH-ES+A256KW\" A128KW = \"A128KW\" A192KW = \"A192KW\" A256KW = \"A256KW\" A128GCMKW = \"A128GCMKW\" A192GCMKW = \"A192GCMKW\" A256GCMKW = \"A256GCMKW\" dir = \"dir\" PBES2_HS256_A128KW = \"PBES2-HS256+A128KW\" PBES2_HS384_A192KW = \"PBES2-HS384+A192KW\" PBES2_HS512_A256KW = \"PBES2-HS512+A256KW\" ALL_SYMMETRIC = [ A128KW , A192KW , A256KW , A128GCMKW , A192GCMKW , A256GCMKW , dir , PBES2_HS256_A128KW , PBES2_HS384_A192KW , PBES2_HS512_A256KW , ] ALL_ASYMMETRIC = [ RSA1_5 , RSA_OAEP , RSA_OAEP_256 , RSA_OAEP_384 , RSA_OAEP_512 , ECDH_ES , ECDH_ES_A128KW , ECDH_ES_A192KW , ECDH_ES_A256KW , ]","title":"KeyManagementAlgs"},{"location":"api/#jwskate.OKPCurve","text":"Represent an Octet Key Pair (OKP) Curve. Source code in jwskate/jwa/okp.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @dataclass class OKPCurve : \"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\" name : str \"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` headers.\"\"\" description : str \"\"\"Curve description (human readable).\"\"\" cryptography_private_key_class : Type [ Any ] \"\"\"`cryptography` private key class.\"\"\" cryptography_public_key_class : Type [ Any ] \"\"\"`cryptography` public key class.\"\"\" use : str \"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\" instances : ClassVar [ Dict [ str , OKPCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key: `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" )","title":"OKPCurve"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_private_key_class","text":"cryptography private key class.","title":"cryptography_private_key_class"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_public_key_class","text":"cryptography public key class.","title":"cryptography_public_key_class"},{"location":"api/#jwskate.jwa.okp.OKPCurve.description","text":"Curve description (human readable).","title":"description"},{"location":"api/#jwskate.jwa.okp.OKPCurve.instances","text":"Registry of subclasses, in a {name: instance} mapping.","title":"instances"},{"location":"api/#jwskate.jwa.okp.OKPCurve.name","text":"Curve name as defined in IANA JOSE . This name will appear in alg headers.","title":"name"},{"location":"api/#jwskate.jwa.okp.OKPCurve.use","text":"Curve usage ( 'sig' or ' enc' ).","title":"use"},{"location":"api/#jwskate.jwa.okp.OKPCurve.__post_init__","text":"Automatically registers subclasses in the instance registry. Source code in jwskate/jwa/okp.py 66 67 68 def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self","title":"__post_init__()"},{"location":"api/#jwskate.jwa.okp.OKPCurve.generate","text":"Generate a new private key on this curve. Returns: Type Description Tuple [ bytes , bytes ] a tuple of x (public part), and d (private part), as bytes Source code in jwskate/jwa/okp.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d","title":"generate()"},{"location":"api/#jwskate.jwa.okp.OKPCurve.get_curve","text":"Return the appropriate OKPCurve instance for a given cryptography private or public key. Parameters: Name Type Description Default key Union [ PublicKeyProtocol , PrivateKeyProtocol ] cryptography private or public OKP key. required Returns: Name Type Description OKPCurve OKPCurve the appropriate OKPCurve for the given key Raises: Type Description NotImplementedError if the required OKP curve is not supported Source code in jwskate/jwa/okp.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key: `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" )","title":"get_curve()"},{"location":"api/#jwskate.OKPJwk","text":"Bases: Jwk Represent an OKP Jwk, with kty=OKP . Source code in jwskate/jwk/okp.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 class OKPJwk ( Jwk ): \"\"\"Represent an OKP Jwk, with `kty=OKP`.\"\"\" KTY = \"OKP\" CRYPTOGRAPHY_KEY_CLASSES = ( ed25519 . Ed25519PrivateKey , ed25519 . Ed25519PublicKey , ed448 . Ed448PrivateKey , ed448 . Ed448PublicKey , x25519 . X25519PrivateKey , x25519 . X25519PublicKey , x448 . X448PrivateKey , x448 . X448PublicKey , ) PARAMS = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"Public Key\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Key\" , is_private = True , is_required = False , kind = \"b64u\" ), } CURVES : Mapping [ str , OKPCurve ] = { curve . name : curve for curve in [ Ed25519 , Ed448 , X448 , X25519 ] } SIGNATURE_ALGORITHMS = { alg . name : alg for alg in ( EdDsa ,)} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedOKPCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) @cached_property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) @cached_property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> OKPJwk : \"\"\"Initialize a OKPJwk from a `cryptography` key. Args: cryptography_key: a `cryptography` key **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if isinstance ( cryptography_key , ed25519 . Ed25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed25519 . Ed25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( cryptography_key , ed448 . Ed448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed448 . Ed448PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( cryptography_key , x25519 . X25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x25519 . X25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( cryptography_key , x448 . X448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x448 . X448PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in cls . CRYPTOGRAPHY_KEY_CLASSES ) ) def _to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), ** params )) @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def generate ( cls , crv : str = \"Ed25519\" , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. Args: crv: the curve to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" curve = cls . get_curve ( crv ) x , d = curve . generate () return cls . private ( crv = crv , x = x , d = d , ** params )","title":"OKPJwk"},{"location":"api/#jwskate.jwk.okp.OKPJwk.curve","text":"Get the OKPCurve instance for this key. Returns: Type Description OKPCurve the OKPCurve for this key Source code in jwskate/jwk/okp.py 91 92 93 94 95 96 97 98 @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv )","title":"curve()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.from_cryptography_key","text":"Initialize a OKPJwk from a cryptography key. Parameters: Name Type Description Default cryptography_key Any a cryptography key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the matching OKPJwk Source code in jwskate/jwk/okp.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> OKPJwk : \"\"\"Initialize a OKPJwk from a `cryptography` key. Args: cryptography_key: a `cryptography` key **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if isinstance ( cryptography_key , ed25519 . Ed25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed25519 . Ed25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( cryptography_key , ed448 . Ed448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed448 . Ed448PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( cryptography_key , x25519 . X25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x25519 . X25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( cryptography_key , x448 . X448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = Encoding . Raw , format = PrivateFormat . Raw , encryption_algorithm = NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x448 . X448PublicKey ): pub = cryptography_key . public_bytes ( encoding = Encoding . Raw , format = PublicFormat . Raw ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in cls . CRYPTOGRAPHY_KEY_CLASSES ) )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.generate","text":"Generate a private OKPJwk on a given curve. Parameters: Name Type Description Default crv str the curve to use 'Ed25519' **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 @classmethod def generate ( cls , crv : str = \"Ed25519\" , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. Args: crv: the curve to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" curve = cls . get_curve ( crv ) x , d = curve . generate () return cls . private ( crv = crv , x = x , d = d , ** params )","title":"generate()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.get_curve","text":"Get the OKPCurve instance from a curve identifier. Parameters: Name Type Description Default crv str a crv identifier required Returns: Type Description OKPCurve the matching OKPCurve instance Raises: Type Description UnsupportedOKPCurve if the curve is not supported Source code in jwskate/jwk/okp.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve","title":"get_curve()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.private","text":"Initialize a private OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the OKP curve required x bytes the public key required d bytes the private key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . to ( \"b64u\" ) . ascii (), ** params , ) )","title":"private()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.private_key","text":"Get the private key from this Jwk. Returns: Type Description bytes the private key (from param d ) Source code in jwskate/jwk/okp.py 109 110 111 112 113 114 115 116 @cached_property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" )","title":"private_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.public","text":"Initialize a public OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the key curve required x bytes the public key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 246 247 248 249 250 251 252 253 254 255 256 257 258 @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), ** params ))","title":"public()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.public_key","text":"Get the public key from this Jwk. Returns: Type Description bytes the public key (from param x ) Source code in jwskate/jwk/okp.py 100 101 102 103 104 105 106 107 @cached_property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" )","title":"public_key()"},{"location":"api/#jwskate.PS256","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Source code in jwskate/jwa/signature/rsa.py 89 90 91 92 93 94 95 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 )","title":"PS256"},{"location":"api/#jwskate.PS384","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Source code in jwskate/jwa/signature/rsa.py 98 99 100 101 102 103 104 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 )","title":"PS384"},{"location":"api/#jwskate.PS512","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Source code in jwskate/jwa/signature/rsa.py 107 108 109 110 111 112 113 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 )","title":"PS512"},{"location":"api/#jwskate.Pbes2_HS256_A128KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 94 95 96 97 98 99 100 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 ()","title":"Pbes2_HS256_A128KW"},{"location":"api/#jwskate.Pbes2_HS384_A192KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 103 104 105 106 107 108 109 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 ()","title":"Pbes2_HS384_A192KW"},{"location":"api/#jwskate.Pbes2_HS512_A256KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 112 113 114 115 116 117 118 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 ()","title":"Pbes2_HS512_A256KW"},{"location":"api/#jwskate.PrivateKeyRequired","text":"Bases: AttributeError Raised when a cryptographic operation requires a private key, and a public key has been provided instead. Source code in jwskate/jwa/base.py 11 12 class PrivateKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a private key, and a public key has been provided instead.\"\"\"","title":"PrivateKeyRequired"},{"location":"api/#jwskate.PublicKeyRequired","text":"Bases: AttributeError Raised when a cryptographic operation requires a public key, and a private key has been provided instead. Source code in jwskate/jwa/base.py 15 16 class PublicKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a public key, and a private key has been provided instead.\"\"\"","title":"PublicKeyRequired"},{"location":"api/#jwskate.RS256","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate/jwa/signature/rsa.py 65 66 67 68 69 70 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 ()","title":"RS256"},{"location":"api/#jwskate.RS384","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384 Source code in jwskate/jwa/signature/rsa.py 73 74 75 76 77 78 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 ()","title":"RS384"},{"location":"api/#jwskate.RS512","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256 Source code in jwskate/jwa/signature/rsa.py 81 82 83 84 85 86 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 ()","title":"RS512"},{"location":"api/#jwskate.RSAJwk","text":"Bases: Jwk Represent a RSA Jwk, with kty=RSA . Source code in jwskate/jwk/rsa.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class RSAJwk ( Jwk ): \"\"\"Represent a RSA Jwk, with `kty=RSA`.\"\"\" KTY = \"RSA\" CRYPTOGRAPHY_KEY_CLASSES = ( rsa . RSAPrivateKey , rsa . RSAPublicKey ) PARAMS = { \"n\" : JwkParameter ( \"Modulus\" , is_private = False , is_required = True , kind = \"b64u\" ), \"e\" : JwkParameter ( \"Exponent\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Exponent\" , is_private = True , is_required = True , kind = \"b64u\" ), \"p\" : JwkParameter ( \"First Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"q\" : JwkParameter ( \"Second Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dp\" : JwkParameter ( \"First Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dq\" : JwkParameter ( \"Second Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" , ), \"qi\" : JwkParameter ( \"First CRT Coefficient\" , is_private = True , is_required = False , kind = \"b64u\" ), \"oth\" : JwkParameter ( \"Other Primes Info\" , is_private = True , is_required = False , kind = \"unsupported\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ RS256 , RS384 , RS512 , PS256 , PS384 , PS512 ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ RsaEsPcks1v1_5 , RsaEsOaep , RsaEsOaepSha256 , RsaEsOaepSha384 , RsaEsOaepSha512 , ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: cryptography_key: a `cryptography` RSA key **kwargs: additional members to include in the Jwk Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( cryptography_key , rsa . RSAPrivateKey ): priv = cryptography_key . private_numbers () # type: ignore[attr-defined] pub = cryptography_key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( cryptography_key , rsa . RSAPublicKey ): pub = cryptography_key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) def _to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key () @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public RsaJwk from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initializes a Private RsaJwk from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d ) . to ( \"b64u\" ) . ascii (), p = BinaPy . from_int ( p ) . to ( \"b64u\" ) . ascii () if p is not None else None , q = BinaPy . from_int ( q ) . to ( \"b64u\" ) . ascii () if q is not None else None , dp = BinaPy . from_int ( dp ) . to ( \"b64u\" ) . ascii () if dp is not None else None , dq = BinaPy . from_int ( dq ) . to ( \"b64u\" ) . ascii () if dq is not None else None , qi = BinaPy . from_int ( qi ) . to ( \"b64u\" ) . ascii () if qi is not None else None , ** params , ) ) @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generates a new random private RSAJwk. Args: key_size: the key size to use for the generated key, in bits **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) @cached_property def modulus ( self ) -> int : \"\"\"Returns the modulus from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () @cached_property def exponent ( self ) -> int : \"\"\"Returns the exponent from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () @cached_property def private_exponent ( self ) -> int : \"\"\"Returns the private exponent from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () @cached_property def first_prime_factor ( self ) -> int : \"\"\"Returns the first prime factor from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int () @cached_property def second_prime_factor ( self ) -> int : \"\"\"Returns the second prime factor from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int () @cached_property def first_factor_crt_exponent ( self ) -> int : \"\"\"Returns the first factor CRT exponent from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () @cached_property def second_factor_crt_exponent ( self ) -> int : \"\"\"Returns the second factor CRT exponent from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () @cached_property def first_crt_coefficient ( self ) -> int : \"\"\"Returns the first CRT coefficient from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int ()","title":"RSAJwk"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.exponent","text":"Returns the exponent from this Jwk. Returns: Type Description int the key exponent (from parameter e ) Source code in jwskate/jwk/rsa.py 236 237 238 239 240 241 242 243 @cached_property def exponent ( self ) -> int : \"\"\"Returns the exponent from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int ()","title":"exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_crt_coefficient","text":"Returns the first CRT coefficient from this Jwk. Returns: Type Description int the first CRT coefficient (from parameter qi ) Source code in jwskate/jwk/rsa.py 290 291 292 293 294 295 296 297 @cached_property def first_crt_coefficient ( self ) -> int : \"\"\"Returns the first CRT coefficient from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int ()","title":"first_crt_coefficient()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_factor_crt_exponent","text":"Returns the first factor CRT exponent from this Jwk. Returns: Type Description int the first factor CRT coefficient (from parameter dp ) Source code in jwskate/jwk/rsa.py 272 273 274 275 276 277 278 279 @cached_property def first_factor_crt_exponent ( self ) -> int : \"\"\"Returns the first factor CRT exponent from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int ()","title":"first_factor_crt_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_prime_factor","text":"Returns the first prime factor from this Jwk. Returns: Type Description int the first prime factor (from parameter p ) Source code in jwskate/jwk/rsa.py 254 255 256 257 258 259 260 261 @cached_property def first_prime_factor ( self ) -> int : \"\"\"Returns the first prime factor from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int ()","title":"first_prime_factor()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.from_cryptography_key","text":"Initialize a Jwk from a cryptography RSA key. Parameters: Name Type Description Default cryptography_key Any a cryptography RSA key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized with the given key Raises: Type Description TypeError if the given key type is not supported Source code in jwskate/jwk/rsa.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: cryptography_key: a `cryptography` RSA key **kwargs: additional members to include in the Jwk Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( cryptography_key , rsa . RSAPrivateKey ): priv = cryptography_key . private_numbers () # type: ignore[attr-defined] pub = cryptography_key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( cryptography_key , rsa . RSAPublicKey ): pub = cryptography_key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.generate","text":"Generates a new random private RSAJwk. Parameters: Name Type Description Default key_size int the key size to use for the generated key, in bits 4096 **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a generated RSAJwk Source code in jwskate/jwk/rsa.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generates a new random private RSAJwk. Args: key_size: the key size to use for the generated key, in bits **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , )","title":"generate()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.modulus","text":"Returns the modulus from this Jwk. Returns: Type Description int the key modulus (from parameter n ) Source code in jwskate/jwk/rsa.py 227 228 229 230 231 232 233 234 @cached_property def modulus ( self ) -> int : \"\"\"Returns the modulus from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int ()","title":"modulus()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.private","text":"Initializes a Private RsaJwk from its required parameters. Parameters: Name Type Description Default n int the modulus required e int the exponent required d int the private exponent required p Optional [ int ] the first prime factor None q Optional [ int ] the second prime factor None dp Optional [ int ] the first factor CRT exponent None dq Optional [ int ] the second factor CRT exponent None qi Optional [ int ] the first CRT coefficient None **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized from the given parameters Source code in jwskate/jwk/rsa.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initializes a Private RsaJwk from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d ) . to ( \"b64u\" ) . ascii (), p = BinaPy . from_int ( p ) . to ( \"b64u\" ) . ascii () if p is not None else None , q = BinaPy . from_int ( q ) . to ( \"b64u\" ) . ascii () if q is not None else None , dp = BinaPy . from_int ( dp ) . to ( \"b64u\" ) . ascii () if dp is not None else None , dq = BinaPy . from_int ( dq ) . to ( \"b64u\" ) . ascii () if dq is not None else None , qi = BinaPy . from_int ( qi ) . to ( \"b64u\" ) . ascii () if qi is not None else None , ** params , ) )","title":"private()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.private_exponent","text":"Returns the private exponent from this Jwk. Returns: Type Description int the key private exponent (from parameter d ) Source code in jwskate/jwk/rsa.py 245 246 247 248 249 250 251 252 @cached_property def private_exponent ( self ) -> int : \"\"\"Returns the private exponent from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int ()","title":"private_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.public","text":"Initialize a public RsaJwk from a modulus and an exponent. Parameters: Name Type Description Default n int the modulus required e int the exponent required **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RsaJwk initialized from the provided parameters Source code in jwskate/jwk/rsa.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public RsaJwk from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), ** params , ) )","title":"public()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.second_factor_crt_exponent","text":"Returns the second factor CRT exponent from this Jwk. Returns: Type Description int the second factor CRT coefficient (from parameter dq ) Source code in jwskate/jwk/rsa.py 281 282 283 284 285 286 287 288 @cached_property def second_factor_crt_exponent ( self ) -> int : \"\"\"Returns the second factor CRT exponent from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int ()","title":"second_factor_crt_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.second_prime_factor","text":"Returns the second prime factor from this Jwk. Returns: Type Description int the second prime factor (from parameter q ) Source code in jwskate/jwk/rsa.py 263 264 265 266 267 268 269 270 @cached_property def second_prime_factor ( self ) -> int : \"\"\"Returns the second prime factor from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int ()","title":"second_prime_factor()"},{"location":"api/#jwskate.RsaEsOaep","text":"Bases: BaseRsaKeyWrap RSAES OAEP using default parameters Source code in jwskate/jwa/key_mgmt/rsa.py 77 78 79 80 81 82 83 84 85 86 87 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , )","title":"RsaEsOaep"},{"location":"api/#jwskate.RsaEsOaepSha256","text":"Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256 Source code in jwskate/jwa/key_mgmt/rsa.py 90 91 92 93 94 95 96 97 98 99 100 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , )","title":"RsaEsOaepSha256"},{"location":"api/#jwskate.RsaEsOaepSha384","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384 Source code in jwskate/jwa/key_mgmt/rsa.py 103 104 105 106 107 108 109 110 111 112 113 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , )","title":"RsaEsOaepSha384"},{"location":"api/#jwskate.RsaEsOaepSha512","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512 Source code in jwskate/jwa/key_mgmt/rsa.py 116 117 118 119 120 121 122 123 124 125 126 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , )","title":"RsaEsOaepSha512"},{"location":"api/#jwskate.RsaEsPcks1v1_5","text":"Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5 Source code in jwskate/jwa/key_mgmt/rsa.py 67 68 69 70 71 72 73 74 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5\"\"\" name = \"RSA1_5\" description = __doc__ read_only = True padding = padding . PKCS1v15 ()","title":"RsaEsPcks1v1_5"},{"location":"api/#jwskate.SignatureAlgs","text":"Identifiers for Signature algorithms. Source code in jwskate/enums.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SignatureAlgs : \"\"\"Identifiers for Signature algorithms.\"\"\" RS256 = \"RS256\" RS384 = \"RS384\" RS512 = \"RS512\" ES256 = \"ES256\" ES384 = \"ES384\" ES512 = \"ES512\" PS256 = \"PS256\" PS384 = \"PS384\" PS512 = \"PS512\" EdDSA = \"EdDSA\" HS256 = \"HS256\" HS384 = \"HS384\" HS512 = \"HS512\" ALL_SYMMETRIC = [ HS256 , HS384 , HS512 ] ALL_ASYMMETRIC = [ RS256 , RS384 , RS512 , ES256 , ES384 , ES512 , PS256 , PS384 , PS512 , EdDSA , ]","title":"SignatureAlgs"},{"location":"api/#jwskate.SignedJwt","text":"Bases: Jwt Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use Jwt.sign . Parameters: Name Type Description Default value Union [ bytes , str ] the token value. required Source code in jwskate/jwt/signed.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 class SignedJwt ( Jwt ): \"\"\"Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use [Jwt.sign][jwskate.jwt.Jwt.sign]. Args: value: the token value. \"\"\" def __init__ ( self , value : Union [ bytes , str ]) -> None : super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJwt ( \"A JWT must contain a header, a payload and a signature, separated by dots\" , value , ) header , payload , signature = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT header: it must be a Base64URL-encoded JSON object\" ) try : self . claims = BinaPy ( payload ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\" ) @cached_property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Args: leeway: additional number of seconds for leeway. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < ( datetime . now ( timezone . utc ) + timedelta ( seconds = leeway )) @cached_property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = datetime . fromtimestamp ( exp , tz = timezone . utc ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) @cached_property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = datetime . fromtimestamp ( iat , tz = timezone . utc ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) @cached_property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = datetime . fromtimestamp ( nbf , tz = timezone . utc ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) @cached_property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) @cached_property def audiences ( self ) -> Optional [ List [ str ]]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return None if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) @cached_property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) @cached_property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signature alg to use to verify the signature. algs: allowed signature algs, if several issuer: the expected issuer for this token. audience: the expected audience for this token. check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg , algs ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audiences ) if check_exp : expired = self . is_expired () if expired is True : raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) elif expired is None : raise InvalidClaim ( \"exp\" , \"This token misses a 'exp' claim.\" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim )","title":"SignedJwt"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__bytes__","text":"Return the Jwt serialized value, as bytes . Returns: Type Description bytes the serialized token value. Source code in jwskate/jwt/signed.py 286 287 288 289 290 291 292 def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value","title":"__bytes__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__getattr__","text":"Allow claim access as attributes. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate/jwt/signed.py 264 265 266 267 268 269 270 271 272 273 274 275 276 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value","title":"__getattr__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__getitem__","text":"Allow claim access with subscription. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate/jwt/signed.py 250 251 252 253 254 255 256 257 258 259 260 261 262 def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value","title":"__getitem__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__str__","text":"Return the Jwt serialized value, as str . Returns: Type Description str the serialized token value. Source code in jwskate/jwt/signed.py 278 279 280 281 282 283 284 def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode ()","title":"__str__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.audiences","text":"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a list anyway. Returns: Type Description Optional [ List [ str ]] the list of audiences from this token, from the aud claim. Raises: Type Description AttributeError if the audience is an unexpected type Source code in jwskate/jwt/signed.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 @cached_property def audiences ( self ) -> Optional [ List [ str ]]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return None if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud ))","title":"audiences()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.expires_at","text":"Get the \"Expires At\" (exp) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the exp claim, or None if there is no exp claim Raises: Type Description AttributeError if the exp claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @cached_property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = datetime . fromtimestamp ( exp , tz = timezone . utc ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp )","title":"expires_at()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.get_claim","text":"Get a claim from this Jwt. Parameters: Name Type Description Default key str the claim name. required default Any a default value if the claim is not found None Returns: Type Description Any the claim value if found, or default if not found Source code in jwskate/jwt/signed.py 238 239 240 241 242 243 244 245 246 247 248 def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default )","title":"get_claim()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.is_expired","text":"Check if this token is expired, based on its exp claim. Parameters: Name Type Description Default leeway int additional number of seconds for leeway. 0 Returns: Type Description Optional [ bool ] True if the token is expired, False if it's not, None if there is no exp claim. Source code in jwskate/jwt/signed.py 101 102 103 104 105 106 107 108 109 110 111 112 113 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Args: leeway: additional number of seconds for leeway. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < ( datetime . now ( timezone . utc ) + timedelta ( seconds = leeway ))","title":"is_expired()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.issued_at","text":"Get the \"Issued At\" (iat) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the iat claim, or None if there is no iat claim Raises: Type Description AttributeError if the iss claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 @cached_property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = datetime . fromtimestamp ( iat , tz = timezone . utc ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat )","title":"issued_at()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.issuer","text":"Get the Issuer (iss) claim from this token. Returns: Type Description Optional [ str ] the issuer, as str , or None if there is no \u00ecss claim Raises: Type Description AttributeError if the \u00ecss claim value is not a string Source code in jwskate/jwt/signed.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 @cached_property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss ))","title":"issuer()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.jwt_token_id","text":"Get the JWT Token ID (jti) from this token claims. Returns: Type Description Optional [ str ] the token identifier, as str , or None if there is no jti claim Raises: Type Description AttributeError if the jti value is not a string Source code in jwskate/jwt/signed.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @cached_property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti ))","title":"jwt_token_id()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.not_before","text":"Get the \"Not Before\" (nbf) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the nbf claim, or None if there is no nbf claim Raises: Type Description AttributeError if the nbf claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 @cached_property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = datetime . fromtimestamp ( nbf , tz = timezone . utc ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf )","title":"not_before()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.signed_part","text":"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: Type Description bytes the signed part as bytes Source code in jwskate/jwt/signed.py 68 69 70 71 72 73 74 75 76 77 @cached_property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ])","title":"signed_part()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.subject","text":"Get the Subject (sub) from this token claims. Returns: Type Description Optional [ str ] the subject, as str , or None if there is no sub claim Raises: Type Description AttributeError if the sub value is not a string Source code in jwskate/jwt/signed.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @cached_property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub ))","title":"subject()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.validate","text":"Validate a SignedJwt signature and expected claims. This verifies the signature using the provided jwk and alg , then checks the token issuer, audience and expiration date. This can also check custom claims using extra kwargs , whose values can be: a static value ( str , int , etc.): the value from the token will be compared \"as-is\" a callable, taking the claim value as parameter: if that callable returns True , the claim is considered as valid Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the signing key to use to verify the signature. required alg Optional [ str ] the signature alg to use to verify the signature. None algs Optional [ Iterable [ str ]] allowed signature algs, if several None issuer Optional [ str ] the expected issuer for this token. None audience Union [None, str ] the expected audience for this token. None check_exp bool \u00ecf True (default), check that the token is not expired. True **kwargs Any additional claims to check {} Returns: Type Description None Raises exceptions if any validation check fails. Raises: Type Description InvalidSignature if the signature is not valid InvalidClaim if a claim doesn't validate ExpiredJwt if the expiration date is passed Source code in jwskate/jwt/signed.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signature alg to use to verify the signature. algs: allowed signature algs, if several issuer: the expected issuer for this token. audience: the expected audience for this token. check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg , algs ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audiences ) if check_exp : expired = self . is_expired () if expired is True : raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) elif expired is None : raise InvalidClaim ( \"exp\" , \"This token misses a 'exp' claim.\" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim )","title":"validate()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.verify_signature","text":"Verify this JWT signature using a given key and algorithm(s). Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private Jwk to use to verify the signature required alg Optional [ str ] the alg to use to verify the signature, if only 1 is allowed None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the token signature is verified, False otherwise Source code in jwskate/jwt/signed.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = Jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs )","title":"verify_signature()"},{"location":"api/#jwskate.SymmetricJwk","text":"Bases: Jwk Implement Symetric keys, with kty=oct . Source code in jwskate/jwk/oct.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 class SymmetricJwk ( Jwk ): \"\"\"Implement Symetric keys, with `kty=oct`.\"\"\" KTY = \"oct\" CRYPTOGRAPHY_KEY_CLASSES = ( bytes ,) PARAMS = { \"k\" : JwkParameter ( \"Key Value\" , is_private = True , is_required = True , kind = \"b64u\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ HS256 , HS384 , HS512 ]} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ A128KW , A192KW , A256KW , A128GCMKW , A192GCMKW , A256GCMKW , DirectKeyUse , ] } ENCRYPTION_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ Aes128CbcHmacSha256 , Aes192CbcHmacSha384 , Aes256CbcHmacSha512 , A128GCM , A192GCM , A256GCM , ] } def public_jwk ( self ) -> Jwk : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk : \"\"\"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . to ( \"b64u\" ) . ascii (), ** params )) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> SymmetricJwk : \"\"\"Alias for `from_bytes()` since symmetric keys are simply bytes. Args: cryptography_key: the key to use **kwargs: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls . from_bytes ( cryptography_key , ** kwargs ) @classmethod def generate ( cls , key_size : int = 128 , ** params : str ) -> SymmetricJwk : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: key_size: the size of the generated key, in bits **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( key_size ) return cls . from_bytes ( key , ** params ) @classmethod def generate_for_alg ( cls , alg : str , ** params : str ) -> SymmetricJwk : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the signing algorithm to use this key with **params: additional members to include in the Jwk Returns: the resulting Jwk Raises: ValueError: if the provided `alg` is not supported \"\"\" if alg in cls . SIGNATURE_ALGORITHMS : sigalg = cls . SIGNATURE_ALGORITHMS [ alg ] return cls . generate ( sigalg . min_key_size , alg = alg , ** params ) if alg in cls . ENCRYPTION_ALGORITHMS : encalg = cls . ENCRYPTION_ALGORITHMS [ alg ] return cls . generate ( encalg . key_size , alg = alg , ** params ) raise ValueError ( \"Unsupported alg\" , alg ) def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () ) def _to_cryptography_key ( self ) -> BinaPy : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" ) @property def key ( self ) -> BinaPy : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return self . cryptography_key # type: ignore def encrypt ( self , plaintext : bytes , * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data (`aad`). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) if iv is None : iv = encalg . generate_iv () wrapper : BaseAESEncryptionAlg = encalg ( self . cryptography_key ) ciphertext , tag = wrapper . encrypt ( plaintext , iv = iv , aad = aad ) return ciphertext , BinaPy ( iv ), tag @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 def decrypt ( self , ciphertext : bytes , * , iv : bytes , tag : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data iv: the Initialization Vector (must be the same as used during encryption) tag: the authentication tag aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) decryptor : BaseAESEncryptionAlg = encalg ( self . cryptography_key ) plaintext : bytes = decryptor . decrypt ( ciphertext , auth_tag = tag , iv = iv , aad = aad ) return BinaPy ( plaintext ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) # type: ignore ] def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) ]","title":"SymmetricJwk"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.decrypt","text":"Decrypt arbitrary data. Parameters: Name Type Description Default ciphertext bytes the encrypted data required iv bytes the Initialization Vector (must be the same as used during encryption) required tag bytes the authentication tag required aad Optional [ bytes ] the Additional Authenticated Data (must be the same as used during encryption) None alg Optional [ str ] the decryption alg (must be the same as used during encryption) None Returns: Type Description BinaPy the decrypted clear-text Source code in jwskate/jwk/oct.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def decrypt ( self , ciphertext : bytes , * , iv : bytes , tag : bytes , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data iv: the Initialization Vector (must be the same as used during encryption) tag: the authentication tag aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) decryptor : BaseAESEncryptionAlg = encalg ( self . cryptography_key ) plaintext : bytes = decryptor . decrypt ( ciphertext , auth_tag = tag , iv = iv , aad = aad ) return BinaPy ( plaintext )","title":"decrypt()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.encrypt","text":"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data ( aad ). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the iv parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Parameters: Name Type Description Default plaintext bytes the plaintext to encrypt required aad Optional [ bytes ] the Additional Authentication Data, if any None alg Optional [ str ] the encryption alg to use None iv Optional [ bytes ] the IV to use, if you want a specific value None Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (ciphertext, authentication_tag, iv) tuple Source code in jwskate/jwk/oct.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def encrypt ( self , plaintext : bytes , * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with the Additional Authenticated Data (`aad`). An Initializatin Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This return the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" encalg = select_alg ( self . alg , alg , self . ENCRYPTION_ALGORITHMS ) if iv is None : iv = encalg . generate_iv () wrapper : BaseAESEncryptionAlg = encalg ( self . cryptography_key ) ciphertext , tag = wrapper . encrypt ( plaintext , iv = iv , aad = aad ) return ciphertext , BinaPy ( iv ), tag","title":"encrypt()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.from_bytes","text":"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the k parameter for the returned SymetricKey. Parameters: Name Type Description Default k Union [ bytes , str ] the key to use required **params Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the resulting SymmetricJwk Source code in jwskate/jwk/oct.py 78 79 80 81 82 83 84 85 86 87 88 89 @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk : \"\"\"Initializes a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . to ( \"b64u\" ) . ascii (), ** params ))","title":"from_bytes()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.from_cryptography_key","text":"Alias for from_bytes() since symmetric keys are simply bytes. Parameters: Name Type Description Default cryptography_key Any the key to use required **kwargs Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the resulting SymmetricJwk Source code in jwskate/jwk/oct.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> SymmetricJwk : \"\"\"Alias for `from_bytes()` since symmetric keys are simply bytes. Args: cryptography_key: the key to use **kwargs: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls . from_bytes ( cryptography_key , ** kwargs )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.generate","text":"Generate a random SymmetricJwk, with a given key size. Parameters: Name Type Description Default key_size int the size of the generated key, in bits 128 **params str additional members to include in the Jwk {} Returns: Type Description SymmetricJwk a SymmetricJwk with a randomly generated key Source code in jwskate/jwk/oct.py 106 107 108 109 110 111 112 113 114 115 116 117 118 @classmethod def generate ( cls , key_size : int = 128 , ** params : str ) -> SymmetricJwk : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: key_size: the size of the generated key, in bits **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( key_size ) return cls . from_bytes ( key , ** params )","title":"generate()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.generate_for_alg","text":"Generate a SymmetricJwk that is suitable for use with the given alg. Parameters: Name Type Description Default alg str the signing algorithm to use this key with required **params str additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the resulting Jwk Raises: Type Description ValueError if the provided alg is not supported Source code in jwskate/jwk/oct.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 @classmethod def generate_for_alg ( cls , alg : str , ** params : str ) -> SymmetricJwk : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the signing algorithm to use this key with **params: additional members to include in the Jwk Returns: the resulting Jwk Raises: ValueError: if the provided `alg` is not supported \"\"\" if alg in cls . SIGNATURE_ALGORITHMS : sigalg = cls . SIGNATURE_ALGORITHMS [ alg ] return cls . generate ( sigalg . min_key_size , alg = alg , ** params ) if alg in cls . ENCRYPTION_ALGORITHMS : encalg = cls . ENCRYPTION_ALGORITHMS [ alg ] return cls . generate ( encalg . key_size , alg = alg , ** params ) raise ValueError ( \"Unsupported alg\" , alg )","title":"generate_for_alg()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.key","text":"Returns the raw symmetric key. Returns: Type Description BinaPy the key from the k parameter, base64u-decoded Source code in jwskate/jwk/oct.py 170 171 172 173 174 175 176 177 @property def key ( self ) -> BinaPy : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return self . cryptography_key # type: ignore","title":"key()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.key_size","text":"The key size, in bits. Returns: Type Description int the key size in bits Source code in jwskate/jwk/oct.py 209 210 211 212 213 214 215 216 @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8","title":"key_size()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.public_jwk","text":"This always raises a ValueError since SymmetricKeys are always private. Raises: Type Description ValueError symmetric keys are always private, it makes no sense to use them as public keys Source code in jwskate/jwk/oct.py 70 71 72 73 74 75 76 def public_jwk ( self ) -> Jwk : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" )","title":"public_jwk()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.supported_encryption_algorithms","text":"Return the list of supported Encryption/Decryption algorithms with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/oct.py 257 258 259 260 261 262 263 264 265 266 267 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) ]","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.supported_key_management_algorithms","text":"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/oct.py 245 246 247 248 249 250 251 252 253 254 255 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms, usable for key (un)wrapping with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) # type: ignore ]","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.thumbprint","text":"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Returns: Type Description str the calculated thumbprint Source code in jwskate/jwk/oct.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () )","title":"thumbprint()"},{"location":"api/#jwskate.UnsupportedAlg","text":"Bases: ValueError Raised when an UnsupportedAlg is requested. Source code in jwskate/jwk/alg.py 9 10 class UnsupportedAlg ( ValueError ): \"\"\"Raised when an UnsupportedAlg is requested.\"\"\"","title":"UnsupportedAlg"},{"location":"api/#jwskate.UnsupportedEllipticCurve","text":"Bases: KeyError Raised when an unsupported Elliptic curve is requested. Source code in jwskate/jwk/ec.py 31 32 class UnsupportedEllipticCurve ( KeyError ): \"\"\"Raised when an unsupported Elliptic curve is requested.\"\"\"","title":"UnsupportedEllipticCurve"},{"location":"api/#jwskate.UnsupportedOKPCurve","text":"Bases: KeyError Raised when an unsupported OKP curve is requested. Source code in jwskate/jwk/okp.py 23 24 class UnsupportedOKPCurve ( KeyError ): \"\"\"Raised when an unsupported OKP curve is requested.\"\"\" selection: docstring_style: google filters: - \"!^_\" - \"^ init \" rendering: members_order: source show_root_heading: true heading_level: 2","title":"UnsupportedOKPCurve"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Guillaume Pujol guill.p.linux@gmail.com Contributors \u00b6 None yet. Why not be the first?","title":"Authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Guillaume Pujol guill.p.linux@gmail.com","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/guillp/jwskate/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 JsonWebSkate could always use more documentation, whether as part of the official JsonWebSkate docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/guillp/jwskate/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up jwskate for local development. Fork the jwskate repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/jwskate.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/jwskate/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_jwskate ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass. ```","title":"contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/guillp/jwskate/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"JsonWebSkate could always use more documentation, whether as part of the official JsonWebSkate docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/guillp/jwskate/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up jwskate for local development. Fork the jwskate repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/jwskate.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/jwskate/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_jwskate ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass. ```","title":"Deploying"},{"location":"history/","text":"History \u00b6 0.1.0 (2021-11-15) \u00b6 First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2021-11-15","text":"First release on PyPI.","title":"0.1.0 (2021-11-15)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install jwskate , run this command in your terminal: 1 $ pip install jwskate This is the preferred method to install jwskate , as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for jwskate can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/jwskate Or download the tarball : 1 $ curl -OJL https://github.com/guillp/jwskate/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install jwskate , run this command in your terminal: 1 $ pip install jwskate This is the preferred method to install jwskate , as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for jwskate can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/jwskate Or download the tarball : 1 $ curl -OJL https://github.com/guillp/jwskate/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use jwskate in a project, you can import all exposed objects from the root module: 1 from jwskate import * JWK \u00b6 Loading keys \u00b6 The Jwk class and its subclasses represent keys in JWK format. You can initialize a Jwk from: a dict representing the JWK content, already parsed from JSON: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) a string containing a JSON representation of the JWK: 1 2 3 4 5 6 7 8 from jwskate import Jwk jwk = Jwk ( '{\"kty\": \"EC\", \"crv\": \"P-256\",' 'x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",' 'y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",' 'd\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}' ) a cryptography key: 1 2 3 4 5 from jwskate import Jwk from cryptography.hazmat.primitives.asymmetric import ec key = ec . generate_private_key ( ec . SECP256R1 ) jwk = Jwk ( key ) a public or private key in PEM format, optionally protected by a password: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import Jwk public_jwk = Jwk . from_pem_key ( b \"\"\"-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsjtGIk8SxD+OEiBpP2/T JUAF0upwuKGMk6wH8Rwov88VvzJrVm2NCticTk5FUg+UG5r8JArrV4tJPRHQyvqK wF4NiksuvOjv3HyIf4oaOhZjT8hDne1Bfv+cFqZJ61Gk0MjANh/T5q9vxER/7TdU NHKpoRV+NVlKN5bEU/NQ5FQjVXicfswxh6Y6fl2PIFqT2CfjD+FkBPU1iT9qyJYH A38IRvwNtcitFgCeZwdGPoxiPPh1WHY8VxpUVBv/2JsUtrB/rAIbGqZoxAIWvijJ Pe9o1TY3VlOzk9ASZ1AeatvOir+iDVJ5OpKmLnzc46QgGPUsjIyo6Sje9dxpGtoG QQIDAQAB -----END PUBLIC KEY-----\"\"\" ) private_jwk = Jwk . from_pem_key ( b \"\"\"-----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAywYF71cKSo3xyi7/0S7N1blFCmBX4eZz0gXf+zyBfomuqhwr .... daBAqhoDEr4SoKju8pagw6lqm65XeARyWkxqFqAZbb2K3bWY3x9qZT6oubLrCDGD -----END RSA PRIVATE KEY-----\"\"\" , \"P@ssw0rd\" , ) Getting key parameters \u00b6 Once you have a Jwk instance, you can get its parameters either with subscription or attribute access: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert jwk . kty == \"EC\" assert jwk . crv == \"P-256\" assert jwk . x == \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" assert jwk [ \"x\" ] == jwk . x Those will return the exact (usually base64url-encoded) value exactly as expressed in the JWK. You can also get the real, decoded parameters with some special attributes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert ( jwk . x_coordinate == 41091394722340406951651919287101979028566994134304719828008599584440827098914 ) assert ( jwk . y_coordinate == 5099336126642036233987555101153084413345413137896124327269101893088581300336 ) assert ( jwk . ecc_private_key == 8342345011805978907621665437908035545366143771247820774310445528411160853919 ) The available special attributes vary depending on the key type. Generating keys \u00b6 You can generate a Jwk with the class method Jwk.generate_for_kty() . It needs the key type as parameter, and type-specific parameters: 1 2 3 4 5 from jwskate import Jwk ec_jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) rsa_jwk = Jwk . generate_for_kty ( \"RSA\" , key_size = 4096 ) okp_jwk = Jwk . generate_for_kty ( \"OKP\" , crv = \"Ed25519\" ) You can include additional parameters such as \"use\" or \"key_ops\", or custom parameters which will be included in the generated key: 1 2 3 4 5 from jwskate import Jwk jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" , use = \"sig\" ) assert jwk . use == \"sig\" Private and Public Keys \u00b6 You can check if a key is public or private with the is_private property: 1 2 3 4 5 6 7 8 9 10 11 12 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert jwk . is_private You can get the public key that match a given private key with the public_jwk() method. It returns a new Jwk instance that does not contain the private parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) public_jwk = jwk . public_jwk () assert \"d\" not in public_jwk # \"d\" would contain the private key assert not public_jwk . is_private Note that Symmetric keys are always considered private, so calling .public_jwk() will raise a ValueError . Dumping keys \u00b6 to JSON \u00b6 Jwk instances are dicts, so you can serialize it to JSON in the usual ways (with Python json module or any other means). You can also use the to_json() convenience method to serialize a Jwk: 1 2 3 4 5 6 7 8 9 10 11 12 13 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) jwk . to_json () # '{\"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\", \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\", \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}' to cryptography keys \u00b6 You can access the cryptography_key attribute to get a cryptography key instance that matches a Jwk : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) cryptography_key = jwk . cryptography_key assert ( str ( cryptography_key . __class__ ) == \"<class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePrivateKey'>\" ) Signing and verifying data \u00b6 You can sign arbitrary data, then validate the signature with a Jwk instance, using the sign() and verify() methods: 1 2 3 4 5 6 7 8 9 10 11 12 from jwskate import Jwk data = b \"Signing is easy!\" jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) signature = jwk . sign ( data , alg = \"ES256\" ) assert jwk . verify ( data , signature , alg = \"ES256\" ) assert not jwk . verify ( data , b \"this_is_a_wrong_signature_value_12345678012345678012345678012345\" , alg = \"ES256\" , ) Encrypting and Decrypting data \u00b6 Encryption or decryption require a symmetric key, which translates to an instance of SymmetricJwk , with kty='oct' . You can encrypt and decrypt arbitrary data with a Jwk instance, using the encrypt() and decrypt() methods: 1 2 3 4 5 6 7 8 9 from jwskate import Jwk data = b \"Encryption is easy!\" alg = \"A256GCM\" jwk = Jwk . generate_for_kty ( \"oct\" , key_size = 256 , alg = alg ) ciphertext , iv , tag = jwk . encrypt ( data ) assert jwk . decrypt ( ciphertext , iv = iv , tag = tag ) == data Authenticated encryption \u00b6 You can include Additional Authenticated Data ( aad ) in the encrypt() and decrypt() operations: 1 2 3 4 5 6 7 8 9 10 from jwskate import Jwk data = b \"Authenticated Encryption is easy!\" alg = \"A256GCM\" aad = b \"This is my auth tag\" jwk = Jwk . generate_for_kty ( \"oct\" , key_size = 256 , alg = alg ) ciphertext , iv , tag = jwk . encrypt ( data , aad = aad ) assert jwk . decrypt ( ciphertext , iv = iv , tag = tag , aad = aad ) == data Key Management \u00b6 Encrypting/decrypting arbitrary data requires a symmetric key. But it is possible to encrypt/decrypt or otherwise derive symmetric keys from asymmetric keys, using Key Management algorithms. Some of those Key Management algorithms rely on key wrapping, where a randomly-generated symmetric key (called a Content Encryption Key or CEK) is itself asymmetrically encrypted. It is also possible to use a symmetric key to \"wrap\" the CEK. Other algorithms rely on Diffie-Hellman, where the CEK is derived from a pair of keys, one private, the other public. You can use the methods sender_key() and receiver_key() to handle all the key management stuff for you. For sender_key() , which the message sender will use get a CEK, you just need to specify which encryption algorithm you will use with the CEK, and the key management algorithm you want to wrap or derive that CEK. It will return a tuple (plaintext_message, encrypted_cek, extra_headers) , with plaintext_message being the generated CEK (as an instance of SymmetricJwk ), encrypted_cek is the wrapped CEK value (which can be empty for Diffie-Hellman based algorithms), and extra_headers a dict of extra headers that are required for the key management algorithm (for example, epk for ECDH-ES based algorithms), You can use cleartext_cek to encrypt your message with a given Encryption algorithm. You must then send encrypted_cek and extra_headers to your recipient, along with the encrypted message, and both Key Management and Encryption algorithms identifiers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from jwskate import Jwk plaintext_message = b \"Key Management is easy!\" recipient_private_jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) # {'kty': 'EC', # 'crv': 'P-256', # 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE', # 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4', # 'd': 'Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E'} recipient_public_jwk = recipient_private_jwk . public_jwk () # {'kty': 'EC', # 'crv': 'P-256', # 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE', # 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4'} enc_alg = \"A256GCM\" km_alg = \"ECDH-ES\" plaintext_cek , encrypted_cek , extra_headers = recipient_public_jwk . sender_key ( enc = enc_alg , alg = km_alg ) # plaintext_cek: {'kty': 'oct', 'k': 'iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc'} # encrypted_cek: b'' # extra_headers: {'epk': {'kty': 'EC', # 'crv': 'P-256', # 'x': '_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg', # 'y': 'nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs'}} encrypted_message , iv , tag = plaintext_cek . encrypt ( plaintext_message , alg = enc_alg ) # encrypted_message: b'\\xb5J\\x16\\x08\\x82Xp\\x0f,\\x0eu\\xe5\\xd6\\xa6y\\xe0J\\xae\\xcbu\\xf8B\\xbd' # iv: b'K\"H\\xf3@\\tt\\\\\\xc78\\xc2D' # tag: b'\\xc4\\xee\\xcf`\\xfa\\\\\\x8e\\x9dn\\xc4>D\\xd8\\x1d\\x8c\\x1a' On recipient side, in order to decrypt the message, you will need to obtain the same symmetric CEK that was used to encrypt the message. That is done with recipient_key() . You need to provide it with the encrypted_cek received from the sender (possibly empty for Diffie-Hellman based algorithms), the Key Management algorithm that is used to wrap the CEK, the Encryption algorithm that is used to encrypt/decrypt the message, and the eventual extra headers depending on the Key Management algorithm. You can then use that CEK to decrypt the received message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from jwskate import Jwk # reusing the variables from above enc_alg = \"A256GCM\" km_alg = \"ECDH-ES\" plaintext_cek = { \"kty\" : \"oct\" , \"k\" : \"iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc\" } encrypted_cek = b \"\" extra_headers = { \"epk\" : { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg\" , \"y\" : \"nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs\" , } } recipient_private_jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE\" , \"y\" : \"Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4\" , \"d\" : \"Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E\" , } ) encrypted_message = b \" \\xb5 J \\x16\\x08\\x82 Xp \\x0f , \\x0e u \\xe5\\xd6\\xa6 y \\xe0 J \\xae\\xcb u \\xf8 B \\xbd \" iv = b 'K\"H \\xf3 @ \\t t \\\\\\xc7 8 \\xc2 D' tag = b \" \\xc4\\xee\\xcf ` \\xfa\\\\\\x8e\\x9d n \\xc4 >D \\xd8\\x1d\\x8c\\x1a \" # obtain the same CEK than the sender, based on our private key, and public data provided by sender cek = recipient_private_jwk . recipient_key ( encrypted_cek , enc = \"A256GCM\" , alg = \"ECDH-ES\" , ** extra_headers ) # and decrypt the message with that CEK (and the IV, Auth Tag and encryption alg identifier provided by sender) plaintext_message = cek . decrypt ( encrypted_message , iv = iv , tag = tag , alg = enc_alg ) assert plaintext_message == b \"Key Management is easy!\" JWS \u00b6 The JwsCompact class represents a syntactically valid JWS token in compact representation. Parsing tokens \u00b6 To parse an existing Jws token and access its content (without validating the signature yet), you simply need to create an instance of JwsCompact with the serialized token as value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import JwsCompact jws = JwsCompact ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\" \"SGVsbG8gV29ybGQh.\" \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\" \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\" \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\" \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\" \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\" ) jws . payload # b'Hello World!' jws . headers # {'alg': 'RS256', 'kid': 'JWK-ABCD'} jws . alg # 'RS256' jws . kid # 'JWK-ABCD' jws . signature # '\\xd5\\xeb\\x9cK\\xd6ZNp\\t\\xc9\\xf5M\\x87\\x12\\xc9\\xfe\\x98E7Z\\xde\\xc6m%\\xfar\\x17X\\x18\\xd4\"gR\\xdb\\xdc\\xf9\\xe4\\x1b\\xb1\\x1f\\xa3c\\x1a\\x99mIr\\xab\\x81\\x8cXC\\x1a\\x86\\n\\xc1\\x88\\xc6T\\x95\\xa0\\x81!)Wa\\x13U]\\xf4\\xd3\\xc9G,;#\\x8c\\xc1E\\xdc\\x15\\xbd\\xca\\x8cD\\xe0\\xcc\\xa8<B\\x8a\\xa6\\xc3C\\xfe[#\\x98\\xc0\\xa8Q\\t\\x00P\\x97f\\x8d\\x93\\xe2,e\\xc6\\xcf\\xb6y{fHJz\\xbd~uN\\ri\\xbe\\'\\x0c\\xe7\\xf6+)\\xf4\\xbc&}\\xe5\\xb7\\xdcV\\xe5\\x16\\x8d)B}\\xe0\\xa5K\\x96\\x8b\\xff\"w\\x05\\xb2\\x1d\\x9b\\x83\\x98\\xdd\\xa3T\\x84\\xa1Le\\x07b\\x08\\xd0\\x97e|+ \\x1e\\x88Iw\\x9f\\x1eZ1S\\xa1\\xe3m\\x1fW\\xa2\\\\g\\x998v\\xe50\\xbc\\xf9k\\x90!c\\xc8\\xd8\\xdc.6\\xe3\\xeb`\\x82>\\x81+\\xa7\\xf0\\xa5\\xe7]tP\\xf7\\x9a\\xd1EL\\xdc:)?\\xb6\\x12\\x04\\xde:Q\\x00\\xd3\\xdaP\\xa9na\\xa2\\xc0\\xa3\\xd9\\xdb\\x80\\x95\\x1f\\x85A' Verifying tokens \u00b6 To verify a Jws signature, you need the matching public key: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import JwsCompact jws = JwsCompact ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\" \"SGVsbG8gV29ybGQh.\" \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\" \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\" \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\" \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\" \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\" ) public_jwk = { \"kty\" : \"RSA\" , \"kid\" : \"JWK-ABCD\" , \"alg\" : \"RS256\" , \"n\" : \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\" , \"e\" : \"AQAB\" , } if jws . verify_signature ( public_jwk ): print ( \"Signature is verified.\" ) else : print ( \"Signature verification failed!\" ) Signing tokens \u00b6 To sign a Jws, you need its payload, the private key and alg to sign with, and provide those to JwsCompact.sign() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from jwskate import JwsCompact payload = b \"Hello World!\" private_jwk = { \"kty\" : \"RSA\" , \"kid\" : \"JWK-ABCD\" , \"alg\" : \"RS256\" , \"n\" : \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\" , \"e\" : \"AQAB\" , \"d\" : \"XCtpsCRQ1DBBm51yqdQ88C82lEjW30Xp0cy6iVEzBKZhmPGmI1PY8gnXWQ5PMlK3sLTM6yypDNvORoNlo6YXWJYA7LGlXEIczj2DOsJmF8T9-OEwGZixvNFDcmYnwWnlA6N_CQKmR0ziQr9ZAzZMCU5Tvr7f8cRZKdAALQEwk5FYpLnEbXOBduJtY9x2kddJSCJwRaEJhx0fG_pJAO3yLUZBY20dZK8UrxDoCgB9eiZV3N4uWGt367r1MDdaxGY6l6bC1HZCHkttBuTxfSUMCgooZevdU6ThQNpFrwZNY3KoP-OksEdqMs-neecfk_AQREkubDW2VPNFnaVEa38BKQ\" , \"p\" : \"8QNZGwUINpkuZi8l2ZfQzKVeOeNe3aQ7UW0wperM-63DFEJDRO1UyNC1n6yeo8_RxPZKSTlr6xZDoilQq23mopeF6O0ZmYz6E2VWJuma65V-A7tB-6xjqUXPlSkCNA6Ia8kMeCmNpKs0r0ijTBf_2y2GSsNH4EcP7XzcDEeJIh0\" , \"q\" : \"58nWgg-qRorRddwKM7qhLxJnEDsnCiYhbKJrP78OfBZ-839bNRvL5D5sfjJqxcKMQidgpYZVvVNL8oDEywcC5T7kKW0HK1JUdYiX9DuI40Mv9WzXQ8B8FBjp5wV4IX6_0KgyIiyoUiKpVHBvO0YFPUYuk0Ns4H9yEws93RWwhSc\" , \"dp\" : \"zFsLZcaphSnzVr9pd4urhqo9MBZjbMmBZnSQCE8ECe729ymMQlh-SFv3dHF4feuLsVcn-9iNceMJ6-jeNs1T_s89wxevWixYKrQFDa-MJW83T1CrDQvJ4VCJR69i5-Let43cXdLWACcO4AVWOQIsdpquQJw-SKPYlIUHS_4n_90\" , \"dq\" : \"fP79rNnhy3TlDBgDcG3-qjHUXo5nuTNi5wCXsaLInuZKw-k0OGmrBIUdYNizd744gRxXJCxTZGvdEwOaHJrFVvcZd7WSHiyh21g0CcNpSJVc8Y8mbyUIRJZC3RC3_egqbM2na4KFqvWCN0UC1wYloSuNxmCgAFj6HYb8b5NYxBU\" , \"qi\" : \"hxXfLYgwrfZBvZ27nrPsm6mLuoO-V2rKdOj3-YDJzf0gnVGBLl0DZbgydZ8WZmSLn2290mO_J8XY-Ss8PjLYbz3JXPDNLMJ-da3iEPKTvh6OfliM_dBxhaW8sq5afLMUR0H8NeabbWkfPz5h0W11CCBYxsyPC6CzniFYCYXfByU\" , } jws = JwsCompact . sign ( payload , jwk = private_jwk , alg = \"RS256\" ) str ( jws ) # 'eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.SGVsbG8gV29ybGQh.1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCsGIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixlxs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoUxlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedddFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ' JWE \u00b6 The JweCompact class represents a syntactically valid JWE token. Parsing and decrypting JWE tokens \u00b6 Provide the serialized token value to JweCompact , then use .deccrypt() with the private key to decrypt the token payload: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 from jwskate import JweCompact jwe = JweCompact ( \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\" \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\" \"ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\" \"Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\" \"mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\" \"1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\" \"6UklfCpIMfIjf7iGdXKHzg.\" \"48V1_ALb6US04U3b.\" \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\" \"SdiwkIr3ajwQzaBtQD_A.\" \"XFBoMYUZodetZdvTiFvSkQ\" ) # all 'raw' attributes are accessible: jwe . headers # {'alg': 'RSA-OAEP', 'enc': 'A256GCM'} jwe . alg # 'RSA-OAEP' jwe . enc # 'A256GCM' jwe . ciphertext # b\"\\xe5\\xec\\xa6\\xf15\\xbfs\\xc4\\xae+Im'z\\xe9`\\x8c\\xcex43\\xed0\\x0b\\xbe\\xdb\\xbaPoh2\\x8e/\\xa7;=\\xb5\\x7f\\xc4\\x15(R\\xf2 {\\x8f\\xa8\\xe2I\\xd8\\xb0\\x90\\x8a\\xf7j<\\x10\\xcd\\xa0m@?\\xc0\" jwe . wrapped_cek # b'8\\xa3\\x9a\\xc0:5\\xde\\x04i\\xda\\x88\\xda\\x1d^\\xcb\\x16\\x96\\\\\\x81^\\xd3\\xe85Y)<\\x8a8\\xc4\\xd8Rb\\xa8L%IF\\x07$\\x08\\xbfd\\x88\\xc4\\xf4\\xdc\\x91\\x9e\\x8a\\x9b\\x04u\\x8d\\xe6\\xc7\\xf7\\xad-\\xb6\\xd6J\\xb1k\\xd3\\x99\\x0b\\xcd\\xc4\\xab\\xe2\\xa2\\x80\\xab\\xb6\\r\\xed\\xefc\\xc1\\x04[\\xdby\\xdfk\\xa7=w\\xe4\\xad\\x9c\\x89\\x86\\xc8P\\xdbJ\\xfd8\\xb9[\\xb1\"\\x9eY\\x9a\\xcd`7\\x12\\x8a+`\\xda\\xd7\\x80|K\\x8a\\xf3U\\x19mu\\x8c\\x1a\\x9b\\xf9C\\xa7\\x95\\xe7d\\x06)A\\xd6\\xfb\\xe8WH(\\xb6\\x95\\x9a\\xa8\\x1f\\xc1~\\xd7Y\\x1co\\xdb}\\xb6\\x8b\\xeb\\xc3\\xc5\\x17\\xea7:?\\xb4D\\xca\\xce\\x95K\\xcd\\xf8\\xb0C\\'\\xb2<b\\xc1 \\xeez`\\x9e\\xde9\\xb7o\\xd27\\xbc\\xd7\\xce\\xb4\\xa6\\x96\\xa6j\\xfa7\\xe5H(E\\xd6\\xd8h\\x17(\\x87\\xd4\\x1c\\x7f)P\\xaf\\xae\\xa8s\\xab\\xc5Yt\\\\g\\xf6S\\xd8\\xb6\\xb0T%\\x93#-\\xdb\\xacc\\xe2\\xe9I%|*H1\\xf2#\\x7f\\xb8\\x86ur\\x87\\xce' jwe . initialization_vector # b'\\xe3\\xc5u\\xfc\\x02\\xdb\\xe9D\\xb4\\xe1M\\xdb' jwe . authentication_tag # b'\\\\Ph1\\x85\\x19\\xa1\\xd7\\xade\\xdb\\xd3\\x88[\\xd2\\x91' private_jwk = { \"kty\" : \"RSA\" , \"n\" : \"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW\" \"cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S\" \"psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a\" \"sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS\" \"tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj\" \"YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\" , \"e\" : \"AQAB\" , \"d\" : \"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N\" \"WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9\" \"3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk\" \"qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl\" \"t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd\" \"VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\" , \"p\" : \"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-\" \"SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf\" \"fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\" , \"q\" : \"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm\" \"UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX\" \"IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\" , \"dp\" : \"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL\" \"hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827\" \"rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\" , \"dq\" : \"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj\" \"ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB\" \"UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\" , \"qi\" : \"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7\" \"AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3\" \"eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\" , } payload = jwe . decrypt ( private_jwk ) assert payload == b \"The true sign of intelligence is not knowledge but imagination.\" # you can also decrypt only the CEK (returned as SymmetricJwk instance): cek = jwe . unwrap_cek ( private_jwk ) assert cek == { \"kty\" : \"oct\" , \"k\" : \"saH0gFSP4XM_tAP_a5rU9ooHbltwLiJpL4LLLnrqQPw\" } Encrypting JWE tokens \u00b6 To encrypt a JWE token, use JweCompact.encrypt() with the plaintext, public key, key management alg (alg) and encryption alg (enc): 1 2 3 4 5 6 7 8 9 from jwskate import JweCompact , Jwk plaintext = b \"Encrypting JWE is easy!\" private_jwk = Jwk . generate_for_kty ( \"EC\" ) public_jwk = private_jwk . public_jwk () jwe = JweCompact . encrypt ( plaintext , public_jwk , alg = \"ECDH-ES+A128KW\" , enc = \"A128GCM\" ) str ( jwe ) # 'eyJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTI1NiIsIngiOiI3a2VIdGxXdnVQQWVfYzR3d1hsNXFBZENHYzNKSk9KX0c5WThWU29Cc0tBIiwieSI6ImlyVFpRVzFlckZUSGd4WG1nUVdpcTVBYXdNOXNtamxybE96X2RTMmpld1kifSwiYWxnIjoiRUNESC1FUytBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.s7iUWLT2TG_kRnxuRvMxL5lY1oVRRVlI.kQaT5CM0HYfdwQ9H.49Trq2lpEtOEk8u_HP20TuJ80xpkqK8.RsQMBzvLj5i9bk4eew21gg' JWT \u00b6 JWT tokens are JWS tokens which contain a JSON object as payload. Some attributes of this JSON object are standardised to represent the token issuer, audience, and lifetime. The Jwt class and its subclasses represent a syntactically valid Jwt token. It then allows to access the JWT content and verify its signature. Note that a JWT token can optionally be encrypted. In that case, the signed JWT content will be the plaintext of a JWE token. Decrypting that JWE can then be achieved with the JweCompact class, then this plaintext can be manipulated with the Jwt class. Parsing JWT tokens \u00b6 To parse an existing JWT token, simply provide its value to Jwt . It exposes all the JWT attributes, and a verify_signature() method just like JwsCompact() . Claims can be accessed either: with the claims attribute, which is a dict of the parsed JSON content with subscription: jwt['attribute'] does a key lookup inside the claims dict, just like jwt.claims['attribute'] with attribute access: jwt.attribute does the same as jwt.claims['attribute'] . Note that attribute names containing special characters are not accessible this way due to Python syntax for attribute names. for 'special' standardised attributes, with their special attribute, which will parse and validate the attribute value. Example: jwt.expires_at returns a datetime initialised from the exp claim. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from jwskate import Jwt jwt = Jwt ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\" ) jwt . claims # {'acr': '2', # 'amr': ['pwd', 'otp'], # 'aud': 'client_id', # 'auth_time': 1629204560, # 'exp': 1629204620, # 'iat': 1629204560, # 'iss': 'https://myas.local', # 'nonce': 'nonce', # 'sub': '123456'} # example claim access via subscription: jwt [ \"acr\" ] # '2' # example claim access via attribute: jwt . sub # '123456' # example special claim access: jwt . expires_at # datetime.datetime(2021, 8, 17, 12, 50, 20, tzinfo=datetime.timezone.utc) # the raw 'exp' value is still accessible with the other means: jwt [ \"exp\" ] == jwt . exp == 1629204620 # True # other special attributes: jwt . audiences # always return a list # ['client_id'] jwt . issued_at # datetime.datetime(2021, 8, 17, 12, 49, 20, tzinfo=datetime.timezone.utc) jwt . not_before # this would be a datetime if there was a valid 'nbf' claim in the token None jwt . subject # makes sure that it is a string # '123456' jwt . issuer # makes sure that it is a string # 'https://myas.local' jwt . headers # {'alg': 'RS256', 'kid': 'my_key'} jwt . signature # b\"\\xc1G\\xe33(\\xe59'olQ\\x85?\\xc3\\xbc\\xc0g\\r\\x04\\xae\\xda\\x91\\xec\\x8eP\\x13/a\\xc3YrQT\\xb6\\x89\\x0e\\xcb\\x18KP\\xfcf\\xa3T\\xc7\\xa3P\\xd5\\xd4\\x11\\xd4U\\xde\\x80Y\\xf7\\x8aR|\\x93\\xc6_\\xfc\\xf8m\\xc4\\xfd\\xafn\\xe7\\x02_\\x0f'\\xe0\\x84\\xf0\\xe1\\ng\\xe4`\\x04o\\xa9\\t\\xe7W\\xfd\\xda!\\xb7\\xd3}@B\\xe1\\xfd\\x1b\\x1e\\xbd<w\\xfa\\xb4|@\\xfc\\xf1\\x12\\xee\\xef\\xbc\\x04H\\x83\\xc2V\\xa4\\x18\\xcbf\\xe4\\xe0R\\xeeq\\xce\\xb7\\xc8`oh+$\\xab;ag\\xceCl\\x12XX\\xb9Q\\xf2\\xa0T\\x93\\xf3@\\xf1\\xb5\\x80M\\x81-\\x8f\\x04\\xeb\\xc6\\x86^\\xfa\\xe0>\\xbc\\x1e\\x8d\\xc1K\\xf5\\x87\\xc0\\xcaF\\xc0\\xc5\\xfb\\xd1\\xd2Tw\\x96]p\\x1e\\xa0oT[\\xbc\\xe0\\xc6\\x867)\\xb0\\xc8W7\\xa6\\xbcl\\xec\\xd9\\x1fN\\x800QE\\xa7\\xc1\\x05W\\x80\\x905z\\t\\xd6\\xdd0\\xd2C\\x98|\\xdc\\x8d\\xab\\x1e\\xe65\\xfa,O\\xb7`,\\xbbs\\xb0\\x0c3[\\x96D)\\xca\\xdd\\xff\\x9a\\xcc\" # verifying the signature: assert jwt . verify_signature ( { \"kty\" : \"RSA\" , \"kid\" : \"my_key\" , \"alg\" : \"RS256\" , \"n\" : \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\" , \"e\" : \"AQAB\" , } ) # verifying expiration: assert jwt . is_expired () Validating JWT tokens \u00b6 To validate a JWT token, verifying the signature is usually not enough. You probably want to validate the issuer, audience, expiration date, and other claims. To make things easier, use SignedJwt.validate() . It raises exceptions if one of the check fails: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwt jwt = Jwt ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.\" \"eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\" ) jwk = { \"kty\" : \"RSA\" , \"kid\" : \"my_key\" , \"alg\" : \"RS256\" , \"n\" : \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\" , \"e\" : \"AQAB\" , } jwt . validate ( jwk , issuer = \"https://myas.local\" , audience = \"client_id\" ) # at the time you run this, it will probably raise a `jwskate.ExpiredJwt` exception Signing JWT tokens \u00b6 To sign a set of claims into a JWT, use Jwt.sign() . It takes the claims (as a dict), the signing key, and the signature alg to use (if the key doesn't have an 'alg' parameter). 1 2 3 4 5 6 7 8 from jwskate import Jwt , Jwk claims = { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" } jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) jwt = Jwt . sign ( claims , jwk , alg = \"ES256\" ) print ( jwt ) # eyJhbGciOiJFUzI1NiJ9.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.mqqXTljXQwNff0Sah88oFGBNWC9XpZxUj3WDa9-00UAyuEoL6cey-rHQNtmYgYgPRgI_HnWpRm5M4_a9qv9m0g JWT headers \u00b6 The default header will contain the signing algorithm identifier (alg) and the JWK Key Identifier (kid), if there was one in the used JWK. You can add additional headers by using the extra_headers parameter to Jwt.sign() : 1 2 3 4 5 6 7 8 9 10 from jwskate import Jwt , Jwk claims = { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" } jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) jwt = Jwt . sign ( claims , jwk , alg = \"ES256\" , extra_headers = { \"header1\" : \"value1\" }) print ( jwt ) # eyJoZWFkZXIxIjoidmFsdWUxIiwiYWxnIjoiRVMyNTYifQ.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.m0Bi8D6Rdi6HeH4J45JPSaeGPxjboAf_-efQ3mUAi6Gs0ipC0MXg9rd727IIINUsVfU0geUn7IwA1HjoTOsHvg print ( jwt . headers ) # {'header1': 'value1', 'alg': 'ES256'}","title":"usage"},{"location":"usage/#usage","text":"To use jwskate in a project, you can import all exposed objects from the root module: 1 from jwskate import *","title":"Usage"},{"location":"usage/#jwk","text":"","title":"JWK"},{"location":"usage/#loading-keys","text":"The Jwk class and its subclasses represent keys in JWK format. You can initialize a Jwk from: a dict representing the JWK content, already parsed from JSON: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) a string containing a JSON representation of the JWK: 1 2 3 4 5 6 7 8 from jwskate import Jwk jwk = Jwk ( '{\"kty\": \"EC\", \"crv\": \"P-256\",' 'x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",' 'y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",' 'd\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}' ) a cryptography key: 1 2 3 4 5 from jwskate import Jwk from cryptography.hazmat.primitives.asymmetric import ec key = ec . generate_private_key ( ec . SECP256R1 ) jwk = Jwk ( key ) a public or private key in PEM format, optionally protected by a password: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import Jwk public_jwk = Jwk . from_pem_key ( b \"\"\"-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsjtGIk8SxD+OEiBpP2/T JUAF0upwuKGMk6wH8Rwov88VvzJrVm2NCticTk5FUg+UG5r8JArrV4tJPRHQyvqK wF4NiksuvOjv3HyIf4oaOhZjT8hDne1Bfv+cFqZJ61Gk0MjANh/T5q9vxER/7TdU NHKpoRV+NVlKN5bEU/NQ5FQjVXicfswxh6Y6fl2PIFqT2CfjD+FkBPU1iT9qyJYH A38IRvwNtcitFgCeZwdGPoxiPPh1WHY8VxpUVBv/2JsUtrB/rAIbGqZoxAIWvijJ Pe9o1TY3VlOzk9ASZ1AeatvOir+iDVJ5OpKmLnzc46QgGPUsjIyo6Sje9dxpGtoG QQIDAQAB -----END PUBLIC KEY-----\"\"\" ) private_jwk = Jwk . from_pem_key ( b \"\"\"-----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAywYF71cKSo3xyi7/0S7N1blFCmBX4eZz0gXf+zyBfomuqhwr .... daBAqhoDEr4SoKju8pagw6lqm65XeARyWkxqFqAZbb2K3bWY3x9qZT6oubLrCDGD -----END RSA PRIVATE KEY-----\"\"\" , \"P@ssw0rd\" , )","title":"Loading keys"},{"location":"usage/#getting-key-parameters","text":"Once you have a Jwk instance, you can get its parameters either with subscription or attribute access: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert jwk . kty == \"EC\" assert jwk . crv == \"P-256\" assert jwk . x == \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" assert jwk [ \"x\" ] == jwk . x Those will return the exact (usually base64url-encoded) value exactly as expressed in the JWK. You can also get the real, decoded parameters with some special attributes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert ( jwk . x_coordinate == 41091394722340406951651919287101979028566994134304719828008599584440827098914 ) assert ( jwk . y_coordinate == 5099336126642036233987555101153084413345413137896124327269101893088581300336 ) assert ( jwk . ecc_private_key == 8342345011805978907621665437908035545366143771247820774310445528411160853919 ) The available special attributes vary depending on the key type.","title":"Getting key parameters"},{"location":"usage/#generating-keys","text":"You can generate a Jwk with the class method Jwk.generate_for_kty() . It needs the key type as parameter, and type-specific parameters: 1 2 3 4 5 from jwskate import Jwk ec_jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) rsa_jwk = Jwk . generate_for_kty ( \"RSA\" , key_size = 4096 ) okp_jwk = Jwk . generate_for_kty ( \"OKP\" , crv = \"Ed25519\" ) You can include additional parameters such as \"use\" or \"key_ops\", or custom parameters which will be included in the generated key: 1 2 3 4 5 from jwskate import Jwk jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" , use = \"sig\" ) assert jwk . use == \"sig\"","title":"Generating keys"},{"location":"usage/#private-and-public-keys","text":"You can check if a key is public or private with the is_private property: 1 2 3 4 5 6 7 8 9 10 11 12 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert jwk . is_private You can get the public key that match a given private key with the public_jwk() method. It returns a new Jwk instance that does not contain the private parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) public_jwk = jwk . public_jwk () assert \"d\" not in public_jwk # \"d\" would contain the private key assert not public_jwk . is_private Note that Symmetric keys are always considered private, so calling .public_jwk() will raise a ValueError .","title":"Private and Public Keys"},{"location":"usage/#dumping-keys","text":"","title":"Dumping keys"},{"location":"usage/#to-json","text":"Jwk instances are dicts, so you can serialize it to JSON in the usual ways (with Python json module or any other means). You can also use the to_json() convenience method to serialize a Jwk: 1 2 3 4 5 6 7 8 9 10 11 12 13 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) jwk . to_json () # '{\"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\", \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\", \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}'","title":"to JSON"},{"location":"usage/#to-cryptography-keys","text":"You can access the cryptography_key attribute to get a cryptography key instance that matches a Jwk : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) cryptography_key = jwk . cryptography_key assert ( str ( cryptography_key . __class__ ) == \"<class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePrivateKey'>\" )","title":"to cryptography keys"},{"location":"usage/#signing-and-verifying-data","text":"You can sign arbitrary data, then validate the signature with a Jwk instance, using the sign() and verify() methods: 1 2 3 4 5 6 7 8 9 10 11 12 from jwskate import Jwk data = b \"Signing is easy!\" jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) signature = jwk . sign ( data , alg = \"ES256\" ) assert jwk . verify ( data , signature , alg = \"ES256\" ) assert not jwk . verify ( data , b \"this_is_a_wrong_signature_value_12345678012345678012345678012345\" , alg = \"ES256\" , )","title":"Signing and verifying data"},{"location":"usage/#encrypting-and-decrypting-data","text":"Encryption or decryption require a symmetric key, which translates to an instance of SymmetricJwk , with kty='oct' . You can encrypt and decrypt arbitrary data with a Jwk instance, using the encrypt() and decrypt() methods: 1 2 3 4 5 6 7 8 9 from jwskate import Jwk data = b \"Encryption is easy!\" alg = \"A256GCM\" jwk = Jwk . generate_for_kty ( \"oct\" , key_size = 256 , alg = alg ) ciphertext , iv , tag = jwk . encrypt ( data ) assert jwk . decrypt ( ciphertext , iv = iv , tag = tag ) == data","title":"Encrypting and Decrypting data"},{"location":"usage/#authenticated-encryption","text":"You can include Additional Authenticated Data ( aad ) in the encrypt() and decrypt() operations: 1 2 3 4 5 6 7 8 9 10 from jwskate import Jwk data = b \"Authenticated Encryption is easy!\" alg = \"A256GCM\" aad = b \"This is my auth tag\" jwk = Jwk . generate_for_kty ( \"oct\" , key_size = 256 , alg = alg ) ciphertext , iv , tag = jwk . encrypt ( data , aad = aad ) assert jwk . decrypt ( ciphertext , iv = iv , tag = tag , aad = aad ) == data","title":"Authenticated encryption"},{"location":"usage/#key-management","text":"Encrypting/decrypting arbitrary data requires a symmetric key. But it is possible to encrypt/decrypt or otherwise derive symmetric keys from asymmetric keys, using Key Management algorithms. Some of those Key Management algorithms rely on key wrapping, where a randomly-generated symmetric key (called a Content Encryption Key or CEK) is itself asymmetrically encrypted. It is also possible to use a symmetric key to \"wrap\" the CEK. Other algorithms rely on Diffie-Hellman, where the CEK is derived from a pair of keys, one private, the other public. You can use the methods sender_key() and receiver_key() to handle all the key management stuff for you. For sender_key() , which the message sender will use get a CEK, you just need to specify which encryption algorithm you will use with the CEK, and the key management algorithm you want to wrap or derive that CEK. It will return a tuple (plaintext_message, encrypted_cek, extra_headers) , with plaintext_message being the generated CEK (as an instance of SymmetricJwk ), encrypted_cek is the wrapped CEK value (which can be empty for Diffie-Hellman based algorithms), and extra_headers a dict of extra headers that are required for the key management algorithm (for example, epk for ECDH-ES based algorithms), You can use cleartext_cek to encrypt your message with a given Encryption algorithm. You must then send encrypted_cek and extra_headers to your recipient, along with the encrypted message, and both Key Management and Encryption algorithms identifiers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from jwskate import Jwk plaintext_message = b \"Key Management is easy!\" recipient_private_jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) # {'kty': 'EC', # 'crv': 'P-256', # 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE', # 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4', # 'd': 'Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E'} recipient_public_jwk = recipient_private_jwk . public_jwk () # {'kty': 'EC', # 'crv': 'P-256', # 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE', # 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4'} enc_alg = \"A256GCM\" km_alg = \"ECDH-ES\" plaintext_cek , encrypted_cek , extra_headers = recipient_public_jwk . sender_key ( enc = enc_alg , alg = km_alg ) # plaintext_cek: {'kty': 'oct', 'k': 'iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc'} # encrypted_cek: b'' # extra_headers: {'epk': {'kty': 'EC', # 'crv': 'P-256', # 'x': '_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg', # 'y': 'nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs'}} encrypted_message , iv , tag = plaintext_cek . encrypt ( plaintext_message , alg = enc_alg ) # encrypted_message: b'\\xb5J\\x16\\x08\\x82Xp\\x0f,\\x0eu\\xe5\\xd6\\xa6y\\xe0J\\xae\\xcbu\\xf8B\\xbd' # iv: b'K\"H\\xf3@\\tt\\\\\\xc78\\xc2D' # tag: b'\\xc4\\xee\\xcf`\\xfa\\\\\\x8e\\x9dn\\xc4>D\\xd8\\x1d\\x8c\\x1a' On recipient side, in order to decrypt the message, you will need to obtain the same symmetric CEK that was used to encrypt the message. That is done with recipient_key() . You need to provide it with the encrypted_cek received from the sender (possibly empty for Diffie-Hellman based algorithms), the Key Management algorithm that is used to wrap the CEK, the Encryption algorithm that is used to encrypt/decrypt the message, and the eventual extra headers depending on the Key Management algorithm. You can then use that CEK to decrypt the received message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from jwskate import Jwk # reusing the variables from above enc_alg = \"A256GCM\" km_alg = \"ECDH-ES\" plaintext_cek = { \"kty\" : \"oct\" , \"k\" : \"iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc\" } encrypted_cek = b \"\" extra_headers = { \"epk\" : { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg\" , \"y\" : \"nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs\" , } } recipient_private_jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE\" , \"y\" : \"Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4\" , \"d\" : \"Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E\" , } ) encrypted_message = b \" \\xb5 J \\x16\\x08\\x82 Xp \\x0f , \\x0e u \\xe5\\xd6\\xa6 y \\xe0 J \\xae\\xcb u \\xf8 B \\xbd \" iv = b 'K\"H \\xf3 @ \\t t \\\\\\xc7 8 \\xc2 D' tag = b \" \\xc4\\xee\\xcf ` \\xfa\\\\\\x8e\\x9d n \\xc4 >D \\xd8\\x1d\\x8c\\x1a \" # obtain the same CEK than the sender, based on our private key, and public data provided by sender cek = recipient_private_jwk . recipient_key ( encrypted_cek , enc = \"A256GCM\" , alg = \"ECDH-ES\" , ** extra_headers ) # and decrypt the message with that CEK (and the IV, Auth Tag and encryption alg identifier provided by sender) plaintext_message = cek . decrypt ( encrypted_message , iv = iv , tag = tag , alg = enc_alg ) assert plaintext_message == b \"Key Management is easy!\"","title":"Key Management"},{"location":"usage/#jws","text":"The JwsCompact class represents a syntactically valid JWS token in compact representation.","title":"JWS"},{"location":"usage/#parsing-tokens","text":"To parse an existing Jws token and access its content (without validating the signature yet), you simply need to create an instance of JwsCompact with the serialized token as value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import JwsCompact jws = JwsCompact ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\" \"SGVsbG8gV29ybGQh.\" \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\" \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\" \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\" \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\" \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\" ) jws . payload # b'Hello World!' jws . headers # {'alg': 'RS256', 'kid': 'JWK-ABCD'} jws . alg # 'RS256' jws . kid # 'JWK-ABCD' jws . signature # '\\xd5\\xeb\\x9cK\\xd6ZNp\\t\\xc9\\xf5M\\x87\\x12\\xc9\\xfe\\x98E7Z\\xde\\xc6m%\\xfar\\x17X\\x18\\xd4\"gR\\xdb\\xdc\\xf9\\xe4\\x1b\\xb1\\x1f\\xa3c\\x1a\\x99mIr\\xab\\x81\\x8cXC\\x1a\\x86\\n\\xc1\\x88\\xc6T\\x95\\xa0\\x81!)Wa\\x13U]\\xf4\\xd3\\xc9G,;#\\x8c\\xc1E\\xdc\\x15\\xbd\\xca\\x8cD\\xe0\\xcc\\xa8<B\\x8a\\xa6\\xc3C\\xfe[#\\x98\\xc0\\xa8Q\\t\\x00P\\x97f\\x8d\\x93\\xe2,e\\xc6\\xcf\\xb6y{fHJz\\xbd~uN\\ri\\xbe\\'\\x0c\\xe7\\xf6+)\\xf4\\xbc&}\\xe5\\xb7\\xdcV\\xe5\\x16\\x8d)B}\\xe0\\xa5K\\x96\\x8b\\xff\"w\\x05\\xb2\\x1d\\x9b\\x83\\x98\\xdd\\xa3T\\x84\\xa1Le\\x07b\\x08\\xd0\\x97e|+ \\x1e\\x88Iw\\x9f\\x1eZ1S\\xa1\\xe3m\\x1fW\\xa2\\\\g\\x998v\\xe50\\xbc\\xf9k\\x90!c\\xc8\\xd8\\xdc.6\\xe3\\xeb`\\x82>\\x81+\\xa7\\xf0\\xa5\\xe7]tP\\xf7\\x9a\\xd1EL\\xdc:)?\\xb6\\x12\\x04\\xde:Q\\x00\\xd3\\xdaP\\xa9na\\xa2\\xc0\\xa3\\xd9\\xdb\\x80\\x95\\x1f\\x85A'","title":"Parsing tokens"},{"location":"usage/#verifying-tokens","text":"To verify a Jws signature, you need the matching public key: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import JwsCompact jws = JwsCompact ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\" \"SGVsbG8gV29ybGQh.\" \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\" \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\" \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\" \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\" \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\" ) public_jwk = { \"kty\" : \"RSA\" , \"kid\" : \"JWK-ABCD\" , \"alg\" : \"RS256\" , \"n\" : \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\" , \"e\" : \"AQAB\" , } if jws . verify_signature ( public_jwk ): print ( \"Signature is verified.\" ) else : print ( \"Signature verification failed!\" )","title":"Verifying tokens"},{"location":"usage/#signing-tokens","text":"To sign a Jws, you need its payload, the private key and alg to sign with, and provide those to JwsCompact.sign() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from jwskate import JwsCompact payload = b \"Hello World!\" private_jwk = { \"kty\" : \"RSA\" , \"kid\" : \"JWK-ABCD\" , \"alg\" : \"RS256\" , \"n\" : \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\" , \"e\" : \"AQAB\" , \"d\" : \"XCtpsCRQ1DBBm51yqdQ88C82lEjW30Xp0cy6iVEzBKZhmPGmI1PY8gnXWQ5PMlK3sLTM6yypDNvORoNlo6YXWJYA7LGlXEIczj2DOsJmF8T9-OEwGZixvNFDcmYnwWnlA6N_CQKmR0ziQr9ZAzZMCU5Tvr7f8cRZKdAALQEwk5FYpLnEbXOBduJtY9x2kddJSCJwRaEJhx0fG_pJAO3yLUZBY20dZK8UrxDoCgB9eiZV3N4uWGt367r1MDdaxGY6l6bC1HZCHkttBuTxfSUMCgooZevdU6ThQNpFrwZNY3KoP-OksEdqMs-neecfk_AQREkubDW2VPNFnaVEa38BKQ\" , \"p\" : \"8QNZGwUINpkuZi8l2ZfQzKVeOeNe3aQ7UW0wperM-63DFEJDRO1UyNC1n6yeo8_RxPZKSTlr6xZDoilQq23mopeF6O0ZmYz6E2VWJuma65V-A7tB-6xjqUXPlSkCNA6Ia8kMeCmNpKs0r0ijTBf_2y2GSsNH4EcP7XzcDEeJIh0\" , \"q\" : \"58nWgg-qRorRddwKM7qhLxJnEDsnCiYhbKJrP78OfBZ-839bNRvL5D5sfjJqxcKMQidgpYZVvVNL8oDEywcC5T7kKW0HK1JUdYiX9DuI40Mv9WzXQ8B8FBjp5wV4IX6_0KgyIiyoUiKpVHBvO0YFPUYuk0Ns4H9yEws93RWwhSc\" , \"dp\" : \"zFsLZcaphSnzVr9pd4urhqo9MBZjbMmBZnSQCE8ECe729ymMQlh-SFv3dHF4feuLsVcn-9iNceMJ6-jeNs1T_s89wxevWixYKrQFDa-MJW83T1CrDQvJ4VCJR69i5-Let43cXdLWACcO4AVWOQIsdpquQJw-SKPYlIUHS_4n_90\" , \"dq\" : \"fP79rNnhy3TlDBgDcG3-qjHUXo5nuTNi5wCXsaLInuZKw-k0OGmrBIUdYNizd744gRxXJCxTZGvdEwOaHJrFVvcZd7WSHiyh21g0CcNpSJVc8Y8mbyUIRJZC3RC3_egqbM2na4KFqvWCN0UC1wYloSuNxmCgAFj6HYb8b5NYxBU\" , \"qi\" : \"hxXfLYgwrfZBvZ27nrPsm6mLuoO-V2rKdOj3-YDJzf0gnVGBLl0DZbgydZ8WZmSLn2290mO_J8XY-Ss8PjLYbz3JXPDNLMJ-da3iEPKTvh6OfliM_dBxhaW8sq5afLMUR0H8NeabbWkfPz5h0W11CCBYxsyPC6CzniFYCYXfByU\" , } jws = JwsCompact . sign ( payload , jwk = private_jwk , alg = \"RS256\" ) str ( jws ) # 'eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.SGVsbG8gV29ybGQh.1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCsGIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixlxs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoUxlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedddFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ'","title":"Signing tokens"},{"location":"usage/#jwe","text":"The JweCompact class represents a syntactically valid JWE token.","title":"JWE"},{"location":"usage/#parsing-and-decrypting-jwe-tokens","text":"Provide the serialized token value to JweCompact , then use .deccrypt() with the private key to decrypt the token payload: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 from jwskate import JweCompact jwe = JweCompact ( \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\" \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\" \"ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\" \"Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\" \"mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\" \"1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\" \"6UklfCpIMfIjf7iGdXKHzg.\" \"48V1_ALb6US04U3b.\" \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\" \"SdiwkIr3ajwQzaBtQD_A.\" \"XFBoMYUZodetZdvTiFvSkQ\" ) # all 'raw' attributes are accessible: jwe . headers # {'alg': 'RSA-OAEP', 'enc': 'A256GCM'} jwe . alg # 'RSA-OAEP' jwe . enc # 'A256GCM' jwe . ciphertext # b\"\\xe5\\xec\\xa6\\xf15\\xbfs\\xc4\\xae+Im'z\\xe9`\\x8c\\xcex43\\xed0\\x0b\\xbe\\xdb\\xbaPoh2\\x8e/\\xa7;=\\xb5\\x7f\\xc4\\x15(R\\xf2 {\\x8f\\xa8\\xe2I\\xd8\\xb0\\x90\\x8a\\xf7j<\\x10\\xcd\\xa0m@?\\xc0\" jwe . wrapped_cek # b'8\\xa3\\x9a\\xc0:5\\xde\\x04i\\xda\\x88\\xda\\x1d^\\xcb\\x16\\x96\\\\\\x81^\\xd3\\xe85Y)<\\x8a8\\xc4\\xd8Rb\\xa8L%IF\\x07$\\x08\\xbfd\\x88\\xc4\\xf4\\xdc\\x91\\x9e\\x8a\\x9b\\x04u\\x8d\\xe6\\xc7\\xf7\\xad-\\xb6\\xd6J\\xb1k\\xd3\\x99\\x0b\\xcd\\xc4\\xab\\xe2\\xa2\\x80\\xab\\xb6\\r\\xed\\xefc\\xc1\\x04[\\xdby\\xdfk\\xa7=w\\xe4\\xad\\x9c\\x89\\x86\\xc8P\\xdbJ\\xfd8\\xb9[\\xb1\"\\x9eY\\x9a\\xcd`7\\x12\\x8a+`\\xda\\xd7\\x80|K\\x8a\\xf3U\\x19mu\\x8c\\x1a\\x9b\\xf9C\\xa7\\x95\\xe7d\\x06)A\\xd6\\xfb\\xe8WH(\\xb6\\x95\\x9a\\xa8\\x1f\\xc1~\\xd7Y\\x1co\\xdb}\\xb6\\x8b\\xeb\\xc3\\xc5\\x17\\xea7:?\\xb4D\\xca\\xce\\x95K\\xcd\\xf8\\xb0C\\'\\xb2<b\\xc1 \\xeez`\\x9e\\xde9\\xb7o\\xd27\\xbc\\xd7\\xce\\xb4\\xa6\\x96\\xa6j\\xfa7\\xe5H(E\\xd6\\xd8h\\x17(\\x87\\xd4\\x1c\\x7f)P\\xaf\\xae\\xa8s\\xab\\xc5Yt\\\\g\\xf6S\\xd8\\xb6\\xb0T%\\x93#-\\xdb\\xacc\\xe2\\xe9I%|*H1\\xf2#\\x7f\\xb8\\x86ur\\x87\\xce' jwe . initialization_vector # b'\\xe3\\xc5u\\xfc\\x02\\xdb\\xe9D\\xb4\\xe1M\\xdb' jwe . authentication_tag # b'\\\\Ph1\\x85\\x19\\xa1\\xd7\\xade\\xdb\\xd3\\x88[\\xd2\\x91' private_jwk = { \"kty\" : \"RSA\" , \"n\" : \"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW\" \"cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S\" \"psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a\" \"sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS\" \"tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj\" \"YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\" , \"e\" : \"AQAB\" , \"d\" : \"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N\" \"WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9\" \"3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk\" \"qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl\" \"t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd\" \"VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\" , \"p\" : \"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-\" \"SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf\" \"fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\" , \"q\" : \"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm\" \"UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX\" \"IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\" , \"dp\" : \"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL\" \"hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827\" \"rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\" , \"dq\" : \"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj\" \"ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB\" \"UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\" , \"qi\" : \"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7\" \"AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3\" \"eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\" , } payload = jwe . decrypt ( private_jwk ) assert payload == b \"The true sign of intelligence is not knowledge but imagination.\" # you can also decrypt only the CEK (returned as SymmetricJwk instance): cek = jwe . unwrap_cek ( private_jwk ) assert cek == { \"kty\" : \"oct\" , \"k\" : \"saH0gFSP4XM_tAP_a5rU9ooHbltwLiJpL4LLLnrqQPw\" }","title":"Parsing and decrypting JWE tokens"},{"location":"usage/#encrypting-jwe-tokens","text":"To encrypt a JWE token, use JweCompact.encrypt() with the plaintext, public key, key management alg (alg) and encryption alg (enc): 1 2 3 4 5 6 7 8 9 from jwskate import JweCompact , Jwk plaintext = b \"Encrypting JWE is easy!\" private_jwk = Jwk . generate_for_kty ( \"EC\" ) public_jwk = private_jwk . public_jwk () jwe = JweCompact . encrypt ( plaintext , public_jwk , alg = \"ECDH-ES+A128KW\" , enc = \"A128GCM\" ) str ( jwe ) # 'eyJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTI1NiIsIngiOiI3a2VIdGxXdnVQQWVfYzR3d1hsNXFBZENHYzNKSk9KX0c5WThWU29Cc0tBIiwieSI6ImlyVFpRVzFlckZUSGd4WG1nUVdpcTVBYXdNOXNtamxybE96X2RTMmpld1kifSwiYWxnIjoiRUNESC1FUytBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.s7iUWLT2TG_kRnxuRvMxL5lY1oVRRVlI.kQaT5CM0HYfdwQ9H.49Trq2lpEtOEk8u_HP20TuJ80xpkqK8.RsQMBzvLj5i9bk4eew21gg'","title":"Encrypting JWE tokens"},{"location":"usage/#jwt","text":"JWT tokens are JWS tokens which contain a JSON object as payload. Some attributes of this JSON object are standardised to represent the token issuer, audience, and lifetime. The Jwt class and its subclasses represent a syntactically valid Jwt token. It then allows to access the JWT content and verify its signature. Note that a JWT token can optionally be encrypted. In that case, the signed JWT content will be the plaintext of a JWE token. Decrypting that JWE can then be achieved with the JweCompact class, then this plaintext can be manipulated with the Jwt class.","title":"JWT"},{"location":"usage/#parsing-jwt-tokens","text":"To parse an existing JWT token, simply provide its value to Jwt . It exposes all the JWT attributes, and a verify_signature() method just like JwsCompact() . Claims can be accessed either: with the claims attribute, which is a dict of the parsed JSON content with subscription: jwt['attribute'] does a key lookup inside the claims dict, just like jwt.claims['attribute'] with attribute access: jwt.attribute does the same as jwt.claims['attribute'] . Note that attribute names containing special characters are not accessible this way due to Python syntax for attribute names. for 'special' standardised attributes, with their special attribute, which will parse and validate the attribute value. Example: jwt.expires_at returns a datetime initialised from the exp claim. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from jwskate import Jwt jwt = Jwt ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\" ) jwt . claims # {'acr': '2', # 'amr': ['pwd', 'otp'], # 'aud': 'client_id', # 'auth_time': 1629204560, # 'exp': 1629204620, # 'iat': 1629204560, # 'iss': 'https://myas.local', # 'nonce': 'nonce', # 'sub': '123456'} # example claim access via subscription: jwt [ \"acr\" ] # '2' # example claim access via attribute: jwt . sub # '123456' # example special claim access: jwt . expires_at # datetime.datetime(2021, 8, 17, 12, 50, 20, tzinfo=datetime.timezone.utc) # the raw 'exp' value is still accessible with the other means: jwt [ \"exp\" ] == jwt . exp == 1629204620 # True # other special attributes: jwt . audiences # always return a list # ['client_id'] jwt . issued_at # datetime.datetime(2021, 8, 17, 12, 49, 20, tzinfo=datetime.timezone.utc) jwt . not_before # this would be a datetime if there was a valid 'nbf' claim in the token None jwt . subject # makes sure that it is a string # '123456' jwt . issuer # makes sure that it is a string # 'https://myas.local' jwt . headers # {'alg': 'RS256', 'kid': 'my_key'} jwt . signature # b\"\\xc1G\\xe33(\\xe59'olQ\\x85?\\xc3\\xbc\\xc0g\\r\\x04\\xae\\xda\\x91\\xec\\x8eP\\x13/a\\xc3YrQT\\xb6\\x89\\x0e\\xcb\\x18KP\\xfcf\\xa3T\\xc7\\xa3P\\xd5\\xd4\\x11\\xd4U\\xde\\x80Y\\xf7\\x8aR|\\x93\\xc6_\\xfc\\xf8m\\xc4\\xfd\\xafn\\xe7\\x02_\\x0f'\\xe0\\x84\\xf0\\xe1\\ng\\xe4`\\x04o\\xa9\\t\\xe7W\\xfd\\xda!\\xb7\\xd3}@B\\xe1\\xfd\\x1b\\x1e\\xbd<w\\xfa\\xb4|@\\xfc\\xf1\\x12\\xee\\xef\\xbc\\x04H\\x83\\xc2V\\xa4\\x18\\xcbf\\xe4\\xe0R\\xeeq\\xce\\xb7\\xc8`oh+$\\xab;ag\\xceCl\\x12XX\\xb9Q\\xf2\\xa0T\\x93\\xf3@\\xf1\\xb5\\x80M\\x81-\\x8f\\x04\\xeb\\xc6\\x86^\\xfa\\xe0>\\xbc\\x1e\\x8d\\xc1K\\xf5\\x87\\xc0\\xcaF\\xc0\\xc5\\xfb\\xd1\\xd2Tw\\x96]p\\x1e\\xa0oT[\\xbc\\xe0\\xc6\\x867)\\xb0\\xc8W7\\xa6\\xbcl\\xec\\xd9\\x1fN\\x800QE\\xa7\\xc1\\x05W\\x80\\x905z\\t\\xd6\\xdd0\\xd2C\\x98|\\xdc\\x8d\\xab\\x1e\\xe65\\xfa,O\\xb7`,\\xbbs\\xb0\\x0c3[\\x96D)\\xca\\xdd\\xff\\x9a\\xcc\" # verifying the signature: assert jwt . verify_signature ( { \"kty\" : \"RSA\" , \"kid\" : \"my_key\" , \"alg\" : \"RS256\" , \"n\" : \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\" , \"e\" : \"AQAB\" , } ) # verifying expiration: assert jwt . is_expired ()","title":"Parsing JWT tokens"},{"location":"usage/#validating-jwt-tokens","text":"To validate a JWT token, verifying the signature is usually not enough. You probably want to validate the issuer, audience, expiration date, and other claims. To make things easier, use SignedJwt.validate() . It raises exceptions if one of the check fails: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwt jwt = Jwt ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.\" \"eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\" ) jwk = { \"kty\" : \"RSA\" , \"kid\" : \"my_key\" , \"alg\" : \"RS256\" , \"n\" : \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\" , \"e\" : \"AQAB\" , } jwt . validate ( jwk , issuer = \"https://myas.local\" , audience = \"client_id\" ) # at the time you run this, it will probably raise a `jwskate.ExpiredJwt` exception","title":"Validating JWT tokens"},{"location":"usage/#signing-jwt-tokens","text":"To sign a set of claims into a JWT, use Jwt.sign() . It takes the claims (as a dict), the signing key, and the signature alg to use (if the key doesn't have an 'alg' parameter). 1 2 3 4 5 6 7 8 from jwskate import Jwt , Jwk claims = { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" } jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) jwt = Jwt . sign ( claims , jwk , alg = \"ES256\" ) print ( jwt ) # eyJhbGciOiJFUzI1NiJ9.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.mqqXTljXQwNff0Sah88oFGBNWC9XpZxUj3WDa9-00UAyuEoL6cey-rHQNtmYgYgPRgI_HnWpRm5M4_a9qv9m0g","title":"Signing JWT tokens"},{"location":"usage/#jwt-headers","text":"The default header will contain the signing algorithm identifier (alg) and the JWK Key Identifier (kid), if there was one in the used JWK. You can add additional headers by using the extra_headers parameter to Jwt.sign() : 1 2 3 4 5 6 7 8 9 10 from jwskate import Jwt , Jwk claims = { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" } jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) jwt = Jwt . sign ( claims , jwk , alg = \"ES256\" , extra_headers = { \"header1\" : \"value1\" }) print ( jwt ) # eyJoZWFkZXIxIjoidmFsdWUxIiwiYWxnIjoiRVMyNTYifQ.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.m0Bi8D6Rdi6HeH4J45JPSaeGPxjboAf_-efQ3mUAi6Gs0ipC0MXg9rd727IIINUsVfU0geUn7IwA1HjoTOsHvg print ( jwt . headers ) # {'header1': 'value1', 'alg': 'ES256'}","title":"JWT headers"}]}