{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JwSkate \u00b6 A Pythonic implementation of the JOSE set of IETF specifications: Json Web Signature , Keys , Algorithms , Tokens and Encryption (RFC7515 to 7519), and their extensions ECDH Signatures (RFC8037), JWK Thumbprints (RFC7638), and JWK Thumbprint URI (RFC9278). Free software: MIT Documentation: https://guillp.github.io/jwskate/ A quick usage example, generating an RSA private key, signing some data, then validating that signature: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import Jwk # let's generate a random private key rsa_private_jwk = ( Jwk . generate_for_alg ( # generated key will automatically be RSA, based on the required 'alg' alg = \"RS256\" , key_size = 2048 ) . with_kid_thumbprint () # include an RFC7638 thumbprint as key id . with_usage_parameters () # include the appropriate 'use' and 'key_ops' parameters in the JWK, based on the 'alg' ) data = b \"Signing is easy!\" signature = rsa_private_jwk . sign ( data ) # extract the public key, and verify the signature with it rsa_public_jwk = rsa_private_jwk . public_jwk () assert rsa_public_jwk . verify ( data , signature ) # let's see what a Jwk looks like: assert isinstance ( rsa_private_jwk , dict ) # Jwk are dict print ( rsa_private_jwk ) The result of this print will look like this (with the random parts abbreviated to ... for display purposes only): 1 2 3 4 5 6 7 8 9 10 11 12 13 {'kty': 'RSA', 'n': '...', 'e': 'AQAB', 'd': '...', 'p': '...', 'q': '...', 'dp': '...', 'dq': '...', 'qi': '...', 'alg': 'RS256', 'kid': '...', 'use': 'sig', 'key_ops': ['sign']} Now let's sign a JWT containing arbitrary claims, this time using an EC key: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import Jwk , Jwt private_jwk = Jwk . generate_for_alg ( \"ES256\" , kid = \"my_key\" ) # let's specify a kid manually claims = { \"sub\" : \"some_sub\" , \"claim1\" : \"value1\" } jwt = Jwt . sign ( claims , private_jwk ) # that's it! we have a signed JWT assert jwt . claims == claims # claims can be accessed as a dict assert jwt . sub == \"some_sub\" # or individual claims can be accessed as attributes assert jwt [ \"claim1\" ] == \"value1\" # or as dict items assert jwt . alg == \"ES256\" # alg and kid headers are also accessible as attributes assert jwt . kid == private_jwk . kid assert jwt . verify_signature ( private_jwk . public_jwk ()) print ( jwt ) # eyJhbGciOiJFUzI1NiIsImtpZCI6Im15a2V5In0.eyJzdWIiOiJzb21lX3N1YiIsImNsYWltMSI6InZhbHVlMSJ9.C1KcDyDT8qXwUqcWzPKkQD7f6xai-gCgaRFMdKPe80Vk7XeYNa8ovuLwvdXgGW4ZZ_lL73QIyncY7tHGXUthag # This will output the full JWT compact representation. You can inspect it for example at <https://jwt.io> print ( jwt . headers ) # {'alg': 'ES256', 'kid': 'my_key'} Note above that the JWT headers are automatically generated with the appropriate values. Or let's sign a JWT with the standardised lifetime, subject, audience and ID claims: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk , JwtSigner private_jwk = Jwk . generate_for_alg ( \"ES256\" ) signer = JwtSigner ( issuer = \"https://myissuer.com\" , jwk = private_jwk ) jwt = signer . sign ( subject = \"some_sub\" , audience = \"some_aud\" , extra_claims = { \"custom_claim1\" : \"value1\" , \"custom_claim2\" : \"value2\" }, ) print ( jwt . claims ) The generated JWT claims will include the standardised claims: 1 2 3 4 5 6 7 8 9 {'custom_claim1': 'value1', 'custom_claim2': 'value2', 'iss': 'https://myissuer.com', 'aud': 'some_aud', 'sub': 'some_sub', 'iat': 1648823184, 'exp': 1648823244, 'jti': '3b400e27-c111-4013-84e0-714acd76bf3a' } Features \u00b6 Simple, Clean, Pythonic interface Convenience wrappers around cryptography for all algorithms described in JWA Json Web Keys (JWK) loading and generation Arbitrary data signature and verification using Json Web Keys Json Web Signatures (JWS) signing and verification Json Web Encryption (JWE) encryption and decryption Json Web Tokens (JWT) signing, verification and validation 100% type annotated nearly 100% code coverage Relies on cryptography for all cryptographic operations Relies on BinaPy for binary data manipulations Supported Token Types \u00b6 Token Type Support Json Web Signature (JWS) \u2611 Compact \u2611 JSON Flat \u2611 JSON General Json Web Encryption (JWE) \u2611 Compact \u2610 JSON Flat \u2610 JSON General Json Web Tokens (JWT) \u2611 Signed \u2611 Signed and Encrypted Supported Signature algorithms \u00b6 jwskate supports the following signature algorithms: Signature Alg Description Key Type Reference Note HS256 HMAC using SHA-256 oct RFC7518, Section 3.2 HS384 HMAC using SHA-384 oct RFC7518, Section 3.2 HS512 HMAC using SHA-512 oct RFC7518, Section 3.2 RS256 RSASSA-PKCS1-v1_5 using SHA-256 RSA RFC7518, Section 3.3 RS384 RSASSA-PKCS1-v1_5 using SHA-384 RSA RFC7518, Section 3.3 RS512 RSASSA-PKCS1-v1_5 using SHA-512 RSA RFC7518, Section 3.3 ES256 ECDSA using P-256 and SHA-256 EC RFC7518, Section 3.4 ES384 ECDSA using P-384 and SHA-384 EC RFC7518, Section 3.4 ES512 ECDSA using P-521 and SHA-512 EC RFC7518, Section 3.4 PS256 RSASSA-PSS using SHA-256 and MGF1 with SHA-256 RSA RFC7518, Section 3.5 PS384 RSASSA-PSS using SHA-384 and MGF1 with SHA-384 RSA RFC7518, Section 3.5 PS512 RSASSA-PSS using SHA-512 and MGF1 with SHA-512 RSA RFC7518, Section 3.5 EdDSA EdDSA signature algorithms OKP RFC8037, Section 3.1 ES256K ECDSA using secp256k1 curve and SHA-256 EC RFC8812, Section 3.2 HS1 HMAC using SHA-1 oct https://www.w3.org/TR/WebCryptoAPI Validation Only RS1 RSASSA-PKCS1-v1_5 with SHA-1 oct https://www.w3.org/TR/WebCryptoAPI Validation Only none No digital signature or MAC performed RFC7518, Section 3.6 Not usable by mistake Supported Key Management algorithms \u00b6 jwskate supports the following key management algorithms: Signature Alg Description Key Type Reference Note RSA1_5 RSAES-PKCS1-v1_5 RSA RFC7518, Section 4.2 Unwrap Only RSA-OAEP RSAES OAEP using default parameters RSA RFC7518, Section 4.3 RSA-OAEP-256 RSAES OAEP using SHA-256 and MGF1 with SHA-256 RSA RFC7518, Section 4.3 RSA-OAEP-384 RSA-OAEP using SHA-384 and MGF1 with SHA-384 RSA https://www.w3.org/TR/WebCryptoAPI RSA-OAEP-512 RSA-OAEP using SHA-512 and MGF1 with SHA-512 RSA https://www.w3.org/TR/WebCryptoAPI A128KW AES Key Wrap using 128-bit key oct RFC7518, Section 4.4 A192KW AES Key Wrap using 192-bit key oct RFC7518, Section 4.4 A256KW AES Key Wrap using 256-bit key oct RFC7518, Section 4.4 dir Direct use of a shared symmetric key oct RFC7518, Section 4.5 ECDH-ES ECDH-ES using Concat KDF EC RFC7518, Section 4.6 ECDH-ES+A128KW ECDH-ES using Concat KDF and \"A128KW\" wrapping EC RFC7518, Section 4.6 ECDH-ES+A192KW ECDH-ES using Concat KDF and \"A192KW\" wrapping EC RFC7518, Section 4.6 ECDH-ES+A256KW ECDH-ES using Concat KDF and \"A256KW\" wrapping EC RFC7518, Section 4.6 A128GCMKW Key wrapping with AES GCM using 128-bit key oct RFC7518, Section 4.7 A192GCMKW Key wrapping with AES GCM using 192-bit key oct RFC7518, Section 4.7 A256GCMKW Key wrapping with AES GCM using 256-bit key oct RFC7518, Section 4.7 PBES2-HS256+A128KW PBES2 with HMAC SHA-256 and \"A128KW\" wrapping password RFC7518, Section 4.8 PBES2-HS384+A192KW PBES2 with HMAC SHA-384 and \"A192KW\" wrapping password RFC7518, Section 4.8 PBES2-HS512+A256KW PBES2 with HMAC SHA-512 and \"A256KW\" wrapping password RFC7518, Section 4.8 Supported Encryption algorithms \u00b6 jwskate supports the following encryption algorithms: Signature Alg Description Reference A128CBC-HS256 AES_128_CBC_HMAC_SHA_256 authenticated encryption algorithm RFC7518, Section 5.2.3 A192CBC-HS384 AES_192_CBC_HMAC_SHA_384 authenticated encryption algorithm RFC7518, Section 5.2.4 A256CBC-HS512 AES_256_CBC_HMAC_SHA_512 authenticated encryption algorithm RFC7518, Section 5.2.5 A128GCM AES GCM using 128-bit key RFC7518, Section 5.3 A192GCM AES GCM using 192-bit key RFC7518, Section 5.3 A256GCM AES GCM using 256-bit key RFC7518, Section 5.3 Supported Elliptic Curves \u00b6 jwskate supports the following Elliptic Curves: Curve Description Key Type Usage Reference P-256 P-256 Curve EC signature, encryption RFC7518, Section 6.2.1.1 P-384 P-384 Curve EC signature, encryption RFC7518, Section 6.2.1.1 P-521 P-521 Curve EC signature, encryption RFC7518, Section 6.2.1.1 Ed25519 Ed25519 signature algorithm key pairs OKP signature RFC8037, Section 3.1 Ed448 Ed448 signature algorithm key pairs OKP signature RFC8037, Section 3.1 X25519 X25519 function key pairs OKP encryption RFC8037, Section 3.2 X448 X448 function key pairs OKP encryption RFC8037, Section 3.2 secp256k1 SECG secp256k1 curve EC signature, encryption RFC8812, Section 3.1 Why a new lib ? \u00b6 There are already multiple modules implementing JOSE and Json Web Crypto related specifications in Python. However, I have been dissatisfied by all of them so far, so I decided to come up with my own module. PyJWT JWCrypto Python-JOSE AuthLib Not to say that those are bad libs (I actually use jwcrypto myself for jwskate unit tests), but they either don't support some important features, lack documentation, or generally have APIs that don't feel easy-enough, Pythonic-enough to use. Design \u00b6 JWK are dicts \u00b6 JWK are specified as JSON objects, which are parsed as dict in Python. The Jwk class in jwskate is actually a dict subclass, so you can use it exactly like you would use a dict: you can access its members, dump it back as JSON, etc. The same is true for Signed or Encrypted Json Web tokens in JSON format. JWA Wrappers \u00b6 You can use cryptography to do the cryptographic operations that are described in JWA , but since cryptography is a general purpose library, its usage is not straightforward and gives you plenty of options to carefully select and combine, leaving room for errors. It has also a quite inconsistent API to handle the different type of keys and algorithms. To work around this, jwskate comes with a set of consistent wrappers that implement the exact JWA specifications, with minimum risk of mistakes. Safe Signature Verification \u00b6 For every signature verification method in jwskate , the expected signature(s) algorithm(s) must be specified. That is to avoid a security flaw where your application accepts tokens with a weaker encryption scheme than what your security policy mandates; or even worse, where it accepts unsigned tokens, or tokens that are symmetrically signed with an improperly used public key, leaving your application exposed to exploitation by attackers. To specify which signature algorithms are accepted, each signature verification method accepts, in order of preference: an alg parameter which contains the expected algorithm, or an algs parameter which contains a list of acceptable algorithms the alg parameter from the signature verification Jwk , if present. This alg is the algorithm intended for use with that key. Note that you cannot use alg and algs at the same time. If your Jwk contains an alg parameter, and you provide an alg or algs which does not match that value, a Warning will be emitted. Credits \u00b6 All cryptographic operations are handled by cryptography .","title":"home"},{"location":"#jwskate","text":"A Pythonic implementation of the JOSE set of IETF specifications: Json Web Signature , Keys , Algorithms , Tokens and Encryption (RFC7515 to 7519), and their extensions ECDH Signatures (RFC8037), JWK Thumbprints (RFC7638), and JWK Thumbprint URI (RFC9278). Free software: MIT Documentation: https://guillp.github.io/jwskate/ A quick usage example, generating an RSA private key, signing some data, then validating that signature: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import Jwk # let's generate a random private key rsa_private_jwk = ( Jwk . generate_for_alg ( # generated key will automatically be RSA, based on the required 'alg' alg = \"RS256\" , key_size = 2048 ) . with_kid_thumbprint () # include an RFC7638 thumbprint as key id . with_usage_parameters () # include the appropriate 'use' and 'key_ops' parameters in the JWK, based on the 'alg' ) data = b \"Signing is easy!\" signature = rsa_private_jwk . sign ( data ) # extract the public key, and verify the signature with it rsa_public_jwk = rsa_private_jwk . public_jwk () assert rsa_public_jwk . verify ( data , signature ) # let's see what a Jwk looks like: assert isinstance ( rsa_private_jwk , dict ) # Jwk are dict print ( rsa_private_jwk ) The result of this print will look like this (with the random parts abbreviated to ... for display purposes only): 1 2 3 4 5 6 7 8 9 10 11 12 13 {'kty': 'RSA', 'n': '...', 'e': 'AQAB', 'd': '...', 'p': '...', 'q': '...', 'dp': '...', 'dq': '...', 'qi': '...', 'alg': 'RS256', 'kid': '...', 'use': 'sig', 'key_ops': ['sign']} Now let's sign a JWT containing arbitrary claims, this time using an EC key: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import Jwk , Jwt private_jwk = Jwk . generate_for_alg ( \"ES256\" , kid = \"my_key\" ) # let's specify a kid manually claims = { \"sub\" : \"some_sub\" , \"claim1\" : \"value1\" } jwt = Jwt . sign ( claims , private_jwk ) # that's it! we have a signed JWT assert jwt . claims == claims # claims can be accessed as a dict assert jwt . sub == \"some_sub\" # or individual claims can be accessed as attributes assert jwt [ \"claim1\" ] == \"value1\" # or as dict items assert jwt . alg == \"ES256\" # alg and kid headers are also accessible as attributes assert jwt . kid == private_jwk . kid assert jwt . verify_signature ( private_jwk . public_jwk ()) print ( jwt ) # eyJhbGciOiJFUzI1NiIsImtpZCI6Im15a2V5In0.eyJzdWIiOiJzb21lX3N1YiIsImNsYWltMSI6InZhbHVlMSJ9.C1KcDyDT8qXwUqcWzPKkQD7f6xai-gCgaRFMdKPe80Vk7XeYNa8ovuLwvdXgGW4ZZ_lL73QIyncY7tHGXUthag # This will output the full JWT compact representation. You can inspect it for example at <https://jwt.io> print ( jwt . headers ) # {'alg': 'ES256', 'kid': 'my_key'} Note above that the JWT headers are automatically generated with the appropriate values. Or let's sign a JWT with the standardised lifetime, subject, audience and ID claims: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk , JwtSigner private_jwk = Jwk . generate_for_alg ( \"ES256\" ) signer = JwtSigner ( issuer = \"https://myissuer.com\" , jwk = private_jwk ) jwt = signer . sign ( subject = \"some_sub\" , audience = \"some_aud\" , extra_claims = { \"custom_claim1\" : \"value1\" , \"custom_claim2\" : \"value2\" }, ) print ( jwt . claims ) The generated JWT claims will include the standardised claims: 1 2 3 4 5 6 7 8 9 {'custom_claim1': 'value1', 'custom_claim2': 'value2', 'iss': 'https://myissuer.com', 'aud': 'some_aud', 'sub': 'some_sub', 'iat': 1648823184, 'exp': 1648823244, 'jti': '3b400e27-c111-4013-84e0-714acd76bf3a' }","title":"JwSkate"},{"location":"#features","text":"Simple, Clean, Pythonic interface Convenience wrappers around cryptography for all algorithms described in JWA Json Web Keys (JWK) loading and generation Arbitrary data signature and verification using Json Web Keys Json Web Signatures (JWS) signing and verification Json Web Encryption (JWE) encryption and decryption Json Web Tokens (JWT) signing, verification and validation 100% type annotated nearly 100% code coverage Relies on cryptography for all cryptographic operations Relies on BinaPy for binary data manipulations","title":"Features"},{"location":"#supported-token-types","text":"Token Type Support Json Web Signature (JWS) \u2611 Compact \u2611 JSON Flat \u2611 JSON General Json Web Encryption (JWE) \u2611 Compact \u2610 JSON Flat \u2610 JSON General Json Web Tokens (JWT) \u2611 Signed \u2611 Signed and Encrypted","title":"Supported Token Types"},{"location":"#supported-signature-algorithms","text":"jwskate supports the following signature algorithms: Signature Alg Description Key Type Reference Note HS256 HMAC using SHA-256 oct RFC7518, Section 3.2 HS384 HMAC using SHA-384 oct RFC7518, Section 3.2 HS512 HMAC using SHA-512 oct RFC7518, Section 3.2 RS256 RSASSA-PKCS1-v1_5 using SHA-256 RSA RFC7518, Section 3.3 RS384 RSASSA-PKCS1-v1_5 using SHA-384 RSA RFC7518, Section 3.3 RS512 RSASSA-PKCS1-v1_5 using SHA-512 RSA RFC7518, Section 3.3 ES256 ECDSA using P-256 and SHA-256 EC RFC7518, Section 3.4 ES384 ECDSA using P-384 and SHA-384 EC RFC7518, Section 3.4 ES512 ECDSA using P-521 and SHA-512 EC RFC7518, Section 3.4 PS256 RSASSA-PSS using SHA-256 and MGF1 with SHA-256 RSA RFC7518, Section 3.5 PS384 RSASSA-PSS using SHA-384 and MGF1 with SHA-384 RSA RFC7518, Section 3.5 PS512 RSASSA-PSS using SHA-512 and MGF1 with SHA-512 RSA RFC7518, Section 3.5 EdDSA EdDSA signature algorithms OKP RFC8037, Section 3.1 ES256K ECDSA using secp256k1 curve and SHA-256 EC RFC8812, Section 3.2 HS1 HMAC using SHA-1 oct https://www.w3.org/TR/WebCryptoAPI Validation Only RS1 RSASSA-PKCS1-v1_5 with SHA-1 oct https://www.w3.org/TR/WebCryptoAPI Validation Only none No digital signature or MAC performed RFC7518, Section 3.6 Not usable by mistake","title":"Supported Signature algorithms"},{"location":"#supported-key-management-algorithms","text":"jwskate supports the following key management algorithms: Signature Alg Description Key Type Reference Note RSA1_5 RSAES-PKCS1-v1_5 RSA RFC7518, Section 4.2 Unwrap Only RSA-OAEP RSAES OAEP using default parameters RSA RFC7518, Section 4.3 RSA-OAEP-256 RSAES OAEP using SHA-256 and MGF1 with SHA-256 RSA RFC7518, Section 4.3 RSA-OAEP-384 RSA-OAEP using SHA-384 and MGF1 with SHA-384 RSA https://www.w3.org/TR/WebCryptoAPI RSA-OAEP-512 RSA-OAEP using SHA-512 and MGF1 with SHA-512 RSA https://www.w3.org/TR/WebCryptoAPI A128KW AES Key Wrap using 128-bit key oct RFC7518, Section 4.4 A192KW AES Key Wrap using 192-bit key oct RFC7518, Section 4.4 A256KW AES Key Wrap using 256-bit key oct RFC7518, Section 4.4 dir Direct use of a shared symmetric key oct RFC7518, Section 4.5 ECDH-ES ECDH-ES using Concat KDF EC RFC7518, Section 4.6 ECDH-ES+A128KW ECDH-ES using Concat KDF and \"A128KW\" wrapping EC RFC7518, Section 4.6 ECDH-ES+A192KW ECDH-ES using Concat KDF and \"A192KW\" wrapping EC RFC7518, Section 4.6 ECDH-ES+A256KW ECDH-ES using Concat KDF and \"A256KW\" wrapping EC RFC7518, Section 4.6 A128GCMKW Key wrapping with AES GCM using 128-bit key oct RFC7518, Section 4.7 A192GCMKW Key wrapping with AES GCM using 192-bit key oct RFC7518, Section 4.7 A256GCMKW Key wrapping with AES GCM using 256-bit key oct RFC7518, Section 4.7 PBES2-HS256+A128KW PBES2 with HMAC SHA-256 and \"A128KW\" wrapping password RFC7518, Section 4.8 PBES2-HS384+A192KW PBES2 with HMAC SHA-384 and \"A192KW\" wrapping password RFC7518, Section 4.8 PBES2-HS512+A256KW PBES2 with HMAC SHA-512 and \"A256KW\" wrapping password RFC7518, Section 4.8","title":"Supported Key Management algorithms"},{"location":"#supported-encryption-algorithms","text":"jwskate supports the following encryption algorithms: Signature Alg Description Reference A128CBC-HS256 AES_128_CBC_HMAC_SHA_256 authenticated encryption algorithm RFC7518, Section 5.2.3 A192CBC-HS384 AES_192_CBC_HMAC_SHA_384 authenticated encryption algorithm RFC7518, Section 5.2.4 A256CBC-HS512 AES_256_CBC_HMAC_SHA_512 authenticated encryption algorithm RFC7518, Section 5.2.5 A128GCM AES GCM using 128-bit key RFC7518, Section 5.3 A192GCM AES GCM using 192-bit key RFC7518, Section 5.3 A256GCM AES GCM using 256-bit key RFC7518, Section 5.3","title":"Supported Encryption algorithms"},{"location":"#supported-elliptic-curves","text":"jwskate supports the following Elliptic Curves: Curve Description Key Type Usage Reference P-256 P-256 Curve EC signature, encryption RFC7518, Section 6.2.1.1 P-384 P-384 Curve EC signature, encryption RFC7518, Section 6.2.1.1 P-521 P-521 Curve EC signature, encryption RFC7518, Section 6.2.1.1 Ed25519 Ed25519 signature algorithm key pairs OKP signature RFC8037, Section 3.1 Ed448 Ed448 signature algorithm key pairs OKP signature RFC8037, Section 3.1 X25519 X25519 function key pairs OKP encryption RFC8037, Section 3.2 X448 X448 function key pairs OKP encryption RFC8037, Section 3.2 secp256k1 SECG secp256k1 curve EC signature, encryption RFC8812, Section 3.1","title":"Supported Elliptic Curves"},{"location":"#why-a-new-lib-","text":"There are already multiple modules implementing JOSE and Json Web Crypto related specifications in Python. However, I have been dissatisfied by all of them so far, so I decided to come up with my own module. PyJWT JWCrypto Python-JOSE AuthLib Not to say that those are bad libs (I actually use jwcrypto myself for jwskate unit tests), but they either don't support some important features, lack documentation, or generally have APIs that don't feel easy-enough, Pythonic-enough to use.","title":"Why a new lib ?"},{"location":"#design","text":"","title":"Design"},{"location":"#jwk-are-dicts","text":"JWK are specified as JSON objects, which are parsed as dict in Python. The Jwk class in jwskate is actually a dict subclass, so you can use it exactly like you would use a dict: you can access its members, dump it back as JSON, etc. The same is true for Signed or Encrypted Json Web tokens in JSON format.","title":"JWK are dicts"},{"location":"#jwa-wrappers","text":"You can use cryptography to do the cryptographic operations that are described in JWA , but since cryptography is a general purpose library, its usage is not straightforward and gives you plenty of options to carefully select and combine, leaving room for errors. It has also a quite inconsistent API to handle the different type of keys and algorithms. To work around this, jwskate comes with a set of consistent wrappers that implement the exact JWA specifications, with minimum risk of mistakes.","title":"JWA Wrappers"},{"location":"#safe-signature-verification","text":"For every signature verification method in jwskate , the expected signature(s) algorithm(s) must be specified. That is to avoid a security flaw where your application accepts tokens with a weaker encryption scheme than what your security policy mandates; or even worse, where it accepts unsigned tokens, or tokens that are symmetrically signed with an improperly used public key, leaving your application exposed to exploitation by attackers. To specify which signature algorithms are accepted, each signature verification method accepts, in order of preference: an alg parameter which contains the expected algorithm, or an algs parameter which contains a list of acceptable algorithms the alg parameter from the signature verification Jwk , if present. This alg is the algorithm intended for use with that key. Note that you cannot use alg and algs at the same time. If your Jwk contains an alg parameter, and you provide an alg or algs which does not match that value, a Warning will be emitted.","title":"Safe Signature Verification"},{"location":"#credits","text":"All cryptographic operations are handled by cryptography .","title":"Credits"},{"location":"api/","text":"jwskate.jwk \u00b6 This module implements Json Web Key RFC7517 . UnsupportedAlg \u00b6 Bases: ValueError Raised when a unsupported alg is requested. Source code in jwskate/jwk/alg.py 9 10 class UnsupportedAlg ( ValueError ): \"\"\"Raised when a unsupported alg is requested.\"\"\" JwkSet \u00b6 Bases: BaseJsonDict A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. a dict from the parsed JSON object representing this JwkSet (in paramter jwks ) a list of Jwk (in parameter keys nothing, to initialize an empty JwkSet Parameters: Name Type Description Default jwks Optional [ Dict [ str , Any ]] a dict, containing the JwkSet, parsed as a JSON object. None keys Optional [ Iterable [ Union [ Jwk , Dict [ str , Any ]]]] a list of Jwk , that will be added to this JwkSet None Source code in jwskate/jwk/jwks.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class JwkSet ( BaseJsonDict ): \"\"\"A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`) - a list of `Jwk` (in parameter `keys` - nothing, to initialize an empty JwkSet Args: jwks: a dict, containing the JwkSet, parsed as a JSON object. keys: a list of `Jwk`, that will be added to this JwkSet \"\"\" def __init__ ( self , jwks : Optional [ Dict [ str , Any ]] = None , keys : Optional [ Iterable [ Union [ Jwk , Dict [ str , Any ]]]] = None , ): if jwks is None and keys is None : keys = [] if jwks is not None : keys = jwks . pop ( \"keys\" , []) super () . __init__ ( jwks ) # init the dict with all the dict content that is not keys else : super () . __init__ () if keys is not None : for jwk in keys : self . add_jwk ( jwk ) @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" jwk = to_jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass @property def is_private ( self ) -> bool : \"\"\"True if the JwkSet contains at least one private key. Returns: `True` if this JwkSet contains at least one private key \"\"\" return any ( key . is_private for key in self . jwks ) def public_jwks ( self ) -> \"JwkSet\" : \"\"\"Return another JwkSet with the public keys associated with the current keys. Returns: a public JwkSet \"\"\" return JwkSet ( keys = ( key . public_jwk () for key in self . jwks )) def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" if not alg and not algs : raise ValueError ( \"Please provide either 'alg' or 'algs' parameter\" ) # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) if algs is None : if alg is not None : algs = ( alg ,) else : algs = list ( algs ) for jwk in self . verification_keys (): for alg in algs or ( None ,): if alg in jwk . supported_signing_algorithms (): if jwk . verify ( data , signature , alg = alg ): return True # no key matches, so consider the signature invalid return False def verification_keys ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JWKS that a usable for signature verification. To be usable for signature verification, a key must: - be asymmetric - be public - have an \"alg\" parameter that is a signature alg Returns: a list of `Jwk` that are usable for signature verification \"\"\" return [ jwk for jwk in self . jwks if not jwk . is_symmetric and not jwk . is_private and jwk . use == \"sig\" ] def encryption_keys ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JWKS that are usable for encryption. To be usable for encryption, a key must: - be asymmetric - be public - have an \"alg\" parameter that is an encryption alg Returns: a list of `Jwk` that are suitable for encryption \"\"\" return [ jwk for jwk in self . jwks if not jwk . is_symmetric and not jwk . is_private and jwk . use == \"enc\" ] jwks property \u00b6 1 jwks () -> List [ Jwk ] Return the list of keys from this JwkSet, as Jwk instances. Returns: Type Description List [ Jwk ] a list of Jwk Source code in jwskate/jwk/jwks.py 46 47 48 49 50 51 52 53 @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) get_jwk_by_kid \u00b6 1 get_jwk_by_kid ( kid : str ) -> Jwk Return a Jwk from this JwkSet, based on its kid. Parameters: Name Type Description Default kid str the kid of the key to obtain required Returns: Type Description Jwk the key with the matching Key ID Raises: Type Description KeyError if no key matches Source code in jwskate/jwk/jwks.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) __len__ \u00b6 1 __len__ () -> int Return the number of Jwk in this JwkSet. Returns: Type Description int the number of keys Source code in jwskate/jwk/jwks.py 72 73 74 75 76 77 78 def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) add_jwk \u00b6 1 2 3 4 5 add_jwk ( jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str Add a Jwk in this JwkSet. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to add (either a Jwk instance, or a dict containing the Jwk parameters) required kid Optional [ str ] the kid to use, if jwk doesn't contain one None use Optional [ str ] the defined use for the added Jwk None Returns: Type Description str the kid from the added Jwk (it may be generated if no kid is provided) Source code in jwskate/jwk/jwks.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" jwk = to_jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid remove_jwk \u00b6 1 remove_jwk ( kid : str ) -> None Removes a Jwk from this JwkSet, based on a kid . Parameters: Name Type Description Default kid str the kid from the key to be removed. required Raises: Type Description KeyError if no key matches Source code in jwskate/jwk/jwks.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass is_private property \u00b6 1 is_private () -> bool True if the JwkSet contains at least one private key. Returns: Type Description bool True if this JwkSet contains at least one private key Source code in jwskate/jwk/jwks.py 127 128 129 130 131 132 133 134 @property def is_private ( self ) -> bool : \"\"\"True if the JwkSet contains at least one private key. Returns: `True` if this JwkSet contains at least one private key \"\"\" return any ( key . is_private for key in self . jwks ) public_jwks \u00b6 1 public_jwks () -> JwkSet Return another JwkSet with the public keys associated with the current keys. Returns: Type Description JwkSet a public JwkSet Source code in jwskate/jwk/jwks.py 136 137 138 139 140 141 142 def public_jwks ( self ) -> \"JwkSet\" : \"\"\"Return another JwkSet with the public keys associated with the current keys. Returns: a public JwkSet \"\"\" return JwkSet ( keys = ( key . public_jwk () for key in self . jwks )) verify \u00b6 1 2 3 4 5 6 7 verify ( data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a kid is provided, only the key with this kid will be tried. Otherwise, if an alg or several algs are provided, only keys that are compatible with the supplied alg will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Parameters: Name Type Description Default data bytes the signed data to verify required signature bytes the signature to verify against the signed data required alg Optional [ str ] alg to verify the signature, if there is only 1 None algs Optional [ Iterable [ str ]] list of allowed signature algs, if there are several None kid Optional [ str ] the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys None from this key set may be tried. Returns: Type Description bool True if the signature validates with any of the tried keys, False otherwise Source code in jwskate/jwk/jwks.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" if not alg and not algs : raise ValueError ( \"Please provide either 'alg' or 'algs' parameter\" ) # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) if algs is None : if alg is not None : algs = ( alg ,) else : algs = list ( algs ) for jwk in self . verification_keys (): for alg in algs or ( None ,): if alg in jwk . supported_signing_algorithms (): if jwk . verify ( data , signature , alg = alg ): return True # no key matches, so consider the signature invalid return False verification_keys \u00b6 1 verification_keys () -> List [ Jwk ] Return the list of keys from this JWKS that a usable for signature verification. To be usable for signature verification, a key must: - be asymmetric - be public - have an \"alg\" parameter that is a signature alg Returns: Type Description List [ Jwk ] a list of Jwk that are usable for signature verification Source code in jwskate/jwk/jwks.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def verification_keys ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JWKS that a usable for signature verification. To be usable for signature verification, a key must: - be asymmetric - be public - have an \"alg\" parameter that is a signature alg Returns: a list of `Jwk` that are usable for signature verification \"\"\" return [ jwk for jwk in self . jwks if not jwk . is_symmetric and not jwk . is_private and jwk . use == \"sig\" ] encryption_keys \u00b6 1 encryption_keys () -> List [ Jwk ] Return the list of keys from this JWKS that are usable for encryption. To be usable for encryption, a key must: - be asymmetric - be public - have an \"alg\" parameter that is an encryption alg Returns: Type Description List [ Jwk ] a list of Jwk that are suitable for encryption Source code in jwskate/jwk/jwks.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def encryption_keys ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JWKS that are usable for encryption. To be usable for encryption, a key must: - be asymmetric - be public - have an \"alg\" parameter that is an encryption alg Returns: a list of `Jwk` that are suitable for encryption \"\"\" return [ jwk for jwk in self . jwks if not jwk . is_symmetric and not jwk . is_private and jwk . use == \"enc\" ] ExpectedAlgRequired \u00b6 Bases: ValueError Raised when the expected signature alg(s) must be provided. Source code in jwskate/jwk/alg.py 13 14 class ExpectedAlgRequired ( ValueError ): \"\"\"Raised when the expected signature alg(s) must be provided.\"\"\" RSAJwk \u00b6 Bases: Jwk Represent a RSA Jwk, with kty=RSA . Source code in jwskate/jwk/rsa.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 class RSAJwk ( Jwk ): \"\"\"Represent a RSA Jwk, with `kty=RSA`.\"\"\" KTY = \"RSA\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = ( rsa . RSAPrivateKey ,) CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = ( rsa . RSAPublicKey ,) PARAMS = { \"n\" : JwkParameter ( \"Modulus\" , is_private = False , is_required = True , kind = \"b64u\" ), \"e\" : JwkParameter ( \"Exponent\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Exponent\" , is_private = True , is_required = True , kind = \"b64u\" ), \"p\" : JwkParameter ( \"First Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"q\" : JwkParameter ( \"Second Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dp\" : JwkParameter ( \"First Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dq\" : JwkParameter ( \"Second Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" , ), \"qi\" : JwkParameter ( \"First CRT Coefficient\" , is_private = True , is_required = False , kind = \"b64u\" ), \"oth\" : JwkParameter ( \"Other Primes Info\" , is_private = True , is_required = False , kind = \"unsupported\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ RS256 , RS384 , RS512 , PS256 , PS384 , PS512 ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ RsaEsPcks1v1_5 , RsaEsOaep , RsaEsOaepSha256 , RsaEsOaepSha384 , RsaEsOaepSha512 , ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: cryptography_key: a `cryptography` RSA key **kwargs: additional members to include in the Jwk Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( cryptography_key , rsa . RSAPrivateKey ): priv = cryptography_key . private_numbers () # type: ignore[attr-defined] pub = cryptography_key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( cryptography_key , rsa . RSAPublicKey ): pub = cryptography_key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) def _to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key () @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public `RsaJwk` from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initialize a private `RsaJwk` from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d ) . to ( \"b64u\" ) . ascii (), p = BinaPy . from_int ( p ) . to ( \"b64u\" ) . ascii () if p is not None else None , q = BinaPy . from_int ( q ) . to ( \"b64u\" ) . ascii () if q is not None else None , dp = BinaPy . from_int ( dp ) . to ( \"b64u\" ) . ascii () if dp is not None else None , dq = BinaPy . from_int ( dq ) . to ( \"b64u\" ) . ascii () if dq is not None else None , qi = BinaPy . from_int ( qi ) . to ( \"b64u\" ) . ascii () if qi is not None else None , ** params , ) ) @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generate a new random private `RSAJwk`. Args: key_size: the key size to use for the generated key, in bits **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) @cached_property def modulus ( self ) -> int : \"\"\"Return the modulus `n` from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () @cached_property def exponent ( self ) -> int : \"\"\"Return the public exponent `e` from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () @cached_property def private_exponent ( self ) -> int : \"\"\"Return the private exponent `d` from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () @cached_property def first_prime_factor ( self ) -> int : \"\"\"Return the first prime factor `p` from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return self . prime_factors [ 0 ] @cached_property def second_prime_factor ( self ) -> int : \"\"\"Return the second prime factor `q` from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return self . prime_factors [ 1 ] @cached_property def prime_factors ( self ) -> Tuple [ int , int ]: \"\"\"Return the 2 prime factors `p` and `q` from this Jwk.\"\"\" if \"p\" not in self or \"q\" not in self : p , q = rsa . rsa_recover_prime_factors ( self . modulus , self . exponent , self . private_exponent ) return ( p , q ) if p < q else ( q , p ) return ( BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int (), BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int (), ) @cached_property def first_factor_crt_exponent ( self ) -> int : \"\"\"Return the first factor CRT exponent `dp` from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" if \"dp\" in self : return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_dmp1 ( self . private_exponent , self . first_prime_factor ) @cached_property def second_factor_crt_exponent ( self ) -> int : \"\"\"Return the second factor CRT exponent `dq` from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" if \"dq\" in self : return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_dmq1 ( self . private_exponent , self . second_prime_factor ) @cached_property def first_crt_coefficient ( self ) -> int : \"\"\"Return the first CRT coefficient `qi` from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" if \"qi\" in self : return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_iqmp ( self . first_prime_factor , self . second_prime_factor ) @cached_property def key_size ( self ) -> int : \"\"\"Key size, in bits. Returns: the key size \"\"\" return len ( BinaPy ( self . n ) . decode_from ( \"b64u\" )) * 8 def with_optional_private_parameters ( self ) -> RSAJwk : \"\"\"Compute the optional RSA private parameters and add them into the JWK. The optional parameters are: - p: first prime factor - q: second prime factor - dp: first factor Chinese Remainder Theorem exponent - dq: second factor Chinese Remainder Theorem exponent - qi: first Chinese Remainder Theorem coefficient \"\"\" if not self . is_private : raise ValueError ( \"Optional private parameters can only be computed for private RSA keys.\" ) jwk = dict ( self ) jwk . update ( { \"p\" : BinaPy . from_int ( self . first_prime_factor ) . to ( \"b64u\" ) . ascii (), \"q\" : BinaPy . from_int ( self . second_prime_factor ) . to ( \"b64u\" ) . ascii (), \"dp\" : BinaPy . from_int ( self . first_factor_crt_exponent ) . to ( \"b64u\" ) . ascii (), \"dq\" : BinaPy . from_int ( self . second_factor_crt_exponent ) . to ( \"b64u\" ) . ascii (), \"qi\" : BinaPy . from_int ( self . first_crt_coefficient ) . to ( \"b64u\" ) . ascii (), } ) return RSAJwk ( jwk ) def without_optional_private_parameters ( self ) -> RSAJwk : \"\"\"Remove the optional private parameters and return another Jwk instance without them.\"\"\" jwk = dict ( self ) for param in \"p\" , \"q\" , \"dp\" , \"dq\" , \"qi\" : jwk . pop ( param , None ) return RSAJwk ( jwk ) from_cryptography_key classmethod \u00b6 1 2 3 from_cryptography_key ( cryptography_key : Any , ** kwargs : Any ) -> RSAJwk Initialize a Jwk from a cryptography RSA key. Parameters: Name Type Description Default cryptography_key Any a cryptography RSA key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized with the given key Raises: Type Description TypeError if the given key type is not supported Source code in jwskate/jwk/rsa.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: cryptography_key: a `cryptography` RSA key **kwargs: additional members to include in the Jwk Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( cryptography_key , rsa . RSAPrivateKey ): priv = cryptography_key . private_numbers () # type: ignore[attr-defined] pub = cryptography_key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( cryptography_key , rsa . RSAPublicKey ): pub = cryptography_key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) _to_cryptography_key \u00b6 1 2 3 _to_cryptography_key () -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ] Initialize a cryptography key based on this Jwk. Returns: Type Description Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ] a cryptography RSAPrivateKey or RSAPublicKey Source code in jwskate/jwk/rsa.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def _to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key () public classmethod \u00b6 1 public ( n : int , e : int , ** params : Any ) -> RSAJwk Initialize a public RsaJwk from a modulus and an exponent. Parameters: Name Type Description Default n int the modulus required e int the exponent required **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RsaJwk initialized from the provided parameters Source code in jwskate/jwk/rsa.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public `RsaJwk` from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), ** params , ) ) private classmethod \u00b6 1 2 3 4 5 6 7 8 9 10 11 private ( n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any ) -> RSAJwk Initialize a private RsaJwk from its required parameters. Parameters: Name Type Description Default n int the modulus required e int the exponent required d int the private exponent required p Optional [ int ] the first prime factor None q Optional [ int ] the second prime factor None dp Optional [ int ] the first factor CRT exponent None dq Optional [ int ] the second factor CRT exponent None qi Optional [ int ] the first CRT coefficient None **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized from the given parameters Source code in jwskate/jwk/rsa.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initialize a private `RsaJwk` from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d ) . to ( \"b64u\" ) . ascii (), p = BinaPy . from_int ( p ) . to ( \"b64u\" ) . ascii () if p is not None else None , q = BinaPy . from_int ( q ) . to ( \"b64u\" ) . ascii () if q is not None else None , dp = BinaPy . from_int ( dp ) . to ( \"b64u\" ) . ascii () if dp is not None else None , dq = BinaPy . from_int ( dq ) . to ( \"b64u\" ) . ascii () if dq is not None else None , qi = BinaPy . from_int ( qi ) . to ( \"b64u\" ) . ascii () if qi is not None else None , ** params , ) ) generate classmethod \u00b6 1 generate ( key_size : int = 4096 , ** params : Any ) -> RSAJwk Generate a new random private RSAJwk . Parameters: Name Type Description Default key_size int the key size to use for the generated key, in bits 4096 **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a generated RSAJwk Source code in jwskate/jwk/rsa.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generate a new random private `RSAJwk`. Args: key_size: the key size to use for the generated key, in bits **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) modulus \u00b6 1 modulus () -> int Return the modulus n from this Jwk. Returns: Type Description int the key modulus (from parameter n ) Source code in jwskate/jwk/rsa.py 228 229 230 231 232 233 234 235 @cached_property def modulus ( self ) -> int : \"\"\"Return the modulus `n` from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () exponent \u00b6 1 exponent () -> int Return the public exponent e from this Jwk. Returns: Type Description int the key exponent (from parameter e ) Source code in jwskate/jwk/rsa.py 237 238 239 240 241 242 243 244 @cached_property def exponent ( self ) -> int : \"\"\"Return the public exponent `e` from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () private_exponent \u00b6 1 private_exponent () -> int Return the private exponent d from this Jwk. Returns: Type Description int the key private exponent (from parameter d ) Source code in jwskate/jwk/rsa.py 246 247 248 249 250 251 252 253 @cached_property def private_exponent ( self ) -> int : \"\"\"Return the private exponent `d` from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () first_prime_factor \u00b6 1 first_prime_factor () -> int Return the first prime factor p from this Jwk. Returns: Type Description int the first prime factor (from parameter p ) Source code in jwskate/jwk/rsa.py 255 256 257 258 259 260 261 262 @cached_property def first_prime_factor ( self ) -> int : \"\"\"Return the first prime factor `p` from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return self . prime_factors [ 0 ] second_prime_factor \u00b6 1 second_prime_factor () -> int Return the second prime factor q from this Jwk. Returns: Type Description int the second prime factor (from parameter q ) Source code in jwskate/jwk/rsa.py 264 265 266 267 268 269 270 271 @cached_property def second_prime_factor ( self ) -> int : \"\"\"Return the second prime factor `q` from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return self . prime_factors [ 1 ] prime_factors \u00b6 1 prime_factors () -> Tuple [ int , int ] Return the 2 prime factors p and q from this Jwk. Source code in jwskate/jwk/rsa.py 273 274 275 276 277 278 279 280 281 282 283 284 @cached_property def prime_factors ( self ) -> Tuple [ int , int ]: \"\"\"Return the 2 prime factors `p` and `q` from this Jwk.\"\"\" if \"p\" not in self or \"q\" not in self : p , q = rsa . rsa_recover_prime_factors ( self . modulus , self . exponent , self . private_exponent ) return ( p , q ) if p < q else ( q , p ) return ( BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int (), BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int (), ) first_factor_crt_exponent \u00b6 1 first_factor_crt_exponent () -> int Return the first factor CRT exponent dp from this Jwk. Returns: Type Description int the first factor CRT coefficient (from parameter dp ) Source code in jwskate/jwk/rsa.py 286 287 288 289 290 291 292 293 294 295 @cached_property def first_factor_crt_exponent ( self ) -> int : \"\"\"Return the first factor CRT exponent `dp` from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" if \"dp\" in self : return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_dmp1 ( self . private_exponent , self . first_prime_factor ) second_factor_crt_exponent \u00b6 1 second_factor_crt_exponent () -> int Return the second factor CRT exponent dq from this Jwk. Returns: Type Description int the second factor CRT coefficient (from parameter dq ) Source code in jwskate/jwk/rsa.py 297 298 299 300 301 302 303 304 305 306 @cached_property def second_factor_crt_exponent ( self ) -> int : \"\"\"Return the second factor CRT exponent `dq` from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" if \"dq\" in self : return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_dmq1 ( self . private_exponent , self . second_prime_factor ) first_crt_coefficient \u00b6 1 first_crt_coefficient () -> int Return the first CRT coefficient qi from this Jwk. Returns: Type Description int the first CRT coefficient (from parameter qi ) Source code in jwskate/jwk/rsa.py 308 309 310 311 312 313 314 315 316 317 @cached_property def first_crt_coefficient ( self ) -> int : \"\"\"Return the first CRT coefficient `qi` from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" if \"qi\" in self : return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_iqmp ( self . first_prime_factor , self . second_prime_factor ) key_size \u00b6 1 key_size () -> int Key size, in bits. Returns: Type Description int the key size Source code in jwskate/jwk/rsa.py 319 320 321 322 323 324 325 326 @cached_property def key_size ( self ) -> int : \"\"\"Key size, in bits. Returns: the key size \"\"\" return len ( BinaPy ( self . n ) . decode_from ( \"b64u\" )) * 8 with_optional_private_parameters \u00b6 1 with_optional_private_parameters () -> RSAJwk Compute the optional RSA private parameters and add them into the JWK. The optional parameters are: - p: first prime factor - q: second prime factor - dp: first factor Chinese Remainder Theorem exponent - dq: second factor Chinese Remainder Theorem exponent - qi: first Chinese Remainder Theorem coefficient Source code in jwskate/jwk/rsa.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def with_optional_private_parameters ( self ) -> RSAJwk : \"\"\"Compute the optional RSA private parameters and add them into the JWK. The optional parameters are: - p: first prime factor - q: second prime factor - dp: first factor Chinese Remainder Theorem exponent - dq: second factor Chinese Remainder Theorem exponent - qi: first Chinese Remainder Theorem coefficient \"\"\" if not self . is_private : raise ValueError ( \"Optional private parameters can only be computed for private RSA keys.\" ) jwk = dict ( self ) jwk . update ( { \"p\" : BinaPy . from_int ( self . first_prime_factor ) . to ( \"b64u\" ) . ascii (), \"q\" : BinaPy . from_int ( self . second_prime_factor ) . to ( \"b64u\" ) . ascii (), \"dp\" : BinaPy . from_int ( self . first_factor_crt_exponent ) . to ( \"b64u\" ) . ascii (), \"dq\" : BinaPy . from_int ( self . second_factor_crt_exponent ) . to ( \"b64u\" ) . ascii (), \"qi\" : BinaPy . from_int ( self . first_crt_coefficient ) . to ( \"b64u\" ) . ascii (), } ) return RSAJwk ( jwk ) without_optional_private_parameters \u00b6 1 without_optional_private_parameters () -> RSAJwk Remove the optional private parameters and return another Jwk instance without them. Source code in jwskate/jwk/rsa.py 361 362 363 364 365 366 367 def without_optional_private_parameters ( self ) -> RSAJwk : \"\"\"Remove the optional private parameters and return another Jwk instance without them.\"\"\" jwk = dict ( self ) for param in \"p\" , \"q\" , \"dp\" , \"dq\" , \"qi\" : jwk . pop ( param , None ) return RSAJwk ( jwk ) UnsupportedEllipticCurve \u00b6 Bases: KeyError Raised when an unsupported Elliptic curve is requested. Source code in jwskate/jwk/ec.py 32 33 class UnsupportedEllipticCurve ( KeyError ): \"\"\"Raised when an unsupported Elliptic curve is requested.\"\"\" UnsupportedOKPCurve \u00b6 Bases: KeyError Raised when an unsupported OKP curve is requested. Source code in jwskate/jwk/okp.py 32 33 class UnsupportedOKPCurve ( KeyError ): \"\"\"Raised when an unsupported OKP curve is requested.\"\"\" SymmetricJwk \u00b6 Bases: Jwk Implement Symmetric keys, with kty=oct . Source code in jwskate/jwk/oct.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class SymmetricJwk ( Jwk ): \"\"\"Implement Symmetric keys, with `kty=oct`.\"\"\" KTY = \"oct\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = ( bytes ,) CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = ( bytes ,) PARAMS = { \"k\" : JwkParameter ( \"Key Value\" , is_private = True , is_required = True , kind = \"b64u\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ HS256 , HS384 , HS512 ]} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ A128KW , A192KW , A256KW , A128GCMKW , A192GCMKW , A256GCMKW , DirectKeyUse , ] } ENCRYPTION_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ A128CBC_HS256 , A192CBC_HS384 , A256CBC_HS512 , A128GCM , A192GCM , A256GCM , ] } @property def is_symmetric ( self ) -> bool : \"\"\"Always returns `True`.\"\"\" return True def public_jwk ( self ) -> Jwk : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk : \"\"\"Initialize a `SymmetricJwk` from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymmetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . to ( \"b64u\" ) . ascii (), ** params )) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** params : Any ) -> SymmetricJwk : \"\"\"Alias for `from_bytes()` since symmetric keys are simply bytes. Args: cryptography_key: the key to use **kwargs: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls . from_bytes ( cryptography_key , ** params ) @classmethod def generate ( cls , key_size : int = 128 , ** params : Any ) -> SymmetricJwk : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: key_size: size of the generated key, in bits **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( key_size ) return cls . from_bytes ( key , ** params ) @classmethod def generate_for_alg ( cls , alg : str , ** params : Any ) -> SymmetricJwk : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the algorithm identifier **params: additional members to include in the Jwk Returns: the generated `Jwk` Raises: UnsupportedAlg: if the provided `alg` is not supported \"\"\" alg_class = cls . _get_alg_class ( alg ) if issubclass ( alg_class , BaseHMACSigAlg ): return cls . generate ( key_size = alg_class . min_key_size , alg = alg , ** params ) elif issubclass ( alg_class , ( BaseAESEncryptionAlg , BaseAesKeyWrap )): return cls . generate ( key_size = alg_class . key_size , alg = alg , ** params ) return cls . generate ( alg = alg , ** params ) def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () ) def _to_cryptography_key ( self ) -> BinaPy : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" ) @property def key ( self ) -> BinaPy : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return self . cryptography_key # type: ignore def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with Additional Authenticated Data (`aad`). An Initialization Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This returns the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" wrapper = self . encryption_wrapper ( alg ) if iv is None : iv = wrapper . generate_iv () ciphertext , tag = wrapper . encrypt ( plaintext , iv = iv , aad = aad ) return ciphertext , BinaPy ( iv ), tag @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data iv: the Initialization Vector (must be the same as used during encryption) tag: the authentication tag aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" aad = b \"\" if aad is None else aad if not isinstance ( aad , bytes ): aad = bytes ( aad ) if not isinstance ( iv , bytes ): iv = bytes ( iv ) if not isinstance ( tag , bytes ): tag = bytes ( tag ) wrapper = self . encryption_wrapper ( alg ) plaintext : bytes = wrapper . decrypt ( ciphertext , auth_tag = tag , iv = iv , aad = aad ) return BinaPy ( plaintext ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that this key supports. Key Management algorithms are used to generate or wrap Content Encryption Keys (CEK). Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) # type: ignore ] def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) ] def to_pem ( self , password : Union [ bytes , str , None ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. Symmetric keys are not serializable to PEM so this will raise a TypeError. Args: password: password to use to encrypt the PEM. Raises: TypeError: always \"\"\" raise TypeError ( \"Symmetric keys are not serializable to PEM.\" ) is_symmetric property \u00b6 1 is_symmetric () -> bool Always returns True . Source code in jwskate/jwk/oct.py 72 73 74 75 @property def is_symmetric ( self ) -> bool : \"\"\"Always returns `True`.\"\"\" return True public_jwk \u00b6 1 public_jwk () -> Jwk This always raises a ValueError since SymmetricKeys are always private. Raises: Type Description ValueError symmetric keys are always private, it makes no sense to use them as public keys Source code in jwskate/jwk/oct.py 77 78 79 80 81 82 83 def public_jwk ( self ) -> Jwk : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) from_bytes classmethod \u00b6 1 2 3 from_bytes ( k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk Initialize a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the k parameter for the returned SymmetricKey. Parameters: Name Type Description Default k Union [ bytes , str ] the key to use required **params Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the resulting SymmetricJwk Source code in jwskate/jwk/oct.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk : \"\"\"Initialize a `SymmetricJwk` from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymmetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . to ( \"b64u\" ) . ascii (), ** params )) from_cryptography_key classmethod \u00b6 1 2 3 from_cryptography_key ( cryptography_key : Any , ** params : Any ) -> SymmetricJwk Alias for from_bytes() since symmetric keys are simply bytes. Parameters: Name Type Description Default cryptography_key Any the key to use required **kwargs additional members to include in the Jwk required Returns: Type Description SymmetricJwk the resulting SymmetricJwk Source code in jwskate/jwk/oct.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** params : Any ) -> SymmetricJwk : \"\"\"Alias for `from_bytes()` since symmetric keys are simply bytes. Args: cryptography_key: the key to use **kwargs: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls . from_bytes ( cryptography_key , ** params ) generate classmethod \u00b6 1 2 3 generate ( key_size : int = 128 , ** params : Any ) -> SymmetricJwk Generate a random SymmetricJwk, with a given key size. Parameters: Name Type Description Default key_size int size of the generated key, in bits 128 **params Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk a SymmetricJwk with a randomly generated key Source code in jwskate/jwk/oct.py 115 116 117 118 119 120 121 122 123 124 125 126 127 @classmethod def generate ( cls , key_size : int = 128 , ** params : Any ) -> SymmetricJwk : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: key_size: size of the generated key, in bits **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( key_size ) return cls . from_bytes ( key , ** params ) generate_for_alg classmethod \u00b6 1 generate_for_alg ( alg : str , ** params : Any ) -> SymmetricJwk Generate a SymmetricJwk that is suitable for use with the given alg. Parameters: Name Type Description Default alg str the algorithm identifier required **params Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the generated Jwk Raises: Type Description UnsupportedAlg if the provided alg is not supported Source code in jwskate/jwk/oct.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @classmethod def generate_for_alg ( cls , alg : str , ** params : Any ) -> SymmetricJwk : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the algorithm identifier **params: additional members to include in the Jwk Returns: the generated `Jwk` Raises: UnsupportedAlg: if the provided `alg` is not supported \"\"\" alg_class = cls . _get_alg_class ( alg ) if issubclass ( alg_class , BaseHMACSigAlg ): return cls . generate ( key_size = alg_class . min_key_size , alg = alg , ** params ) elif issubclass ( alg_class , ( BaseAESEncryptionAlg , BaseAesKeyWrap )): return cls . generate ( key_size = alg_class . key_size , alg = alg , ** params ) return cls . generate ( alg = alg , ** params ) thumbprint \u00b6 1 thumbprint ( hashalg : str = 'SHA256' ) -> str Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Returns: Type Description str the calculated thumbprint Source code in jwskate/jwk/oct.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () ) _to_cryptography_key \u00b6 1 _to_cryptography_key () -> BinaPy Converts this Jwk into a key usable with cryptography . For SymmetricJwk instances, those are just bytes values. Returns: Type Description BinaPy the raw private key, as bytes Source code in jwskate/jwk/oct.py 168 169 170 171 172 173 174 175 176 def _to_cryptography_key ( self ) -> BinaPy : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" ) key property \u00b6 1 key () -> BinaPy Returns the raw symmetric key. Returns: Type Description BinaPy the key from the k parameter, base64u-decoded Source code in jwskate/jwk/oct.py 178 179 180 181 182 183 184 185 @property def key ( self ) -> BinaPy : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return self . cryptography_key # type: ignore encrypt \u00b6 1 2 3 4 5 6 7 encrypt ( plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None ) -> Tuple [ BinaPy , BinaPy , BinaPy ] Encrypt arbitrary data using this key. Supports Authenticated Encryption with Additional Authenticated Data ( aad ). An Initialization Vector (IV) will be generated automatically. You can choose your own IV by providing the iv parameter (only use this if you know what you are doing). This returns the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Parameters: Name Type Description Default plaintext Union [ bytes , SupportsBytes ] the plaintext to encrypt required aad Optional [ bytes ] the Additional Authentication Data, if any None alg Optional [ str ] the encryption alg to use None iv Optional [ bytes ] the IV to use, if you want a specific value None Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (ciphertext, authentication_tag, iv) tuple Source code in jwskate/jwk/oct.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with Additional Authenticated Data (`aad`). An Initialization Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This returns the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" wrapper = self . encryption_wrapper ( alg ) if iv is None : iv = wrapper . generate_iv () ciphertext , tag = wrapper . encrypt ( plaintext , iv = iv , aad = aad ) return ciphertext , BinaPy ( iv ), tag key_size property \u00b6 1 key_size () -> int The key size, in bits. Returns: Type Description int the key size in bits Source code in jwskate/jwk/oct.py 218 219 220 221 222 223 224 225 @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 decrypt \u00b6 1 2 3 4 5 6 7 8 decrypt ( ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None ) -> BinaPy Decrypt arbitrary data. Parameters: Name Type Description Default ciphertext Union [ bytes , SupportsBytes ] the encrypted data required iv Union [ bytes , SupportsBytes ] the Initialization Vector (must be the same as used during encryption) required tag Union [ bytes , SupportsBytes ] the authentication tag required aad Union [ bytes , SupportsBytes , None] the Additional Authenticated Data (must be the same as used during encryption) None alg Optional [ str ] the decryption alg (must be the same as used during encryption) None Returns: Type Description BinaPy the decrypted clear-text Source code in jwskate/jwk/oct.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data iv: the Initialization Vector (must be the same as used during encryption) tag: the authentication tag aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" aad = b \"\" if aad is None else aad if not isinstance ( aad , bytes ): aad = bytes ( aad ) if not isinstance ( iv , bytes ): iv = bytes ( iv ) if not isinstance ( tag , bytes ): tag = bytes ( tag ) wrapper = self . encryption_wrapper ( alg ) plaintext : bytes = wrapper . decrypt ( ciphertext , auth_tag = tag , iv = iv , aad = aad ) return BinaPy ( plaintext ) supported_key_management_algorithms \u00b6 1 supported_key_management_algorithms () -> List [ str ] Return the list of Key Management algorithms that this key supports. Key Management algorithms are used to generate or wrap Content Encryption Keys (CEK). Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/oct.py 261 262 263 264 265 266 267 268 269 270 271 272 273 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that this key supports. Key Management algorithms are used to generate or wrap Content Encryption Keys (CEK). Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) # type: ignore ] supported_encryption_algorithms \u00b6 1 supported_encryption_algorithms () -> List [ str ] Return the list of supported Encryption/Decryption algorithms with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/oct.py 275 276 277 278 279 280 281 282 283 284 285 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) ] to_pem \u00b6 1 to_pem ( password : Union [ bytes , str , None ] = None ) -> bytes Serialize this key to PEM format. Symmetric keys are not serializable to PEM so this will raise a TypeError. Parameters: Name Type Description Default password Union [ bytes , str , None] password to use to encrypt the PEM. None Raises: Type Description TypeError always Source code in jwskate/jwk/oct.py 287 288 289 290 291 292 293 294 295 296 297 298 def to_pem ( self , password : Union [ bytes , str , None ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. Symmetric keys are not serializable to PEM so this will raise a TypeError. Args: password: password to use to encrypt the PEM. Raises: TypeError: always \"\"\" raise TypeError ( \"Symmetric keys are not serializable to PEM.\" ) ECJwk \u00b6 Bases: Jwk Represent an Elliptic Curve Jwk, with kty=EC . Source code in jwskate/jwk/ec.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 class ECJwk ( Jwk ): \"\"\"Represent an Elliptic Curve Jwk, with `kty=EC`.\"\"\" KTY = \"EC\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = ( asymmetric . ec . EllipticCurvePrivateKey ,) CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = ( asymmetric . ec . EllipticCurvePublicKey ,) PARAMS : Mapping [ str , JwkParameter ] = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"X Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"y\" : JwkParameter ( \"Y Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"ECC Private Key\" , is_private = True , is_required = True , kind = \"b64u\" ), } CURVES : Mapping [ str , EllipticCurve ] = { curve . name : curve for curve in [ P_256 , P_384 , P_521 , secp256k1 ] } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ ES256 , ES384 , ES512 , ES256K ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self def _validate ( self ) -> None : self . get_curve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . to ( \"b64u\" ), ** { k : v for k , v in params . items () if v is not None }, ) ) @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . to ( \"b64u\" ) . ascii (), y = BinaPy . from_int ( y , coord_size ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d , coord_size ) . to ( \"b64u\" ) . ascii (), ** { k : v for k , v in params . items () if v is not None }, ) ) @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: cryptography_key: `cryptography` key **kwargs: additional members to include in the Jwk Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_jwk_parameters ( cryptography_key ) return cls ( parameters ) def _to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key () @classmethod def generate ( cls , crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : str ) -> \"ECJwk\" : \"\"\"Generate a random ECJwk. Args: alg: the alg crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" if crv is None and alg is None : warnings . warn ( \"No Curve identifier (crv) or an Algorithm identifier (alg) have been provided \" \"when generating an Elliptic Curve JWK. So there is no hint to determine which curve to use. \" \"Curve 'P-256' is used by default. You should explicitly pass an 'alg' or 'crv' parameter \" \"to explicitly select the appropriate Curve and avoid this warning.\" ) crv = \"P-256\" curve : Optional [ EllipticCurve ] = None if crv : curve = cls . get_curve ( crv ) elif alg : if alg in cls . SIGNATURE_ALGORITHMS : curve = cls . SIGNATURE_ALGORITHMS [ alg ] . curve elif alg in cls . KEY_MANAGEMENT_ALGORITHMS : curve = P_256 if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = curve . name , alg = alg , x = x , y = y , d = d , ** params , ) @cached_property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () @cached_property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () @cached_property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) get_curve classmethod \u00b6 1 get_curve ( crv : str ) -> EllipticCurve Get the EllipticCurve instance for a given curve identifier. Parameters: Name Type Description Default crv str the curve identifier required Returns: Type Description EllipticCurve the matching EllipticCurve instance Raises: Type Description UnsupportedEllipticCurve if the curve identifier is not supported Source code in jwskate/jwk/ec.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve curve property \u00b6 1 curve () -> EllipticCurve Get the EllipticCurve instance for this key. Returns: Type Description EllipticCurve the EllipticCurve instance Source code in jwskate/jwk/ec.py 97 98 99 100 101 102 103 104 @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) public classmethod \u00b6 1 public ( crv : str , x : int , y : int , ** params : str ) -> ECJwk Initialize a public ECJwk from its public parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required **params str additional member to include in the Jwk {} Returns: Type Description ECJwk an ECJwk initialized with the supplied parameters Source code in jwskate/jwk/ec.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . to ( \"b64u\" ), ** { k : v for k , v in params . items () if v is not None }, ) ) private classmethod \u00b6 1 2 3 private ( crv : str , x : int , y : int , d : int , ** params : Any ) -> ECJwk Initialize a private ECJwk from its private parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required d int the elliptic curve private key required **params Any additional members to include in the JWK {} Returns: Type Description ECJwk an ECJWk initialized with the supplied parameters Source code in jwskate/jwk/ec.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . to ( \"b64u\" ) . ascii (), y = BinaPy . from_int ( y , coord_size ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d , coord_size ) . to ( \"b64u\" ) . ascii (), ** { k : v for k , v in params . items () if v is not None }, ) ) coordinate_size property \u00b6 1 coordinate_size () -> int The coordinate size to use with the key curve. Returns: Type Description int 32, 48, or 66 (bits) Source code in jwskate/jwk/ec.py 156 157 158 159 160 161 162 163 @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size from_cryptography_key classmethod \u00b6 1 2 3 from_cryptography_key ( cryptography_key : Any , ** kwargs : Any ) -> ECJwk Initialize an ECJwk from a cryptography key. Parameters: Name Type Description Default cryptography_key Any cryptography key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description ECJwk an ECJwk initialized from the provided cryptography key Source code in jwskate/jwk/ec.py 165 166 167 168 169 170 171 172 173 174 175 176 177 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: cryptography_key: `cryptography` key **kwargs: additional members to include in the Jwk Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_jwk_parameters ( cryptography_key ) return cls ( parameters ) _to_cryptography_key \u00b6 1 2 3 4 _to_cryptography_key () -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ] Initialize a cryptography key based on this Jwk. Returns: Type Description Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] an EllipticCurvePublicKey or EllipticCurvePrivateKey Source code in jwskate/jwk/ec.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def _to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key () generate classmethod \u00b6 1 2 3 4 5 generate ( crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : str ) -> ECJwk Generate a random ECJwk. Parameters: Name Type Description Default alg Optional [ str ] the alg None crv Optional [ str ] the curve to use None **params str {} Returns: Type Description ECJwk a generated ECJwk Raises: Type Description UnsupportedEllipticCurve if the provided curve identifier is not supported. Source code in jwskate/jwk/ec.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 @classmethod def generate ( cls , crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : str ) -> \"ECJwk\" : \"\"\"Generate a random ECJwk. Args: alg: the alg crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" if crv is None and alg is None : warnings . warn ( \"No Curve identifier (crv) or an Algorithm identifier (alg) have been provided \" \"when generating an Elliptic Curve JWK. So there is no hint to determine which curve to use. \" \"Curve 'P-256' is used by default. You should explicitly pass an 'alg' or 'crv' parameter \" \"to explicitly select the appropriate Curve and avoid this warning.\" ) crv = \"P-256\" curve : Optional [ EllipticCurve ] = None if crv : curve = cls . get_curve ( crv ) elif alg : if alg in cls . SIGNATURE_ALGORITHMS : curve = cls . SIGNATURE_ALGORITHMS [ alg ] . curve elif alg in cls . KEY_MANAGEMENT_ALGORITHMS : curve = P_256 if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = curve . name , alg = alg , x = x , y = y , d = d , ** params , ) x_coordinate \u00b6 1 x_coordinate () -> int Return the x coordinate from this ECJwk. Returns: Type Description int the x coordinate (from parameter x ) Source code in jwskate/jwk/ec.py 253 254 255 256 257 258 259 260 @cached_property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () y_coordinate \u00b6 1 y_coordinate () -> int Return the y coordinate from this ECJwk. Returns: Type Description int the y coordinate (from parameter y ) Source code in jwskate/jwk/ec.py 262 263 264 265 266 267 268 269 @cached_property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () ecc_private_key \u00b6 1 ecc_private_key () -> int Return the ECC private key from this ECJwk. Returns: Type Description int the ECC private key (from parameter d ) Source code in jwskate/jwk/ec.py 271 272 273 274 275 276 277 278 @cached_property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () supported_signing_algorithms \u00b6 1 supported_signing_algorithms () -> List [ str ] Return the list of supported signature algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 280 281 282 283 284 285 286 287 288 289 290 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] supported_key_management_algorithms \u00b6 1 supported_key_management_algorithms () -> List [ str ] Return the list of supported Key Management algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 292 293 294 295 296 297 298 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) supported_encryption_algorithms \u00b6 1 supported_encryption_algorithms () -> List [ str ] Return the list of support Encryption algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 300 301 302 303 304 305 306 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) OKPJwk \u00b6 Bases: Jwk Represent an OKP Jwk, with kty=OKP . Source code in jwskate/jwk/okp.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 class OKPJwk ( Jwk ): \"\"\"Represent an OKP Jwk, with `kty=OKP`.\"\"\" KTY = \"OKP\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ) CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ) PARAMS = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"Public Key\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Key\" , is_private = True , is_required = True , kind = \"b64u\" ), } CURVES : Mapping [ str , OKPCurve ] = { curve . name : curve for curve in [ Ed25519 , Ed448 , X448 , X25519 ] } SIGNATURE_ALGORITHMS = { alg . name : alg for alg in ( EdDsa ,)} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedOKPCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) @cached_property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) @cached_property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) @classmethod def from_bytes ( cls , private_key : bytes , crv : Optional [ str ] = None , use : Optional [ str ] = None , ** kwargs : Any , ) -> OKPJwk : \"\"\"Initialize an `OKPJwk` from its private key. The public key will be automatically derived from the supplied private key, The appropriate curve will be guessed based on the key length or supplied `crv`/`use` hints: - 56 bytes will use X448 - 57 bytes will use Ed448 - 32 bytes will use Ed25519 or X25519. Since there is no way to guess which one you want, it needs an hint with either a `crv` or `use` parameter. Args: private_key: the 32, 56 or 57 bytes private key, as raw bytes crv: the curve to use use: the key usage **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if crv and use : if ( crv in ( \"Ed25519\" , \"Ed448\" ) and use != \"sig\" ) or ( crv in ( \"X25519\" , \"X448\" ) and use != \"enc\" ): raise ValueError ( f \"Inconsistent `crv= { crv } ` and `use= { use } ` parameters.\" ) elif crv : if crv in ( \"Ed25519\" , \"Ed448\" ): use = \"sig\" elif crv in ( \"X25519\" , \"X448\" ): use = \"enc\" else : raise UnsupportedOKPCurve ( crv ) elif use : if use not in ( \"sig\" , \"enc\" ): raise ValueError ( f \"Invalid `use= { use } ` parameter, need 'sig' or 'enc'.\" ) cryptography_key : Any if len ( private_key ) == 32 : if use == \"sig\" : cryptography_key = ed25519 . Ed25519PrivateKey . from_private_bytes ( private_key ) elif use == \"enc\" : cryptography_key = x25519 . X25519PrivateKey . from_private_bytes ( private_key ) else : raise ValueError ( \"You need to specify either crv={'Ed25519', 'X25519'} or use={'sig', 'enc'} when providing a 32 bytes private key.\" ) elif len ( private_key ) == 56 : cryptography_key = x448 . X448PrivateKey . from_private_bytes ( private_key ) if use and use != \"enc\" : raise ValueError ( f \"Invalid `use= { use } ` parameter. Keys of length 56 bytes are for curve X448.\" ) use = \"enc\" elif len ( private_key ) == 57 : cryptography_key = ed448 . Ed448PrivateKey . from_private_bytes ( private_key ) if use and use != \"sig\" : raise ValueError ( f \"Invalid `use= { use } ` parameter. Keys of length 57 bytes are for curve Ed448.\" ) use = \"sig\" else : raise ValueError ( \"Invalid private key. It must be bytes of length 32, 56 or 57.\" ) return OKPJwk . from_cryptography_key ( cryptography_key , use = use , ** kwargs ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> OKPJwk : \"\"\"Initialize an `OKPJwk` from a `cryptography` key. Args: cryptography_key: a `cryptography` key **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if isinstance ( cryptography_key , ed25519 . Ed25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed25519 . Ed25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( cryptography_key , ed448 . Ed448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed448 . Ed448PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( cryptography_key , x25519 . X25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x25519 . X25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( cryptography_key , x448 . X448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x448 . X448PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in ( cls . CRYPTOGRAPHY_PRIVATE_KEY_CLASSES + cls . CRYPTOGRAPHY_PUBLIC_KEY_CLASSES ) ) ) def _to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) # pragma: no cover @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), ** params )) @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def generate ( cls , crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. You can specify either a curve or an algorithm identifier, or both. If using an alg identifier, crv will default to Ed25519 for signature algs, or X25519 for encryption algs. Args: crv: the curve to use alg: algorithm to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" if crv : curve = cls . get_curve ( crv ) elif alg : if alg in cls . SIGNATURE_ALGORITHMS : curve = Ed25519 elif alg in cls . KEY_MANAGEMENT_ALGORITHMS : curve = X25519 else : raise UnsupportedAlg ( alg ) else : raise ValueError ( \"You must supply at least a Curve identifier (crv) or an Algorithm identifier (alg) \" \"in order to generate an OKP JWK.\" ) x , d = curve . generate () return cls . private ( crv = curve . name , x = x , d = d , alg = alg , ** params ) @cached_property def use ( self ) -> Optional [ str ]: \"\"\"Return the key use. For OKP keys, this can be directly deduced from the curve. \"\"\" if self . curve in ( Ed25519 , Ed448 ): return \"sig\" elif self . curve in ( X25519 , X448 ): return \"enc\" return None # pragma: no cover get_curve classmethod \u00b6 1 get_curve ( crv : str ) -> OKPCurve Get the OKPCurve instance from a curve identifier. Parameters: Name Type Description Default crv str a crv identifier required Returns: Type Description OKPCurve the matching OKPCurve instance Raises: Type Description UnsupportedOKPCurve if the curve is not supported Source code in jwskate/jwk/okp.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve curve property \u00b6 1 curve () -> OKPCurve Get the OKPCurve instance for this key. Returns: Type Description OKPCurve the OKPCurve for this key Source code in jwskate/jwk/okp.py 103 104 105 106 107 108 109 110 @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) public_key \u00b6 1 public_key () -> bytes Get the public key from this Jwk. Returns: Type Description bytes the public key (from param x ) Source code in jwskate/jwk/okp.py 112 113 114 115 116 117 118 119 @cached_property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) private_key \u00b6 1 private_key () -> bytes Get the private key from this Jwk. Returns: Type Description bytes the private key (from param d ) Source code in jwskate/jwk/okp.py 121 122 123 124 125 126 127 128 @cached_property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) from_bytes classmethod \u00b6 1 2 3 4 5 6 from_bytes ( private_key : bytes , crv : Optional [ str ] = None , use : Optional [ str ] = None , ** kwargs : Any ) -> OKPJwk Initialize an OKPJwk from its private key. The public key will be automatically derived from the supplied private key, The appropriate curve will be guessed based on the key length or supplied crv / use hints: - 56 bytes will use X448 - 57 bytes will use Ed448 - 32 bytes will use Ed25519 or X25519. Since there is no way to guess which one you want, it needs an hint with either a crv or use parameter. Parameters: Name Type Description Default private_key bytes the 32, 56 or 57 bytes private key, as raw bytes required crv Optional [ str ] the curve to use None use Optional [ str ] the key usage None **kwargs Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the matching OKPJwk Source code in jwskate/jwk/okp.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 @classmethod def from_bytes ( cls , private_key : bytes , crv : Optional [ str ] = None , use : Optional [ str ] = None , ** kwargs : Any , ) -> OKPJwk : \"\"\"Initialize an `OKPJwk` from its private key. The public key will be automatically derived from the supplied private key, The appropriate curve will be guessed based on the key length or supplied `crv`/`use` hints: - 56 bytes will use X448 - 57 bytes will use Ed448 - 32 bytes will use Ed25519 or X25519. Since there is no way to guess which one you want, it needs an hint with either a `crv` or `use` parameter. Args: private_key: the 32, 56 or 57 bytes private key, as raw bytes crv: the curve to use use: the key usage **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if crv and use : if ( crv in ( \"Ed25519\" , \"Ed448\" ) and use != \"sig\" ) or ( crv in ( \"X25519\" , \"X448\" ) and use != \"enc\" ): raise ValueError ( f \"Inconsistent `crv= { crv } ` and `use= { use } ` parameters.\" ) elif crv : if crv in ( \"Ed25519\" , \"Ed448\" ): use = \"sig\" elif crv in ( \"X25519\" , \"X448\" ): use = \"enc\" else : raise UnsupportedOKPCurve ( crv ) elif use : if use not in ( \"sig\" , \"enc\" ): raise ValueError ( f \"Invalid `use= { use } ` parameter, need 'sig' or 'enc'.\" ) cryptography_key : Any if len ( private_key ) == 32 : if use == \"sig\" : cryptography_key = ed25519 . Ed25519PrivateKey . from_private_bytes ( private_key ) elif use == \"enc\" : cryptography_key = x25519 . X25519PrivateKey . from_private_bytes ( private_key ) else : raise ValueError ( \"You need to specify either crv={'Ed25519', 'X25519'} or use={'sig', 'enc'} when providing a 32 bytes private key.\" ) elif len ( private_key ) == 56 : cryptography_key = x448 . X448PrivateKey . from_private_bytes ( private_key ) if use and use != \"enc\" : raise ValueError ( f \"Invalid `use= { use } ` parameter. Keys of length 56 bytes are for curve X448.\" ) use = \"enc\" elif len ( private_key ) == 57 : cryptography_key = ed448 . Ed448PrivateKey . from_private_bytes ( private_key ) if use and use != \"sig\" : raise ValueError ( f \"Invalid `use= { use } ` parameter. Keys of length 57 bytes are for curve Ed448.\" ) use = \"sig\" else : raise ValueError ( \"Invalid private key. It must be bytes of length 32, 56 or 57.\" ) return OKPJwk . from_cryptography_key ( cryptography_key , use = use , ** kwargs ) from_cryptography_key classmethod \u00b6 1 2 3 from_cryptography_key ( cryptography_key : Any , ** kwargs : Any ) -> OKPJwk Initialize an OKPJwk from a cryptography key. Parameters: Name Type Description Default cryptography_key Any a cryptography key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the matching OKPJwk Source code in jwskate/jwk/okp.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> OKPJwk : \"\"\"Initialize an `OKPJwk` from a `cryptography` key. Args: cryptography_key: a `cryptography` key **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if isinstance ( cryptography_key , ed25519 . Ed25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed25519 . Ed25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( cryptography_key , ed448 . Ed448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed448 . Ed448PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( cryptography_key , x25519 . X25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x25519 . X25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( cryptography_key , x448 . X448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x448 . X448PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in ( cls . CRYPTOGRAPHY_PRIVATE_KEY_CLASSES + cls . CRYPTOGRAPHY_PUBLIC_KEY_CLASSES ) ) ) _to_cryptography_key \u00b6 1 _to_cryptography_key () -> Any Intialize a cryptography key based on this Jwk. Returns: Type Description Any a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: Type Description UnsupportedOKPCurve if this Jwk curve is not supported. Source code in jwskate/jwk/okp.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def _to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) # pragma: no cover public classmethod \u00b6 1 public ( crv : str , x : bytes , ** params : Any ) -> OKPJwk Initialize a public OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the key curve required x bytes the public key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 351 352 353 354 355 356 357 358 359 360 361 362 363 @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), ** params )) private classmethod \u00b6 1 2 3 private ( crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk Initialize a private OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the OKP curve required x bytes the public key required d bytes the private key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . to ( \"b64u\" ) . ascii (), ** params , ) ) generate classmethod \u00b6 1 2 3 4 5 generate ( crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : Any ) -> OKPJwk Generate a private OKPJwk on a given curve. You can specify either a curve or an algorithm identifier, or both. If using an alg identifier, crv will default to Ed25519 for signature algs, or X25519 for encryption algs. Parameters: Name Type Description Default crv Optional [ str ] the curve to use None alg Optional [ str ] algorithm to use None **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 @classmethod def generate ( cls , crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. You can specify either a curve or an algorithm identifier, or both. If using an alg identifier, crv will default to Ed25519 for signature algs, or X25519 for encryption algs. Args: crv: the curve to use alg: algorithm to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" if crv : curve = cls . get_curve ( crv ) elif alg : if alg in cls . SIGNATURE_ALGORITHMS : curve = Ed25519 elif alg in cls . KEY_MANAGEMENT_ALGORITHMS : curve = X25519 else : raise UnsupportedAlg ( alg ) else : raise ValueError ( \"You must supply at least a Curve identifier (crv) or an Algorithm identifier (alg) \" \"in order to generate an OKP JWK.\" ) x , d = curve . generate () return cls . private ( crv = curve . name , x = x , d = d , alg = alg , ** params ) use \u00b6 1 use () -> Optional [ str ] Return the key use. For OKP keys, this can be directly deduced from the curve. Source code in jwskate/jwk/okp.py 424 425 426 427 428 429 430 431 432 433 434 @cached_property def use ( self ) -> Optional [ str ]: \"\"\"Return the key use. For OKP keys, this can be directly deduced from the curve. \"\"\" if self . curve in ( Ed25519 , Ed448 ): return \"sig\" elif self . curve in ( X25519 , X448 ): return \"enc\" return None # pragma: no cover UnsupportedKeyType \u00b6 Bases: ValueError Raised when an unsupported Key Type is requested. Source code in jwskate/jwk/base.py 48 49 class UnsupportedKeyType ( ValueError ): \"\"\"Raised when an unsupported Key Type is requested.\"\"\" InvalidJwk \u00b6 Bases: ValueError Raised when an invalid JWK is encountered. Source code in jwskate/jwk/base.py 52 53 class InvalidJwk ( ValueError ): \"\"\"Raised when an invalid JWK is encountered.\"\"\" Jwk \u00b6 Bases: BaseJsonDict Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class: Jwk is a dict, so you can do with a Jwk anything you can do with a dict . In addition, all keys parameters are exposed as attributes. There are subclasses of Jwk for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Parameters: Name Type Description Default params Union [ Dict [ str , Any ], Any ] a dict with the parsed Jwk parameters, or a cryptography key , or another Jwk required include_kid_thumbprint bool if True (default), and there is no kid in the provided params, generate a kid based on the key thumbprint False Source code in jwskate/jwk/base.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 class Jwk ( BaseJsonDict ): \"\"\"Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class:`Jwk` is a dict, so you can do with a Jwk anything you can do with a `dict`. In addition, all keys parameters are exposed as attributes. There are subclasses of `Jwk` for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Args: params: a dict with the parsed Jwk parameters, or a `cryptography key`, or another `Jwk` include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint \"\"\" subclasses : Dict [ str , Type [ Jwk ]] = {} \"\"\"A dict of 'kty' values to subclasses implementing each specific Key Type\"\"\" cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} \"\"\"A dict of cryptography key classes to its specific 'kty' value\"\"\" PARAMS : Mapping [ str , JwkParameter ] \"\"\"A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)\"\"\" KTY : ClassVar [ str ] \"\"\"The Key Type associated with this JWK.\"\"\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES : ClassVar [ Iterable [ Any ]] CRYPTOGRAPHY_PUBLIC_KEY_CLASSES : ClassVar [ Iterable [ Any ]] SIGNATURE_ALGORITHMS : Mapping [ str , Type [ BaseSignatureAlg ]] = {} KEY_MANAGEMENT_ALGORITHMS : Mapping [ str , Type [ BaseKeyManagementAlg ]] = {} ENCRYPTION_ALGORITHMS : Mapping [ str , Type [ BaseAESEncryptionAlg ]] = {} IANA_HASH_FUNCTION_NAMES : Mapping [ str , str ] = { # IANA registered names to binapy hash name \"sha-1\" : \"sha1\" , \"sha-224\" : \"sha224\" , \"sha-256\" : \"sha256\" , \"sha-384\" : \"sha384\" , \"sha-512\" : \"sha512\" , \"shake128\" : \"shake128\" , \"shake256\" : \"shake256\" , } def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows `__new__` to pick the appropriate subclass when creating a Jwk. \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_PRIVATE_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls for klass in cls . CRYPTOGRAPHY_PUBLIC_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls def __new__ ( cls , key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key **kwargs: additional members to include in the Jwk \"\"\" if cls == Jwk : if isinstance ( key , Jwk ): return cls . from_cryptography_key ( key . cryptography_key , ** kwargs ) if isinstance ( key , dict ): kty : Optional [ str ] = key . get ( \"kty\" ) if kty is None : raise InvalidJwk ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise InvalidJwk ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) elif isinstance ( key , str ): return cls . from_json ( key ) else : return cls . from_cryptography_key ( key , ** kwargs ) return super () . __new__ ( cls , key , ** kwargs ) def __init__ ( self , params : Union [ Dict [ str , Any ], Any ], include_kid_thumbprint : bool = False ): if isinstance ( params , dict ): # this is to avoid double init due to the __new__ above super () . __init__ ( { key : val for key , val in params . items () if val is not None } ) self . _validate () if self . get ( \"kid\" ) is None and include_kid_thumbprint : self [ \"kid\" ] = self . thumbprint () try : self . cryptography_key = self . _to_cryptography_key () except AttributeError as exc : raise InvalidJwk ( \"Invalid JWK parameter\" , * exc . args ) from exc @classmethod def _get_alg_class ( cls , alg : str ) -> Type [ BaseAlg ]: \"\"\"Given an alg identifier, return the matching JWA wrapper. Args: alg: an alg identifier Returns: the matching JWA wrapper \"\"\" alg_class : Optional [ Type [ BaseAlg ]] alg_class = cls . SIGNATURE_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class alg_class = cls . KEY_MANAGEMENT_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class alg_class = cls . ENCRYPTION_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class raise UnsupportedAlg ( alg ) @property def is_private ( self ) -> bool : \"\"\"Return `True` if the key is private, `False` otherwise. Returns: `True` if the key is private, `False` otherwise \"\"\" return True @property def is_symmetric ( self ) -> bool : \"\"\"Return `True` if the key is symmetric, `False` otherwise.\"\"\" return False def __getattr__ ( self , param : str ) -> Any : \"\"\"Allow access to key parameters as attributes. This is a convenience to allow `jwk.param` instead of `jwk['param']`. Args: param: the parameter name to access Return: the param value Raises: AttributeError: if the param is not found \"\"\" value = self . get ( param ) if value is None : raise AttributeError ( param ) return value def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Override base method to avoid modifying cryptographic key attributes. Args: key: name of the attribute to set value: value to set Raises: RuntimeError: when trying to modify cryptographic attributes \"\"\" if key in self . PARAMS : raise RuntimeError ( \"JWK key attributes cannot be modified.\" ) super () . __setitem__ ( key , value ) def thumbprint ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" alg = self . IANA_HASH_FUNCTION_NAMES . get ( hashalg ) if not alg : raise ValueError ( f \"Unsupported hash alg { hashalg } \" ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) return ( BinaPy . serialize_to ( \"json\" , t , separators = ( \",\" , \":\" ), sort_keys = True ) . to ( alg ) . to ( \"b64u\" ) . ascii () ) def thumbprint_uri ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Returns the JWK thumbprint URI for this key. Args: hashalg: the IANA registered name for the hash alg to use Returns: the JWK thumbprint uri for this Jwk \"\"\" return ( f \"urn:ietf:params:oauth:jwk-thumbprint: { hashalg } : { self . thumbprint ( hashalg ) } \" ) @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): # pragma: no branch raise TypeError ( f \"Invalid alg type { type ( alg ) } \" , alg ) return alg def signature_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseSignatureAlg ]: \"\"\"Return the appropriate signature algorithm class (a `BaseSignatureAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseSignatureAlg` subclass \"\"\" return select_alg_class ( self . SIGNATURE_ALGORITHMS , jwk_alg = self . alg , alg = alg ) def encryption_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseAESEncryptionAlg ]: \"\"\"Return the appropriate encryption algorithm class (a `BaseAESEncryptionAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseAESEncryptionAlg` subclass \"\"\" return select_alg_class ( self . ENCRYPTION_ALGORITHMS , jwk_alg = self . alg , alg = alg ) def key_management_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseKeyManagementAlg ]: \"\"\"Return the appropriate key management algorithm class (a `BaseKeyManagementAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseKeyManagementAlg` subclass \"\"\" return select_alg_class ( self . KEY_MANAGEMENT_ALGORITHMS , jwk_alg = self . alg , alg = alg ) def signature_wrapper ( self , alg : Optional [ str ] = None ) -> BaseSignatureAlg : \"\"\"Initialize a key management wrapper (an instance of a `BaseKeyManagementAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseKeyManagementAlg` instance initialized with the current key \"\"\" alg_class = self . signature_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): return alg_class ( self . cryptography_key ) raise UnsupportedAlg ( alg ) # pragma: no cover def encryption_wrapper ( self , alg : Optional [ str ] = None ) -> BaseAESEncryptionAlg : \"\"\"Initialize an encryption wrapper (an instance of a `BaseAESEncryptionAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseAESEncryptionAlg` instance initialized with the current key \"\"\" alg_class = self . encryption_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): # pragma: no cover return alg_class ( self . cryptography_key ) # pragma: no cover raise UnsupportedAlg ( alg ) # pragma: no cover def key_management_wrapper ( self , alg : Optional [ str ] = None ) -> BaseKeyManagementAlg : \"\"\"Initialize a key management wrapper (an instance of a `BaseKeyManagementAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseKeyManagementAlg` instance initialized with the current key \"\"\" alg_class = self . key_management_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): return alg_class ( self . cryptography_key ) raise UnsupportedAlg ( alg ) # pragma: no cover @property def kid ( self ) -> Optional [ str ]: \"\"\"Return the JWK key ID (kid), if present.\"\"\" kid = self . get ( \"kid\" ) if kid is not None and not isinstance ( kid , str ): # pragma: no branch raise TypeError ( f \"invalid kid type { type ( kid ) } \" , kid ) return kid @cached_property def use ( self ) -> Optional [ str ]: \"\"\"Return the key use. If no `alg` parameter is present, this returns the `use` parameter from this JWK. If an `alg` parameter is present, the use is deduced from this alg. To check for the presence of the `use` parameter, use `jwk.get('use')`. \"\"\" if self . alg : return self . _get_alg_class ( self . alg ) . use else : return self . get ( \"use\" ) @cached_property def key_ops ( self ) -> Tuple [ str , ... ]: \"\"\"Return the key operations. If no `alg` parameter is present, this returns the `key_ops` parameter from this JWK. If an `alg` parameter is present, the key operations are deduced from this alg. To check for the presence of the `key_ops` parameter, use `jwk.get('key_ops')`. \"\"\" key_ops : Tuple [ str , ... ] if self . use == \"sig\" : if self . is_symmetric : key_ops = ( \"sign\" , \"verify\" ) elif self . is_private : key_ops = ( \"sign\" ,) else : key_ops = ( \"verify\" ,) elif self . use == \"enc\" : if self . is_symmetric : if self . alg : alg_class = self . _get_alg_class ( self . alg ) if issubclass ( alg_class , BaseKeyManagementAlg ): key_ops = ( \"wrapKey\" , \"unwrapKey\" ) elif issubclass ( alg_class , BaseAESEncryptionAlg ): key_ops = ( \"encrypt\" , \"decrypt\" ) else : key_ops = ( \"wrapKey\" , \"unwrapKey\" , \"encrypt\" , \"decrypt\" ) elif self . is_private : key_ops = ( \"unwrapKey\" ,) else : key_ops = ( \"wrapKey\" ,) else : key_ops = self . get ( \"key_ops\" , ()) return tuple ( key_ops ) def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : # pragma: no cover raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"unwrapKey\" ) and not self . is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } if \"key_ops\" in self : key_ops = list ( self . key_ops ) if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) else : key_ops = None return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) def sign ( self , data : Union [ bytes , SupportsBytes ], alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" wrapper = self . signature_wrapper ( alg ) signature = wrapper . sign ( data ) return BinaPy ( signature ) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" if not self . is_symmetric and self . is_private : warnings . warn ( \"You are trying to validate a signature with a private key. \" \"Signature should always be verified with a public key.\" ) public_jwk = self . public_jwk () else : public_jwk = self if algs is None and alg : algs = [ alg ] for alg in algs or ( None ,): wrapper = public_jwk . signature_wrapper ( alg ) if wrapper . verify ( data , signature ): return True return False def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext with Authenticated Encryption using this key. Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data (`aad`). This returns a tuple with 3 raw data, in order: - the encrypted Data - the Initialization Vector that was used to encrypt data - the generated Authentication Tag Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same. Returns: a tuple (ciphertext, iv, authentication_tag), as raw data \"\"\" raise NotImplementedError # pragma: no cover def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt iv: the Initialization Vector (IV) that was used for encryption tag: the Authentication Tag that will be verified while decrypting data aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover def sender_key ( self , enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]]: \"\"\"Used by encrypted token senders to produce a Content Encryption Key. Returns a tuple with 3 items: - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone! - the encrypted CEK, as bytes. You must send this to your recipient. This may be `None` for Key Management algs which derive a CEK instead of generating one. - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well. For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only do this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: a tuple (cek, wrapped_cek, additional_headers_map) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk if not self . is_symmetric and self . is_private : warnings . warn ( \"You are using a private key for sender key wrapping. Key wrapping should always be done using the recipient public key.\" ) key_alg_wrapper = self . public_jwk () . key_management_wrapper ( alg ) else : key_alg_wrapper = self . key_management_wrapper ( alg ) enc_alg_class = select_alg_class ( SymmetricJwk . ENCRYPTION_ALGORITHMS , alg = enc ) cek_headers : Dict [ str , Any ] = {} if isinstance ( key_alg_wrapper , BaseRsaKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key ( cek ) elif isinstance ( key_alg_wrapper , EcdhEs ): epk = epk or Jwk . from_cryptography_key ( key_alg_wrapper . generate_ephemeral_key () ) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( key_alg_wrapper , BaseEcdhEs_AesKw ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key_with_epk ( cek , epk . cryptography_key , alg = key_alg_wrapper . name , ** headers ) else : cek = key_alg_wrapper . sender_key ( epk . cryptography_key , alg = enc_alg_class . name , key_size = enc_alg_class . key_size , ** headers , ) wrapped_cek = BinaPy ( b \"\" ) elif isinstance ( key_alg_wrapper , BaseAesKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key ( cek ) elif isinstance ( key_alg_wrapper , BaseAesGcmKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek iv = key_alg_wrapper . generate_iv () wrapped_cek , tag = key_alg_wrapper . wrap_key ( cek , iv = iv ) cek_headers = { \"iv\" : iv . to ( \"b64u\" ) . ascii (), \"tag\" : tag . to ( \"b64u\" ) . ascii (), } elif isinstance ( key_alg_wrapper , DirectKeyUse ): cek = key_alg_wrapper . direct_key ( enc_alg_class ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { key_alg_wrapper } \" ) # pragma: no cover return SymmetricJwk . from_bytes ( cek ), wrapped_cek , cek_headers def recipient_key ( self , wrapped_cek : Union [ bytes , SupportsBytes ], enc : str , * , alg : Optional [ str ] = None , ** headers : Any , ) -> Jwk : \"\"\"Used by token recipients to obtain the CEK, which then allows decryption of the payload. Args: wrapped_cek: the wrapped CEK enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to unwrap the CEK **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk if not self . is_symmetric and not self . is_private : warnings . warn ( \"You are using a public key for recipient key unwrapping. Key wrapping should always be done using the recipient private key.\" ) key_alg_wrapper = self . key_management_wrapper ( alg ) enc_alg_class = select_alg_class ( SymmetricJwk . ENCRYPTION_ALGORITHMS , alg = enc ) if isinstance ( key_alg_wrapper , BaseRsaKeyWrap ): cek = key_alg_wrapper . unwrap_key ( wrapped_cek ) elif isinstance ( key_alg_wrapper , EcdhEs ): epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . cryptography_key if isinstance ( key_alg_wrapper , BaseEcdhEs_AesKw ): cek = key_alg_wrapper . unwrap_key_with_epk ( wrapped_cek , epk , alg = key_alg_wrapper . name ) else : cek = key_alg_wrapper . recipient_key ( epk , alg = enc_alg_class . name , key_size = enc_alg_class . key_size , ** headers , ) elif isinstance ( key_alg_wrapper , BaseAesKeyWrap ): cek = key_alg_wrapper . unwrap_key ( wrapped_cek ) elif isinstance ( key_alg_wrapper , BaseAesGcmKeyWrap ): iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = key_alg_wrapper . unwrap_key ( wrapped_cek , tag = tag , iv = iv ) elif isinstance ( key_alg_wrapper , DirectKeyUse ): cek = key_alg_wrapper . direct_key ( enc_alg_class ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { key_alg_wrapper } \" ) # pragma: no cover return SymmetricJwk . from_bytes ( cek ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key , ** kwargs ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) def _to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError @classmethod def from_pem_key ( cls , data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any , ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8. **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: a Jwk instance from the loaded key \"\"\" data = data . encode () if isinstance ( data , str ) else data password = password . encode ( \"UTF-8\" ) if isinstance ( password , str ) else password try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception as private_exc : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) from private_exc return cls . from_cryptography_key ( cryptography_key , ** kwargs ) def to_pem ( self , password : Union [ bytes , str , None ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. This password should be bytes. A `str` is also accepted, and will be encoded to `bytes` using UTF-8 before it is used as encryption key. Args: password: password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded with UTF-8. Returns: the PEM serialized key \"\"\" password = ( str ( password ) . encode ( \"UTF-8\" ) if isinstance ( password , str ) else password ) if self . is_private : encryption : serialization . KeySerializationEncryption if password : encryption = serialization . BestAvailableEncryption ( password ) else : encryption = serialization . NoEncryption () return self . cryptography_key . private_bytes ( # type: ignore[no-any-return] serialization . Encoding . PEM , serialization . PrivateFormat . PKCS8 , encryption , ) else : if password : raise ValueError ( \"Public keys cannot be encrypted when serialized in PEM format.\" ) return self . cryptography_key . public_bytes ( # type: ignore[no-any-return] serialization . Encoding . PEM , serialization . PublicFormat . SubjectPublicKeyInfo , ) @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generate a Private Key and return it as a `Jwk` instance. This method is implemented by subclasses for specific Key Types and returns an instance of that subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs ) @classmethod def generate_for_alg ( cls , alg : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key for usage with a specific alg and return the resulting Jwk. Args: alg: a signature or key management alg **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk \"\"\" for kty , jwk_class in cls . subclasses . items (): alg_class : Optional [ Type [ BaseAlg ]] try : alg_class = jwk_class . _get_alg_class ( alg ) if issubclass ( jwk_class , BaseAESEncryptionAlg ): kwargs . setdefault ( \"key_size\" , alg_class . key_size ) return jwk_class . generate ( alg = alg , ** kwargs ) except UnsupportedAlg : continue raise UnsupportedAlg ( alg ) def copy ( self ) -> Jwk : \"\"\"Creates a copy of this key. Returns: a copy of this key, with the same value \"\"\" return Jwk ( super () . copy ()) def with_kid_thumbprint ( self , force : bool = False ) -> Jwk : \"\"\"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if `force` is `True`, this erases the previous \"kid\". - if `force` is `False` (default), do nothing. Args: force: whether to overwrite a previously existing kid Returns: a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`). \"\"\" if self . get ( \"kid\" ) is not None and not force : return self jwk = self . copy () jwk [ \"kid\" ] = self . thumbprint () return jwk def with_usage_parameters ( self , alg : Optional [ str ] = None , with_alg : bool = True , with_use : bool = True , with_key_ops : bool = True , ) -> Jwk : \"\"\"Copy this Jwk and add the `use` and `key_ops` parameters. The returned jwk `alg` parameter will be the one passed as parameter to this method, or as dfault the one declared as `alg` parameter in this Jwk. The `use` (Public Key Use) param is deduced based on this `alg` value. The `key_ops` (Key Operations) param is deduced based on the key `use` and if the key is public, private, or symmetric. Args: alg: the alg to use, if not present in this Jwk with_alg: whether to include an `alg` parameter with_use: whether to include a `use` parameter with_key_ops: whether to include a `key_ops` parameter Returns: a Jwk with the same key, with `alg`, `use` and `key_ops` parameters. \"\"\" alg = alg or self . alg if not alg : raise ExpectedAlgRequired ( \"An algorithm is required to set the usage parameters\" ) self . _get_alg_class ( alg ) # raises an exception if alg is not supported jwk = self . copy () if with_alg : jwk [ \"alg\" ] = alg if with_use : jwk [ \"use\" ] = jwk . use if with_key_ops : jwk [ \"key_ops\" ] = jwk . key_ops return jwk def minimize ( self ) -> Jwk : \"\"\"Strips out any optional or non-standard parameter from that key. This will remove `alg`, `use`, `key_ops`, optional parameters from RSA keys, and other unknown parameters. \"\"\" jwk = self . copy () for key in self . keys (): if key == \"kty\" or key in self . PARAMS and self . PARAMS [ key ] . is_required : continue del jwk [ key ] return jwk def check ( self , * , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None , kty : Optional [ str ] = None , ) -> Jwk : \"\"\"Check this key for type, privateness and/or symmetricness. Raise a ValueError if it not as expected. Args: is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing kty: the expected key type, if any Returns: this key, if all checks passed Raises: ValueError: if any check fails \"\"\" if is_private is not None : if is_private is True and self . is_private is False : raise ValueError ( \"This key is public while a private key is expected.\" ) elif is_private is False and self . is_private is True : raise ValueError ( \"This key is private while a public key is expected.\" ) if is_symmetric is not None : if is_symmetric is True and self . is_symmetric is False : raise ValueError ( \"This key is asymmetric while a symmetric key is expected.\" ) if is_symmetric is False and self . is_symmetric is True : raise ValueError ( \"This key is symmetric while an asymmetric key is expected.\" ) if kty is not None : if self . kty != kty : raise ValueError ( f \"This key has kty= { self . kty } while a kty= { kty } is expected.\" ) return self subclasses class-attribute \u00b6 1 subclasses : Dict [ str , Type [ Jwk ]] = {} A dict of 'kty' values to subclasses implementing each specific Key Type cryptography_key_types class-attribute \u00b6 1 cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} A dict of cryptography key classes to its specific 'kty' value PARAMS class-attribute \u00b6 1 PARAMS : Mapping [ str , JwkParameter ] A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind) KTY class-attribute \u00b6 1 KTY : ClassVar [ str ] The Key Type associated with this JWK. __init_subclass__ \u00b6 1 __init_subclass__ () -> None Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk. Source code in jwskate/jwk/base.py 111 112 113 114 115 116 117 118 119 120 def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows `__new__` to pick the appropriate subclass when creating a Jwk. \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_PRIVATE_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls for klass in cls . CRYPTOGRAPHY_PUBLIC_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls __new__ \u00b6 1 2 3 __new__ ( key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ) Overridden __new__ to make the Jwk constructor smarter. The Jwk constructor will accept a dict with the parsed Jwk content another Jwk, which will be used as-is instead of creating a copy an instance from a cryptography public or private key class Parameters: Name Type Description Default key Union [ Jwk , Dict [ str , Any ], Any ] a dict containing JWK parameters, or another Jwk instance, or a cryptography key required **kwargs Any additional members to include in the Jwk {} Source code in jwskate/jwk/base.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def __new__ ( cls , key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key **kwargs: additional members to include in the Jwk \"\"\" if cls == Jwk : if isinstance ( key , Jwk ): return cls . from_cryptography_key ( key . cryptography_key , ** kwargs ) if isinstance ( key , dict ): kty : Optional [ str ] = key . get ( \"kty\" ) if kty is None : raise InvalidJwk ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise InvalidJwk ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) elif isinstance ( key , str ): return cls . from_json ( key ) else : return cls . from_cryptography_key ( key , ** kwargs ) return super () . __new__ ( cls , key , ** kwargs ) _get_alg_class classmethod \u00b6 1 _get_alg_class ( alg : str ) -> Type [ BaseAlg ] Given an alg identifier, return the matching JWA wrapper. Parameters: Name Type Description Default alg str an alg identifier required Returns: Type Description Type [ BaseAlg ] the matching JWA wrapper Source code in jwskate/jwk/base.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @classmethod def _get_alg_class ( cls , alg : str ) -> Type [ BaseAlg ]: \"\"\"Given an alg identifier, return the matching JWA wrapper. Args: alg: an alg identifier Returns: the matching JWA wrapper \"\"\" alg_class : Optional [ Type [ BaseAlg ]] alg_class = cls . SIGNATURE_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class alg_class = cls . KEY_MANAGEMENT_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class alg_class = cls . ENCRYPTION_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class raise UnsupportedAlg ( alg ) is_private property \u00b6 1 is_private () -> bool Return True if the key is private, False otherwise. Returns: Type Description bool True if the key is private, False otherwise Source code in jwskate/jwk/base.py 197 198 199 200 201 202 203 204 @property def is_private ( self ) -> bool : \"\"\"Return `True` if the key is private, `False` otherwise. Returns: `True` if the key is private, `False` otherwise \"\"\" return True is_symmetric property \u00b6 1 is_symmetric () -> bool Return True if the key is symmetric, False otherwise. Source code in jwskate/jwk/base.py 206 207 208 209 @property def is_symmetric ( self ) -> bool : \"\"\"Return `True` if the key is symmetric, `False` otherwise.\"\"\" return False __getattr__ \u00b6 1 __getattr__ ( param : str ) -> Any Allow access to key parameters as attributes. This is a convenience to allow jwk.param instead of jwk['param'] . Parameters: Name Type Description Default param str the parameter name to access required Return the param value Raises: Type Description AttributeError if the param is not found Source code in jwskate/jwk/base.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def __getattr__ ( self , param : str ) -> Any : \"\"\"Allow access to key parameters as attributes. This is a convenience to allow `jwk.param` instead of `jwk['param']`. Args: param: the parameter name to access Return: the param value Raises: AttributeError: if the param is not found \"\"\" value = self . get ( param ) if value is None : raise AttributeError ( param ) return value __setitem__ \u00b6 1 __setitem__ ( key : str , value : Any ) -> None Override base method to avoid modifying cryptographic key attributes. Parameters: Name Type Description Default key str name of the attribute to set required value Any value to set required Raises: Type Description RuntimeError when trying to modify cryptographic attributes Source code in jwskate/jwk/base.py 230 231 232 233 234 235 236 237 238 239 240 241 242 def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Override base method to avoid modifying cryptographic key attributes. Args: key: name of the attribute to set value: value to set Raises: RuntimeError: when trying to modify cryptographic attributes \"\"\" if key in self . PARAMS : raise RuntimeError ( \"JWK key attributes cannot be modified.\" ) super () . __setitem__ ( key , value ) thumbprint \u00b6 1 thumbprint ( hashalg : str = 'sha-256' ) -> str Return the key thumbprint as specified by RFC 7638. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'sha-256' Returns: Type Description str the calculated thumbprint Source code in jwskate/jwk/base.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def thumbprint ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" alg = self . IANA_HASH_FUNCTION_NAMES . get ( hashalg ) if not alg : raise ValueError ( f \"Unsupported hash alg { hashalg } \" ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) return ( BinaPy . serialize_to ( \"json\" , t , separators = ( \",\" , \":\" ), sort_keys = True ) . to ( alg ) . to ( \"b64u\" ) . ascii () ) thumbprint_uri \u00b6 1 thumbprint_uri ( hashalg : str = 'sha-256' ) -> str Returns the JWK thumbprint URI for this key. Parameters: Name Type Description Default hashalg str the IANA registered name for the hash alg to use 'sha-256' Returns: Type Description str the JWK thumbprint uri for this Jwk Source code in jwskate/jwk/base.py 269 270 271 272 273 274 275 276 277 278 279 280 def thumbprint_uri ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Returns the JWK thumbprint URI for this key. Args: hashalg: the IANA registered name for the hash alg to use Returns: the JWK thumbprint uri for this Jwk \"\"\" return ( f \"urn:ietf:params:oauth:jwk-thumbprint: { hashalg } : { self . thumbprint ( hashalg ) } \" ) kty property \u00b6 1 kty () -> str Return the Key Type. Returns: Type Description str the key type Source code in jwskate/jwk/base.py 282 283 284 285 286 287 288 289 @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY alg property \u00b6 1 alg () -> Optional [ str ] Return the configured key alg, if any. Returns: Type Description Optional [ str ] the key alg Source code in jwskate/jwk/base.py 291 292 293 294 295 296 297 298 299 300 301 @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): # pragma: no branch raise TypeError ( f \"Invalid alg type { type ( alg ) } \" , alg ) return alg signature_class \u00b6 1 2 3 signature_class ( alg : Optional [ str ] = None , ) -> Type [ BaseSignatureAlg ] Return the appropriate signature algorithm class (a BaseSignatureAlg subclass) to use with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description Type [ BaseSignatureAlg ] the appropriate BaseSignatureAlg subclass Source code in jwskate/jwk/base.py 303 304 305 306 307 308 309 310 311 312 313 314 def signature_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseSignatureAlg ]: \"\"\"Return the appropriate signature algorithm class (a `BaseSignatureAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseSignatureAlg` subclass \"\"\" return select_alg_class ( self . SIGNATURE_ALGORITHMS , jwk_alg = self . alg , alg = alg ) encryption_class \u00b6 1 2 3 encryption_class ( alg : Optional [ str ] = None , ) -> Type [ BaseAESEncryptionAlg ] Return the appropriate encryption algorithm class (a BaseAESEncryptionAlg subclass) to use with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description Type [ BaseAESEncryptionAlg ] the appropriate BaseAESEncryptionAlg subclass Source code in jwskate/jwk/base.py 316 317 318 319 320 321 322 323 324 325 326 327 def encryption_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseAESEncryptionAlg ]: \"\"\"Return the appropriate encryption algorithm class (a `BaseAESEncryptionAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseAESEncryptionAlg` subclass \"\"\" return select_alg_class ( self . ENCRYPTION_ALGORITHMS , jwk_alg = self . alg , alg = alg ) key_management_class \u00b6 1 2 3 key_management_class ( alg : Optional [ str ] = None , ) -> Type [ BaseKeyManagementAlg ] Return the appropriate key management algorithm class (a BaseKeyManagementAlg subclass) to use with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description Type [ BaseKeyManagementAlg ] the appropriate BaseKeyManagementAlg subclass Source code in jwskate/jwk/base.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 def key_management_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseKeyManagementAlg ]: \"\"\"Return the appropriate key management algorithm class (a `BaseKeyManagementAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseKeyManagementAlg` subclass \"\"\" return select_alg_class ( self . KEY_MANAGEMENT_ALGORITHMS , jwk_alg = self . alg , alg = alg ) signature_wrapper \u00b6 1 2 3 signature_wrapper ( alg : Optional [ str ] = None , ) -> BaseSignatureAlg Initialize a key management wrapper (an instance of a BaseKeyManagementAlg subclass) with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description BaseSignatureAlg a BaseKeyManagementAlg instance initialized with the current key Source code in jwskate/jwk/base.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def signature_wrapper ( self , alg : Optional [ str ] = None ) -> BaseSignatureAlg : \"\"\"Initialize a key management wrapper (an instance of a `BaseKeyManagementAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseKeyManagementAlg` instance initialized with the current key \"\"\" alg_class = self . signature_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): return alg_class ( self . cryptography_key ) raise UnsupportedAlg ( alg ) # pragma: no cover encryption_wrapper \u00b6 1 2 3 encryption_wrapper ( alg : Optional [ str ] = None , ) -> BaseAESEncryptionAlg Initialize an encryption wrapper (an instance of a BaseAESEncryptionAlg subclass) with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description BaseAESEncryptionAlg a BaseAESEncryptionAlg instance initialized with the current key Source code in jwskate/jwk/base.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def encryption_wrapper ( self , alg : Optional [ str ] = None ) -> BaseAESEncryptionAlg : \"\"\"Initialize an encryption wrapper (an instance of a `BaseAESEncryptionAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseAESEncryptionAlg` instance initialized with the current key \"\"\" alg_class = self . encryption_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): # pragma: no cover return alg_class ( self . cryptography_key ) # pragma: no cover raise UnsupportedAlg ( alg ) # pragma: no cover key_management_wrapper \u00b6 1 2 3 key_management_wrapper ( alg : Optional [ str ] = None , ) -> BaseKeyManagementAlg Initialize a key management wrapper (an instance of a BaseKeyManagementAlg subclass) with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description BaseKeyManagementAlg a BaseKeyManagementAlg instance initialized with the current key Source code in jwskate/jwk/base.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def key_management_wrapper ( self , alg : Optional [ str ] = None ) -> BaseKeyManagementAlg : \"\"\"Initialize a key management wrapper (an instance of a `BaseKeyManagementAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseKeyManagementAlg` instance initialized with the current key \"\"\" alg_class = self . key_management_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): return alg_class ( self . cryptography_key ) raise UnsupportedAlg ( alg ) # pragma: no cover kid property \u00b6 1 kid () -> Optional [ str ] Return the JWK key ID (kid), if present. Source code in jwskate/jwk/base.py 400 401 402 403 404 405 406 @property def kid ( self ) -> Optional [ str ]: \"\"\"Return the JWK key ID (kid), if present.\"\"\" kid = self . get ( \"kid\" ) if kid is not None and not isinstance ( kid , str ): # pragma: no branch raise TypeError ( f \"invalid kid type { type ( kid ) } \" , kid ) return kid use \u00b6 1 use () -> Optional [ str ] Return the key use. If no alg parameter is present, this returns the use parameter from this JWK. If an alg parameter is present, the use is deduced from this alg. To check for the presence of the use parameter, use jwk.get('use') . Source code in jwskate/jwk/base.py 408 409 410 411 412 413 414 415 416 417 418 419 @cached_property def use ( self ) -> Optional [ str ]: \"\"\"Return the key use. If no `alg` parameter is present, this returns the `use` parameter from this JWK. If an `alg` parameter is present, the use is deduced from this alg. To check for the presence of the `use` parameter, use `jwk.get('use')`. \"\"\" if self . alg : return self . _get_alg_class ( self . alg ) . use else : return self . get ( \"use\" ) key_ops \u00b6 1 key_ops () -> Tuple [ str , ... ] Return the key operations. If no alg parameter is present, this returns the key_ops parameter from this JWK. If an alg parameter is present, the key operations are deduced from this alg. To check for the presence of the key_ops parameter, use jwk.get('key_ops') . Source code in jwskate/jwk/base.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 @cached_property def key_ops ( self ) -> Tuple [ str , ... ]: \"\"\"Return the key operations. If no `alg` parameter is present, this returns the `key_ops` parameter from this JWK. If an `alg` parameter is present, the key operations are deduced from this alg. To check for the presence of the `key_ops` parameter, use `jwk.get('key_ops')`. \"\"\" key_ops : Tuple [ str , ... ] if self . use == \"sig\" : if self . is_symmetric : key_ops = ( \"sign\" , \"verify\" ) elif self . is_private : key_ops = ( \"sign\" ,) else : key_ops = ( \"verify\" ,) elif self . use == \"enc\" : if self . is_symmetric : if self . alg : alg_class = self . _get_alg_class ( self . alg ) if issubclass ( alg_class , BaseKeyManagementAlg ): key_ops = ( \"wrapKey\" , \"unwrapKey\" ) elif issubclass ( alg_class , BaseAESEncryptionAlg ): key_ops = ( \"encrypt\" , \"decrypt\" ) else : key_ops = ( \"wrapKey\" , \"unwrapKey\" , \"encrypt\" , \"decrypt\" ) elif self . is_private : key_ops = ( \"unwrapKey\" ,) else : key_ops = ( \"wrapKey\" ,) else : key_ops = self . get ( \"key_ops\" , ()) return tuple ( key_ops ) _validate \u00b6 1 _validate () -> None Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the is_private flag to True . Raises: Type Description TypeError if the key type doesn't match the subclass InvalidJwk if the JWK misses required members or has invalid members Source code in jwskate/jwk/base.py 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : # pragma: no cover raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"unwrapKey\" ) and not self . is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) supported_signing_algorithms \u00b6 1 supported_signing_algorithms () -> List [ str ] Return the list of Signature algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 518 519 520 521 522 523 524 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) supported_key_management_algorithms \u00b6 1 supported_key_management_algorithms () -> List [ str ] Return the list of Key Management algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 526 527 528 529 530 531 532 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) supported_encryption_algorithms \u00b6 1 supported_encryption_algorithms () -> List [ str ] Return the list of Encryption algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 534 535 536 537 538 539 540 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) public_jwk \u00b6 1 public_jwk () -> Jwk Return the public Jwk associated with this key. Returns: Type Description Jwk a Jwk with the public key Source code in jwskate/jwk/base.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } if \"key_ops\" in self : key_ops = list ( self . key_ops ) if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) else : key_ops = None return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) as_jwks \u00b6 1 as_jwks () -> JwkSet Return a JwkSet with this key as single element. Returns: Type Description JwkSet a JwsSet with this single key Source code in jwskate/jwk/base.py 579 580 581 582 583 584 585 586 587 def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) sign \u00b6 1 2 3 4 sign ( data : Union [ bytes , SupportsBytes ], alg : Optional [ str ] = None , ) -> BinaPy Sign a data using this Jwk, and return the generated signature. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the data to sign required alg Optional [ str ] the alg to use (if this key doesn't have an alg parameter) None Returns: Type Description BinaPy the generated signature Source code in jwskate/jwk/base.py 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def sign ( self , data : Union [ bytes , SupportsBytes ], alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" wrapper = self . signature_wrapper ( alg ) signature = wrapper . sign ( data ) return BinaPy ( signature ) verify \u00b6 1 2 3 4 5 6 7 verify ( data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> bool Verify a signature using this Jwk, and return True if valid. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the data to verify required signature Union [ bytes , SupportsBytes ] the signature to verify required alg Optional [ str ] the allowed signature alg, if there is only one None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate/jwk/base.py 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" if not self . is_symmetric and self . is_private : warnings . warn ( \"You are trying to validate a signature with a private key. \" \"Signature should always be verified with a public key.\" ) public_jwk = self . public_jwk () else : public_jwk = self if algs is None and alg : algs = [ alg ] for alg in algs or ( None ,): wrapper = public_jwk . signature_wrapper ( alg ) if wrapper . verify ( data , signature ): return True return False encrypt \u00b6 1 2 3 4 5 6 7 encrypt ( plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None ) -> Tuple [ BinaPy , BinaPy , BinaPy ] Encrypt a plaintext with Authenticated Encryption using this key. Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data ( aad ). This returns a tuple with 3 raw data, in order: - the encrypted Data - the Initialization Vector that was used to encrypt data - the generated Authentication Tag Parameters: Name Type Description Default plaintext Union [ bytes , SupportsBytes ] the data to encrypt. required aad Optional [ bytes ] the Additional Authenticated Data (AAD) to include in the authentication tag None alg Optional [ str ] the alg to use to encrypt the data None iv Optional [ bytes ] the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same. None Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a tuple (ciphertext, iv, authentication_tag), as raw data Source code in jwskate/jwk/base.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext with Authenticated Encryption using this key. Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data (`aad`). This returns a tuple with 3 raw data, in order: - the encrypted Data - the Initialization Vector that was used to encrypt data - the generated Authentication Tag Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same. Returns: a tuple (ciphertext, iv, authentication_tag), as raw data \"\"\" raise NotImplementedError # pragma: no cover decrypt \u00b6 1 2 3 4 5 6 7 8 decrypt ( ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None ) -> BinaPy Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Parameters: Name Type Description Default ciphertext Union [ bytes , SupportsBytes ] the data to decrypt required iv Union [ bytes , SupportsBytes ] the Initialization Vector (IV) that was used for encryption required tag Union [ bytes , SupportsBytes ] the Authentication Tag that will be verified while decrypting data required aad Union [ bytes , SupportsBytes , None] the Additional Authentication Data (AAD) to verify the Tag against None alg Optional [ str ] the alg to use for decryption None Returns: Type Description BinaPy the clear-text data Source code in jwskate/jwk/base.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt iv: the Initialization Vector (IV) that was used for encryption tag: the Authentication Tag that will be verified while decrypting data aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover sender_key \u00b6 1 2 3 4 5 6 7 8 sender_key ( enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]] Used by encrypted token senders to produce a Content Encryption Key. Returns a tuple with 3 items: the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone! the encrypted CEK, as bytes. You must send this to your recipient. This may be None for Key Management algs which derive a CEK instead of generating one. extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well. For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead of letting jwskate generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting jwskate generate an appropriate value for you. Only do this if you know what you are doing! Parameters: Name Type Description Default enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to produce the CEK None cek Optional [ bytes ] CEK to use (leave None to have an adequate random value generated automatically) None epk Optional [ Jwk ] EPK to use (leave None to have an adequate ephemeral key generated automatically) None **headers Any additional headers to include for the CEK derivation {} Returns: Type Description Tuple [ Jwk , BinaPy , Mapping [ str , Any ]] a tuple (cek, wrapped_cek, additional_headers_map) Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate/jwk/base.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 def sender_key ( self , enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]]: \"\"\"Used by encrypted token senders to produce a Content Encryption Key. Returns a tuple with 3 items: - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone! - the encrypted CEK, as bytes. You must send this to your recipient. This may be `None` for Key Management algs which derive a CEK instead of generating one. - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well. For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only do this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: a tuple (cek, wrapped_cek, additional_headers_map) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk if not self . is_symmetric and self . is_private : warnings . warn ( \"You are using a private key for sender key wrapping. Key wrapping should always be done using the recipient public key.\" ) key_alg_wrapper = self . public_jwk () . key_management_wrapper ( alg ) else : key_alg_wrapper = self . key_management_wrapper ( alg ) enc_alg_class = select_alg_class ( SymmetricJwk . ENCRYPTION_ALGORITHMS , alg = enc ) cek_headers : Dict [ str , Any ] = {} if isinstance ( key_alg_wrapper , BaseRsaKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key ( cek ) elif isinstance ( key_alg_wrapper , EcdhEs ): epk = epk or Jwk . from_cryptography_key ( key_alg_wrapper . generate_ephemeral_key () ) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( key_alg_wrapper , BaseEcdhEs_AesKw ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key_with_epk ( cek , epk . cryptography_key , alg = key_alg_wrapper . name , ** headers ) else : cek = key_alg_wrapper . sender_key ( epk . cryptography_key , alg = enc_alg_class . name , key_size = enc_alg_class . key_size , ** headers , ) wrapped_cek = BinaPy ( b \"\" ) elif isinstance ( key_alg_wrapper , BaseAesKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key ( cek ) elif isinstance ( key_alg_wrapper , BaseAesGcmKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek iv = key_alg_wrapper . generate_iv () wrapped_cek , tag = key_alg_wrapper . wrap_key ( cek , iv = iv ) cek_headers = { \"iv\" : iv . to ( \"b64u\" ) . ascii (), \"tag\" : tag . to ( \"b64u\" ) . ascii (), } elif isinstance ( key_alg_wrapper , DirectKeyUse ): cek = key_alg_wrapper . direct_key ( enc_alg_class ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { key_alg_wrapper } \" ) # pragma: no cover return SymmetricJwk . from_bytes ( cek ), wrapped_cek , cek_headers recipient_key \u00b6 1 2 3 4 5 6 7 recipient_key ( wrapped_cek : Union [ bytes , SupportsBytes ], enc : str , * , alg : Optional [ str ] = None , ** headers : Any ) -> Jwk Used by token recipients to obtain the CEK, which then allows decryption of the payload. Parameters: Name Type Description Default wrapped_cek Union [ bytes , SupportsBytes ] the wrapped CEK required enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to unwrap the CEK None **headers Any additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) {} Returns: Type Description Jwk the clear-text CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate/jwk/base.py 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 def recipient_key ( self , wrapped_cek : Union [ bytes , SupportsBytes ], enc : str , * , alg : Optional [ str ] = None , ** headers : Any , ) -> Jwk : \"\"\"Used by token recipients to obtain the CEK, which then allows decryption of the payload. Args: wrapped_cek: the wrapped CEK enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to unwrap the CEK **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk if not self . is_symmetric and not self . is_private : warnings . warn ( \"You are using a public key for recipient key unwrapping. Key wrapping should always be done using the recipient private key.\" ) key_alg_wrapper = self . key_management_wrapper ( alg ) enc_alg_class = select_alg_class ( SymmetricJwk . ENCRYPTION_ALGORITHMS , alg = enc ) if isinstance ( key_alg_wrapper , BaseRsaKeyWrap ): cek = key_alg_wrapper . unwrap_key ( wrapped_cek ) elif isinstance ( key_alg_wrapper , EcdhEs ): epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . cryptography_key if isinstance ( key_alg_wrapper , BaseEcdhEs_AesKw ): cek = key_alg_wrapper . unwrap_key_with_epk ( wrapped_cek , epk , alg = key_alg_wrapper . name ) else : cek = key_alg_wrapper . recipient_key ( epk , alg = enc_alg_class . name , key_size = enc_alg_class . key_size , ** headers , ) elif isinstance ( key_alg_wrapper , BaseAesKeyWrap ): cek = key_alg_wrapper . unwrap_key ( wrapped_cek ) elif isinstance ( key_alg_wrapper , BaseAesGcmKeyWrap ): iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = key_alg_wrapper . unwrap_key ( wrapped_cek , tag = tag , iv = iv ) elif isinstance ( key_alg_wrapper , DirectKeyUse ): cek = key_alg_wrapper . direct_key ( enc_alg_class ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { key_alg_wrapper } \" ) # pragma: no cover return SymmetricJwk . from_bytes ( cek ) from_cryptography_key classmethod \u00b6 1 2 3 from_cryptography_key ( cryptography_key : Any , ** kwargs : Any ) -> Jwk Initialize a Jwk from a key from the cryptography library. The input key can be any private or public key supported by cryptography. Parameters: Name Type Description Default cryptography_key Any a cryptography key instance required **kwargs Any additional members to include in the Jwk (e.g. kid, use) {} Returns: Type Description Jwk the matching Jwk instance Raises: Type Description TypeError if the key type is not supported Source code in jwskate/jwk/base.py 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key , ** kwargs ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) _to_cryptography_key \u00b6 1 _to_cryptography_key () -> Any Return a key from the cryptography library that matches this Jwk. This is implemented by subclasses. Returns: Type Description Any a cryptography key instance initialized from the current key Source code in jwskate/jwk/base.py 907 908 909 910 911 912 913 914 915 def _to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError from_pem_key classmethod \u00b6 1 2 3 4 5 from_pem_key ( data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any ) -> Jwk Load a Jwk from a PEM encoded private or public key. Parameters: Name Type Description Default data Union [ bytes , str ] the PEM encoded data to load required password Union [ bytes , str , None] the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8. None **kwargs Any additional members to include in the Jwk (e.g. kid, use) {} Returns: Type Description Jwk a Jwk instance from the loaded key Source code in jwskate/jwk/base.py 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 @classmethod def from_pem_key ( cls , data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any , ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8. **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: a Jwk instance from the loaded key \"\"\" data = data . encode () if isinstance ( data , str ) else data password = password . encode ( \"UTF-8\" ) if isinstance ( password , str ) else password try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception as private_exc : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) from private_exc return cls . from_cryptography_key ( cryptography_key , ** kwargs ) to_pem \u00b6 1 to_pem ( password : Union [ bytes , str , None ] = None ) -> bytes Serialize this key to PEM format. For private keys, you can provide a password for encryption. This password should be bytes. A str is also accepted, and will be encoded to bytes using UTF-8 before it is used as encryption key. Parameters: Name Type Description Default password Union [ bytes , str , None] password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded with UTF-8. None Returns: Type Description bytes the PEM serialized key Source code in jwskate/jwk/base.py 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 def to_pem ( self , password : Union [ bytes , str , None ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. This password should be bytes. A `str` is also accepted, and will be encoded to `bytes` using UTF-8 before it is used as encryption key. Args: password: password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded with UTF-8. Returns: the PEM serialized key \"\"\" password = ( str ( password ) . encode ( \"UTF-8\" ) if isinstance ( password , str ) else password ) if self . is_private : encryption : serialization . KeySerializationEncryption if password : encryption = serialization . BestAvailableEncryption ( password ) else : encryption = serialization . NoEncryption () return self . cryptography_key . private_bytes ( # type: ignore[no-any-return] serialization . Encoding . PEM , serialization . PrivateFormat . PKCS8 , encryption , ) else : if password : raise ValueError ( \"Public keys cannot be encrypted when serialized in PEM format.\" ) return self . cryptography_key . public_bytes ( # type: ignore[no-any-return] serialization . Encoding . PEM , serialization . PublicFormat . SubjectPublicKeyInfo , ) generate classmethod \u00b6 1 generate ( ** kwargs : Any ) -> Jwk Generate a Private Key and return it as a Jwk instance. This method is implemented by subclasses for specific Key Types and returns an instance of that subclass. Parameters: Name Type Description Default **kwargs Any specific parameters depending on the type of key, or additional members to include in the Jwk {} Returns: Type Description Jwk a Jwk instance with a generated key Source code in jwskate/jwk/base.py 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generate a Private Key and return it as a `Jwk` instance. This method is implemented by subclasses for specific Key Types and returns an instance of that subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError generate_for_kty classmethod \u00b6 1 generate_for_kty ( kty : str , ** kwargs : Any ) -> Jwk Generate a key with a specific type and return the resulting Jwk. Parameters: Name Type Description Default kty str key type to generate required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Raises: Type Description UnsupportedKeyType if the key type is not supported Source code in jwskate/jwk/base.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs ) generate_for_alg classmethod \u00b6 1 generate_for_alg ( alg : str , ** kwargs : Any ) -> Jwk Generate a key for usage with a specific alg and return the resulting Jwk. Parameters: Name Type Description Default alg str a signature or key management alg required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Source code in jwskate/jwk/base.py 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 @classmethod def generate_for_alg ( cls , alg : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key for usage with a specific alg and return the resulting Jwk. Args: alg: a signature or key management alg **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk \"\"\" for kty , jwk_class in cls . subclasses . items (): alg_class : Optional [ Type [ BaseAlg ]] try : alg_class = jwk_class . _get_alg_class ( alg ) if issubclass ( jwk_class , BaseAESEncryptionAlg ): kwargs . setdefault ( \"key_size\" , alg_class . key_size ) return jwk_class . generate ( alg = alg , ** kwargs ) except UnsupportedAlg : continue raise UnsupportedAlg ( alg ) copy \u00b6 1 copy () -> Jwk Creates a copy of this key. Returns: Type Description Jwk a copy of this key, with the same value Source code in jwskate/jwk/base.py 1048 1049 1050 1051 1052 1053 1054 def copy ( self ) -> Jwk : \"\"\"Creates a copy of this key. Returns: a copy of this key, with the same value \"\"\" return Jwk ( super () . copy ()) with_kid_thumbprint \u00b6 1 with_kid_thumbprint ( force : bool = False ) -> Jwk Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if force is True , this erases the previous \"kid\". - if force is False (default), do nothing. Parameters: Name Type Description Default force bool whether to overwrite a previously existing kid False Returns: Type Description Jwk a copy of this key with a \"kid\" (either the previous one or the existing one, depending on force ). Source code in jwskate/jwk/base.py 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def with_kid_thumbprint ( self , force : bool = False ) -> Jwk : \"\"\"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if `force` is `True`, this erases the previous \"kid\". - if `force` is `False` (default), do nothing. Args: force: whether to overwrite a previously existing kid Returns: a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`). \"\"\" if self . get ( \"kid\" ) is not None and not force : return self jwk = self . copy () jwk [ \"kid\" ] = self . thumbprint () return jwk with_usage_parameters \u00b6 1 2 3 4 5 6 with_usage_parameters ( alg : Optional [ str ] = None , with_alg : bool = True , with_use : bool = True , with_key_ops : bool = True , ) -> Jwk Copy this Jwk and add the use and key_ops parameters. The returned jwk alg parameter will be the one passed as parameter to this method, or as dfault the one declared as alg parameter in this Jwk. The use (Public Key Use) param is deduced based on this alg value. The key_ops (Key Operations) param is deduced based on the key use and if the key is public, private, or symmetric. Parameters: Name Type Description Default alg Optional [ str ] the alg to use, if not present in this Jwk None with_alg bool whether to include an alg parameter True with_use bool whether to include a use parameter True with_key_ops bool whether to include a key_ops parameter True Returns: Type Description Jwk a Jwk with the same key, with alg , use and key_ops parameters. Source code in jwskate/jwk/base.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 def with_usage_parameters ( self , alg : Optional [ str ] = None , with_alg : bool = True , with_use : bool = True , with_key_ops : bool = True , ) -> Jwk : \"\"\"Copy this Jwk and add the `use` and `key_ops` parameters. The returned jwk `alg` parameter will be the one passed as parameter to this method, or as dfault the one declared as `alg` parameter in this Jwk. The `use` (Public Key Use) param is deduced based on this `alg` value. The `key_ops` (Key Operations) param is deduced based on the key `use` and if the key is public, private, or symmetric. Args: alg: the alg to use, if not present in this Jwk with_alg: whether to include an `alg` parameter with_use: whether to include a `use` parameter with_key_ops: whether to include a `key_ops` parameter Returns: a Jwk with the same key, with `alg`, `use` and `key_ops` parameters. \"\"\" alg = alg or self . alg if not alg : raise ExpectedAlgRequired ( \"An algorithm is required to set the usage parameters\" ) self . _get_alg_class ( alg ) # raises an exception if alg is not supported jwk = self . copy () if with_alg : jwk [ \"alg\" ] = alg if with_use : jwk [ \"use\" ] = jwk . use if with_key_ops : jwk [ \"key_ops\" ] = jwk . key_ops return jwk minimize \u00b6 1 minimize () -> Jwk Strips out any optional or non-standard parameter from that key. This will remove alg , use , key_ops , optional parameters from RSA keys, and other unknown parameters. Source code in jwskate/jwk/base.py 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 def minimize ( self ) -> Jwk : \"\"\"Strips out any optional or non-standard parameter from that key. This will remove `alg`, `use`, `key_ops`, optional parameters from RSA keys, and other unknown parameters. \"\"\" jwk = self . copy () for key in self . keys (): if key == \"kty\" or key in self . PARAMS and self . PARAMS [ key ] . is_required : continue del jwk [ key ] return jwk check \u00b6 1 2 3 4 5 6 check ( * , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None , kty : Optional [ str ] = None ) -> Jwk Check this key for type, privateness and/or symmetricness. Raise a ValueError if it not as expected. Parameters: Name Type Description Default is_private Optional [ bool ] if True , check if the key is private, if False , check if it is public, if None , do nothing None is_symmetric Optional [ bool ] if True , check if the key is symmetric, if False , check if it is asymmetric, if None , do nothing None kty Optional [ str ] the expected key type, if any None Returns: Type Description Jwk this key, if all checks passed Raises: Type Description ValueError if any check fails Source code in jwskate/jwk/base.py 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 def check ( self , * , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None , kty : Optional [ str ] = None , ) -> Jwk : \"\"\"Check this key for type, privateness and/or symmetricness. Raise a ValueError if it not as expected. Args: is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing kty: the expected key type, if any Returns: this key, if all checks passed Raises: ValueError: if any check fails \"\"\" if is_private is not None : if is_private is True and self . is_private is False : raise ValueError ( \"This key is public while a private key is expected.\" ) elif is_private is False and self . is_private is True : raise ValueError ( \"This key is private while a public key is expected.\" ) if is_symmetric is not None : if is_symmetric is True and self . is_symmetric is False : raise ValueError ( \"This key is asymmetric while a symmetric key is expected.\" ) if is_symmetric is False and self . is_symmetric is True : raise ValueError ( \"This key is symmetric while an asymmetric key is expected.\" ) if kty is not None : if self . kty != kty : raise ValueError ( f \"This key has kty= { self . kty } while a kty= { kty } is expected.\" ) return self select_alg_class \u00b6 1 2 3 4 5 6 select_alg_class ( supported_algs : Mapping [ str , T ], * , jwk_alg : Optional [ str ] = None , alg : Optional [ str ] = None ) -> T Internal helper method to choose the appropriate alg class to use for cryptographic operations. Given: - a mapping of supported algs names to wrapper classes - a preferred alg name (usually the one mentioned in a JWK) - and/or a user-specified alg this returns the wrapper class to use. This checks the coherency between the user specified alg and the jwk_alg , and will emit a warning if the user specified alg is different from the jwk_alg . Parameters: Name Type Description Default supported_algs Mapping [ str , T ] a mapping of supported alg names to alg wrapper required jwk_alg Optional [ str ] the alg from the JWK, if any None alg Optional [ str ] a user specified alg None Returns: Type Description T the alg to use Warnings A warning is emitted if jwk_alg is supplied and alg doesn't match its value. Raises: Type Description UnsupportedAlg if the requested alg is not supported ValueError if supported_algs is empty Source code in jwskate/jwk/alg.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def select_alg_class ( supported_algs : Mapping [ str , T ], * , jwk_alg : Optional [ str ] = None , alg : Optional [ str ] = None , ) -> T : \"\"\"Internal helper method to choose the appropriate alg class to use for cryptographic operations. Given: - a mapping of supported algs names to wrapper classes - a preferred alg name (usually the one mentioned in a JWK) - and/or a user-specified alg this returns the wrapper class to use. This checks the coherency between the user specified `alg` and the `jwk_alg`, and will emit a warning if the user specified alg is different from the `jwk_alg`. Args: supported_algs: a mapping of supported alg names to alg wrapper jwk_alg: the alg from the JWK, if any alg: a user specified alg Returns: the alg to use Warnings: A warning is emitted if `jwk_alg` is supplied and `alg` doesn't match its value. Raises: UnsupportedAlg: if the requested alg is not supported ValueError: if supported_algs is empty \"\"\" if not supported_algs : raise ValueError ( \"No possible algorithms to choose from!\" ) choosen_alg : str if jwk_alg is not None : if alg is not None : if jwk_alg != alg : warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) choosen_alg = alg else : choosen_alg = jwk_alg elif alg is not None : choosen_alg = alg else : raise ExpectedAlgRequired ( \"This key doesn't have an 'alg' parameter, so you need to provide the expected signing alg(s) for each operation.\" ) try : return supported_algs [ choosen_alg ] except KeyError : raise UnsupportedAlg ( f \"Alg { choosen_alg } is not supported. Supported algs: { list ( supported_algs ) } .\" ) select_alg_classes \u00b6 1 2 3 4 5 6 7 select_alg_classes ( supported_algs : Mapping [ str , T ], * , jwk_alg : Optional [ str ] = None , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> List [ T ] Internal helper method to select several appropriate algs classes to use on cryptographic operations. This method is typically used to get the list of valid algorithms when checking a signature, when several algorithms are allowed. Given: - a mapping of supported algorithms name to wrapper classes - an alg parameter from a JWK - and/or a user-specified alg - and/or a user specified list of usable algs this returns a list of supported alg wrapper classes that matches what the user specified, or, as default, the alg parameter from the JWK. This checks the coherency between the user specified alg and the jwk_alg , and will emit a warning if the user specified alg is different from the jwk_alg . Parameters: Name Type Description Default supported_algs Mapping [ str , T ] a mapping of alg names to alg wrappers required jwk_alg Optional [ str ] the alg from the JWK, if any None alg Optional [ str ] a user specified alg to use, if any None algs Optional [ Iterable [ str ]] a user specified list of algs to use, if several are allowed None Returns: Type Description List [ T ] a list of possible algs to check Raises: Type Description ValueError if both 'alg' and 'algs' parameters are used UnsupportedAlg if none of the requested alg are supported Warnings if the requested 'alg' is different that the 'jwk_alg', or the 'jwk_alg' is not in the 'algs' Source code in jwskate/jwk/alg.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def select_alg_classes ( supported_algs : Mapping [ str , T ], * , jwk_alg : Optional [ str ] = None , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> List [ T ]: \"\"\"Internal helper method to select several appropriate algs classes to use on cryptographic operations. This method is typically used to get the list of valid algorithms when checking a signature, when several algorithms are allowed. Given: - a mapping of supported algorithms name to wrapper classes - an alg parameter from a JWK - and/or a user-specified alg - and/or a user specified list of usable algs this returns a list of supported alg wrapper classes that matches what the user specified, or, as default, the alg parameter from the JWK. This checks the coherency between the user specified `alg` and the `jwk_alg`, and will emit a warning if the user specified alg is different from the `jwk_alg`. Args: supported_algs: a mapping of alg names to alg wrappers jwk_alg: the alg from the JWK, if any alg: a user specified alg to use, if any algs: a user specified list of algs to use, if several are allowed Returns: a list of possible algs to check Raises: ValueError: if both 'alg' and 'algs' parameters are used UnsupportedAlg: if none of the requested alg are supported Warnings: if the requested 'alg' is different that the 'jwk_alg', or the 'jwk_alg' is not in the 'algs' \"\"\" if alg and algs : raise ValueError ( \"Please use either parameter 'alg' or 'algs', not both.\" ) if not supported_algs : raise ValueError ( \"No possible algorithms to choose from!\" ) if jwk_alg is not None : if ( alg and alg != jwk_alg ) or ( algs and jwk_alg not in algs ): warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) possible_algs : List [ str ] = [] if alg : possible_algs = [ alg ] elif algs : possible_algs = list ( algs ) elif jwk_alg : possible_algs = [ jwk_alg ] if possible_algs : possible_supported_algs = [ supported_algs [ alg ] for alg in possible_algs if alg in supported_algs ] if possible_supported_algs : return possible_supported_algs else : raise UnsupportedAlg ( f \"None of the user-specified alg(s) are supported. { possible_algs } \" ) raise ExpectedAlgRequired ( \"This key doesn't have an 'alg' parameter, so you need to provide the expected signing alg(s) for each operation.\" ) to_jwk \u00b6 1 2 3 4 5 6 7 to_jwk ( key : Any , * , kty : Optional [ str ] = None , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None ) -> Jwk Convert any supported kind of key to a Jwk, and optionally check if that key is private or symmetric. The key can be any type supported by Jwk: - a cryptography key instance - a bytes, to initialize a symmetric key - a JWK, as a dict or as a JSON formatted string - an existing Jwk instance If the supplied param is already a Jwk, it is left untouched. Parameters: Name Type Description Default key Any the key material required kty Optional [ str ] the expected key type None is_private Optional [ bool ] if True , check if the key is private, if False , check if it is public, if None , do nothing None is_symmetric Optional [ bool ] if True , check if the key is symmetric, if False , check if it is asymmetric, if None , do nothing None Returns: Type Description Jwk a Jwk key Source code in jwskate/jwk/base.py 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 def to_jwk ( key : Any , * , kty : Optional [ str ] = None , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None , ) -> Jwk : \"\"\"Convert any supported kind of key to a Jwk, and optionally check if that key is private or symmetric. The key can be any type supported by Jwk: - a `cryptography` key instance - a bytes, to initialize a symmetric key - a JWK, as a dict or as a JSON formatted string - an existing Jwk instance If the supplied param is already a Jwk, it is left untouched. Args: key: the key material kty: the expected key type is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing Returns: a Jwk key \"\"\" jwk = key if isinstance ( key , Jwk ) else Jwk ( key ) return jwk . check ( kty = kty , is_private = is_private , is_symmetric = is_symmetric ) jwskate.jwt \u00b6 This module contains all Json Web Key (Jwk) related classes and utilities. JwtSigner \u00b6 A helper class to easily sign JWTs with standardised claims. The standardised claims include \u00ecat : issued at date exp : expiration date nbf : not before date: iss : issuer identifier sub : subject identifier aud : audience identifier jti : JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling JwtSigner.sign() . This can be used as an alternative to Jwt.sign() when a single issuer issues multiple tokens. Parameters: Name Type Description Default issuer str the issuer string to use as \u00ecss claim for signed tokens. required jwk Jwk the private Jwk to use to sign tokens. required alg Optional [ str ] the signing alg to use to sign tokens. None default_lifetime int the default lifetime, in seconds, to use for claim exp . This can be overridden when calling .sign() 60 default_leeway Optional [ int ] the default leeway, in seconds, to use for claim nbf . If None, no nbf claim is included. This can be overridden when calling .sign() None Source code in jwskate/jwt/signer.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class JwtSigner : \"\"\"A helper class to easily sign JWTs with standardised claims. The standardised claims include: - `\u00ecat`: issued at date - `exp`: expiration date - `nbf`: not before date: - `iss`: issuer identifier - `sub`: subject identifier - `aud`: audience identifier - `jti`: JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling `JwtSigner.sign()`. This can be used as an alternative to `Jwt.sign()` when a single issuer issues multiple tokens. Args: issuer: the issuer string to use as `\u00ecss` claim for signed tokens. jwk: the private Jwk to use to sign tokens. alg: the signing alg to use to sign tokens. default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden when calling `.sign()` default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is included. This can be overridden when calling `.sign()` \"\"\" def __init__ ( self , issuer : str , jwk : Jwk , alg : Optional [ str ] = None , default_lifetime : int = 60 , default_leeway : Optional [ int ] = None , ): self . issuer = issuer self . jwk = jwk self . alg = jwk . alg or alg self . default_lifetime = default_lifetime self . default_leeway = default_leeway def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = Jwt . timestamp () lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ()) sign \u00b6 1 2 3 4 5 6 7 8 sign ( subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim iat , nbf and exp will reflect the current time when the token is signed. exp includes lifetime seconds in the future, and nbf includes leeway seconds in the past. Parameters: Name Type Description Default subject Optional [ str ] the subject to include in claim sub . (Default value = None) None audience Union [ str , Iterable [ str ], None] the audience identifier(s) to include in claim aud . None extra_claims Optional [ Dict [ str , Any ]] additional claims to include in the signed token. (Default value = None) None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the header part. (Default value = None) None lifetime Optional [ int ] lifetime, in seconds, to use for the exp claim. If None, use the default_lifetime defined at initialization time. None leeway Optional [ int ] leeway, in seconds, to use for the nbf claim. If None, use the default_leeway defined at initialization time. None Returns: Type Description SignedJwt the resulting signed token. Source code in jwskate/jwt/signer.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = Jwt . timestamp () lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) generate_jti \u00b6 1 generate_jti () -> str Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: Type Description str A unique value suitable for use as JWT Token ID (jti) claim. Source code in jwskate/jwt/signer.py 104 105 106 107 108 109 110 111 112 def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ()) ExpiredJwt \u00b6 Bases: ValueError Raised when trying to validate an expired JWT token. Source code in jwskate/jwt/signed.py 14 15 class ExpiredJwt ( ValueError ): \"\"\"Raised when trying to validate an expired JWT token.\"\"\" InvalidJwt \u00b6 Bases: ValueError Raised when an invalid Jwt is parsed. Source code in jwskate/jwt/base.py 18 19 class InvalidJwt ( ValueError ): \"\"\"Raised when an invalid Jwt is parsed.\"\"\" InvalidSignature \u00b6 Bases: ValueError Raised when trying to validate a JWT with an invalid signature. Source code in jwskate/jwt/signed.py 18 19 class InvalidSignature ( ValueError ): \"\"\"Raised when trying to validate a JWT with an invalid signature.\"\"\" Jwt \u00b6 Bases: BaseCompactToken Represents a Json Web Token. Source code in jwskate/jwt/base.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 class Jwt ( BaseCompactToken ): \"\"\"Represents a Json Web Token.\"\"\" def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 4 : from ..jwe import JweCompact return JweCompact ( value ) return super () . __new__ ( cls ) @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = to_jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) extra_headers = extra_headers or {} headers = dict ( alg = alg , ** extra_headers ) if jwk . kid : headers [ \"kid\" ] = jwk . kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , * , sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , sign_extra_headers : Optional [ Dict [ str , Any ]] = None , enc_extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JweCompact : \"\"\"Sign a JWT, then encrypt it as JWE payload. This is a convenience method to do both the signing and encryption, in appropriate order. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature sign_extra_headers: additional headers for the inner signed JWT enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption enc_extra_headers: additional headers for the outer encrypted JWE Returns: the resulting JWE token, with the signed JWT as payload \"\"\" enc_extra_headers = enc_extra_headers or {} enc_extra_headers . setdefault ( \"cty\" , \"JWT\" ) inner_jwt = cls . sign ( claims , jwk = sign_jwk , alg = sign_alg , extra_headers = sign_extra_headers ) jwe = JweCompact . encrypt ( inner_jwt , enc_jwk , enc = enc , alg = enc_alg , extra_headers = enc_extra_headers ) return jwe @classmethod def decrypt_nested_jwt ( cls , jwe : Union [ str , JweCompact ], jwk : Union [ Jwk , Dict [ str , Any ]] ) -> Jwt : \"\"\"Convenience method to decrypt a nested JWT. It will return a [Jwt] instance. Args: jwe: the JWE containing a nested Token jwk: the decryption key Returns: the inner token Raises: InvalidJwt: if the inner JWT is not valid \"\"\" if not isinstance ( jwe , JweCompact ): jwe = JweCompact ( jwe ) cleartext = jwe . decrypt ( jwk ) return Jwt ( cleartext ) @classmethod def decrypt_and_verify ( cls , jwt : Union [ str , JweCompact ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sig_jwk : Union [ Jwk , Dict [ str , Any ], None ], sig_alg : Optional [ str ] = None , sig_algs : Optional [ Iterable [ str ]] = None , ) -> SignedJwt : \"\"\"Decrypt then verify the signature of a JWT nested in a JWE. This can only be used with signed then encrypted Jwt, such as those produce by `Jwt.sign_and_encrypt()`. Args: jwt: the JWE containing a nested signed JWT enc_jwk: the decryption key sig_jwk: the signature verification key sig_alg: the signature verification alg, if only 1 is allowed sig_algs: the signature verifications algs, if several are allowed Returns: the nested signed JWT, in clear-text, signature already verified Raises: InvalidJwt: if the JWT is not valid InvalidSignature: if the nested JWT signature is not valid \"\"\" from .signed import InvalidSignature , SignedJwt nested_jwt = cls . decrypt_nested_jwt ( jwt , enc_jwk ) if not isinstance ( nested_jwt , SignedJwt ): raise ValueError ( \"Nested JWT is not signed\" , nested_jwt ) if sig_jwk : if nested_jwt . verify_signature ( sig_jwk , sig_alg , sig_algs ): return nested_jwt raise InvalidSignature () @classmethod def timestamp ( cls , delta_seconds : int = 0 ) -> int : \"\"\"Return an integer timestamp that is suitable for use in Jwt tokens `iat`, `exp` and `nbf` claims. A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds. By default, the current timestamp is returned. You can include `delta_seconds` to have a timestamp a number of seconds in the future (if positive) or in the past (if negative). Args: delta_seconds: number of seconds in the future or in the past compared to current time Returns: An integer timestamp \"\"\" return int ( datetime . now ( timezone . utc ) . timestamp ()) + delta_seconds @classmethod def timestamp_to_datetime ( cls , timestamp : int ) -> datetime : \"\"\"Convert a JWT timestamp to a `datetime`. Returned datetime is always in the UTC timezone. Args: timestamp: a timestamp from a JWT token Returns: the corresponding `datetime` in UTC timezone \"\"\" return datetime . fromtimestamp ( timestamp , tz = timezone . utc ) __new__ \u00b6 1 __new__ ( value : Union [ bytes , str ]) Allow parsing both Signed and Encrypted JWTs. This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT. Parameters: Name Type Description Default value Union [ bytes , str ] the token value required Source code in jwskate/jwt/base.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 4 : from ..jwe import JweCompact return JweCompact ( value ) return super () . __new__ ( cls ) sign classmethod \u00b6 1 2 3 4 5 6 sign ( claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> SignedJwt Sign a JSON payload with a Jwk and returns the resulting SignedJwt . This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use .unprotected() instead. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signing required alg Optional [ str ] the alg to use for signing None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the Jwt None Returns: Type Description SignedJwt the resulting token Source code in jwskate/jwt/base.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = to_jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) extra_headers = extra_headers or {} headers = dict ( alg = alg , ** extra_headers ) if jwk . kid : headers [ \"kid\" ] = jwk . kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) unprotected classmethod \u00b6 1 2 3 4 unprotected ( claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> SignedJwt Generate a JWT that is not signed and not encrypted (with alg=none). Parameters: Name Type Description Default claims Dict [ str , Any ] the claims to set in the token. required extra_headers Optional [ Dict [ str , Any ]] additional headers to insert in the token. None Returns: Type Description SignedJwt the resulting token Source code in jwskate/jwt/base.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) sign_and_encrypt classmethod \u00b6 1 2 3 4 5 6 7 8 9 10 11 sign_and_encrypt ( claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , * , sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , sign_extra_headers : Optional [ Dict [ str , Any ]] = None , enc_extra_headers : Optional [ Dict [ str , Any ]] = None ) -> JweCompact Sign a JWT, then encrypt it as JWE payload. This is a convenience method to do both the signing and encryption, in appropriate order. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to encrypt required sign_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signature required sign_alg Optional [ str ] the alg to use for signature None sign_extra_headers Optional [ Dict [ str , Any ]] additional headers for the inner signed JWT None enc_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for encryption required enc_alg Optional [ str ] the alg to use for CEK encryption None enc str the alg to use for payload encryption required enc_extra_headers Optional [ Dict [ str , Any ]] additional headers for the outer encrypted JWE None Returns: Type Description JweCompact the resulting JWE token, with the signed JWT as payload Source code in jwskate/jwt/base.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , * , sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , sign_extra_headers : Optional [ Dict [ str , Any ]] = None , enc_extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JweCompact : \"\"\"Sign a JWT, then encrypt it as JWE payload. This is a convenience method to do both the signing and encryption, in appropriate order. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature sign_extra_headers: additional headers for the inner signed JWT enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption enc_extra_headers: additional headers for the outer encrypted JWE Returns: the resulting JWE token, with the signed JWT as payload \"\"\" enc_extra_headers = enc_extra_headers or {} enc_extra_headers . setdefault ( \"cty\" , \"JWT\" ) inner_jwt = cls . sign ( claims , jwk = sign_jwk , alg = sign_alg , extra_headers = sign_extra_headers ) jwe = JweCompact . encrypt ( inner_jwt , enc_jwk , enc = enc , alg = enc_alg , extra_headers = enc_extra_headers ) return jwe decrypt_nested_jwt classmethod \u00b6 1 2 3 4 decrypt_nested_jwt ( jwe : Union [ str , JweCompact ], jwk : Union [ Jwk , Dict [ str , Any ]], ) -> Jwt Convenience method to decrypt a nested JWT. It will return a [Jwt] instance. Parameters: Name Type Description Default jwe Union [ str , JweCompact ] the JWE containing a nested Token required jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required Returns: Type Description Jwt the inner token Raises: Type Description InvalidJwt if the inner JWT is not valid Source code in jwskate/jwt/base.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 @classmethod def decrypt_nested_jwt ( cls , jwe : Union [ str , JweCompact ], jwk : Union [ Jwk , Dict [ str , Any ]] ) -> Jwt : \"\"\"Convenience method to decrypt a nested JWT. It will return a [Jwt] instance. Args: jwe: the JWE containing a nested Token jwk: the decryption key Returns: the inner token Raises: InvalidJwt: if the inner JWT is not valid \"\"\" if not isinstance ( jwe , JweCompact ): jwe = JweCompact ( jwe ) cleartext = jwe . decrypt ( jwk ) return Jwt ( cleartext ) decrypt_and_verify classmethod \u00b6 1 2 3 4 5 6 7 decrypt_and_verify ( jwt : Union [ str , JweCompact ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sig_jwk : Union [ Jwk , Dict [ str , Any ], None ], sig_alg : Optional [ str ] = None , sig_algs : Optional [ Iterable [ str ]] = None , ) -> SignedJwt Decrypt then verify the signature of a JWT nested in a JWE. This can only be used with signed then encrypted Jwt, such as those produce by Jwt.sign_and_encrypt() . Parameters: Name Type Description Default jwt Union [ str , JweCompact ] the JWE containing a nested signed JWT required enc_jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required sig_jwk Union [ Jwk , Dict [ str , Any ], None] the signature verification key required sig_alg Optional [ str ] the signature verification alg, if only 1 is allowed None sig_algs Optional [ Iterable [ str ]] the signature verifications algs, if several are allowed None Returns: Type Description SignedJwt the nested signed JWT, in clear-text, signature already verified Raises: Type Description InvalidJwt if the JWT is not valid InvalidSignature if the nested JWT signature is not valid Source code in jwskate/jwt/base.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 @classmethod def decrypt_and_verify ( cls , jwt : Union [ str , JweCompact ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sig_jwk : Union [ Jwk , Dict [ str , Any ], None ], sig_alg : Optional [ str ] = None , sig_algs : Optional [ Iterable [ str ]] = None , ) -> SignedJwt : \"\"\"Decrypt then verify the signature of a JWT nested in a JWE. This can only be used with signed then encrypted Jwt, such as those produce by `Jwt.sign_and_encrypt()`. Args: jwt: the JWE containing a nested signed JWT enc_jwk: the decryption key sig_jwk: the signature verification key sig_alg: the signature verification alg, if only 1 is allowed sig_algs: the signature verifications algs, if several are allowed Returns: the nested signed JWT, in clear-text, signature already verified Raises: InvalidJwt: if the JWT is not valid InvalidSignature: if the nested JWT signature is not valid \"\"\" from .signed import InvalidSignature , SignedJwt nested_jwt = cls . decrypt_nested_jwt ( jwt , enc_jwk ) if not isinstance ( nested_jwt , SignedJwt ): raise ValueError ( \"Nested JWT is not signed\" , nested_jwt ) if sig_jwk : if nested_jwt . verify_signature ( sig_jwk , sig_alg , sig_algs ): return nested_jwt raise InvalidSignature () timestamp classmethod \u00b6 1 timestamp ( delta_seconds : int = 0 ) -> int Return an integer timestamp that is suitable for use in Jwt tokens iat , exp and nbf claims. A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds. By default, the current timestamp is returned. You can include delta_seconds to have a timestamp a number of seconds in the future (if positive) or in the past (if negative). Parameters: Name Type Description Default delta_seconds int number of seconds in the future or in the past compared to current time 0 Returns: Type Description int An integer timestamp Source code in jwskate/jwt/base.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @classmethod def timestamp ( cls , delta_seconds : int = 0 ) -> int : \"\"\"Return an integer timestamp that is suitable for use in Jwt tokens `iat`, `exp` and `nbf` claims. A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds. By default, the current timestamp is returned. You can include `delta_seconds` to have a timestamp a number of seconds in the future (if positive) or in the past (if negative). Args: delta_seconds: number of seconds in the future or in the past compared to current time Returns: An integer timestamp \"\"\" return int ( datetime . now ( timezone . utc ) . timestamp ()) + delta_seconds timestamp_to_datetime classmethod \u00b6 1 timestamp_to_datetime ( timestamp : int ) -> datetime Convert a JWT timestamp to a datetime . Returned datetime is always in the UTC timezone. Parameters: Name Type Description Default timestamp int a timestamp from a JWT token required Returns: Type Description datetime the corresponding datetime in UTC timezone Source code in jwskate/jwt/base.py 234 235 236 237 238 239 240 241 242 243 244 245 246 @classmethod def timestamp_to_datetime ( cls , timestamp : int ) -> datetime : \"\"\"Convert a JWT timestamp to a `datetime`. Returned datetime is always in the UTC timezone. Args: timestamp: a timestamp from a JWT token Returns: the corresponding `datetime` in UTC timezone \"\"\" return datetime . fromtimestamp ( timestamp , tz = timezone . utc ) InvalidClaim \u00b6 Bases: ValueError Raised when trying to validate a JWT with unexpected claims. Source code in jwskate/jwt/signed.py 22 23 class InvalidClaim ( ValueError ): \"\"\"Raised when trying to validate a JWT with unexpected claims.\"\"\" SignedJwt \u00b6 Bases: Jwt Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use Jwt.sign . Parameters: Name Type Description Default value Union [ bytes , str ] the token value. required Source code in jwskate/jwt/signed.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 class SignedJwt ( Jwt ): \"\"\"Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use [Jwt.sign][jwskate.jwt.Jwt.sign]. Args: value: the token value. \"\"\" def __init__ ( self , value : Union [ bytes , str ]) -> None : super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJwt ( \"A JWT must contain a header, a payload and a signature, separated by dots\" , value , ) header , payload , signature = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT header: it must be a Base64URL-encoded JSON object\" ) try : self . claims = BinaPy ( payload ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\" ) @cached_property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = to_jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Args: leeway: additional number of seconds for leeway. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < ( datetime . now ( timezone . utc ) + timedelta ( seconds = leeway )) @cached_property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = Jwt . timestamp_to_datetime ( exp ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) @cached_property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = Jwt . timestamp_to_datetime ( iat ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) @cached_property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = Jwt . timestamp_to_datetime ( nbf ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) @cached_property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) @cached_property def audiences ( self ) -> List [ str ]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return [] if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) @cached_property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) @cached_property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signature alg to use to verify the signature. algs: allowed signature algs, if several issuer: the expected issuer for this token. audience: the expected audience for this token. check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg , algs ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audiences ) if check_exp : expired = self . is_expired () if expired is True : raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) elif expired is None : raise InvalidClaim ( \"exp\" , \"This token misses a 'exp' claim.\" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim ) signed_part \u00b6 1 signed_part () -> bytes Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: Type Description bytes the signed part as bytes Source code in jwskate/jwt/signed.py 68 69 70 71 72 73 74 75 76 77 @cached_property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) verify_signature \u00b6 1 2 3 4 5 verify_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool Verify this JWT signature using a given key and algorithm(s). Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private Jwk to use to verify the signature required alg Optional [ str ] the alg to use to verify the signature, if only 1 is allowed None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the token signature is verified, False otherwise Source code in jwskate/jwt/signed.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = to_jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) is_expired \u00b6 1 is_expired ( leeway : int = 0 ) -> Optional [ bool ] Check if this token is expired, based on its exp claim. Parameters: Name Type Description Default leeway int additional number of seconds for leeway. 0 Returns: Type Description Optional [ bool ] True if the token is expired, False if it's not, None if there is no exp claim. Source code in jwskate/jwt/signed.py 101 102 103 104 105 106 107 108 109 110 111 112 113 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Args: leeway: additional number of seconds for leeway. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < ( datetime . now ( timezone . utc ) + timedelta ( seconds = leeway )) expires_at \u00b6 1 expires_at () -> Optional [ datetime ] Get the \"Expires At\" (exp) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the exp claim, or None if there is no exp claim Raises: Type Description AttributeError if the exp claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @cached_property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = Jwt . timestamp_to_datetime ( exp ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) issued_at \u00b6 1 issued_at () -> Optional [ datetime ] Get the \"Issued At\" (iat) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the iat claim, or None if there is no iat claim Raises: Type Description AttributeError if the iss claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 @cached_property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = Jwt . timestamp_to_datetime ( iat ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) not_before \u00b6 1 not_before () -> Optional [ datetime ] Get the \"Not Before\" (nbf) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the nbf claim, or None if there is no nbf claim Raises: Type Description AttributeError if the nbf claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 @cached_property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = Jwt . timestamp_to_datetime ( nbf ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) issuer \u00b6 1 issuer () -> Optional [ str ] Get the Issuer (iss) claim from this token. Returns: Type Description Optional [ str ] the issuer, as str , or None if there is no \u00ecss claim Raises: Type Description AttributeError if the \u00ecss claim value is not a string Source code in jwskate/jwt/signed.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 @cached_property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) audiences \u00b6 1 audiences () -> List [ str ] Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a list anyway. Returns: Type Description List [ str ] the list of audiences from this token, from the aud claim. Raises: Type Description AttributeError if the audience is an unexpected type Source code in jwskate/jwt/signed.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 @cached_property def audiences ( self ) -> List [ str ]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return [] if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) subject \u00b6 1 subject () -> Optional [ str ] Get the Subject (sub) from this token claims. Returns: Type Description Optional [ str ] the subject, as str , or None if there is no sub claim Raises: Type Description AttributeError if the sub value is not a string Source code in jwskate/jwt/signed.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @cached_property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) jwt_token_id \u00b6 1 jwt_token_id () -> Optional [ str ] Get the JWT Token ID (jti) from this token claims. Returns: Type Description Optional [ str ] the token identifier, as str , or None if there is no jti claim Raises: Type Description AttributeError if the jti value is not a string Source code in jwskate/jwt/signed.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @cached_property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) get_claim \u00b6 1 get_claim ( key : str , default : Any = None ) -> Any Get a claim from this Jwt. Parameters: Name Type Description Default key str the claim name. required default Any a default value if the claim is not found None Returns: Type Description Any the claim value if found, or default if not found Source code in jwskate/jwt/signed.py 238 239 240 241 242 243 244 245 246 247 248 def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) __getitem__ \u00b6 1 __getitem__ ( item : str ) -> Any Allow claim access with subscription. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate/jwt/signed.py 250 251 252 253 254 255 256 257 258 259 260 261 262 def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value __getattr__ \u00b6 1 __getattr__ ( item : str ) -> Any Allow claim access as attributes. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate/jwt/signed.py 264 265 266 267 268 269 270 271 272 273 274 275 276 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value __str__ \u00b6 1 __str__ () -> str Return the Jwt serialized value, as str . Returns: Type Description str the serialized token value. Source code in jwskate/jwt/signed.py 278 279 280 281 282 283 284 def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () __bytes__ \u00b6 1 __bytes__ () -> bytes Return the Jwt serialized value, as bytes . Returns: Type Description bytes the serialized token value. Source code in jwskate/jwt/signed.py 286 287 288 289 290 291 292 def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value validate \u00b6 1 2 3 4 5 6 7 8 9 10 validate ( jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any ) -> None Validate a SignedJwt signature and expected claims. This verifies the signature using the provided jwk and alg , then checks the token issuer, audience and expiration date. This can also check custom claims using extra kwargs , whose values can be: a static value ( str , int , etc.): the value from the token will be compared \"as-is\" a callable, taking the claim value as parameter: if that callable returns True , the claim is considered as valid Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the signing key to use to verify the signature. required alg Optional [ str ] the signature alg to use to verify the signature. None algs Optional [ Iterable [ str ]] allowed signature algs, if several None issuer Optional [ str ] the expected issuer for this token. None audience Union [None, str ] the expected audience for this token. None check_exp bool \u00ecf True (default), check that the token is not expired. True **kwargs Any additional claims to check {} Returns: Type Description None Raises exceptions if any validation check fails. Raises: Type Description InvalidSignature if the signature is not valid InvalidClaim if a claim doesn't validate ExpiredJwt if the expiration date is passed Source code in jwskate/jwt/signed.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signature alg to use to verify the signature. algs: allowed signature algs, if several issuer: the expected issuer for this token. audience: the expected audience for this token. check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg , algs ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audiences ) if check_exp : expired = self . is_expired () if expired is True : raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) elif expired is None : raise InvalidClaim ( \"exp\" , \"This token misses a 'exp' claim.\" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim ) jwskate.jws \u00b6 This module implements JWS token handling. JwsJsonFlat \u00b6 Bases: JwsSignature Represent a JWS with a single signature in JSON flat format. Source code in jwskate/jws/json.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 class JwsJsonFlat ( JwsSignature ): \"\"\"Represent a JWS with a single signature in JSON flat format.\"\"\" @cached_property def payload ( self ) -> bytes : \"\"\"The JWS payload, decoded. Returns: The raw JWS payload. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) @cached_property def jws_signature ( self ) -> JwsSignature : \"\"\"The JWS signature. Returns: The JWS signature. \"\"\" content = { \"protected\" : self [ \"protected\" ], \"signature\" : self [ \"signature\" ], } header = self . get ( \"header\" ) if header : content [ \"header\" ] = self . header return JwsSignature ( content ) @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> JwsJsonFlat : \"\"\"Signs a payload into a JWS in JSON flat format. Args: payload: the data to sign. jwk: the key to use alg: the signature alg to use extra_protected_headers: additional protected headers to include header: the unprotected header to include **kwargs: extra attributes to include in the JWS Returns: The JWS with the payload, signature, header and extra claims. \"\"\" signature = super () . sign ( payload , jwk , alg , extra_protected_headers , header , ** kwargs ) signature [ \"payload\" ] = BinaPy ( payload ) . to ( \"b64u\" ) . ascii () return cls ( signature ) def generalize ( self ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON general format from this JWS in JSON flat. Returns: A JwsJsonGeneral with the same payload and signature. \"\"\" content = self . copy () protected = content . pop ( \"protected\" ) header = content . pop ( \"header\" , None ) signature = content . pop ( \"signature\" ) jws_signature = { \"protected\" : protected , \"signature\" : signature } if header is not None : jws_signature [ \"header\" ] = header content [ \"signatures\" ] = [ jws_signature ] return JwsJsonGeneral ( content ) def signed_part ( self ) -> bytes : \"\"\"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot (`.`). Returns: The signed data part. \"\"\" return JwsSignature . assemble_signed_part ( self . protected , self . payload ) def compact ( self ) -> JwsCompact : \"\"\"Create a JWS in compact format from this JWS JSON. Returns: A `JwsCompact` with the same payload and signature. \"\"\" return JwsCompact . from_parts ( self . signed_part (), self . signature ) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWS signature with a given key. Args: jwk: the key to use to validate this signature. alg: the signature alg, if only 1 is allowed. algs: the allowed signature algs, if there are several. Returns: `True` if the signature is verified, `False` otherwise. \"\"\" return self . jws_signature . verify ( self . payload , jwk , alg = alg , algs = algs ) payload \u00b6 1 payload () -> bytes The JWS payload, decoded. Returns: Type Description bytes The raw JWS payload. Source code in jwskate/jws/json.py 20 21 22 23 24 25 26 27 28 29 30 @cached_property def payload ( self ) -> bytes : \"\"\"The JWS payload, decoded. Returns: The raw JWS payload. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) jws_signature \u00b6 1 jws_signature () -> JwsSignature The JWS signature. Returns: Type Description JwsSignature The JWS signature. Source code in jwskate/jws/json.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @cached_property def jws_signature ( self ) -> JwsSignature : \"\"\"The JWS signature. Returns: The JWS signature. \"\"\" content = { \"protected\" : self [ \"protected\" ], \"signature\" : self [ \"signature\" ], } header = self . get ( \"header\" ) if header : content [ \"header\" ] = self . header return JwsSignature ( content ) sign classmethod \u00b6 1 2 3 4 5 6 7 8 9 10 sign ( payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ] ] = None , header : Optional [ Any ] = None , ** kwargs : Any ) -> JwsJsonFlat Signs a payload into a JWS in JSON flat format. Parameters: Name Type Description Default payload bytes the data to sign. required jwk Union [ Jwk , Dict [ str , Any ]] the key to use required alg Optional [ str ] the signature alg to use None extra_protected_headers Optional [ Mapping [ str , Any ]] additional protected headers to include None header Optional [ Any ] the unprotected header to include None **kwargs Any extra attributes to include in the JWS {} Returns: Type Description JwsJsonFlat The JWS with the payload, signature, header and extra claims. Source code in jwskate/jws/json.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> JwsJsonFlat : \"\"\"Signs a payload into a JWS in JSON flat format. Args: payload: the data to sign. jwk: the key to use alg: the signature alg to use extra_protected_headers: additional protected headers to include header: the unprotected header to include **kwargs: extra attributes to include in the JWS Returns: The JWS with the payload, signature, header and extra claims. \"\"\" signature = super () . sign ( payload , jwk , alg , extra_protected_headers , header , ** kwargs ) signature [ \"payload\" ] = BinaPy ( payload ) . to ( \"b64u\" ) . ascii () return cls ( signature ) generalize \u00b6 1 generalize () -> JwsJsonGeneral Create a JWS in JSON general format from this JWS in JSON flat. Returns: Type Description JwsJsonGeneral A JwsJsonGeneral with the same payload and signature. Source code in jwskate/jws/json.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def generalize ( self ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON general format from this JWS in JSON flat. Returns: A JwsJsonGeneral with the same payload and signature. \"\"\" content = self . copy () protected = content . pop ( \"protected\" ) header = content . pop ( \"header\" , None ) signature = content . pop ( \"signature\" ) jws_signature = { \"protected\" : protected , \"signature\" : signature } if header is not None : jws_signature [ \"header\" ] = header content [ \"signatures\" ] = [ jws_signature ] return JwsJsonGeneral ( content ) signed_part \u00b6 1 signed_part () -> bytes The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot ( . ). Returns: Type Description bytes The signed data part. Source code in jwskate/jws/json.py 93 94 95 96 97 98 99 100 101 def signed_part ( self ) -> bytes : \"\"\"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot (`.`). Returns: The signed data part. \"\"\" return JwsSignature . assemble_signed_part ( self . protected , self . payload ) compact \u00b6 1 compact () -> JwsCompact Create a JWS in compact format from this JWS JSON. Returns: Type Description JwsCompact A JwsCompact with the same payload and signature. Source code in jwskate/jws/json.py 103 104 105 106 107 108 109 def compact ( self ) -> JwsCompact : \"\"\"Create a JWS in compact format from this JWS JSON. Returns: A `JwsCompact` with the same payload and signature. \"\"\" return JwsCompact . from_parts ( self . signed_part (), self . signature ) verify_signature \u00b6 1 2 3 4 5 6 verify_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> bool Verify this JWS signature with a given key. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the key to use to validate this signature. required alg Optional [ str ] the signature alg, if only 1 is allowed. None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several. None Returns: Type Description bool True if the signature is verified, False otherwise. Source code in jwskate/jws/json.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWS signature with a given key. Args: jwk: the key to use to validate this signature. alg: the signature alg, if only 1 is allowed. algs: the allowed signature algs, if there are several. Returns: `True` if the signature is verified, `False` otherwise. \"\"\" return self . jws_signature . verify ( self . payload , jwk , alg = alg , algs = algs ) InvalidJws \u00b6 Bases: ValueError Raised when an invalid Jws is parsed. Source code in jwskate/jws/compact.py 19 20 class InvalidJws ( ValueError ): \"\"\"Raised when an invalid Jws is parsed.\"\"\" JwsCompact \u00b6 Bases: BaseCompactToken Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Parameters: Name Type Description Default value Union [ bytes , str ] the JWS token value required Source code in jwskate/jws/compact.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class JwsCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Args: value: the JWS token value \"\"\" def __init__ ( self , value : Union [ bytes , str ]): super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = BinaPy ( self . value ) . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJws ( \"Invalid JWS header: it must be a Base64URL-encoded JSON object\" ) try : self . payload = BinaPy ( payload ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def sign ( cls , payload : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JwsCompact : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = to_jwk ( jwk ) if not isinstance ( payload , bytes ): payload = bytes ( payload ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) @classmethod def from_parts ( cls , signed_part : Union [ bytes , SupportsBytes , str ], signature : Union [ bytes , SupportsBytes , str ], ) -> JwsCompact : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if isinstance ( signed_part , str ): signed_part = signed_part . encode ( \"ascii\" ) if not isinstance ( signed_part , bytes ): signed_part = bytes ( signed_part ) if isinstance ( signature , str ): signature = signature . encode ( \"ascii\" ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . to ( \"b64u\" )))) @cached_property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = to_jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg = alg , algs = algs ) def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . value . split ( b \".\" ) content = { \"payload\" : payload . decode (), \"protected\" : protected . decode (), \"signature\" : signature . decode (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize () sign classmethod \u00b6 1 2 3 4 5 6 sign ( payload : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JwsCompact Sign a payload and returns the resulting JwsCompact. Parameters: Name Type Description Default payload Union [ bytes , SupportsBytes ] the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the jwk to use to sign this payload required alg Optional [ str ] the alg to use None extra_headers Optional [ Dict [ str , Any ]] additional headers to add to the Jws Headers None Returns: Type Description JwsCompact the resulting token Source code in jwskate/jws/compact.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @classmethod def sign ( cls , payload : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JwsCompact : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = to_jwk ( jwk ) if not isinstance ( payload , bytes ): payload = bytes ( payload ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) from_parts classmethod \u00b6 1 2 3 4 from_parts ( signed_part : Union [ bytes , SupportsBytes , str ], signature : Union [ bytes , SupportsBytes , str ], ) -> JwsCompact Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Parameters: Name Type Description Default signed_part Union [ bytes , SupportsBytes , str ] the signed part required signature Union [ bytes , SupportsBytes , str ] the signature value required Returns: Type Description JwsCompact the resulting token Source code in jwskate/jws/compact.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @classmethod def from_parts ( cls , signed_part : Union [ bytes , SupportsBytes , str ], signature : Union [ bytes , SupportsBytes , str ], ) -> JwsCompact : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if isinstance ( signed_part , str ): signed_part = signed_part . encode ( \"ascii\" ) if not isinstance ( signed_part , bytes ): signed_part = bytes ( signed_part ) if isinstance ( signature , str ): signature = signature . encode ( \"ascii\" ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . to ( \"b64u\" )))) signed_part \u00b6 1 signed_part () -> bytes Returns the signed part (header + payload) from this JwsCompact. Returns: Type Description bytes the signed part Source code in jwskate/jws/compact.py 123 124 125 126 127 128 129 130 @cached_property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) verify_signature \u00b6 1 2 3 4 5 6 verify_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> bool Verify the signature from this JwsCompact using a Jwk. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use to validate this signature required alg Optional [ str ] the alg to use, if there is only 1 allowed None algs Optional [ Iterable [ str ]] the allowed algs, if here are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate/jws/compact.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = to_jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg = alg , algs = algs ) flat_json \u00b6 1 flat_json ( unprotected_header : Any = None ) -> JwsJsonFlat Create a JWS in JSON flat format based on this Compact JWS. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonFlat the resulting token Source code in jwskate/jws/compact.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . value . split ( b \".\" ) content = { \"payload\" : payload . decode (), \"protected\" : protected . decode (), \"signature\" : signature . decode (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) general_json \u00b6 1 2 3 general_json ( unprotected_header : Any = None , ) -> JwsJsonGeneral Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonGeneral the resulting token Source code in jwskate/jws/compact.py 174 175 176 177 178 179 180 181 182 183 184 185 186 def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize () JwsJsonGeneral \u00b6 Bases: BaseJsonDict Represents a JWS in JSON general format (possibly with multiple signatures). Source code in jwskate/jws/json.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 class JwsJsonGeneral ( BaseJsonDict ): \"\"\"Represents a JWS in JSON general format (possibly with multiple signatures).\"\"\" @cached_property def payload ( self ) -> bytes : \"\"\"The raw signed data. Returns: The signed data. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) @classmethod def sign ( cls , payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , ], Union [ Jwk , Mapping [ str , Any ]], ], ) -> JwsJsonGeneral : \"\"\"Sign a payload with several keys and return the resulting JWS in JSON general format. Args: payload: the data to sign *signature_parameters: each of those parameter can be: - a `(jwk, alg, extra_protected_headers, header)` tuple - a `(jwk, alg, extra_protected_headers)` tuple, - a `(jwk, alg)` tuple, - a `jwk` with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. Returns: A JwsJsonGeneral with the generated signatures. \"\"\" jws = cls ({ \"payload\" : BinaPy ( payload ) . to ( \"b64u\" ) . ascii ()}) for parameters in signature_parameters : jws . add_signature ( * parameters ) return jws @cached_property def signatures ( self ) -> List [ JwsSignature ]: \"\"\"The list of `JwsSignature` from this JWS. Returns: The list of signatures from this JWS. \"\"\" signatures = self . get ( \"signatures\" ) if signatures is None : raise AttributeError ( \"This Jws JSON does not contain a 'signatures' member\" ) return [ JwsSignature ( sig ) for sig in signatures ] def add_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral : \"\"\"Add a new signature in this JWS. Args: jwk: the private key to use alg: the signature algorithm extra_protected_headers: additional headers to include, as a {key: value} mapping header: the raw unprotected header to include in the signature Returns: the same JWS with the new signature included. \"\"\" self . setdefault ( \"signatures\" , []) self [ \"signatures\" ] . append ( JwsSignature . sign ( self . payload , jwk , alg , extra_protected_headers , header ) ) return self def signed_part ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> bytes : \"\"\"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (`.`). You can select the specific signature with the `signature_chooser` parameter. By default, the first signature is selected. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: The raw signed part from the chosen signature. \"\"\" signature = signature_chooser ( self . signatures ) return JwsSignature . assemble_signed_part ( signature . protected , self . payload ) def compact ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsCompact : \"\"\"Create a compact JWS from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsCompact with the payload and the chosen signature from this JWS. \"\"\" return JwsCompact . from_parts ( self . signed_part ( signature_chooser ), self . payload ) def flatten ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsJsonFlat with the payload and the chosen signature from this JWS. \"\"\" signature = signature_chooser ( self . signatures ) return JwsJsonFlat . from_parts ( payload = self [ \"payload\" ], protected = signature . protected , header = signature . header , signature = signature . signature , ) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns `True` if at least one signature verifies. Args: jwk: the public key to use alg: the signature algorithm to use, if only 1 is allowed. algs: the allowed signature algorithms, if there are several. Returns: `True` if any of the signature verifies with the given key, `False` otherwise. \"\"\" for signature in self . signatures : if signature . verify ( self . payload , jwk , alg = alg , algs = algs ): return True return False payload \u00b6 1 payload () -> bytes The raw signed data. Returns: Type Description bytes The signed data. Source code in jwskate/jws/json.py 134 135 136 137 138 139 140 141 142 143 144 @cached_property def payload ( self ) -> bytes : \"\"\"The raw signed data. Returns: The signed data. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) sign classmethod \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sign ( payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str ], Union [ Jwk , Mapping [ str , Any ]], ] ) -> JwsJsonGeneral Sign a payload with several keys and return the resulting JWS in JSON general format. Parameters: Name Type Description Default payload bytes the data to sign required *signature_parameters Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]]], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]]], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str ], Union [ Jwk , Mapping [ str , Any ]]] each of those parameter can be: - a (jwk, alg, extra_protected_headers, header) tuple - a (jwk, alg, extra_protected_headers) tuple, - a (jwk, alg) tuple, - a jwk with jwk being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. () Returns: Type Description JwsJsonGeneral A JwsJsonGeneral with the generated signatures. Source code in jwskate/jws/json.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 @classmethod def sign ( cls , payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , ], Union [ Jwk , Mapping [ str , Any ]], ], ) -> JwsJsonGeneral : \"\"\"Sign a payload with several keys and return the resulting JWS in JSON general format. Args: payload: the data to sign *signature_parameters: each of those parameter can be: - a `(jwk, alg, extra_protected_headers, header)` tuple - a `(jwk, alg, extra_protected_headers)` tuple, - a `(jwk, alg)` tuple, - a `jwk` with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. Returns: A JwsJsonGeneral with the generated signatures. \"\"\" jws = cls ({ \"payload\" : BinaPy ( payload ) . to ( \"b64u\" ) . ascii ()}) for parameters in signature_parameters : jws . add_signature ( * parameters ) return jws signatures \u00b6 1 signatures () -> List [ JwsSignature ] The list of JwsSignature from this JWS. Returns: Type Description List [ JwsSignature ] The list of signatures from this JWS. Source code in jwskate/jws/json.py 188 189 190 191 192 193 194 195 196 197 198 @cached_property def signatures ( self ) -> List [ JwsSignature ]: \"\"\"The list of `JwsSignature` from this JWS. Returns: The list of signatures from this JWS. \"\"\" signatures = self . get ( \"signatures\" ) if signatures is None : raise AttributeError ( \"This Jws JSON does not contain a 'signatures' member\" ) return [ JwsSignature ( sig ) for sig in signatures ] add_signature \u00b6 1 2 3 4 5 6 7 8 add_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ] ] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral Add a new signature in this JWS. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private key to use required alg Optional [ str ] the signature algorithm None extra_protected_headers Optional [ Mapping [ str , Any ]] additional headers to include, as a {key: value} mapping None header Optional [ Mapping [ str , Any ]] the raw unprotected header to include in the signature None Returns: Type Description JwsJsonGeneral the same JWS with the new signature included. Source code in jwskate/jws/json.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def add_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral : \"\"\"Add a new signature in this JWS. Args: jwk: the private key to use alg: the signature algorithm extra_protected_headers: additional headers to include, as a {key: value} mapping header: the raw unprotected header to include in the signature Returns: the same JWS with the new signature included. \"\"\" self . setdefault ( \"signatures\" , []) self [ \"signatures\" ] . append ( JwsSignature . sign ( self . payload , jwk , alg , extra_protected_headers , header ) ) return self signed_part \u00b6 1 2 3 4 5 signed_part ( signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ] ) -> bytes Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot ( . ). You can select the specific signature with the signature_chooser parameter. By default, the first signature is selected. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description bytes The raw signed part from the chosen signature. Source code in jwskate/jws/json.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def signed_part ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> bytes : \"\"\"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (`.`). You can select the specific signature with the `signature_chooser` parameter. By default, the first signature is selected. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: The raw signed part from the chosen signature. \"\"\" signature = signature_chooser ( self . signatures ) return JwsSignature . assemble_signed_part ( signature . protected , self . payload ) compact \u00b6 1 2 3 4 5 compact ( signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ] ) -> JwsCompact Create a compact JWS from a specific signature from this JWS. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description JwsCompact A JwsCompact with the payload and the chosen signature from this JWS. Source code in jwskate/jws/json.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def compact ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsCompact : \"\"\"Create a compact JWS from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsCompact with the payload and the chosen signature from this JWS. \"\"\" return JwsCompact . from_parts ( self . signed_part ( signature_chooser ), self . payload ) flatten \u00b6 1 2 3 4 5 flatten ( signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ] ) -> JwsJsonFlat Create a JWS in JSON flat format from a specific signature from this JWS. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description JwsJsonFlat A JwsJsonFlat with the payload and the chosen signature from this JWS. Source code in jwskate/jws/json.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def flatten ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsJsonFlat with the payload and the chosen signature from this JWS. \"\"\" signature = signature_chooser ( self . signatures ) return JwsJsonFlat . from_parts ( payload = self [ \"payload\" ], protected = signature . protected , header = signature . header , signature = signature . signature , ) verify_signature \u00b6 1 2 3 4 5 6 verify_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> bool Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns True if at least one signature verifies. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the public key to use required alg Optional [ str ] the signature algorithm to use, if only 1 is allowed. None algs Optional [ Iterable [ str ]] the allowed signature algorithms, if there are several. None Returns: Type Description bool True if any of the signature verifies with the given key, False otherwise. Source code in jwskate/jws/json.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns `True` if at least one signature verifies. Args: jwk: the public key to use alg: the signature algorithm to use, if only 1 is allowed. algs: the allowed signature algorithms, if there are several. Returns: `True` if any of the signature verifies with the given key, `False` otherwise. \"\"\" for signature in self . signatures : if signature . verify ( self . payload , jwk , alg = alg , algs = algs ): return True return False jwskate.jwe \u00b6 This module implements Json Web Encryption as described in RFC7516 . InvalidJwe \u00b6 Bases: ValueError Raised when an invalid JWE token is parsed. Source code in jwskate/jwe/compact.py 20 21 class InvalidJwe ( ValueError ): \"\"\"Raised when an invalid JWE token is parsed.\"\"\" JweCompact \u00b6 Bases: BaseCompactToken Represents a Json Web Encryption object, in compact representation, as defined in RFC7516. Parameters: Name Type Description Default value Union [ bytes , str ] the compact representation for this Jwe required Source code in jwskate/jwe/compact.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class JweCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Encryption object, in compact representation, as defined in RFC7516. Args: value: the compact representation for this Jwe \"\"\" def __init__ ( self , value : Union [ bytes , str ]): super () . __init__ ( value ) if self . value . count ( b \".\" ) != 4 : raise InvalidJwe ( \"Invalid JWE: a JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots.\" ) header , cek , iv , ciphertext , auth_tag = self . value . split ( b \".\" ) try : headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) enc = headers . get ( \"enc\" ) if enc is None or not isinstance ( enc , str ): raise InvalidJwe ( \"Invalid JWE header: this JWE doesn't have a valid 'enc' header.\" ) self . headers = headers self . additional_authenticated_data = header except ValueError : raise InvalidJwe ( \"Invalid JWE header: it must be a Base64URL-encoded JSON object.\" ) try : self . wrapped_cek = BinaPy ( cek ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE CEK: it must be a Base64URL-encoded binary data (bytes).\" ) try : self . initialization_vector = BinaPy ( iv ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE IV: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . ciphertext = BinaPy ( ciphertext ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . authentication_tag = BinaPy ( auth_tag ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def from_parts ( cls , * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ), BinaPy ( cek ) . to ( \"b64u\" ), BinaPy ( iv ) . to ( \"b64u\" ), BinaPy ( ciphertext ) . to ( \"b64u\" ), BinaPy ( tag ) . to ( \"b64u\" ), ) ) ) @cached_property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" return self . get_header ( \"enc\" ) # type: ignore[no-any-return] # header has been checked at init time @classmethod def encrypt ( cls , plaintext : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext into a JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use for encryption enc: the encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" extra_headers = extra_headers or {} jwk = to_jwk ( jwk ) alg = select_alg_class ( jwk . KEY_MANAGEMENT_ALGORITHMS , jwk_alg = jwk . alg , alg = alg ) . name cek_jwk , wrapped_cek , cek_headers = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) if jwk . kid is not None : headers [ \"kid\" ] = jwk . kid aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) PBES2_ALGORITHMS : Mapping [ str , Type [ BasePbes2 ]] = { alg . name : alg for alg in [ Pbes2_HS256_A128KW , Pbes2_HS384_A192KW , Pbes2_HS512_A256KW ] } def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> BinaPy : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext @classmethod def encrypt_with_password ( cls , plaintext : Union [ SupportsBytes , bytes ], password : Union [ SupportsBytes , bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '. \" f \"Value must be one of { list ( cls . PBES2_ALGORITHMS . keys ()) } .\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000.\" ) wrapped_cek = wrapper . wrap_key ( cek , salt = salt , count = count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . to ( \"b64u\" ) . ascii (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '. \" f \"Value must be one of { list ( self . PBES2_ALGORITHMS . keys ()) } .\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2s' header is missing.\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2c' header is missing.\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise InvalidJwe ( \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt = salt , count = p2c ) return SymmetricJwk . from_bytes ( cek ) def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext from_parts classmethod \u00b6 1 2 3 4 5 6 7 8 from_parts ( * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes ) -> JweCompact Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Parameters: Name Type Description Default headers Mapping [ str , Any ] the headers (as a mapping of name: value) required cek bytes the raw cek required iv bytes the raw iv required ciphertext bytes the raw ciphertext required tag bytes the authentication tag required Returns: Type Description JweCompact the initialized JweCompact instance Source code in jwskate/jwe/compact.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @classmethod def from_parts ( cls , * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ), BinaPy ( cek ) . to ( \"b64u\" ), BinaPy ( iv ) . to ( \"b64u\" ), BinaPy ( ciphertext ) . to ( \"b64u\" ), BinaPy ( tag ) . to ( \"b64u\" ), ) ) ) enc \u00b6 1 enc () -> str Return the enc from the JWE header. The enc header contains the identifier of the CEK encryption algorithm. Returns: Type Description str the enc value Raises: Type Description AttributeError if there is no enc header or it is not a string Source code in jwskate/jwe/compact.py 116 117 118 119 120 121 122 123 124 125 126 127 128 @cached_property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" return self . get_header ( \"enc\" ) # type: ignore[no-any-return] encrypt classmethod \u00b6 1 2 3 4 5 6 7 8 9 10 11 encrypt ( plaintext : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None ) -> JweCompact Encrypt an arbitrary plaintext into a JweCompact. Parameters: Name Type Description Default plaintext Union [ bytes , SupportsBytes ] the raw plaintext to encrypt required jwk Union [ Jwk , Dict [ str , Any ]] the public or symmetric key to use for encryption required enc str the encryption algorithm to use required alg Optional [ str ] the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the generated token None cek Optional [ bytes ] the CEK to force use, for algorithms relying on a random CEK. Leave None to have a safe value generated by jwskate . None iv Optional [ bytes ] the IV to force use. Leave None to have a safe value generated by jwskate . None epk Optional [ Jwk ] the EPK to force use. Leave None to have a safe value generated by jwskate . None Returns: Type Description JweCompact the generated JweCompact instance Source code in jwskate/jwe/compact.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 @classmethod def encrypt ( cls , plaintext : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext into a JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use for encryption enc: the encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" extra_headers = extra_headers or {} jwk = to_jwk ( jwk ) alg = select_alg_class ( jwk . KEY_MANAGEMENT_ALGORITHMS , jwk_alg = jwk . alg , alg = alg ) . name cek_jwk , wrapped_cek , cek_headers = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) if jwk . kid is not None : headers [ \"kid\" ] = jwk . kid aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) unwrap_cek \u00b6 1 2 3 unwrap_cek ( jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk Unwrap the CEK from this JWE token using the provided key or password. Parameters: Name Type Description Default jwk_or_password Union [ Jwk , Dict [ str , Any ], bytes , str ] the decryption JWK or password required Returns: Type Description Jwk the unwrapped CEK, as a SymmetricJwk Source code in jwskate/jwe/compact.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek decrypt \u00b6 1 decrypt ( jwk : Union [ Jwk , Dict [ str , Any ]]) -> BinaPy Decrypts this Jwe payload using a JWK. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required Returns: Type Description BinaPy the decrypted payload Source code in jwskate/jwe/compact.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> BinaPy : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext encrypt_with_password classmethod \u00b6 1 2 3 4 5 6 7 8 9 10 11 encrypt_with_password ( plaintext : Union [ SupportsBytes , bytes ], password : Union [ SupportsBytes , bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None ) -> JweCompact Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Parameters: Name Type Description Default plaintext Union [ SupportsBytes , bytes ] the data to encrypt required password Union [ SupportsBytes , bytes , str ] the password to use required alg str the Key Management alg to use required enc str the Payload Encryption alg to use required salt Optional [ bytes ] the salt to use. Leave None (default) to have jwskate generate a safe random value None count int the number of PBES2 iterations (recommended minimum 1000) 2000 cek Optional [ bytes ] the CEK to force use. Leave None (default) to have jwskate generate a safe random value None iv Optional [ bytes ] the IV to force use. Leave None (default) to have jwskate generate a safe random value None Returns: Type Description JweCompact the resulting JweCompact Raises: Type Description UnsupportedAlg if the key management alg is not supported ValueError if the count parameter is not a positive integer Source code in jwskate/jwe/compact.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 @classmethod def encrypt_with_password ( cls , plaintext : Union [ SupportsBytes , bytes ], password : Union [ SupportsBytes , bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '. \" f \"Value must be one of { list ( cls . PBES2_ALGORITHMS . keys ()) } .\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000.\" ) wrapped_cek = wrapper . wrap_key ( cek , salt = salt , count = count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . to ( \"b64u\" ) . ascii (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) unwrap_cek_with_password \u00b6 1 2 3 unwrap_cek_with_password ( password : Union [ bytes , str ] ) -> Jwk Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Parameters: Name Type Description Default password Union [ bytes , str ] the decryption password required Returns: Type Description Jwk the CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the token key management algorithm is not supported AttributeError if the token misses the PBES2-related headers Source code in jwskate/jwe/compact.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '. \" f \"Value must be one of { list ( self . PBES2_ALGORITHMS . keys ()) } .\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2s' header is missing.\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2c' header is missing.\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise InvalidJwe ( \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt = salt , count = p2c ) return SymmetricJwk . from_bytes ( cek ) decrypt_with_password \u00b6 1 decrypt_with_password ( password : Union [ bytes , str ]) -> bytes Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Parameters: Name Type Description Default password Union [ bytes , str ] the password to use required Returns: Type Description bytes the unencrypted payload Source code in jwskate/jwe/compact.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext jwskate.jwa \u00b6 This module implements the Json Web Algorithms as defined in RFC7518 . Each algorithm is represented as a wrapper around a symmetric or asymmetric key, and exposes the cryptographic operations as methods. The cryptographic operations themselves are delegated to cryptography . P_256 module-attribute \u00b6 1 2 3 4 5 P_256 = EllipticCurve ( name = \"P-256\" , cryptography_curve = ec . SECP256R1 (), coordinate_size = 32 , ) P-256 curve Ed25519 module-attribute \u00b6 1 2 3 4 5 6 7 Ed25519 = OKPCurve ( name = \"Ed25519\" , description = \"Ed25519 signature algorithm key pairs\" , cryptography_private_key_class = ed25519 . Ed25519PrivateKey , cryptography_public_key_class = ed25519 . Ed25519PublicKey , use = \"sig\" , ) Ed25519 curve. P_384 module-attribute \u00b6 1 2 3 4 5 P_384 = EllipticCurve ( name = \"P-384\" , cryptography_curve = ec . SECP384R1 (), coordinate_size = 48 , ) P-384 curve Ed448 module-attribute \u00b6 1 2 3 4 5 6 7 Ed448 = OKPCurve ( name = \"Ed448\" , description = \"Ed448 signature algorithm key pairs\" , cryptography_private_key_class = ed448 . Ed448PrivateKey , cryptography_public_key_class = ed448 . Ed448PublicKey , use = \"sig\" , ) Ed448 curve. P_521 module-attribute \u00b6 1 2 3 4 5 P_521 = EllipticCurve ( name = \"P-521\" , cryptography_curve = ec . SECP521R1 (), coordinate_size = 66 , ) P-521 curve X25519 module-attribute \u00b6 1 2 3 4 5 6 7 X25519 = OKPCurve ( name = \"X25519\" , description = \"X25519 function key pairs\" , cryptography_private_key_class = x25519 . X25519PrivateKey , cryptography_public_key_class = x25519 . X25519PublicKey , use = \"enc\" , ) X25519 curve. secp256k1 module-attribute \u00b6 1 2 3 4 5 secp256k1 = EllipticCurve ( name = \"secp256k1\" , cryptography_curve = ec . SECP256K1 (), coordinate_size = 32 , ) secp256k1 curve X448 module-attribute \u00b6 1 2 3 4 5 6 7 X448 = OKPCurve ( name = \"X448\" , description = \"X448 function key pairs\" , cryptography_private_key_class = x448 . X448PrivateKey , cryptography_public_key_class = x448 . X448PublicKey , use = \"enc\" , ) X448 curve. BaseAesKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Base class for AES KW algorithms. Source code in jwskate/jwa/key_mgmt/aeskw.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class BaseAesKeyWrap ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Base class for AES KW algorithms.\"\"\" key_size : int \"\"\"Required AES key size in bits.\"\"\" @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits.\" ) def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" if not isinstance ( cipherkey , bytes ): cipherkey = bytes ( cipherkey ) return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) key_size class-attribute \u00b6 1 key_size : int Required AES key size in bits. check_key classmethod \u00b6 1 check_key ( key : bytes ) -> None Check that a key is valid for usage with this algorithm. To be valid, a key must be bytes and be of appropriate length (128, 192 or 256 bits). Parameters: Name Type Description Default key bytes a key to check required Raises: Type Description ValueError if the key is not appropriate Source code in jwskate/jwa/key_mgmt/aeskw.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits.\" ) wrap_key \u00b6 1 wrap_key ( plainkey : bytes ) -> BinaPy Wrap a key. Parameters: Name Type Description Default plainkey bytes the key to wrap. required Returns: Name Type Description BinaPy BinaPy the wrapped key. Source code in jwskate/jwa/key_mgmt/aeskw.py 31 32 33 34 35 36 37 38 39 40 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) unwrap_key \u00b6 1 2 3 unwrap_key ( cipherkey : Union [ bytes , SupportsBytes ] ) -> BinaPy Unwrap a key. Parameters: Name Type Description Default cipherkey Union [ bytes , SupportsBytes ] the wrapped key. required Returns: Name Type Description BinaPy BinaPy the unwrapped key. Source code in jwskate/jwa/key_mgmt/aeskw.py 42 43 44 45 46 47 48 49 50 51 52 53 54 def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" if not isinstance ( cipherkey , bytes ): cipherkey = bytes ( cipherkey ) return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey )) DirectKeyUse \u00b6 Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate/jwa/key_mgmt/dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) direct_key \u00b6 1 direct_key ( aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate/jwa/key_mgmt/dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key ) BaseAesGcmKeyWrap \u00b6 Bases: BaseAESGCM , BaseKeyManagementAlg Base class for AES-GCM Key wrapping algorithms. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class BaseAesGcmKeyWrap ( BaseAESGCM , BaseKeyManagementAlg ): \"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\" use = \"enc\" key_size : int \"\"\"Required key size, in bits.\"\"\" tag_size : int = 16 \"\"\"Authentication tag size, in bits.\"\"\" iv_size : int = 96 \"\"\"Initialisation Vector size, in bits.\"\"\" def wrap_key ( self , plainkey : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a symmetric key, which is typically used as Content Encryption Key (CEK). This method is used by the sender of the encrypted message. This needs a random Initialisation Vector (`iv`) of the appropriate size, which you can generate using the classmethod `generate_iv()`. Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv = iv ) def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ], * , tag : Union [ bytes , SupportsBytes ], iv : Union [ bytes , SupportsBytes ] ) -> BinaPy : \"\"\"Unwrap a symmetric key. This method is used by the recipient of an encrypted message. This requires: - the same IV that was provided during encryption - the same Authentication Tag that was generated during encryption Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , auth_tag = tag , iv = iv ) key_size class-attribute \u00b6 1 key_size : int Required key size, in bits. tag_size class-attribute \u00b6 1 tag_size : int = 16 Authentication tag size, in bits. iv_size class-attribute \u00b6 1 iv_size : int = 96 Initialisation Vector size, in bits. wrap_key \u00b6 1 2 3 4 5 wrap_key ( plainkey : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ] ) -> Tuple [ BinaPy , BinaPy ] Wrap a symmetric key, which is typically used as Content Encryption Key (CEK). This method is used by the sender of the encrypted message. This needs a random Initialisation Vector ( iv ) of the appropriate size, which you can generate using the classmethod generate_iv() . Parameters: Name Type Description Default plainkey Union [ bytes , SupportsBytes ] the key to wrap required iv Union [ bytes , SupportsBytes ] the Initialisation Vector to use required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (wrapped_key, authentication_tag) Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def wrap_key ( self , plainkey : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a symmetric key, which is typically used as Content Encryption Key (CEK). This method is used by the sender of the encrypted message. This needs a random Initialisation Vector (`iv`) of the appropriate size, which you can generate using the classmethod `generate_iv()`. Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv = iv ) unwrap_key \u00b6 1 2 3 4 5 6 unwrap_key ( cipherkey : Union [ bytes , SupportsBytes ], * , tag : Union [ bytes , SupportsBytes ], iv : Union [ bytes , SupportsBytes ] ) -> BinaPy Unwrap a symmetric key. This method is used by the recipient of an encrypted message. This requires: - the same IV that was provided during encryption - the same Authentication Tag that was generated during encryption Parameters: Name Type Description Default cipherkey Union [ bytes , SupportsBytes ] the wrapped key required tag Union [ bytes , SupportsBytes ] the authentication tag required iv Union [ bytes , SupportsBytes ] the Initialisation Vector required Returns: Type Description BinaPy the unwrapped key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ], * , tag : Union [ bytes , SupportsBytes ], iv : Union [ bytes , SupportsBytes ] ) -> BinaPy : \"\"\"Unwrap a symmetric key. This method is used by the recipient of an encrypted message. This requires: - the same IV that was provided during encryption - the same Authentication Tag that was generated during encryption Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , auth_tag = tag , iv = iv ) BaseHMACSigAlg \u00b6 Bases: BaseSymmetricAlg , BaseSignatureAlg Base class for HMAC signature algorithms. Source code in jwskate/jwa/signature/hmac.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class BaseHMACSigAlg ( BaseSymmetricAlg , BaseSignatureAlg ): \"\"\"Base class for HMAC signature algorithms.\"\"\" mac : Type [ hmac . HMAC ] = hmac . HMAC hashing_alg : hashes . HashAlgorithm min_key_size : int def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) if self . read_only : raise NotImplementedError m = self . mac ( self . key , self . hashing_alg ) m . update ( data ) signature = m . finalize () return BinaPy ( signature ) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) candidate_signature = self . sign ( data ) return candidate_signature == signature PrivateKeyRequired \u00b6 Bases: AttributeError Raised when a cryptographic operation requires a private key, and a public key has been provided instead. Source code in jwskate/jwa/base.py 12 13 class PrivateKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a private key, and a public key has been provided instead.\"\"\" EllipticCurve dataclass \u00b6 A descriptive class for Elliptic Curves. Elliptic Curves have a name, a cryptography.ec.EllipticCurve , and a coordinate size. Source code in jwskate/jwa/ec.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @dataclass class EllipticCurve : \"\"\"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size. \"\"\" name : str \"\"\" Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` or `enc` fields in JOSE headers.\"\"\" cryptography_curve : ec . EllipticCurve \"\"\"`cryptography` curve instance.\"\"\" coordinate_size : int \"\"\"Coordinate size, in bytes.\"\"\" instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key: an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) @classmethod def get_jwk_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from the given `cryptography` key. Key must be an instance of `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a dict of JWK parameters matching that key Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) public_numbers : ec . EllipticCurvePublicNumbers if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () y = BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters name class-attribute \u00b6 1 name : str Curve name as defined in IANA JOSE . This name will appear in alg or enc fields in JOSE headers. cryptography_curve class-attribute \u00b6 1 cryptography_curve : ec . EllipticCurve cryptography curve instance. coordinate_size class-attribute \u00b6 1 coordinate_size : int Coordinate size, in bytes. instances class-attribute \u00b6 1 instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} Registry of subclasses, in a {name: instance} mapping. __post_init__ \u00b6 1 __post_init__ () -> None Automatically register subclasses in the instance registry. Source code in jwskate/jwa/ec.py 33 34 35 def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self generate \u00b6 1 generate () -> Tuple [ int , int , int ] Generate a new EC key on this curve. Returns: Type Description Tuple [ int , int , int ] a tuple of 4 int s: x and y coordinates (public key) and d (private key) Source code in jwskate/jwa/ec.py 37 38 39 40 41 42 43 44 45 46 47 48 def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d get_curve classmethod \u00b6 1 2 3 4 5 6 get_curve ( key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey , ] ) -> EllipticCurve Get the appropriate EllipticCurve instance for a given cryptography EllipticCurvePublicKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] an Elliptic Curve private or public key from cryptography . required Returns: Type Description EllipticCurve the appropriate instance of EllipticCurve for the given key. Raises: Type Description NotImplementedError if the curve is not supported Source code in jwskate/jwa/ec.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key: an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) get_jwk_parameters classmethod \u00b6 1 2 3 4 5 6 get_jwk_parameters ( key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey , ] ) -> Dict [ str , Any ] Extract all private and public parameters from the given cryptography key. Key must be an instance of EllipticCurvePrivateKey or EllipticCurvePublicKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] an Elliptic Curve public or private key from cryptography . required Returns: Type Description Dict [ str , Any ] a dict of JWK parameters matching that key Raises: Type Description TypeError if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey Source code in jwskate/jwa/ec.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @classmethod def get_jwk_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from the given `cryptography` key. Key must be an instance of `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a dict of JWK parameters matching that key Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) public_numbers : ec . EllipticCurvePublicNumbers if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () y = BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters BaseRsaKeyWrap \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ rsa . RSAPrivateKey , rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Parameters: Name Type Description Default key Union [ rsa . RSAPublicKey , rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate/jwa/key_mgmt/rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ rsa . RSAPrivateKey , rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms. Args: key: the private or public key to use \"\"\" padding : Any name : str description : str private_key_class = rsa . RSAPrivateKey public_key_class = rsa . RSAPublicKey def __init__ ( self , key : Union [ rsa . RSAPublicKey , rsa . RSAPrivateKey ]): self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" if self . read_only : raise NotImplementedError ( \"Due to security reasons, this algorithm is only usable for decryption.\" ) with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" if not isinstance ( cipherkey , bytes ): cipherkey = bytes ( cipherkey ) with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) wrap_key \u00b6 1 wrap_key ( plainkey : bytes ) -> BinaPy Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate/jwa/key_mgmt/rsa.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" if self . read_only : raise NotImplementedError ( \"Due to security reasons, this algorithm is only usable for decryption.\" ) with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) unwrap_key \u00b6 1 2 3 unwrap_key ( cipherkey : Union [ bytes , SupportsBytes ] ) -> BinaPy Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey Union [ bytes , SupportsBytes ] the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate/jwa/key_mgmt/rsa.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" if not isinstance ( cipherkey , bytes ): cipherkey = bytes ( cipherkey ) with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding )) BaseRSASigAlg \u00b6 Bases: BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] , BaseSignatureAlg Base class for RSA based signature algorithms. Source code in jwskate/jwa/signature/rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class BaseRSASigAlg ( BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], BaseSignatureAlg , ): \"\"\"Base class for RSA based signature algorithms.\"\"\" hashing_alg : hashes . HashAlgorithm padding_alg : padding . AsymmetricPadding = padding . PKCS1v15 () min_key_size : int = 2048 private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Sign arbitrary data. Args: data: the data to sign Returns: the generated signature Raises: NotImplementedError: for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired: if the configured key is not private \"\"\" if self . read_only : raise NotImplementedError if not isinstance ( data , bytes ): data = bytes ( data ) with self . private_key_required () as key : return BinaPy ( key . sign ( data , self . padding_alg , self . hashing_alg )) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : \"\"\"Verify a signature against some data. Args: data: the data to verify signature: the signature Returns: `True` if the signature is valid, `False` otherwise \"\"\" if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) with self . public_key_required () as key : try : key . verify ( signature , data , self . padding_alg , self . hashing_alg , ) return True except exceptions . InvalidSignature : return False sign \u00b6 1 sign ( data : Union [ bytes , SupportsBytes ]) -> BinaPy Sign arbitrary data. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the data to sign required Returns: Type Description BinaPy the generated signature Raises: Type Description NotImplementedError for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired if the configured key is not private Source code in jwskate/jwa/signature/rsa.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Sign arbitrary data. Args: data: the data to sign Returns: the generated signature Raises: NotImplementedError: for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired: if the configured key is not private \"\"\" if self . read_only : raise NotImplementedError if not isinstance ( data , bytes ): data = bytes ( data ) with self . private_key_required () as key : return BinaPy ( key . sign ( data , self . padding_alg , self . hashing_alg )) verify \u00b6 1 2 3 4 verify ( data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], ) -> bool Verify a signature against some data. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the data to verify required signature Union [ bytes , SupportsBytes ] the signature required Returns: Type Description bool True if the signature is valid, False otherwise Source code in jwskate/jwa/signature/rsa.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : \"\"\"Verify a signature against some data. Args: data: the data to verify signature: the signature Returns: `True` if the signature is valid, `False` otherwise \"\"\" if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) with self . public_key_required () as key : try : key . verify ( signature , data , self . padding_alg , self . hashing_alg , ) return True except exceptions . InvalidSignature : return False EdDsa \u00b6 Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate/jwa/signature/eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False BasePbes2 \u00b6 Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. PBES2 derives a cryptographic key from a human-provided password. Parameters: Name Type Description Default password Union [ SupportsBytes , bytes , str ] the encryption/decryption password to use required Source code in jwskate/jwa/key_mgmt/pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms. PBES2 derives a cryptographic key from a human-provided password. Args: password: the encryption/decryption password to use \"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ SupportsBytes , bytes , str ]): if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) if not isinstance ( password , bytes ): password = bytes ( password ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive an encryption key based on the configured password, a given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) generate_salt \u00b6 1 generate_salt ( size : int = 12 ) -> BinaPy Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate/jwa/key_mgmt/pbes2.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) derive \u00b6 1 derive ( * , salt : bytes , count : int ) -> BinaPy Derive an encryption key based on the configured password, a given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate/jwa/key_mgmt/pbes2.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def derive ( self , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive an encryption key based on the configured password, a given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) wrap_key \u00b6 1 2 3 wrap_key ( plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate/jwa/key_mgmt/pbes2.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def wrap_key ( self , plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) unwrap_key \u00b6 1 2 3 unwrap_key ( cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate/jwa/key_mgmt/pbes2.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def unwrap_key ( self , cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey )) BaseECSignatureAlg \u00b6 Bases: BaseAsymmetricAlg [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] , BaseSignatureAlg Base class for Elliptic Curve signature algorithms. Source code in jwskate/jwa/signature/ec.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class BaseECSignatureAlg ( BaseAsymmetricAlg [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ], BaseSignatureAlg , ): \"\"\"Base class for Elliptic Curve signature algorithms.\"\"\" curve : EllipticCurve hashing_alg : hashes . HashAlgorithm public_key_class = ec . EllipticCurvePublicKey private_key_class = ec . EllipticCurvePrivateKey @classmethod def check_key ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> None : # noqa: D102 if key . curve . name != cls . curve . cryptography_curve . name : raise ValueError ( f \"This key is on curve { key . curve . name } . An EC key on curve { cls . curve . name } is expected.\" ) def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) with self . private_key_required () as key : dss_sig = key . sign ( data , ec . ECDSA ( self . hashing_alg )) r , s = asymmetric . utils . decode_dss_signature ( dss_sig ) return BinaPy . from_int ( r , self . curve . coordinate_size ) + BinaPy . from_int ( s , self . curve . coordinate_size ) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) with self . public_key_required () as key : if len ( signature ) != self . curve . coordinate_size * 2 : raise ValueError ( f \"Invalid signature length { len ( signature ) } bytes, expected { self . curve . coordinate_size * 2 } bytes\" ) r_bytes , s_bytes = ( signature [: self . curve . coordinate_size ], signature [ self . curve . coordinate_size :], ) r = int . from_bytes ( r_bytes , \"big\" , signed = False ) s = int . from_bytes ( s_bytes , \"big\" , signed = False ) dss_signature = asymmetric . utils . encode_dss_signature ( r , s ) try : key . verify ( dss_signature , data , ec . ECDSA ( self . hashing_alg ), ) return True except exceptions . InvalidSignature : return False EcdhEs \u00b6 Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ]] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate/jwa/key_mgmt/ecdh.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = ( ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ) private_key_class = ( ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ) @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , key_size : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo key_size: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( key_size or key_size , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" if isinstance ( private_key , ec . EllipticCurvePrivateKey ) and isinstance ( public_key , ec . EllipticCurvePublicKey ): shared_key = private_key . exchange ( ec . ECDH (), public_key ) elif isinstance ( private_key , x25519 . X25519PrivateKey ) and isinstance ( public_key , x25519 . X25519PublicKey ): shared_key = private_key . exchange ( public_key ) elif isinstance ( private_key , x448 . X448PrivateKey ) and isinstance ( public_key , x448 . X448PublicKey ): shared_key = private_key . exchange ( public_key ) else : raise ValueError ( \"Invalid or unsupported private/public key combination for ECDH\" , type ( private_key ), type ( public_key ), ) return BinaPy ( shared_key ) @classmethod def derive ( cls , * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], otherinfo : bytes , key_size : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter key_size: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = key_size // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self , ) -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ]: \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" if isinstance ( self . key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ) ): return ec . generate_private_key ( self . key . curve ) elif isinstance ( self . key , ( x25519 . X25519PrivateKey , x25519 . X25519PublicKey )): return x25519 . X25519PrivateKey . generate () elif isinstance ( self . key , ( x448 . X448PublicKey , x448 . X448PrivateKey )): return x448 . X448PrivateKey . generate () def sender_key ( self , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = ephemeral_private_key , public_key = key , otherinfo = otherinfo , key_size = key_size , ) return cek def recipient_key ( self , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = key , public_key = ephemeral_public_key , otherinfo = otherinfo , key_size = key_size , ) return cek otherinfo classmethod \u00b6 1 2 3 otherinfo ( alg : str , apu : bytes , apv : bytes , key_size : int ) -> BinaPy Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required key_size int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate/jwa/key_mgmt/ecdh.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , key_size : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo key_size: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( key_size or key_size , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) ecdh classmethod \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 ecdh ( private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ], ) -> BinaPy This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] a private EC key required public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate/jwa/key_mgmt/ecdh.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @classmethod def ecdh ( cls , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" if isinstance ( private_key , ec . EllipticCurvePrivateKey ) and isinstance ( public_key , ec . EllipticCurvePublicKey ): shared_key = private_key . exchange ( ec . ECDH (), public_key ) elif isinstance ( private_key , x25519 . X25519PrivateKey ) and isinstance ( public_key , x25519 . X25519PublicKey ): shared_key = private_key . exchange ( public_key ) elif isinstance ( private_key , x448 . X448PrivateKey ) and isinstance ( public_key , x448 . X448PublicKey ): shared_key = private_key . exchange ( public_key ) else : raise ValueError ( \"Invalid or unsupported private/public key combination for ECDH\" , type ( private_key ), type ( public_key ), ) return BinaPy ( shared_key ) derive classmethod \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 derive ( * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ], otherinfo : bytes , key_size : int ) -> BinaPy Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the private key required public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required key_size int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate/jwa/key_mgmt/ecdh.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 @classmethod def derive ( cls , * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], otherinfo : bytes , key_size : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter key_size: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = key_size // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) generate_ephemeral_key \u00b6 1 2 3 4 5 generate_ephemeral_key () -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ] Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate/jwa/key_mgmt/ecdh.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_ephemeral_key ( self , ) -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ]: \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" if isinstance ( self . key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ) ): return ec . generate_private_key ( self . key . curve ) elif isinstance ( self . key , ( x25519 . X25519PrivateKey , x25519 . X25519PublicKey )): return x25519 . X25519PrivateKey . generate () elif isinstance ( self . key , ( x448 . X448PublicKey , x448 . X448PrivateKey )): return x448 . X448PrivateKey . generate () sender_key \u00b6 1 2 3 4 5 6 7 8 9 10 11 sender_key ( ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ], * , alg : str , key_size : int , ** headers : Any ) -> BinaPy Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate/jwa/key_mgmt/ecdh.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def sender_key ( self , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = ephemeral_private_key , public_key = key , otherinfo = otherinfo , key_size = key_size , ) return cek recipient_key \u00b6 1 2 3 4 5 6 7 8 9 10 11 recipient_key ( ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ], * , alg : str , key_size : int , ** headers : Any ) -> BinaPy Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate/jwa/key_mgmt/ecdh.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def recipient_key ( self , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = key , public_key = ephemeral_public_key , otherinfo = otherinfo , key_size = key_size , ) return cek PublicKeyRequired \u00b6 Bases: AttributeError Raised when a cryptographic operation requires a public key, and a private key has been provided instead. Source code in jwskate/jwa/base.py 16 17 class PublicKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a public key, and a private key has been provided instead.\"\"\" BaseAlg \u00b6 Base class for all algorithms. An algorithm has a name and a description , whose reference is found in IANA JOSE registry . Source code in jwskate/jwa/base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class BaseAlg : \"\"\"Base class for all algorithms. An algorithm has a `name` and a `description`, whose reference is found in [IANA JOSE registry][IANA]. [IANA]: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms \"\"\" use : str \"\"\"Alg use ('sig' or 'enc')\"\"\" name : str \"\"\"Technical name of the algorithm\"\"\" description : str \"\"\"Description of the algorithm (human readable)\"\"\" read_only : bool = False \"\"\"For algs that are considered insecure, set to True to allow only signature verification or decryption of existing data, but don't allow new signatures or encryption.\"\"\" def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name use class-attribute \u00b6 1 use : str Alg use ('sig' or 'enc') name class-attribute \u00b6 1 name : str Technical name of the algorithm description class-attribute \u00b6 1 description : str Description of the algorithm (human readable) read_only class-attribute \u00b6 1 read_only : bool = False For algs that are considered insecure, set to True to allow only signature verification or decryption of existing data, but don't allow new signatures or encryption. __repr__ \u00b6 1 __repr__ () -> str Use the name of the alg as repr. Source code in jwskate/jwa/base.py 39 40 41 def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name HS256 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-256. Source code in jwskate/jwa/signature/hmac.py 42 43 44 45 46 47 48 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256.\"\"\" name = \"HS256\" description = __doc__ hashing_alg = hashes . SHA256 () min_key_size = 256 BaseSymmetricAlg \u00b6 Bases: BaseAlg Base class for Symmetric algorithms (using a raw bytes key). Parameters: Name Type Description Default key bytes the key to use for cryptographic operations required Source code in jwskate/jwa/base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class BaseSymmetricAlg ( BaseAlg ): \"\"\"Base class for Symmetric algorithms (using a raw bytes key). Args: key: the key to use for cryptographic operations \"\"\" def __init__ ( self , key : bytes ): self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False check_key classmethod \u00b6 1 check_key ( key : bytes ) -> None Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description None Returns None . Raises an exception if the key is not suitable Source code in jwskate/jwa/base.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass supports_key classmethod \u00b6 1 supports_key ( key : bytes ) -> bool Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate/jwa/base.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False OKPCurve dataclass \u00b6 Represent an Octet Key Pair (OKP) Curve. Source code in jwskate/jwa/okp.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @dataclass class OKPCurve : \"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\" name : str \"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` headers.\"\"\" description : str \"\"\"Curve description (human readable).\"\"\" cryptography_private_key_class : Type [ Any ] \"\"\"`cryptography` private key class.\"\"\" cryptography_public_key_class : Type [ Any ] \"\"\"`cryptography` public key class.\"\"\" use : str \"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\" instances : ClassVar [ Dict [ str , OKPCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key: `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" ) name class-attribute \u00b6 1 name : str Curve name as defined in IANA JOSE . This name will appear in alg headers. description class-attribute \u00b6 1 description : str Curve description (human readable). cryptography_private_key_class class-attribute \u00b6 1 cryptography_private_key_class : Type [ Any ] cryptography private key class. cryptography_public_key_class class-attribute \u00b6 1 cryptography_public_key_class : Type [ Any ] cryptography public key class. use class-attribute \u00b6 1 use : str Curve usage ( 'sig' or ' enc' ). instances class-attribute \u00b6 1 instances : ClassVar [ Dict [ str , OKPCurve ]] = {} Registry of subclasses, in a {name: instance} mapping. __post_init__ \u00b6 1 __post_init__ () -> None Automatically registers subclasses in the instance registry. Source code in jwskate/jwa/okp.py 69 70 71 def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self generate \u00b6 1 generate () -> Tuple [ bytes , bytes ] Generate a new private key on this curve. Returns: Type Description Tuple [ bytes , bytes ] a tuple of x (public part), and d (private part), as bytes Source code in jwskate/jwa/okp.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d get_curve classmethod \u00b6 1 2 3 get_curve ( key : Union [ PublicKeyProtocol , PrivateKeyProtocol ] ) -> OKPCurve Return the appropriate OKPCurve instance for a given cryptography private or public key. Parameters: Name Type Description Default key Union [ PublicKeyProtocol , PrivateKeyProtocol ] cryptography private or public OKP key. required Returns: Name Type Description OKPCurve OKPCurve the appropriate OKPCurve for the given key Raises: Type Description NotImplementedError if the required OKP curve is not supported Source code in jwskate/jwa/okp.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key: `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" ) HS384 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-384. Source code in jwskate/jwa/signature/hmac.py 51 52 53 54 55 56 57 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384.\"\"\" name = \"HS384\" description = __doc__ hashing_alg = hashes . SHA384 () min_key_size = 384 A128KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 57 58 59 60 61 62 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128 HS512 \u00b6 Bases: BaseHMACSigAlg HMAC using SHA-512. Source code in jwskate/jwa/signature/hmac.py 60 61 62 63 64 65 66 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512.\"\"\" name = \"HS512\" description = __doc__ hashing_alg = hashes . SHA512 () min_key_size = 512 A192KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 65 66 67 68 69 70 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192 A128GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 68 69 70 71 72 73 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128 RsaEsPcks1v1_5 \u00b6 Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5. Source code in jwskate/jwa/key_mgmt/rsa.py 70 71 72 73 74 75 76 77 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5.\"\"\" name = \"RSA1_5\" description = __doc__ read_only = True padding = padding . PKCS1v15 () A256KW \u00b6 Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 73 74 75 76 77 78 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256 A192GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 76 77 78 79 80 81 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192 ES256 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256. Source code in jwskate/jwa/signature/ec.py 78 79 80 81 82 83 84 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256.\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 () RS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256. Source code in jwskate/jwa/signature/rsa.py 78 79 80 81 82 83 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256.\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 () RsaEsOaep \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using default parameters. Source code in jwskate/jwa/key_mgmt/rsa.py 80 81 82 83 84 85 86 87 88 89 90 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters.\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , ) A256GCMKW \u00b6 Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 84 85 86 87 88 89 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256 RS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384. Source code in jwskate/jwa/signature/rsa.py 86 87 88 89 90 91 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384.\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 () ES384 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384. Source code in jwskate/jwa/signature/ec.py 87 88 89 90 91 92 93 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384.\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 () BaseAsymmetricAlg \u00b6 Bases: Generic [ Kpriv , Kpub ] , BaseAlg Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Source code in jwskate/jwa/base.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class BaseAsymmetricAlg ( Generic [ Kpriv , Kpub ], BaseAlg ): \"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Args: key: the key to use. \"\"\" private_key_class : Union [ Type [ Kpriv ], Tuple [ Type [ Kpriv ], ... ]] public_key_class : Union [ Type [ Kpub ], Tuple [ Type [ Kpub ], ... ]] def __init__ ( self , key : Union [ Kpriv , Kpub ]): self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore check_key classmethod \u00b6 1 check_key ( key : Union [ Kpriv , Kpub ]) -> None Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Returns: Type Description None Returns None. Raises an exception if the key is not suitable. Raises: Type Description Exception if the key is not suitable for use with this alg class Source code in jwskate/jwa/base.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" private_key_required \u00b6 1 private_key_required () -> Iterator [ Kpriv ] A context manager that checks if this alg is initialised with a private key. Yields: Type Description Iterator [ Kpriv ] the private key Raises: Type Description PrivateKeyRequired if the configured key is not private Source code in jwskate/jwa/base.py 126 127 128 129 130 131 132 133 134 135 136 137 138 @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore public_key_required \u00b6 1 public_key_required () -> Iterator [ Kpub ] A context manager that checks if this alg is initialised with a public key. Yields: Type Description Iterator [ Kpub ] The public key Raises: Type Description PublicKeyRequired if the configured key is private Source code in jwskate/jwa/base.py 140 141 142 143 144 145 146 147 148 149 150 151 152 @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore RsaEsOaepSha256 \u00b6 Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256. Source code in jwskate/jwa/key_mgmt/rsa.py 93 94 95 96 97 98 99 100 101 102 103 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256.\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , ) A128GCM \u00b6 Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 94 95 96 97 98 99 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128 RS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256. Source code in jwskate/jwa/signature/rsa.py 94 95 96 97 98 99 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256.\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 () Pbes2_HS256_A128KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 96 97 98 99 100 101 102 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 () ES512 \u00b6 Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512. Source code in jwskate/jwa/signature/ec.py 96 97 98 99 100 101 102 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512.\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 () A192GCM \u00b6 Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 102 103 104 105 106 107 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192 PS256 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256. Source code in jwskate/jwa/signature/rsa.py 102 103 104 105 106 107 108 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256.\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 ) Pbes2_HS384_A192KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 105 106 107 108 109 110 111 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 () ES256K \u00b6 Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256. Source code in jwskate/jwa/signature/ec.py 105 106 107 108 109 110 111 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256.\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 () RsaEsOaepSha384 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384. Source code in jwskate/jwa/key_mgmt/rsa.py 106 107 108 109 110 111 112 113 114 115 116 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384.\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , ) A256GCM \u00b6 Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 110 111 112 113 114 115 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256 PS384 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384. Source code in jwskate/jwa/signature/rsa.py 111 112 113 114 115 116 117 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384.\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 ) Pbes2_HS512_A256KW \u00b6 Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 114 115 116 117 118 119 120 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 () RsaEsOaepSha512 \u00b6 Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512. Source code in jwskate/jwa/key_mgmt/rsa.py 119 120 121 122 123 124 125 126 127 128 129 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512.\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , ) PS512 \u00b6 Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512. Source code in jwskate/jwa/signature/rsa.py 120 121 122 123 124 125 126 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512.\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 ) BaseSignatureAlg \u00b6 Bases: BaseAlg Base class for signature algorithms. Source code in jwskate/jwa/base.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 class BaseSignatureAlg ( BaseAlg ): \"\"\"Base class for signature algorithms.\"\"\" use = \"sig\" def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError sign \u00b6 1 sign ( data : Union [ bytes , SupportsBytes ]) -> BinaPy Sign arbitrary data, return the signature. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] raw data to sign required Returns: Type Description BinaPy the raw signature Source code in jwskate/jwa/base.py 160 161 162 163 164 165 166 167 168 169 def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError verify \u00b6 1 2 3 4 verify ( data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], ) -> bool Verify a signature against some data. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the raw data to verify required signature Union [ bytes , SupportsBytes ] the raw signature required Returns: Type Description bool True if the signature matches, False otherwise. Source code in jwskate/jwa/base.py 171 172 173 174 175 176 177 178 179 180 181 182 183 def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError A128CBC_HS256 \u00b6 Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate/jwa/encryption/aescbchmac.py 162 163 164 165 166 167 168 169 170 class A128CBC_HS256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 () A192CBC_HS384 \u00b6 Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate/jwa/encryption/aescbchmac.py 173 174 175 176 177 178 179 180 181 class A192CBC_HS384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 () A256CBC_HS512 \u00b6 Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate/jwa/encryption/aescbchmac.py 184 185 186 187 188 189 190 191 192 193 class A256CBC_HS512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 () BaseAESEncryptionAlg \u00b6 Bases: BaseSymmetricAlg Base class for AES encryption algorithms. Source code in jwskate/jwa/base.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 class BaseAESEncryptionAlg ( BaseSymmetricAlg ): \"\"\"Base class for AES encryption algorithms.\"\"\" use = \"enc\" key_size : int tag_size : int iv_size : int @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected key size of { cls . key_size } bits\" ) @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data, with [Authenticated Encryption (with optional Associated Data)][AEAD]. This needs: - the raw data to encrypt (`plaintext`) - a given random Initialisation Vector (`iv`) of the appropriate size - optional Additional Authentication Data (`aad`) And returns a tuple (ciphered_data, authentication_tag). Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag [AEAD]: https://wikipedia.org/wiki/Authenticated_encryption \"\"\" raise NotImplementedError def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], auth_tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , ) -> BinaPy : \"\"\"Decrypt and verify a ciphertext with Authenticated Encryption. This needs: - the raw encrypted Data (`ciphertext`) and Authentication Tag (`auth_tag`) that were produced by encryption, - the same Initialisation Vector (`iv`) and optional Additional Authentication Data that were provided for encryption. and returns the resulting clear text data. Args: ciphertext: the data to decrypt iv: the Initialisation Vector to use. Must be the same one used during encryption auth_tag: the authentication tag aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError @classmethod def init_random_key ( cls ) -> BaseAESEncryptionAlg : \"\"\"Initialize this alg with a random key. Returns: a subclass of BaseAESEncryptionAlg initialized with a randomly generated key \"\"\" return cls ( cls . generate_key ()) check_key classmethod \u00b6 1 check_key ( key : bytes ) -> None Check that a key is suitable for this algorithm. Parameters: Name Type Description Default key bytes the key to check required Raises: Type Description ValueError if the key is not suitable Source code in jwskate/jwa/base.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected key size of { cls . key_size } bits\" ) generate_key classmethod \u00b6 1 generate_key () -> BinaPy Generate a key of an appropriate size for this AES alg subclass. Returns: Type Description BinaPy a random AES key Source code in jwskate/jwa/base.py 210 211 212 213 214 215 216 217 @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) generate_iv classmethod \u00b6 1 generate_iv () -> BinaPy Generate an Initialisation Vector of the appropriate size. Returns: Type Description BinaPy a random IV Source code in jwskate/jwa/base.py 219 220 221 222 223 224 225 226 @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) encrypt \u00b6 1 2 3 4 5 6 encrypt ( plaintext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None ) -> Tuple [ BinaPy , BinaPy ] Encrypt arbitrary data, with Authenticated Encryption (with optional Associated Data) . This needs: - the raw data to encrypt ( plaintext ) - a given random Initialisation Vector ( iv ) of the appropriate size - optional Additional Authentication Data ( aad ) And returns a tuple (ciphered_data, authentication_tag). Parameters: Name Type Description Default plaintext Union [ bytes , SupportsBytes ] the data to encrypt required iv Union [ bytes , SupportsBytes ] the Initialisation Vector to use required aad Union [ bytes , SupportsBytes , None] the Additional Authentication Data None Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple of ciphered data and authentication tag Source code in jwskate/jwa/base.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data, with [Authenticated Encryption (with optional Associated Data)][AEAD]. This needs: - the raw data to encrypt (`plaintext`) - a given random Initialisation Vector (`iv`) of the appropriate size - optional Additional Authentication Data (`aad`) And returns a tuple (ciphered_data, authentication_tag). Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag [AEAD]: https://wikipedia.org/wiki/Authenticated_encryption \"\"\" raise NotImplementedError decrypt \u00b6 1 2 3 4 5 6 7 decrypt ( ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], auth_tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None ) -> BinaPy Decrypt and verify a ciphertext with Authenticated Encryption. This needs: - the raw encrypted Data ( ciphertext ) and Authentication Tag ( auth_tag ) that were produced by encryption, - the same Initialisation Vector ( iv ) and optional Additional Authentication Data that were provided for encryption. and returns the resulting clear text data. Parameters: Name Type Description Default ciphertext Union [ bytes , SupportsBytes ] the data to decrypt required iv Union [ bytes , SupportsBytes ] the Initialisation Vector to use. Must be the same one used during encryption required auth_tag Union [ bytes , SupportsBytes ] the authentication tag required aad Union [ bytes , SupportsBytes , None] the Additional Authentication Data. Must be the same one used during encryption None Returns: Type Description BinaPy the deciphered data Source code in jwskate/jwa/base.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], auth_tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , ) -> BinaPy : \"\"\"Decrypt and verify a ciphertext with Authenticated Encryption. This needs: - the raw encrypted Data (`ciphertext`) and Authentication Tag (`auth_tag`) that were produced by encryption, - the same Initialisation Vector (`iv`) and optional Additional Authentication Data that were provided for encryption. and returns the resulting clear text data. Args: ciphertext: the data to decrypt iv: the Initialisation Vector to use. Must be the same one used during encryption auth_tag: the authentication tag aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError init_random_key classmethod \u00b6 1 init_random_key () -> BaseAESEncryptionAlg Initialize this alg with a random key. Returns: Type Description BaseAESEncryptionAlg a subclass of BaseAESEncryptionAlg initialized with a randomly generated key Source code in jwskate/jwa/base.py 281 282 283 284 285 286 287 288 @classmethod def init_random_key ( cls ) -> BaseAESEncryptionAlg : \"\"\"Initialize this alg with a random key. Returns: a subclass of BaseAESEncryptionAlg initialized with a randomly generated key \"\"\" return cls ( cls . generate_key ()) BaseEcdhEs_AesKw \u00b6 Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate/jwa/key_mgmt/ecdh.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : Union [ bytes , SupportsBytes ], ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) wrap_key_with_epk \u00b6 1 2 3 4 5 6 7 8 9 wrap_key_with_epk ( plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ], ** headers : Any ) -> BinaPy Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate/jwa/key_mgmt/ecdh.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) unwrap_key_with_epk \u00b6 1 2 3 4 5 6 7 8 9 unwrap_key_with_epk ( cipherkey : Union [ bytes , SupportsBytes ], ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ], ** headers : Any ) -> BinaPy Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey Union [ bytes , SupportsBytes ] the wrapped key required ephemeral_public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate/jwa/key_mgmt/ecdh.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def unwrap_key_with_epk ( self , cipherkey : Union [ bytes , SupportsBytes ], ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey ) EcdhEs_A128KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 267 268 269 270 271 272 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW EcdhEs_A192KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 275 276 277 278 279 280 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW EcdhEs_A256KW \u00b6 Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 283 284 285 286 287 288 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW BaseKeyManagementAlg \u00b6 Bases: BaseAlg Base class for Key Management algorithms. Source code in jwskate/jwa/base.py 291 292 293 294 class BaseKeyManagementAlg ( BaseAlg ): \"\"\"Base class for Key Management algorithms.\"\"\" use = \"enc\" MismatchingAuthTag \u00b6 Bases: cryptography . exceptions . InvalidTag Raised when trying to decrypt with an Authentication Tag that doesn't match the expected value. Source code in jwskate/jwa/base.py 297 298 class MismatchingAuthTag ( cryptography . exceptions . InvalidTag ): \"\"\"Raised when trying to decrypt with an Authentication Tag that doesn't match the expected value.\"\"\"","title":"API"},{"location":"api/#jwskate.jwk","text":"This module implements Json Web Key RFC7517 .","title":"jwk"},{"location":"api/#jwskate.jwk.UnsupportedAlg","text":"Bases: ValueError Raised when a unsupported alg is requested. Source code in jwskate/jwk/alg.py 9 10 class UnsupportedAlg ( ValueError ): \"\"\"Raised when a unsupported alg is requested.\"\"\"","title":"UnsupportedAlg"},{"location":"api/#jwskate.jwk.JwkSet","text":"Bases: BaseJsonDict A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. a dict from the parsed JSON object representing this JwkSet (in paramter jwks ) a list of Jwk (in parameter keys nothing, to initialize an empty JwkSet Parameters: Name Type Description Default jwks Optional [ Dict [ str , Any ]] a dict, containing the JwkSet, parsed as a JSON object. None keys Optional [ Iterable [ Union [ Jwk , Dict [ str , Any ]]]] a list of Jwk , that will be added to this JwkSet None Source code in jwskate/jwk/jwks.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class JwkSet ( BaseJsonDict ): \"\"\"A set of JWK keys, with methods for easy management of keys. A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set. - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`) - a list of `Jwk` (in parameter `keys` - nothing, to initialize an empty JwkSet Args: jwks: a dict, containing the JwkSet, parsed as a JSON object. keys: a list of `Jwk`, that will be added to this JwkSet \"\"\" def __init__ ( self , jwks : Optional [ Dict [ str , Any ]] = None , keys : Optional [ Iterable [ Union [ Jwk , Dict [ str , Any ]]]] = None , ): if jwks is None and keys is None : keys = [] if jwks is not None : keys = jwks . pop ( \"keys\" , []) super () . __init__ ( jwks ) # init the dict with all the dict content that is not keys else : super () . __init__ () if keys is not None : for jwk in keys : self . add_jwk ( jwk ) @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , []) def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid ) def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks ) def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" jwk = to_jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass @property def is_private ( self ) -> bool : \"\"\"True if the JwkSet contains at least one private key. Returns: `True` if this JwkSet contains at least one private key \"\"\" return any ( key . is_private for key in self . jwks ) def public_jwks ( self ) -> \"JwkSet\" : \"\"\"Return another JwkSet with the public keys associated with the current keys. Returns: a public JwkSet \"\"\" return JwkSet ( keys = ( key . public_jwk () for key in self . jwks )) def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" if not alg and not algs : raise ValueError ( \"Please provide either 'alg' or 'algs' parameter\" ) # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) if algs is None : if alg is not None : algs = ( alg ,) else : algs = list ( algs ) for jwk in self . verification_keys (): for alg in algs or ( None ,): if alg in jwk . supported_signing_algorithms (): if jwk . verify ( data , signature , alg = alg ): return True # no key matches, so consider the signature invalid return False def verification_keys ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JWKS that a usable for signature verification. To be usable for signature verification, a key must: - be asymmetric - be public - have an \"alg\" parameter that is a signature alg Returns: a list of `Jwk` that are usable for signature verification \"\"\" return [ jwk for jwk in self . jwks if not jwk . is_symmetric and not jwk . is_private and jwk . use == \"sig\" ] def encryption_keys ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JWKS that are usable for encryption. To be usable for encryption, a key must: - be asymmetric - be public - have an \"alg\" parameter that is an encryption alg Returns: a list of `Jwk` that are suitable for encryption \"\"\" return [ jwk for jwk in self . jwks if not jwk . is_symmetric and not jwk . is_private and jwk . use == \"enc\" ]","title":"JwkSet"},{"location":"api/#jwskate.jwk.jwks.JwkSet.jwks","text":"1 jwks () -> List [ Jwk ] Return the list of keys from this JwkSet, as Jwk instances. Returns: Type Description List [ Jwk ] a list of Jwk Source code in jwskate/jwk/jwks.py 46 47 48 49 50 51 52 53 @property def jwks ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JwkSet, as `Jwk` instances. Returns: a list of `Jwk` \"\"\" return self . get ( \"keys\" , [])","title":"jwks()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.get_jwk_by_kid","text":"1 get_jwk_by_kid ( kid : str ) -> Jwk Return a Jwk from this JwkSet, based on its kid. Parameters: Name Type Description Default kid str the kid of the key to obtain required Returns: Type Description Jwk the key with the matching Key ID Raises: Type Description KeyError if no key matches Source code in jwskate/jwk/jwks.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def get_jwk_by_kid ( self , kid : str ) -> Jwk : \"\"\"Return a Jwk from this JwkSet, based on its kid. Args: kid: the kid of the key to obtain Returns: the key with the matching Key ID Raises: KeyError: if no key matches \"\"\" jwk = next ( filter ( lambda jwk : jwk . get ( \"kid\" ) == kid , self . jwks ), None ) if isinstance ( jwk , Jwk ): return jwk raise KeyError ( kid )","title":"get_jwk_by_kid()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.__len__","text":"1 __len__ () -> int Return the number of Jwk in this JwkSet. Returns: Type Description int the number of keys Source code in jwskate/jwk/jwks.py 72 73 74 75 76 77 78 def __len__ ( self ) -> int : \"\"\"Return the number of Jwk in this JwkSet. Returns: the number of keys \"\"\" return len ( self . jwks )","title":"__len__()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.add_jwk","text":"1 2 3 4 5 add_jwk ( jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str Add a Jwk in this JwkSet. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to add (either a Jwk instance, or a dict containing the Jwk parameters) required kid Optional [ str ] the kid to use, if jwk doesn't contain one None use Optional [ str ] the defined use for the added Jwk None Returns: Type Description str the kid from the added Jwk (it may be generated if no kid is provided) Source code in jwskate/jwk/jwks.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def add_jwk ( self , jwk : Union [ Jwk , Dict [ str , Any ]], kid : Optional [ str ] = None , use : Optional [ str ] = None , ) -> str : \"\"\"Add a Jwk in this JwkSet. Args: jwk: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters) kid: the kid to use, if `jwk` doesn't contain one use: the defined use for the added Jwk Returns: the kid from the added Jwk (it may be generated if no kid is provided) \"\"\" jwk = to_jwk ( jwk ) if \"keys\" not in self : self [ \"keys\" ] = [] kid = jwk . get ( \"kid\" , kid ) if not kid : kid = jwk . thumbprint () jwk [ \"kid\" ] = kid use = jwk . get ( \"use\" , use ) if use : jwk [ \"use\" ] = use self . jwks . append ( jwk ) return kid","title":"add_jwk()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.remove_jwk","text":"1 remove_jwk ( kid : str ) -> None Removes a Jwk from this JwkSet, based on a kid . Parameters: Name Type Description Default kid str the kid from the key to be removed. required Raises: Type Description KeyError if no key matches Source code in jwskate/jwk/jwks.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def remove_jwk ( self , kid : str ) -> None : \"\"\"Removes a Jwk from this JwkSet, based on a `kid`. Args: kid: the `kid` from the key to be removed. Raises: KeyError: if no key matches \"\"\" try : jwk = self . get_jwk_by_kid ( kid ) self . jwks . remove ( jwk ) except KeyError : pass","title":"remove_jwk()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.is_private","text":"1 is_private () -> bool True if the JwkSet contains at least one private key. Returns: Type Description bool True if this JwkSet contains at least one private key Source code in jwskate/jwk/jwks.py 127 128 129 130 131 132 133 134 @property def is_private ( self ) -> bool : \"\"\"True if the JwkSet contains at least one private key. Returns: `True` if this JwkSet contains at least one private key \"\"\" return any ( key . is_private for key in self . jwks )","title":"is_private()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.public_jwks","text":"1 public_jwks () -> JwkSet Return another JwkSet with the public keys associated with the current keys. Returns: Type Description JwkSet a public JwkSet Source code in jwskate/jwk/jwks.py 136 137 138 139 140 141 142 def public_jwks ( self ) -> \"JwkSet\" : \"\"\"Return another JwkSet with the public keys associated with the current keys. Returns: a public JwkSet \"\"\" return JwkSet ( keys = ( key . public_jwk () for key in self . jwks ))","title":"public_jwks()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.verify","text":"1 2 3 4 5 6 7 verify ( data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a kid is provided, only the key with this kid will be tried. Otherwise, if an alg or several algs are provided, only keys that are compatible with the supplied alg will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Parameters: Name Type Description Default data bytes the signed data to verify required signature bytes the signature to verify against the signed data required alg Optional [ str ] alg to verify the signature, if there is only 1 None algs Optional [ Iterable [ str ]] list of allowed signature algs, if there are several None kid Optional [ str ] the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys None from this key set may be tried. Returns: Type Description bool True if the signature validates with any of the tried keys, False otherwise Source code in jwskate/jwk/jwks.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def verify ( self , data : bytes , signature : bytes , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , kid : Optional [ str ] = None , ) -> bool : \"\"\"Verify a signature with the key from this key set. It implements multiple techniques to avoid trying all keys: If a `kid` is provided, only the key with this `kid` will be tried. Otherwise, if an `alg` or several `algs` are provided, only keys that are compatible with the supplied `alg` will be tried. Otherwise, keys that have use = signature will be tried. And if the signature is still not verified at that point, the keys with no specified alg and use will be tried. Args: data: the signed data to verify signature: the signature to verify against the signed data alg: alg to verify the signature, if there is only 1 algs: list of allowed signature algs, if there are several kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried. Returns: `True` if the signature validates with any of the tried keys, `False` otherwise \"\"\" if not alg and not algs : raise ValueError ( \"Please provide either 'alg' or 'algs' parameter\" ) # if a kid is provided, try only the key matching `kid` if kid is not None : jwk = self . get_jwk_by_kid ( kid ) return jwk . verify ( data , signature , alg = alg , algs = algs ) if algs is None : if alg is not None : algs = ( alg ,) else : algs = list ( algs ) for jwk in self . verification_keys (): for alg in algs or ( None ,): if alg in jwk . supported_signing_algorithms (): if jwk . verify ( data , signature , alg = alg ): return True # no key matches, so consider the signature invalid return False","title":"verify()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.verification_keys","text":"1 verification_keys () -> List [ Jwk ] Return the list of keys from this JWKS that a usable for signature verification. To be usable for signature verification, a key must: - be asymmetric - be public - have an \"alg\" parameter that is a signature alg Returns: Type Description List [ Jwk ] a list of Jwk that are usable for signature verification Source code in jwskate/jwk/jwks.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def verification_keys ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JWKS that a usable for signature verification. To be usable for signature verification, a key must: - be asymmetric - be public - have an \"alg\" parameter that is a signature alg Returns: a list of `Jwk` that are usable for signature verification \"\"\" return [ jwk for jwk in self . jwks if not jwk . is_symmetric and not jwk . is_private and jwk . use == \"sig\" ]","title":"verification_keys()"},{"location":"api/#jwskate.jwk.jwks.JwkSet.encryption_keys","text":"1 encryption_keys () -> List [ Jwk ] Return the list of keys from this JWKS that are usable for encryption. To be usable for encryption, a key must: - be asymmetric - be public - have an \"alg\" parameter that is an encryption alg Returns: Type Description List [ Jwk ] a list of Jwk that are suitable for encryption Source code in jwskate/jwk/jwks.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def encryption_keys ( self ) -> List [ Jwk ]: \"\"\"Return the list of keys from this JWKS that are usable for encryption. To be usable for encryption, a key must: - be asymmetric - be public - have an \"alg\" parameter that is an encryption alg Returns: a list of `Jwk` that are suitable for encryption \"\"\" return [ jwk for jwk in self . jwks if not jwk . is_symmetric and not jwk . is_private and jwk . use == \"enc\" ]","title":"encryption_keys()"},{"location":"api/#jwskate.jwk.ExpectedAlgRequired","text":"Bases: ValueError Raised when the expected signature alg(s) must be provided. Source code in jwskate/jwk/alg.py 13 14 class ExpectedAlgRequired ( ValueError ): \"\"\"Raised when the expected signature alg(s) must be provided.\"\"\"","title":"ExpectedAlgRequired"},{"location":"api/#jwskate.jwk.RSAJwk","text":"Bases: Jwk Represent a RSA Jwk, with kty=RSA . Source code in jwskate/jwk/rsa.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 class RSAJwk ( Jwk ): \"\"\"Represent a RSA Jwk, with `kty=RSA`.\"\"\" KTY = \"RSA\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = ( rsa . RSAPrivateKey ,) CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = ( rsa . RSAPublicKey ,) PARAMS = { \"n\" : JwkParameter ( \"Modulus\" , is_private = False , is_required = True , kind = \"b64u\" ), \"e\" : JwkParameter ( \"Exponent\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Exponent\" , is_private = True , is_required = True , kind = \"b64u\" ), \"p\" : JwkParameter ( \"First Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"q\" : JwkParameter ( \"Second Prime Factor\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dp\" : JwkParameter ( \"First Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" ), \"dq\" : JwkParameter ( \"Second Factor CRT Exponent\" , is_private = True , is_required = False , kind = \"b64u\" , ), \"qi\" : JwkParameter ( \"First CRT Coefficient\" , is_private = True , is_required = False , kind = \"b64u\" ), \"oth\" : JwkParameter ( \"Other Primes Info\" , is_private = True , is_required = False , kind = \"unsupported\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ RS256 , RS384 , RS512 , PS256 , PS384 , PS512 ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ RsaEsPcks1v1_5 , RsaEsOaep , RsaEsOaepSha256 , RsaEsOaepSha384 , RsaEsOaepSha512 , ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: cryptography_key: a `cryptography` RSA key **kwargs: additional members to include in the Jwk Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( cryptography_key , rsa . RSAPrivateKey ): priv = cryptography_key . private_numbers () # type: ignore[attr-defined] pub = cryptography_key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( cryptography_key , rsa . RSAPublicKey ): pub = cryptography_key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" ) def _to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key () @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public `RsaJwk` from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initialize a private `RsaJwk` from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d ) . to ( \"b64u\" ) . ascii (), p = BinaPy . from_int ( p ) . to ( \"b64u\" ) . ascii () if p is not None else None , q = BinaPy . from_int ( q ) . to ( \"b64u\" ) . ascii () if q is not None else None , dp = BinaPy . from_int ( dp ) . to ( \"b64u\" ) . ascii () if dp is not None else None , dq = BinaPy . from_int ( dq ) . to ( \"b64u\" ) . ascii () if dq is not None else None , qi = BinaPy . from_int ( qi ) . to ( \"b64u\" ) . ascii () if qi is not None else None , ** params , ) ) @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generate a new random private `RSAJwk`. Args: key_size: the key size to use for the generated key, in bits **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , ) @cached_property def modulus ( self ) -> int : \"\"\"Return the modulus `n` from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int () @cached_property def exponent ( self ) -> int : \"\"\"Return the public exponent `e` from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int () @cached_property def private_exponent ( self ) -> int : \"\"\"Return the private exponent `d` from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () @cached_property def first_prime_factor ( self ) -> int : \"\"\"Return the first prime factor `p` from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return self . prime_factors [ 0 ] @cached_property def second_prime_factor ( self ) -> int : \"\"\"Return the second prime factor `q` from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return self . prime_factors [ 1 ] @cached_property def prime_factors ( self ) -> Tuple [ int , int ]: \"\"\"Return the 2 prime factors `p` and `q` from this Jwk.\"\"\" if \"p\" not in self or \"q\" not in self : p , q = rsa . rsa_recover_prime_factors ( self . modulus , self . exponent , self . private_exponent ) return ( p , q ) if p < q else ( q , p ) return ( BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int (), BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int (), ) @cached_property def first_factor_crt_exponent ( self ) -> int : \"\"\"Return the first factor CRT exponent `dp` from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" if \"dp\" in self : return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_dmp1 ( self . private_exponent , self . first_prime_factor ) @cached_property def second_factor_crt_exponent ( self ) -> int : \"\"\"Return the second factor CRT exponent `dq` from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" if \"dq\" in self : return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_dmq1 ( self . private_exponent , self . second_prime_factor ) @cached_property def first_crt_coefficient ( self ) -> int : \"\"\"Return the first CRT coefficient `qi` from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" if \"qi\" in self : return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_iqmp ( self . first_prime_factor , self . second_prime_factor ) @cached_property def key_size ( self ) -> int : \"\"\"Key size, in bits. Returns: the key size \"\"\" return len ( BinaPy ( self . n ) . decode_from ( \"b64u\" )) * 8 def with_optional_private_parameters ( self ) -> RSAJwk : \"\"\"Compute the optional RSA private parameters and add them into the JWK. The optional parameters are: - p: first prime factor - q: second prime factor - dp: first factor Chinese Remainder Theorem exponent - dq: second factor Chinese Remainder Theorem exponent - qi: first Chinese Remainder Theorem coefficient \"\"\" if not self . is_private : raise ValueError ( \"Optional private parameters can only be computed for private RSA keys.\" ) jwk = dict ( self ) jwk . update ( { \"p\" : BinaPy . from_int ( self . first_prime_factor ) . to ( \"b64u\" ) . ascii (), \"q\" : BinaPy . from_int ( self . second_prime_factor ) . to ( \"b64u\" ) . ascii (), \"dp\" : BinaPy . from_int ( self . first_factor_crt_exponent ) . to ( \"b64u\" ) . ascii (), \"dq\" : BinaPy . from_int ( self . second_factor_crt_exponent ) . to ( \"b64u\" ) . ascii (), \"qi\" : BinaPy . from_int ( self . first_crt_coefficient ) . to ( \"b64u\" ) . ascii (), } ) return RSAJwk ( jwk ) def without_optional_private_parameters ( self ) -> RSAJwk : \"\"\"Remove the optional private parameters and return another Jwk instance without them.\"\"\" jwk = dict ( self ) for param in \"p\" , \"q\" , \"dp\" , \"dq\" , \"qi\" : jwk . pop ( param , None ) return RSAJwk ( jwk )","title":"RSAJwk"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.from_cryptography_key","text":"1 2 3 from_cryptography_key ( cryptography_key : Any , ** kwargs : Any ) -> RSAJwk Initialize a Jwk from a cryptography RSA key. Parameters: Name Type Description Default cryptography_key Any a cryptography RSA key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized with the given key Raises: Type Description TypeError if the given key type is not supported Source code in jwskate/jwk/rsa.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> RSAJwk : \"\"\"Initialize a Jwk from a `cryptography` RSA key. Args: cryptography_key: a `cryptography` RSA key **kwargs: additional members to include in the Jwk Returns: a RSAJwk initialized with the given key Raises: TypeError: if the given key type is not supported \"\"\" if isinstance ( cryptography_key , rsa . RSAPrivateKey ): priv = cryptography_key . private_numbers () # type: ignore[attr-defined] pub = cryptography_key . public_key () . public_numbers () return cls . private ( n = pub . n , e = pub . e , d = priv . d , p = priv . p , q = priv . q , dp = priv . dmp1 , dq = priv . dmq1 , qi = priv . iqmp , ) elif isinstance ( cryptography_key , rsa . RSAPublicKey ): pub = cryptography_key . public_numbers () return cls . public ( n = pub . n , e = pub . e , ) else : raise TypeError ( \"A RSAPrivateKey or a RSAPublicKey is required.\" )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk._to_cryptography_key","text":"1 2 3 _to_cryptography_key () -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ] Initialize a cryptography key based on this Jwk. Returns: Type Description Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ] a cryptography RSAPrivateKey or RSAPublicKey Source code in jwskate/jwk/rsa.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def _to_cryptography_key ( self ) -> Union [ rsa . RSAPrivateKey , rsa . RSAPublicKey ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: a cryptography RSAPrivateKey or RSAPublicKey \"\"\" if self . is_private : return rsa . RSAPrivateNumbers ( self . first_prime_factor , self . second_prime_factor , self . private_exponent , self . first_factor_crt_exponent , self . second_factor_crt_exponent , self . first_crt_coefficient , rsa . RSAPublicNumbers ( self . exponent , self . modulus ), ) . private_key () else : return rsa . RSAPublicNumbers ( e = self . exponent , n = self . modulus ) . public_key ()","title":"_to_cryptography_key()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.public","text":"1 public ( n : int , e : int , ** params : Any ) -> RSAJwk Initialize a public RsaJwk from a modulus and an exponent. Parameters: Name Type Description Default n int the modulus required e int the exponent required **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RsaJwk initialized from the provided parameters Source code in jwskate/jwk/rsa.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 @classmethod def public ( cls , n : int , e : int , ** params : Any ) -> RSAJwk : \"\"\"Initialize a public `RsaJwk` from a modulus and an exponent. Args: n: the modulus e: the exponent **params: additional members to include in the Jwk Returns: a RsaJwk initialized from the provided parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), ** params , ) )","title":"public()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.private","text":"1 2 3 4 5 6 7 8 9 10 11 private ( n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any ) -> RSAJwk Initialize a private RsaJwk from its required parameters. Parameters: Name Type Description Default n int the modulus required e int the exponent required d int the private exponent required p Optional [ int ] the first prime factor None q Optional [ int ] the second prime factor None dp Optional [ int ] the first factor CRT exponent None dq Optional [ int ] the second factor CRT exponent None qi Optional [ int ] the first CRT coefficient None **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a RSAJwk initialized from the given parameters Source code in jwskate/jwk/rsa.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 @classmethod def private ( cls , n : int , e : int , d : int , p : Optional [ int ] = None , q : Optional [ int ] = None , dp : Optional [ int ] = None , dq : Optional [ int ] = None , qi : Optional [ int ] = None , ** params : Any , ) -> RSAJwk : \"\"\"Initialize a private `RsaJwk` from its required parameters. Args: n: the modulus e: the exponent d: the private exponent p: the first prime factor q: the second prime factor dp: the first factor CRT exponent dq: the second factor CRT exponent qi: the first CRT coefficient **params: additional members to include in the Jwk Returns: a RSAJwk initialized from the given parameters \"\"\" return cls ( dict ( kty = \"RSA\" , n = BinaPy . from_int ( n ) . to ( \"b64u\" ) . ascii (), e = BinaPy . from_int ( e ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d ) . to ( \"b64u\" ) . ascii (), p = BinaPy . from_int ( p ) . to ( \"b64u\" ) . ascii () if p is not None else None , q = BinaPy . from_int ( q ) . to ( \"b64u\" ) . ascii () if q is not None else None , dp = BinaPy . from_int ( dp ) . to ( \"b64u\" ) . ascii () if dp is not None else None , dq = BinaPy . from_int ( dq ) . to ( \"b64u\" ) . ascii () if dq is not None else None , qi = BinaPy . from_int ( qi ) . to ( \"b64u\" ) . ascii () if qi is not None else None , ** params , ) )","title":"private()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.generate","text":"1 generate ( key_size : int = 4096 , ** params : Any ) -> RSAJwk Generate a new random private RSAJwk . Parameters: Name Type Description Default key_size int the key size to use for the generated key, in bits 4096 **params Any additional members to include in the Jwk {} Returns: Type Description RSAJwk a generated RSAJwk Source code in jwskate/jwk/rsa.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 @classmethod def generate ( cls , key_size : int = 4096 , ** params : Any ) -> RSAJwk : \"\"\"Generate a new random private `RSAJwk`. Args: key_size: the key size to use for the generated key, in bits **params: additional members to include in the Jwk Returns: a generated RSAJwk \"\"\" private_key = rsa . generate_private_key ( 65537 , key_size = key_size ) pn = private_key . private_numbers () return cls . private ( n = pn . public_numbers . n , e = pn . public_numbers . e , d = pn . d , p = pn . p , q = pn . q , dp = pn . dmp1 , dq = pn . dmq1 , qi = pn . iqmp , ** params , )","title":"generate()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.modulus","text":"1 modulus () -> int Return the modulus n from this Jwk. Returns: Type Description int the key modulus (from parameter n ) Source code in jwskate/jwk/rsa.py 228 229 230 231 232 233 234 235 @cached_property def modulus ( self ) -> int : \"\"\"Return the modulus `n` from this Jwk. Returns: the key modulus (from parameter `n`) \"\"\" return BinaPy ( self . n ) . decode_from ( \"b64u\" ) . to_int ()","title":"modulus()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.exponent","text":"1 exponent () -> int Return the public exponent e from this Jwk. Returns: Type Description int the key exponent (from parameter e ) Source code in jwskate/jwk/rsa.py 237 238 239 240 241 242 243 244 @cached_property def exponent ( self ) -> int : \"\"\"Return the public exponent `e` from this Jwk. Returns: the key exponent (from parameter `e`) \"\"\" return BinaPy ( self . e ) . decode_from ( \"b64u\" ) . to_int ()","title":"exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.private_exponent","text":"1 private_exponent () -> int Return the private exponent d from this Jwk. Returns: Type Description int the key private exponent (from parameter d ) Source code in jwskate/jwk/rsa.py 246 247 248 249 250 251 252 253 @cached_property def private_exponent ( self ) -> int : \"\"\"Return the private exponent `d` from this Jwk. Returns: the key private exponent (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int ()","title":"private_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_prime_factor","text":"1 first_prime_factor () -> int Return the first prime factor p from this Jwk. Returns: Type Description int the first prime factor (from parameter p ) Source code in jwskate/jwk/rsa.py 255 256 257 258 259 260 261 262 @cached_property def first_prime_factor ( self ) -> int : \"\"\"Return the first prime factor `p` from this Jwk. Returns: the first prime factor (from parameter `p`) \"\"\" return self . prime_factors [ 0 ]","title":"first_prime_factor()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.second_prime_factor","text":"1 second_prime_factor () -> int Return the second prime factor q from this Jwk. Returns: Type Description int the second prime factor (from parameter q ) Source code in jwskate/jwk/rsa.py 264 265 266 267 268 269 270 271 @cached_property def second_prime_factor ( self ) -> int : \"\"\"Return the second prime factor `q` from this Jwk. Returns: the second prime factor (from parameter `q`) \"\"\" return self . prime_factors [ 1 ]","title":"second_prime_factor()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.prime_factors","text":"1 prime_factors () -> Tuple [ int , int ] Return the 2 prime factors p and q from this Jwk. Source code in jwskate/jwk/rsa.py 273 274 275 276 277 278 279 280 281 282 283 284 @cached_property def prime_factors ( self ) -> Tuple [ int , int ]: \"\"\"Return the 2 prime factors `p` and `q` from this Jwk.\"\"\" if \"p\" not in self or \"q\" not in self : p , q = rsa . rsa_recover_prime_factors ( self . modulus , self . exponent , self . private_exponent ) return ( p , q ) if p < q else ( q , p ) return ( BinaPy ( self . p ) . decode_from ( \"b64u\" ) . to_int (), BinaPy ( self . q ) . decode_from ( \"b64u\" ) . to_int (), )","title":"prime_factors()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_factor_crt_exponent","text":"1 first_factor_crt_exponent () -> int Return the first factor CRT exponent dp from this Jwk. Returns: Type Description int the first factor CRT coefficient (from parameter dp ) Source code in jwskate/jwk/rsa.py 286 287 288 289 290 291 292 293 294 295 @cached_property def first_factor_crt_exponent ( self ) -> int : \"\"\"Return the first factor CRT exponent `dp` from this Jwk. Returns: the first factor CRT coefficient (from parameter `dp`) \"\"\" if \"dp\" in self : return BinaPy ( self . dp ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_dmp1 ( self . private_exponent , self . first_prime_factor )","title":"first_factor_crt_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.second_factor_crt_exponent","text":"1 second_factor_crt_exponent () -> int Return the second factor CRT exponent dq from this Jwk. Returns: Type Description int the second factor CRT coefficient (from parameter dq ) Source code in jwskate/jwk/rsa.py 297 298 299 300 301 302 303 304 305 306 @cached_property def second_factor_crt_exponent ( self ) -> int : \"\"\"Return the second factor CRT exponent `dq` from this Jwk. Returns: the second factor CRT coefficient (from parameter `dq`) \"\"\" if \"dq\" in self : return BinaPy ( self . dq ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_dmq1 ( self . private_exponent , self . second_prime_factor )","title":"second_factor_crt_exponent()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_crt_coefficient","text":"1 first_crt_coefficient () -> int Return the first CRT coefficient qi from this Jwk. Returns: Type Description int the first CRT coefficient (from parameter qi ) Source code in jwskate/jwk/rsa.py 308 309 310 311 312 313 314 315 316 317 @cached_property def first_crt_coefficient ( self ) -> int : \"\"\"Return the first CRT coefficient `qi` from this Jwk. Returns: the first CRT coefficient (from parameter `qi`) \"\"\" if \"qi\" in self : return BinaPy ( self . qi ) . decode_from ( \"b64u\" ) . to_int () return rsa . rsa_crt_iqmp ( self . first_prime_factor , self . second_prime_factor )","title":"first_crt_coefficient()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.key_size","text":"1 key_size () -> int Key size, in bits. Returns: Type Description int the key size Source code in jwskate/jwk/rsa.py 319 320 321 322 323 324 325 326 @cached_property def key_size ( self ) -> int : \"\"\"Key size, in bits. Returns: the key size \"\"\" return len ( BinaPy ( self . n ) . decode_from ( \"b64u\" )) * 8","title":"key_size()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.with_optional_private_parameters","text":"1 with_optional_private_parameters () -> RSAJwk Compute the optional RSA private parameters and add them into the JWK. The optional parameters are: - p: first prime factor - q: second prime factor - dp: first factor Chinese Remainder Theorem exponent - dq: second factor Chinese Remainder Theorem exponent - qi: first Chinese Remainder Theorem coefficient Source code in jwskate/jwk/rsa.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def with_optional_private_parameters ( self ) -> RSAJwk : \"\"\"Compute the optional RSA private parameters and add them into the JWK. The optional parameters are: - p: first prime factor - q: second prime factor - dp: first factor Chinese Remainder Theorem exponent - dq: second factor Chinese Remainder Theorem exponent - qi: first Chinese Remainder Theorem coefficient \"\"\" if not self . is_private : raise ValueError ( \"Optional private parameters can only be computed for private RSA keys.\" ) jwk = dict ( self ) jwk . update ( { \"p\" : BinaPy . from_int ( self . first_prime_factor ) . to ( \"b64u\" ) . ascii (), \"q\" : BinaPy . from_int ( self . second_prime_factor ) . to ( \"b64u\" ) . ascii (), \"dp\" : BinaPy . from_int ( self . first_factor_crt_exponent ) . to ( \"b64u\" ) . ascii (), \"dq\" : BinaPy . from_int ( self . second_factor_crt_exponent ) . to ( \"b64u\" ) . ascii (), \"qi\" : BinaPy . from_int ( self . first_crt_coefficient ) . to ( \"b64u\" ) . ascii (), } ) return RSAJwk ( jwk )","title":"with_optional_private_parameters()"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.without_optional_private_parameters","text":"1 without_optional_private_parameters () -> RSAJwk Remove the optional private parameters and return another Jwk instance without them. Source code in jwskate/jwk/rsa.py 361 362 363 364 365 366 367 def without_optional_private_parameters ( self ) -> RSAJwk : \"\"\"Remove the optional private parameters and return another Jwk instance without them.\"\"\" jwk = dict ( self ) for param in \"p\" , \"q\" , \"dp\" , \"dq\" , \"qi\" : jwk . pop ( param , None ) return RSAJwk ( jwk )","title":"without_optional_private_parameters()"},{"location":"api/#jwskate.jwk.UnsupportedEllipticCurve","text":"Bases: KeyError Raised when an unsupported Elliptic curve is requested. Source code in jwskate/jwk/ec.py 32 33 class UnsupportedEllipticCurve ( KeyError ): \"\"\"Raised when an unsupported Elliptic curve is requested.\"\"\"","title":"UnsupportedEllipticCurve"},{"location":"api/#jwskate.jwk.UnsupportedOKPCurve","text":"Bases: KeyError Raised when an unsupported OKP curve is requested. Source code in jwskate/jwk/okp.py 32 33 class UnsupportedOKPCurve ( KeyError ): \"\"\"Raised when an unsupported OKP curve is requested.\"\"\"","title":"UnsupportedOKPCurve"},{"location":"api/#jwskate.jwk.SymmetricJwk","text":"Bases: Jwk Implement Symmetric keys, with kty=oct . Source code in jwskate/jwk/oct.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class SymmetricJwk ( Jwk ): \"\"\"Implement Symmetric keys, with `kty=oct`.\"\"\" KTY = \"oct\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = ( bytes ,) CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = ( bytes ,) PARAMS = { \"k\" : JwkParameter ( \"Key Value\" , is_private = True , is_required = True , kind = \"b64u\" ), } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ HS256 , HS384 , HS512 ]} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ A128KW , A192KW , A256KW , A128GCMKW , A192GCMKW , A256GCMKW , DirectKeyUse , ] } ENCRYPTION_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ A128CBC_HS256 , A192CBC_HS384 , A256CBC_HS512 , A128GCM , A192GCM , A256GCM , ] } @property def is_symmetric ( self ) -> bool : \"\"\"Always returns `True`.\"\"\" return True def public_jwk ( self ) -> Jwk : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" ) @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk : \"\"\"Initialize a `SymmetricJwk` from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymmetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . to ( \"b64u\" ) . ascii (), ** params )) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** params : Any ) -> SymmetricJwk : \"\"\"Alias for `from_bytes()` since symmetric keys are simply bytes. Args: cryptography_key: the key to use **kwargs: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls . from_bytes ( cryptography_key , ** params ) @classmethod def generate ( cls , key_size : int = 128 , ** params : Any ) -> SymmetricJwk : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: key_size: size of the generated key, in bits **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( key_size ) return cls . from_bytes ( key , ** params ) @classmethod def generate_for_alg ( cls , alg : str , ** params : Any ) -> SymmetricJwk : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the algorithm identifier **params: additional members to include in the Jwk Returns: the generated `Jwk` Raises: UnsupportedAlg: if the provided `alg` is not supported \"\"\" alg_class = cls . _get_alg_class ( alg ) if issubclass ( alg_class , BaseHMACSigAlg ): return cls . generate ( key_size = alg_class . min_key_size , alg = alg , ** params ) elif issubclass ( alg_class , ( BaseAESEncryptionAlg , BaseAesKeyWrap )): return cls . generate ( key_size = alg_class . key_size , alg = alg , ** params ) return cls . generate ( alg = alg , ** params ) def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () ) def _to_cryptography_key ( self ) -> BinaPy : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" ) @property def key ( self ) -> BinaPy : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return self . cryptography_key # type: ignore def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with Additional Authenticated Data (`aad`). An Initialization Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This returns the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" wrapper = self . encryption_wrapper ( alg ) if iv is None : iv = wrapper . generate_iv () ciphertext , tag = wrapper . encrypt ( plaintext , iv = iv , aad = aad ) return ciphertext , BinaPy ( iv ), tag @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8 def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data iv: the Initialization Vector (must be the same as used during encryption) tag: the authentication tag aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" aad = b \"\" if aad is None else aad if not isinstance ( aad , bytes ): aad = bytes ( aad ) if not isinstance ( iv , bytes ): iv = bytes ( iv ) if not isinstance ( tag , bytes ): tag = bytes ( tag ) wrapper = self . encryption_wrapper ( alg ) plaintext : bytes = wrapper . decrypt ( ciphertext , auth_tag = tag , iv = iv , aad = aad ) return BinaPy ( plaintext ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that this key supports. Key Management algorithms are used to generate or wrap Content Encryption Keys (CEK). Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) # type: ignore ] def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) ] def to_pem ( self , password : Union [ bytes , str , None ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. Symmetric keys are not serializable to PEM so this will raise a TypeError. Args: password: password to use to encrypt the PEM. Raises: TypeError: always \"\"\" raise TypeError ( \"Symmetric keys are not serializable to PEM.\" )","title":"SymmetricJwk"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.is_symmetric","text":"1 is_symmetric () -> bool Always returns True . Source code in jwskate/jwk/oct.py 72 73 74 75 @property def is_symmetric ( self ) -> bool : \"\"\"Always returns `True`.\"\"\" return True","title":"is_symmetric()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.public_jwk","text":"1 public_jwk () -> Jwk This always raises a ValueError since SymmetricKeys are always private. Raises: Type Description ValueError symmetric keys are always private, it makes no sense to use them as public keys Source code in jwskate/jwk/oct.py 77 78 79 80 81 82 83 def public_jwk ( self ) -> Jwk : \"\"\"This always raises a ValueError since SymmetricKeys are always private. Raises: ValueError: symmetric keys are always private, it makes no sense to use them as public keys \"\"\" raise ValueError ( \"Symmetric keys don't have a public key\" )","title":"public_jwk()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.from_bytes","text":"1 2 3 from_bytes ( k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk Initialize a SymmetricJwk from a raw secret key. The provided secret key is encoded and used as the k parameter for the returned SymmetricKey. Parameters: Name Type Description Default k Union [ bytes , str ] the key to use required **params Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the resulting SymmetricJwk Source code in jwskate/jwk/oct.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 @classmethod def from_bytes ( cls , k : Union [ bytes , str ], ** params : Any ) -> SymmetricJwk : \"\"\"Initialize a `SymmetricJwk` from a raw secret key. The provided secret key is encoded and used as the `k` parameter for the returned SymmetricKey. Args: k: the key to use **params: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls ( dict ( kty = \"oct\" , k = BinaPy ( k ) . to ( \"b64u\" ) . ascii (), ** params ))","title":"from_bytes()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.from_cryptography_key","text":"1 2 3 from_cryptography_key ( cryptography_key : Any , ** params : Any ) -> SymmetricJwk Alias for from_bytes() since symmetric keys are simply bytes. Parameters: Name Type Description Default cryptography_key Any the key to use required **kwargs additional members to include in the Jwk required Returns: Type Description SymmetricJwk the resulting SymmetricJwk Source code in jwskate/jwk/oct.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** params : Any ) -> SymmetricJwk : \"\"\"Alias for `from_bytes()` since symmetric keys are simply bytes. Args: cryptography_key: the key to use **kwargs: additional members to include in the Jwk Returns: the resulting SymmetricJwk \"\"\" return cls . from_bytes ( cryptography_key , ** params )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.generate","text":"1 2 3 generate ( key_size : int = 128 , ** params : Any ) -> SymmetricJwk Generate a random SymmetricJwk, with a given key size. Parameters: Name Type Description Default key_size int size of the generated key, in bits 128 **params Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk a SymmetricJwk with a randomly generated key Source code in jwskate/jwk/oct.py 115 116 117 118 119 120 121 122 123 124 125 126 127 @classmethod def generate ( cls , key_size : int = 128 , ** params : Any ) -> SymmetricJwk : \"\"\"Generate a random SymmetricJwk, with a given key size. Args: key_size: size of the generated key, in bits **params: additional members to include in the Jwk Returns: a SymmetricJwk with a randomly generated key \"\"\" key = BinaPy . random_bits ( key_size ) return cls . from_bytes ( key , ** params )","title":"generate()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.generate_for_alg","text":"1 generate_for_alg ( alg : str , ** params : Any ) -> SymmetricJwk Generate a SymmetricJwk that is suitable for use with the given alg. Parameters: Name Type Description Default alg str the algorithm identifier required **params Any additional members to include in the Jwk {} Returns: Type Description SymmetricJwk the generated Jwk Raises: Type Description UnsupportedAlg if the provided alg is not supported Source code in jwskate/jwk/oct.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @classmethod def generate_for_alg ( cls , alg : str , ** params : Any ) -> SymmetricJwk : \"\"\"Generate a SymmetricJwk that is suitable for use with the given alg. Args: alg: the algorithm identifier **params: additional members to include in the Jwk Returns: the generated `Jwk` Raises: UnsupportedAlg: if the provided `alg` is not supported \"\"\" alg_class = cls . _get_alg_class ( alg ) if issubclass ( alg_class , BaseHMACSigAlg ): return cls . generate ( key_size = alg_class . min_key_size , alg = alg , ** params ) elif issubclass ( alg_class , ( BaseAESEncryptionAlg , BaseAesKeyWrap )): return cls . generate ( key_size = alg_class . key_size , alg = alg , ** params ) return cls . generate ( alg = alg , ** params )","title":"generate_for_alg()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.thumbprint","text":"1 thumbprint ( hashalg : str = 'SHA256' ) -> str Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Returns: Type Description str the calculated thumbprint Source code in jwskate/jwk/oct.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. This is reimplemented for SymmetricJwk because the private parameter 'k' must be included. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" return ( BinaPy . serialize_to ( \"json\" , { \"k\" : self . k , \"kty\" : self . kty }) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () )","title":"thumbprint()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk._to_cryptography_key","text":"1 _to_cryptography_key () -> BinaPy Converts this Jwk into a key usable with cryptography . For SymmetricJwk instances, those are just bytes values. Returns: Type Description BinaPy the raw private key, as bytes Source code in jwskate/jwk/oct.py 168 169 170 171 172 173 174 175 176 def _to_cryptography_key ( self ) -> BinaPy : \"\"\"Converts this Jwk into a key usable with `cryptography`. For SymmetricJwk instances, those are just `bytes` values. Returns: the raw private key, as `bytes` \"\"\" return BinaPy ( self . k ) . decode_from ( \"b64u\" )","title":"_to_cryptography_key()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.key","text":"1 key () -> BinaPy Returns the raw symmetric key. Returns: Type Description BinaPy the key from the k parameter, base64u-decoded Source code in jwskate/jwk/oct.py 178 179 180 181 182 183 184 185 @property def key ( self ) -> BinaPy : \"\"\"Returns the raw symmetric key. Returns: the key from the `k` parameter, base64u-decoded \"\"\" return self . cryptography_key # type: ignore","title":"key()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.encrypt","text":"1 2 3 4 5 6 7 encrypt ( plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None ) -> Tuple [ BinaPy , BinaPy , BinaPy ] Encrypt arbitrary data using this key. Supports Authenticated Encryption with Additional Authenticated Data ( aad ). An Initialization Vector (IV) will be generated automatically. You can choose your own IV by providing the iv parameter (only use this if you know what you are doing). This returns the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Parameters: Name Type Description Default plaintext Union [ bytes , SupportsBytes ] the plaintext to encrypt required aad Optional [ bytes ] the Additional Authentication Data, if any None alg Optional [ str ] the encryption alg to use None iv Optional [ bytes ] the IV to use, if you want a specific value None Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a (ciphertext, authentication_tag, iv) tuple Source code in jwskate/jwk/oct.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data using this key. Supports Authenticated Encryption with Additional Authenticated Data (`aad`). An Initialization Vector (IV) will be generated automatically. You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing). This returns the ciphertext, the authentication tag, and the used IV (if an IV was provided as parameter, the same IV is returned). Args: plaintext: the plaintext to encrypt aad: the Additional Authentication Data, if any alg: the encryption alg to use iv: the IV to use, if you want a specific value Returns: a (ciphertext, authentication_tag, iv) tuple \"\"\" wrapper = self . encryption_wrapper ( alg ) if iv is None : iv = wrapper . generate_iv () ciphertext , tag = wrapper . encrypt ( plaintext , iv = iv , aad = aad ) return ciphertext , BinaPy ( iv ), tag","title":"encrypt()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.key_size","text":"1 key_size () -> int The key size, in bits. Returns: Type Description int the key size in bits Source code in jwskate/jwk/oct.py 218 219 220 221 222 223 224 225 @property def key_size ( self ) -> int : \"\"\"The key size, in bits. Returns: the key size in bits \"\"\" return len ( self . key ) * 8","title":"key_size()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.decrypt","text":"1 2 3 4 5 6 7 8 decrypt ( ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None ) -> BinaPy Decrypt arbitrary data. Parameters: Name Type Description Default ciphertext Union [ bytes , SupportsBytes ] the encrypted data required iv Union [ bytes , SupportsBytes ] the Initialization Vector (must be the same as used during encryption) required tag Union [ bytes , SupportsBytes ] the authentication tag required aad Union [ bytes , SupportsBytes , None] the Additional Authenticated Data (must be the same as used during encryption) None alg Optional [ str ] the decryption alg (must be the same as used during encryption) None Returns: Type Description BinaPy the decrypted clear-text Source code in jwskate/jwk/oct.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt arbitrary data. Args: ciphertext: the encrypted data iv: the Initialization Vector (must be the same as used during encryption) tag: the authentication tag aad: the Additional Authenticated Data (must be the same as used during encryption) alg: the decryption alg (must be the same as used during encryption) Returns: the decrypted clear-text \"\"\" aad = b \"\" if aad is None else aad if not isinstance ( aad , bytes ): aad = bytes ( aad ) if not isinstance ( iv , bytes ): iv = bytes ( iv ) if not isinstance ( tag , bytes ): tag = bytes ( tag ) wrapper = self . encryption_wrapper ( alg ) plaintext : bytes = wrapper . decrypt ( ciphertext , auth_tag = tag , iv = iv , aad = aad ) return BinaPy ( plaintext )","title":"decrypt()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.supported_key_management_algorithms","text":"1 supported_key_management_algorithms () -> List [ str ] Return the list of Key Management algorithms that this key supports. Key Management algorithms are used to generate or wrap Content Encryption Keys (CEK). Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/oct.py 261 262 263 264 265 266 267 268 269 270 271 272 273 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that this key supports. Key Management algorithms are used to generate or wrap Content Encryption Keys (CEK). Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . KEY_MANAGEMENT_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) # type: ignore ]","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.supported_encryption_algorithms","text":"1 supported_encryption_algorithms () -> List [ str ] Return the list of supported Encryption/Decryption algorithms with this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/oct.py 275 276 277 278 279 280 281 282 283 284 285 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Encryption/Decryption algorithms with this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . ENCRYPTION_ALGORITHMS . items () if alg . supports_key ( self . cryptography_key ) ]","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.to_pem","text":"1 to_pem ( password : Union [ bytes , str , None ] = None ) -> bytes Serialize this key to PEM format. Symmetric keys are not serializable to PEM so this will raise a TypeError. Parameters: Name Type Description Default password Union [ bytes , str , None] password to use to encrypt the PEM. None Raises: Type Description TypeError always Source code in jwskate/jwk/oct.py 287 288 289 290 291 292 293 294 295 296 297 298 def to_pem ( self , password : Union [ bytes , str , None ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. Symmetric keys are not serializable to PEM so this will raise a TypeError. Args: password: password to use to encrypt the PEM. Raises: TypeError: always \"\"\" raise TypeError ( \"Symmetric keys are not serializable to PEM.\" )","title":"to_pem()"},{"location":"api/#jwskate.jwk.ECJwk","text":"Bases: Jwk Represent an Elliptic Curve Jwk, with kty=EC . Source code in jwskate/jwk/ec.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 class ECJwk ( Jwk ): \"\"\"Represent an Elliptic Curve Jwk, with `kty=EC`.\"\"\" KTY = \"EC\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = ( asymmetric . ec . EllipticCurvePrivateKey ,) CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = ( asymmetric . ec . EllipticCurvePublicKey ,) PARAMS : Mapping [ str , JwkParameter ] = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"X Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"y\" : JwkParameter ( \"Y Coordinate\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"ECC Private Key\" , is_private = True , is_required = True , kind = \"b64u\" ), } CURVES : Mapping [ str , EllipticCurve ] = { curve . name : curve for curve in [ P_256 , P_384 , P_521 , secp256k1 ] } SIGNATURE_ALGORITHMS = { sigalg . name : sigalg for sigalg in [ ES256 , ES384 , ES512 , ES256K ] } KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self def _validate ( self ) -> None : self . get_curve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv ) @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . to ( \"b64u\" ), ** { k : v for k , v in params . items () if v is not None }, ) ) @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . to ( \"b64u\" ) . ascii (), y = BinaPy . from_int ( y , coord_size ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d , coord_size ) . to ( \"b64u\" ) . ascii (), ** { k : v for k , v in params . items () if v is not None }, ) ) @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: cryptography_key: `cryptography` key **kwargs: additional members to include in the Jwk Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_jwk_parameters ( cryptography_key ) return cls ( parameters ) def _to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key () @classmethod def generate ( cls , crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : str ) -> \"ECJwk\" : \"\"\"Generate a random ECJwk. Args: alg: the alg crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" if crv is None and alg is None : warnings . warn ( \"No Curve identifier (crv) or an Algorithm identifier (alg) have been provided \" \"when generating an Elliptic Curve JWK. So there is no hint to determine which curve to use. \" \"Curve 'P-256' is used by default. You should explicitly pass an 'alg' or 'crv' parameter \" \"to explicitly select the appropriate Curve and avoid this warning.\" ) crv = \"P-256\" curve : Optional [ EllipticCurve ] = None if crv : curve = cls . get_curve ( crv ) elif alg : if alg in cls . SIGNATURE_ALGORITHMS : curve = cls . SIGNATURE_ALGORITHMS [ alg ] . curve elif alg in cls . KEY_MANAGEMENT_ALGORITHMS : curve = P_256 if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = curve . name , alg = alg , x = x , y = y , d = d , ** params , ) @cached_property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int () @cached_property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int () @cached_property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int () def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ] def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS )","title":"ECJwk"},{"location":"api/#jwskate.jwk.ec.ECJwk.get_curve","text":"1 get_curve ( crv : str ) -> EllipticCurve Get the EllipticCurve instance for a given curve identifier. Parameters: Name Type Description Default crv str the curve identifier required Returns: Type Description EllipticCurve the matching EllipticCurve instance Raises: Type Description UnsupportedEllipticCurve if the curve identifier is not supported Source code in jwskate/jwk/ec.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @classmethod def get_curve ( cls , crv : str ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for a given curve identifier. Args: crv: the curve identifier Returns: the matching EllipticCurve instance Raises: UnsupportedEllipticCurve: if the curve identifier is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedEllipticCurve ( crv ) return curve","title":"get_curve()"},{"location":"api/#jwskate.jwk.ec.ECJwk.curve","text":"1 curve () -> EllipticCurve Get the EllipticCurve instance for this key. Returns: Type Description EllipticCurve the EllipticCurve instance Source code in jwskate/jwk/ec.py 97 98 99 100 101 102 103 104 @property def curve ( self ) -> EllipticCurve : \"\"\"Get the EllipticCurve instance for this key. Returns: the EllipticCurve instance \"\"\" return self . get_curve ( self . crv )","title":"curve()"},{"location":"api/#jwskate.jwk.ec.ECJwk.public","text":"1 public ( crv : str , x : int , y : int , ** params : str ) -> ECJwk Initialize a public ECJwk from its public parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required **params str additional member to include in the Jwk {} Returns: Type Description ECJwk an ECJwk initialized with the supplied parameters Source code in jwskate/jwk/ec.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @classmethod def public ( cls , crv : str , x : int , y : int , ** params : str ) -> \"ECJwk\" : \"\"\"Initialize a public ECJwk from its public parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate **params: additional member to include in the Jwk Returns: an ECJwk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( key = \"EC\" , crv = crv , x = BinaPy . from_int ( x , length = coord_size ) . to ( \"b64u\" ), y = BinaPy . from_int ( y , length = coord_size ) . to ( \"b64u\" ), ** { k : v for k , v in params . items () if v is not None }, ) )","title":"public()"},{"location":"api/#jwskate.jwk.ec.ECJwk.private","text":"1 2 3 private ( crv : str , x : int , y : int , d : int , ** params : Any ) -> ECJwk Initialize a private ECJwk from its private parameters. Parameters: Name Type Description Default crv str the curve to use required x int the x coordinate required y int the y coordinate required d int the elliptic curve private key required **params Any additional members to include in the JWK {} Returns: Type Description ECJwk an ECJWk initialized with the supplied parameters Source code in jwskate/jwk/ec.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @classmethod def private ( cls , crv : str , x : int , y : int , d : int , ** params : Any ) -> \"ECJwk\" : \"\"\"Initialize a private ECJwk from its private parameters. Args: crv: the curve to use x: the x coordinate y: the y coordinate d: the elliptic curve private key **params: additional members to include in the JWK Returns: an ECJWk initialized with the supplied parameters \"\"\" coord_size = cls . get_curve ( crv ) . coordinate_size return cls ( dict ( kty = \"EC\" , crv = crv , x = BinaPy . from_int ( x , coord_size ) . to ( \"b64u\" ) . ascii (), y = BinaPy . from_int ( y , coord_size ) . to ( \"b64u\" ) . ascii (), d = BinaPy . from_int ( d , coord_size ) . to ( \"b64u\" ) . ascii (), ** { k : v for k , v in params . items () if v is not None }, ) )","title":"private()"},{"location":"api/#jwskate.jwk.ec.ECJwk.coordinate_size","text":"1 coordinate_size () -> int The coordinate size to use with the key curve. Returns: Type Description int 32, 48, or 66 (bits) Source code in jwskate/jwk/ec.py 156 157 158 159 160 161 162 163 @property def coordinate_size ( self ) -> int : \"\"\"The coordinate size to use with the key curve. Returns: 32, 48, or 66 (bits) \"\"\" return self . curve . coordinate_size","title":"coordinate_size()"},{"location":"api/#jwskate.jwk.ec.ECJwk.from_cryptography_key","text":"1 2 3 from_cryptography_key ( cryptography_key : Any , ** kwargs : Any ) -> ECJwk Initialize an ECJwk from a cryptography key. Parameters: Name Type Description Default cryptography_key Any cryptography key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description ECJwk an ECJwk initialized from the provided cryptography key Source code in jwskate/jwk/ec.py 165 166 167 168 169 170 171 172 173 174 175 176 177 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> ECJwk : \"\"\"Initialize an ECJwk from a `cryptography` key. Args: cryptography_key: `cryptography` key **kwargs: additional members to include in the Jwk Returns: an ECJwk initialized from the provided `cryptography` key \"\"\" parameters = EllipticCurve . get_jwk_parameters ( cryptography_key ) return cls ( parameters )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk._to_cryptography_key","text":"1 2 3 4 _to_cryptography_key () -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ] Initialize a cryptography key based on this Jwk. Returns: Type Description Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey ] an EllipticCurvePublicKey or EllipticCurvePrivateKey Source code in jwskate/jwk/ec.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def _to_cryptography_key ( self , ) -> Union [ asymmetric . ec . EllipticCurvePrivateKey , asymmetric . ec . EllipticCurvePublicKey , ]: \"\"\"Initialize a `cryptography` key based on this Jwk. Returns: an EllipticCurvePublicKey or EllipticCurvePrivateKey \"\"\" if self . is_private : return asymmetric . ec . EllipticCurvePrivateNumbers ( private_value = self . ecc_private_key , public_numbers = asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ), ) . private_key () else : return asymmetric . ec . EllipticCurvePublicNumbers ( x = self . x_coordinate , y = self . y_coordinate , curve = self . curve . cryptography_curve , ) . public_key ()","title":"_to_cryptography_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk.generate","text":"1 2 3 4 5 generate ( crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : str ) -> ECJwk Generate a random ECJwk. Parameters: Name Type Description Default alg Optional [ str ] the alg None crv Optional [ str ] the curve to use None **params str {} Returns: Type Description ECJwk a generated ECJwk Raises: Type Description UnsupportedEllipticCurve if the provided curve identifier is not supported. Source code in jwskate/jwk/ec.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 @classmethod def generate ( cls , crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : str ) -> \"ECJwk\" : \"\"\"Generate a random ECJwk. Args: alg: the alg crv: the curve to use **params: Returns: a generated ECJwk Raises: UnsupportedEllipticCurve: if the provided curve identifier is not supported. \"\"\" if crv is None and alg is None : warnings . warn ( \"No Curve identifier (crv) or an Algorithm identifier (alg) have been provided \" \"when generating an Elliptic Curve JWK. So there is no hint to determine which curve to use. \" \"Curve 'P-256' is used by default. You should explicitly pass an 'alg' or 'crv' parameter \" \"to explicitly select the appropriate Curve and avoid this warning.\" ) crv = \"P-256\" curve : Optional [ EllipticCurve ] = None if crv : curve = cls . get_curve ( crv ) elif alg : if alg in cls . SIGNATURE_ALGORITHMS : curve = cls . SIGNATURE_ALGORITHMS [ alg ] . curve elif alg in cls . KEY_MANAGEMENT_ALGORITHMS : curve = P_256 if curve is None : raise UnsupportedEllipticCurve ( crv ) x , y , d = curve . generate () return cls . private ( crv = curve . name , alg = alg , x = x , y = y , d = d , ** params , )","title":"generate()"},{"location":"api/#jwskate.jwk.ec.ECJwk.x_coordinate","text":"1 x_coordinate () -> int Return the x coordinate from this ECJwk. Returns: Type Description int the x coordinate (from parameter x ) Source code in jwskate/jwk/ec.py 253 254 255 256 257 258 259 260 @cached_property def x_coordinate ( self ) -> int : \"\"\"Return the x coordinate from this ECJwk. Returns: the x coordinate (from parameter `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) . to_int ()","title":"x_coordinate()"},{"location":"api/#jwskate.jwk.ec.ECJwk.y_coordinate","text":"1 y_coordinate () -> int Return the y coordinate from this ECJwk. Returns: Type Description int the y coordinate (from parameter y ) Source code in jwskate/jwk/ec.py 262 263 264 265 266 267 268 269 @cached_property def y_coordinate ( self ) -> int : \"\"\"Return the y coordinate from this ECJwk. Returns: the y coordinate (from parameter `y`) \"\"\" return BinaPy ( self . y ) . decode_from ( \"b64u\" ) . to_int ()","title":"y_coordinate()"},{"location":"api/#jwskate.jwk.ec.ECJwk.ecc_private_key","text":"1 ecc_private_key () -> int Return the ECC private key from this ECJwk. Returns: Type Description int the ECC private key (from parameter d ) Source code in jwskate/jwk/ec.py 271 272 273 274 275 276 277 278 @cached_property def ecc_private_key ( self ) -> int : \"\"\"Return the ECC private key from this ECJwk. Returns: the ECC private key (from parameter `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) . to_int ()","title":"ecc_private_key()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_signing_algorithms","text":"1 supported_signing_algorithms () -> List [ str ] Return the list of supported signature algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 280 281 282 283 284 285 286 287 288 289 290 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported signature algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return [ name for name , alg in self . SIGNATURE_ALGORITHMS . items () if alg . curve == self . curve ]","title":"supported_signing_algorithms()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_key_management_algorithms","text":"1 supported_key_management_algorithms () -> List [ str ] Return the list of supported Key Management algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 292 293 294 295 296 297 298 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of supported Key Management algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS )","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.ec.ECJwk.supported_encryption_algorithms","text":"1 supported_encryption_algorithms () -> List [ str ] Return the list of support Encryption algorithms for this key. Returns: Type Description List [ str ] a list of supported algorithms identifiers Source code in jwskate/jwk/ec.py 300 301 302 303 304 305 306 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of support Encryption algorithms for this key. Returns: a list of supported algorithms identifiers \"\"\" return list ( self . ENCRYPTION_ALGORITHMS )","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jwk.OKPJwk","text":"Bases: Jwk Represent an OKP Jwk, with kty=OKP . Source code in jwskate/jwk/okp.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 class OKPJwk ( Jwk ): \"\"\"Represent an OKP Jwk, with `kty=OKP`.\"\"\" KTY = \"OKP\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ) CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ) PARAMS = { \"crv\" : JwkParameter ( \"Curve\" , is_private = False , is_required = True , kind = \"name\" ), \"x\" : JwkParameter ( \"Public Key\" , is_private = False , is_required = True , kind = \"b64u\" ), \"d\" : JwkParameter ( \"Private Key\" , is_private = True , is_required = True , kind = \"b64u\" ), } CURVES : Mapping [ str , OKPCurve ] = { curve . name : curve for curve in [ Ed25519 , Ed448 , X448 , X25519 ] } SIGNATURE_ALGORITHMS = { alg . name : alg for alg in ( EdDsa ,)} KEY_MANAGEMENT_ALGORITHMS = { keyalg . name : keyalg for keyalg in [ EcdhEs , EcdhEs_A128KW , EcdhEs_A192KW , EcdhEs_A256KW ] } @property def is_private ( self ) -> bool : # noqa: D102 return \"d\" in self def _validate ( self ) -> None : if not isinstance ( self . crv , str ) or self . crv not in self . CURVES : raise UnsupportedOKPCurve ( self . crv ) super () . _validate () @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv ) @cached_property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" ) @cached_property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" ) @classmethod def from_bytes ( cls , private_key : bytes , crv : Optional [ str ] = None , use : Optional [ str ] = None , ** kwargs : Any , ) -> OKPJwk : \"\"\"Initialize an `OKPJwk` from its private key. The public key will be automatically derived from the supplied private key, The appropriate curve will be guessed based on the key length or supplied `crv`/`use` hints: - 56 bytes will use X448 - 57 bytes will use Ed448 - 32 bytes will use Ed25519 or X25519. Since there is no way to guess which one you want, it needs an hint with either a `crv` or `use` parameter. Args: private_key: the 32, 56 or 57 bytes private key, as raw bytes crv: the curve to use use: the key usage **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if crv and use : if ( crv in ( \"Ed25519\" , \"Ed448\" ) and use != \"sig\" ) or ( crv in ( \"X25519\" , \"X448\" ) and use != \"enc\" ): raise ValueError ( f \"Inconsistent `crv= { crv } ` and `use= { use } ` parameters.\" ) elif crv : if crv in ( \"Ed25519\" , \"Ed448\" ): use = \"sig\" elif crv in ( \"X25519\" , \"X448\" ): use = \"enc\" else : raise UnsupportedOKPCurve ( crv ) elif use : if use not in ( \"sig\" , \"enc\" ): raise ValueError ( f \"Invalid `use= { use } ` parameter, need 'sig' or 'enc'.\" ) cryptography_key : Any if len ( private_key ) == 32 : if use == \"sig\" : cryptography_key = ed25519 . Ed25519PrivateKey . from_private_bytes ( private_key ) elif use == \"enc\" : cryptography_key = x25519 . X25519PrivateKey . from_private_bytes ( private_key ) else : raise ValueError ( \"You need to specify either crv={'Ed25519', 'X25519'} or use={'sig', 'enc'} when providing a 32 bytes private key.\" ) elif len ( private_key ) == 56 : cryptography_key = x448 . X448PrivateKey . from_private_bytes ( private_key ) if use and use != \"enc\" : raise ValueError ( f \"Invalid `use= { use } ` parameter. Keys of length 56 bytes are for curve X448.\" ) use = \"enc\" elif len ( private_key ) == 57 : cryptography_key = ed448 . Ed448PrivateKey . from_private_bytes ( private_key ) if use and use != \"sig\" : raise ValueError ( f \"Invalid `use= { use } ` parameter. Keys of length 57 bytes are for curve Ed448.\" ) use = \"sig\" else : raise ValueError ( \"Invalid private key. It must be bytes of length 32, 56 or 57.\" ) return OKPJwk . from_cryptography_key ( cryptography_key , use = use , ** kwargs ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> OKPJwk : \"\"\"Initialize an `OKPJwk` from a `cryptography` key. Args: cryptography_key: a `cryptography` key **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if isinstance ( cryptography_key , ed25519 . Ed25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed25519 . Ed25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( cryptography_key , ed448 . Ed448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed448 . Ed448PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( cryptography_key , x25519 . X25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x25519 . X25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( cryptography_key , x448 . X448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x448 . X448PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in ( cls . CRYPTOGRAPHY_PRIVATE_KEY_CLASSES + cls . CRYPTOGRAPHY_PUBLIC_KEY_CLASSES ) ) ) def _to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) # pragma: no cover @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), ** params )) @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . to ( \"b64u\" ) . ascii (), ** params , ) ) @classmethod def generate ( cls , crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. You can specify either a curve or an algorithm identifier, or both. If using an alg identifier, crv will default to Ed25519 for signature algs, or X25519 for encryption algs. Args: crv: the curve to use alg: algorithm to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" if crv : curve = cls . get_curve ( crv ) elif alg : if alg in cls . SIGNATURE_ALGORITHMS : curve = Ed25519 elif alg in cls . KEY_MANAGEMENT_ALGORITHMS : curve = X25519 else : raise UnsupportedAlg ( alg ) else : raise ValueError ( \"You must supply at least a Curve identifier (crv) or an Algorithm identifier (alg) \" \"in order to generate an OKP JWK.\" ) x , d = curve . generate () return cls . private ( crv = curve . name , x = x , d = d , alg = alg , ** params ) @cached_property def use ( self ) -> Optional [ str ]: \"\"\"Return the key use. For OKP keys, this can be directly deduced from the curve. \"\"\" if self . curve in ( Ed25519 , Ed448 ): return \"sig\" elif self . curve in ( X25519 , X448 ): return \"enc\" return None # pragma: no cover","title":"OKPJwk"},{"location":"api/#jwskate.jwk.okp.OKPJwk.get_curve","text":"1 get_curve ( crv : str ) -> OKPCurve Get the OKPCurve instance from a curve identifier. Parameters: Name Type Description Default crv str a crv identifier required Returns: Type Description OKPCurve the matching OKPCurve instance Raises: Type Description UnsupportedOKPCurve if the curve is not supported Source code in jwskate/jwk/okp.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @classmethod def get_curve ( cls , crv : str ) -> OKPCurve : \"\"\"Get the OKPCurve instance from a curve identifier. Args: crv: a crv identifier Returns: the matching OKPCurve instance Raises: UnsupportedOKPCurve: if the curve is not supported \"\"\" curve = cls . CURVES . get ( crv ) if curve is None : raise UnsupportedOKPCurve ( crv ) return curve","title":"get_curve()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.curve","text":"1 curve () -> OKPCurve Get the OKPCurve instance for this key. Returns: Type Description OKPCurve the OKPCurve for this key Source code in jwskate/jwk/okp.py 103 104 105 106 107 108 109 110 @property def curve ( self ) -> OKPCurve : \"\"\"Get the OKPCurve instance for this key. Returns: the OKPCurve for this key \"\"\" return self . get_curve ( self . crv )","title":"curve()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.public_key","text":"1 public_key () -> bytes Get the public key from this Jwk. Returns: Type Description bytes the public key (from param x ) Source code in jwskate/jwk/okp.py 112 113 114 115 116 117 118 119 @cached_property def public_key ( self ) -> bytes : \"\"\"Get the public key from this Jwk. Returns: the public key (from param `x`) \"\"\" return BinaPy ( self . x ) . decode_from ( \"b64u\" )","title":"public_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.private_key","text":"1 private_key () -> bytes Get the private key from this Jwk. Returns: Type Description bytes the private key (from param d ) Source code in jwskate/jwk/okp.py 121 122 123 124 125 126 127 128 @cached_property def private_key ( self ) -> bytes : \"\"\"Get the private key from this Jwk. Returns: the private key (from param `d`) \"\"\" return BinaPy ( self . d ) . decode_from ( \"b64u\" )","title":"private_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.from_bytes","text":"1 2 3 4 5 6 from_bytes ( private_key : bytes , crv : Optional [ str ] = None , use : Optional [ str ] = None , ** kwargs : Any ) -> OKPJwk Initialize an OKPJwk from its private key. The public key will be automatically derived from the supplied private key, The appropriate curve will be guessed based on the key length or supplied crv / use hints: - 56 bytes will use X448 - 57 bytes will use Ed448 - 32 bytes will use Ed25519 or X25519. Since there is no way to guess which one you want, it needs an hint with either a crv or use parameter. Parameters: Name Type Description Default private_key bytes the 32, 56 or 57 bytes private key, as raw bytes required crv Optional [ str ] the curve to use None use Optional [ str ] the key usage None **kwargs Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the matching OKPJwk Source code in jwskate/jwk/okp.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 @classmethod def from_bytes ( cls , private_key : bytes , crv : Optional [ str ] = None , use : Optional [ str ] = None , ** kwargs : Any , ) -> OKPJwk : \"\"\"Initialize an `OKPJwk` from its private key. The public key will be automatically derived from the supplied private key, The appropriate curve will be guessed based on the key length or supplied `crv`/`use` hints: - 56 bytes will use X448 - 57 bytes will use Ed448 - 32 bytes will use Ed25519 or X25519. Since there is no way to guess which one you want, it needs an hint with either a `crv` or `use` parameter. Args: private_key: the 32, 56 or 57 bytes private key, as raw bytes crv: the curve to use use: the key usage **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if crv and use : if ( crv in ( \"Ed25519\" , \"Ed448\" ) and use != \"sig\" ) or ( crv in ( \"X25519\" , \"X448\" ) and use != \"enc\" ): raise ValueError ( f \"Inconsistent `crv= { crv } ` and `use= { use } ` parameters.\" ) elif crv : if crv in ( \"Ed25519\" , \"Ed448\" ): use = \"sig\" elif crv in ( \"X25519\" , \"X448\" ): use = \"enc\" else : raise UnsupportedOKPCurve ( crv ) elif use : if use not in ( \"sig\" , \"enc\" ): raise ValueError ( f \"Invalid `use= { use } ` parameter, need 'sig' or 'enc'.\" ) cryptography_key : Any if len ( private_key ) == 32 : if use == \"sig\" : cryptography_key = ed25519 . Ed25519PrivateKey . from_private_bytes ( private_key ) elif use == \"enc\" : cryptography_key = x25519 . X25519PrivateKey . from_private_bytes ( private_key ) else : raise ValueError ( \"You need to specify either crv={'Ed25519', 'X25519'} or use={'sig', 'enc'} when providing a 32 bytes private key.\" ) elif len ( private_key ) == 56 : cryptography_key = x448 . X448PrivateKey . from_private_bytes ( private_key ) if use and use != \"enc\" : raise ValueError ( f \"Invalid `use= { use } ` parameter. Keys of length 56 bytes are for curve X448.\" ) use = \"enc\" elif len ( private_key ) == 57 : cryptography_key = ed448 . Ed448PrivateKey . from_private_bytes ( private_key ) if use and use != \"sig\" : raise ValueError ( f \"Invalid `use= { use } ` parameter. Keys of length 57 bytes are for curve Ed448.\" ) use = \"sig\" else : raise ValueError ( \"Invalid private key. It must be bytes of length 32, 56 or 57.\" ) return OKPJwk . from_cryptography_key ( cryptography_key , use = use , ** kwargs )","title":"from_bytes()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.from_cryptography_key","text":"1 2 3 from_cryptography_key ( cryptography_key : Any , ** kwargs : Any ) -> OKPJwk Initialize an OKPJwk from a cryptography key. Parameters: Name Type Description Default cryptography_key Any a cryptography key required **kwargs Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the matching OKPJwk Source code in jwskate/jwk/okp.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> OKPJwk : \"\"\"Initialize an `OKPJwk` from a `cryptography` key. Args: cryptography_key: a `cryptography` key **kwargs: additional members to include in the Jwk Returns: the matching OKPJwk \"\"\" if isinstance ( cryptography_key , ed25519 . Ed25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"Ed25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed25519 . Ed25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"Ed25519\" , x = pub , ) elif isinstance ( cryptography_key , ed448 . Ed448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"Ed448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , ed448 . Ed448PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"Ed448\" , x = pub ) elif isinstance ( cryptography_key , x25519 . X25519PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"X25519\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x25519 . X25519PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"X25519\" , x = pub ) elif isinstance ( cryptography_key , x448 . X448PrivateKey ): priv = cryptography_key . private_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PrivateFormat . Raw , encryption_algorithm = serialization . NoEncryption (), ) pub = cryptography_key . public_key () . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . private ( crv = \"X448\" , x = pub , d = priv , ) elif isinstance ( cryptography_key , x448 . X448PublicKey ): pub = cryptography_key . public_bytes ( encoding = serialization . Encoding . Raw , format = serialization . PublicFormat . Raw , ) return cls . public ( crv = \"X448\" , x = pub ) else : raise TypeError ( \"Unsupported key type for OKP. Supported key types are: \" + \", \" . join ( kls . __name__ for kls in ( cls . CRYPTOGRAPHY_PRIVATE_KEY_CLASSES + cls . CRYPTOGRAPHY_PUBLIC_KEY_CLASSES ) ) )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk._to_cryptography_key","text":"1 _to_cryptography_key () -> Any Intialize a cryptography key based on this Jwk. Returns: Type Description Any a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: Type Description UnsupportedOKPCurve if this Jwk curve is not supported. Source code in jwskate/jwk/okp.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def _to_cryptography_key ( self ) -> Any : \"\"\"Intialize a `cryptography` key based on this Jwk. Returns: a Ed25519PrivateKey or a Ed25519PublicKey or a Ed448PrivateKey or a Ed448PublicKey based on the current Jwk Raises: UnsupportedOKPCurve: if this Jwk curve is not supported. \"\"\" if self . curve . name == \"Ed25519\" : if self . is_private : return ed25519 . Ed25519PrivateKey . from_private_bytes ( self . private_key ) else : return ed25519 . Ed25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"Ed448\" : if self . is_private : return ed448 . Ed448PrivateKey . from_private_bytes ( self . private_key ) else : return ed448 . Ed448PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X25519\" : if self . is_private : return x25519 . X25519PrivateKey . from_private_bytes ( self . private_key ) else : return x25519 . X25519PublicKey . from_public_bytes ( self . public_key ) elif self . curve . name == \"X448\" : if self . is_private : return x448 . X448PrivateKey . from_private_bytes ( self . private_key ) else : return x448 . X448PublicKey . from_public_bytes ( self . public_key ) else : raise UnsupportedOKPCurve ( self . curve ) # pragma: no cover","title":"_to_cryptography_key()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.public","text":"1 public ( crv : str , x : bytes , ** params : Any ) -> OKPJwk Initialize a public OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the key curve required x bytes the public key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 351 352 353 354 355 356 357 358 359 360 361 362 363 @classmethod def public ( cls , crv : str , x : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a public OKPJwk based on the provided parameters. Args: crv: the key curve x: the public key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = \"OKP\" , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), ** params ))","title":"public()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.private","text":"1 2 3 private ( crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk Initialize a private OKPJwk based on the provided parameters. Parameters: Name Type Description Default crv str the OKP curve required x bytes the public key required d bytes the private key required **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 @classmethod def private ( cls , crv : str , x : bytes , d : bytes , ** params : Any ) -> OKPJwk : \"\"\"Initialize a private OKPJwk based on the provided parameters. Args: crv: the OKP curve x: the public key d: the private key **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" return cls ( dict ( kty = cls . KTY , crv = crv , x = BinaPy ( x ) . to ( \"b64u\" ) . ascii (), d = BinaPy ( d ) . to ( \"b64u\" ) . ascii (), ** params , ) )","title":"private()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.generate","text":"1 2 3 4 5 generate ( crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : Any ) -> OKPJwk Generate a private OKPJwk on a given curve. You can specify either a curve or an algorithm identifier, or both. If using an alg identifier, crv will default to Ed25519 for signature algs, or X25519 for encryption algs. Parameters: Name Type Description Default crv Optional [ str ] the curve to use None alg Optional [ str ] algorithm to use None **params Any additional members to include in the Jwk {} Returns: Type Description OKPJwk the resulting OKPJwk Source code in jwskate/jwk/okp.py 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 @classmethod def generate ( cls , crv : Optional [ str ] = None , alg : Optional [ str ] = None , ** params : Any ) -> OKPJwk : \"\"\"Generate a private OKPJwk on a given curve. You can specify either a curve or an algorithm identifier, or both. If using an alg identifier, crv will default to Ed25519 for signature algs, or X25519 for encryption algs. Args: crv: the curve to use alg: algorithm to use **params: additional members to include in the Jwk Returns: the resulting OKPJwk \"\"\" if crv : curve = cls . get_curve ( crv ) elif alg : if alg in cls . SIGNATURE_ALGORITHMS : curve = Ed25519 elif alg in cls . KEY_MANAGEMENT_ALGORITHMS : curve = X25519 else : raise UnsupportedAlg ( alg ) else : raise ValueError ( \"You must supply at least a Curve identifier (crv) or an Algorithm identifier (alg) \" \"in order to generate an OKP JWK.\" ) x , d = curve . generate () return cls . private ( crv = curve . name , x = x , d = d , alg = alg , ** params )","title":"generate()"},{"location":"api/#jwskate.jwk.okp.OKPJwk.use","text":"1 use () -> Optional [ str ] Return the key use. For OKP keys, this can be directly deduced from the curve. Source code in jwskate/jwk/okp.py 424 425 426 427 428 429 430 431 432 433 434 @cached_property def use ( self ) -> Optional [ str ]: \"\"\"Return the key use. For OKP keys, this can be directly deduced from the curve. \"\"\" if self . curve in ( Ed25519 , Ed448 ): return \"sig\" elif self . curve in ( X25519 , X448 ): return \"enc\" return None # pragma: no cover","title":"use()"},{"location":"api/#jwskate.jwk.UnsupportedKeyType","text":"Bases: ValueError Raised when an unsupported Key Type is requested. Source code in jwskate/jwk/base.py 48 49 class UnsupportedKeyType ( ValueError ): \"\"\"Raised when an unsupported Key Type is requested.\"\"\"","title":"UnsupportedKeyType"},{"location":"api/#jwskate.jwk.InvalidJwk","text":"Bases: ValueError Raised when an invalid JWK is encountered. Source code in jwskate/jwk/base.py 52 53 class InvalidJwk ( ValueError ): \"\"\"Raised when an invalid JWK is encountered.\"\"\"","title":"InvalidJwk"},{"location":"api/#jwskate.jwk.Jwk","text":"Bases: BaseJsonDict Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class: Jwk is a dict, so you can do with a Jwk anything you can do with a dict . In addition, all keys parameters are exposed as attributes. There are subclasses of Jwk for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Parameters: Name Type Description Default params Union [ Dict [ str , Any ], Any ] a dict with the parsed Jwk parameters, or a cryptography key , or another Jwk required include_kid_thumbprint bool if True (default), and there is no kid in the provided params, generate a kid based on the key thumbprint False Source code in jwskate/jwk/base.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 class Jwk ( BaseJsonDict ): \"\"\"Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Just like a parsed JSON object, a :class:`Jwk` is a dict, so you can do with a Jwk anything you can do with a `dict`. In addition, all keys parameters are exposed as attributes. There are subclasses of `Jwk` for each specific Key Type, but you shouldn't have to use the subclasses directly since they all present a common interface. Args: params: a dict with the parsed Jwk parameters, or a `cryptography key`, or another `Jwk` include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint \"\"\" subclasses : Dict [ str , Type [ Jwk ]] = {} \"\"\"A dict of 'kty' values to subclasses implementing each specific Key Type\"\"\" cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} \"\"\"A dict of cryptography key classes to its specific 'kty' value\"\"\" PARAMS : Mapping [ str , JwkParameter ] \"\"\"A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)\"\"\" KTY : ClassVar [ str ] \"\"\"The Key Type associated with this JWK.\"\"\" CRYPTOGRAPHY_PRIVATE_KEY_CLASSES : ClassVar [ Iterable [ Any ]] CRYPTOGRAPHY_PUBLIC_KEY_CLASSES : ClassVar [ Iterable [ Any ]] SIGNATURE_ALGORITHMS : Mapping [ str , Type [ BaseSignatureAlg ]] = {} KEY_MANAGEMENT_ALGORITHMS : Mapping [ str , Type [ BaseKeyManagementAlg ]] = {} ENCRYPTION_ALGORITHMS : Mapping [ str , Type [ BaseAESEncryptionAlg ]] = {} IANA_HASH_FUNCTION_NAMES : Mapping [ str , str ] = { # IANA registered names to binapy hash name \"sha-1\" : \"sha1\" , \"sha-224\" : \"sha224\" , \"sha-256\" : \"sha256\" , \"sha-384\" : \"sha384\" , \"sha-512\" : \"sha512\" , \"shake128\" : \"shake128\" , \"shake256\" : \"shake256\" , } def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows `__new__` to pick the appropriate subclass when creating a Jwk. \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_PRIVATE_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls for klass in cls . CRYPTOGRAPHY_PUBLIC_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls def __new__ ( cls , key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key **kwargs: additional members to include in the Jwk \"\"\" if cls == Jwk : if isinstance ( key , Jwk ): return cls . from_cryptography_key ( key . cryptography_key , ** kwargs ) if isinstance ( key , dict ): kty : Optional [ str ] = key . get ( \"kty\" ) if kty is None : raise InvalidJwk ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise InvalidJwk ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) elif isinstance ( key , str ): return cls . from_json ( key ) else : return cls . from_cryptography_key ( key , ** kwargs ) return super () . __new__ ( cls , key , ** kwargs ) def __init__ ( self , params : Union [ Dict [ str , Any ], Any ], include_kid_thumbprint : bool = False ): if isinstance ( params , dict ): # this is to avoid double init due to the __new__ above super () . __init__ ( { key : val for key , val in params . items () if val is not None } ) self . _validate () if self . get ( \"kid\" ) is None and include_kid_thumbprint : self [ \"kid\" ] = self . thumbprint () try : self . cryptography_key = self . _to_cryptography_key () except AttributeError as exc : raise InvalidJwk ( \"Invalid JWK parameter\" , * exc . args ) from exc @classmethod def _get_alg_class ( cls , alg : str ) -> Type [ BaseAlg ]: \"\"\"Given an alg identifier, return the matching JWA wrapper. Args: alg: an alg identifier Returns: the matching JWA wrapper \"\"\" alg_class : Optional [ Type [ BaseAlg ]] alg_class = cls . SIGNATURE_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class alg_class = cls . KEY_MANAGEMENT_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class alg_class = cls . ENCRYPTION_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class raise UnsupportedAlg ( alg ) @property def is_private ( self ) -> bool : \"\"\"Return `True` if the key is private, `False` otherwise. Returns: `True` if the key is private, `False` otherwise \"\"\" return True @property def is_symmetric ( self ) -> bool : \"\"\"Return `True` if the key is symmetric, `False` otherwise.\"\"\" return False def __getattr__ ( self , param : str ) -> Any : \"\"\"Allow access to key parameters as attributes. This is a convenience to allow `jwk.param` instead of `jwk['param']`. Args: param: the parameter name to access Return: the param value Raises: AttributeError: if the param is not found \"\"\" value = self . get ( param ) if value is None : raise AttributeError ( param ) return value def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Override base method to avoid modifying cryptographic key attributes. Args: key: name of the attribute to set value: value to set Raises: RuntimeError: when trying to modify cryptographic attributes \"\"\" if key in self . PARAMS : raise RuntimeError ( \"JWK key attributes cannot be modified.\" ) super () . __setitem__ ( key , value ) def thumbprint ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" alg = self . IANA_HASH_FUNCTION_NAMES . get ( hashalg ) if not alg : raise ValueError ( f \"Unsupported hash alg { hashalg } \" ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) return ( BinaPy . serialize_to ( \"json\" , t , separators = ( \",\" , \":\" ), sort_keys = True ) . to ( alg ) . to ( \"b64u\" ) . ascii () ) def thumbprint_uri ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Returns the JWK thumbprint URI for this key. Args: hashalg: the IANA registered name for the hash alg to use Returns: the JWK thumbprint uri for this Jwk \"\"\" return ( f \"urn:ietf:params:oauth:jwk-thumbprint: { hashalg } : { self . thumbprint ( hashalg ) } \" ) @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): # pragma: no branch raise TypeError ( f \"Invalid alg type { type ( alg ) } \" , alg ) return alg def signature_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseSignatureAlg ]: \"\"\"Return the appropriate signature algorithm class (a `BaseSignatureAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseSignatureAlg` subclass \"\"\" return select_alg_class ( self . SIGNATURE_ALGORITHMS , jwk_alg = self . alg , alg = alg ) def encryption_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseAESEncryptionAlg ]: \"\"\"Return the appropriate encryption algorithm class (a `BaseAESEncryptionAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseAESEncryptionAlg` subclass \"\"\" return select_alg_class ( self . ENCRYPTION_ALGORITHMS , jwk_alg = self . alg , alg = alg ) def key_management_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseKeyManagementAlg ]: \"\"\"Return the appropriate key management algorithm class (a `BaseKeyManagementAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseKeyManagementAlg` subclass \"\"\" return select_alg_class ( self . KEY_MANAGEMENT_ALGORITHMS , jwk_alg = self . alg , alg = alg ) def signature_wrapper ( self , alg : Optional [ str ] = None ) -> BaseSignatureAlg : \"\"\"Initialize a key management wrapper (an instance of a `BaseKeyManagementAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseKeyManagementAlg` instance initialized with the current key \"\"\" alg_class = self . signature_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): return alg_class ( self . cryptography_key ) raise UnsupportedAlg ( alg ) # pragma: no cover def encryption_wrapper ( self , alg : Optional [ str ] = None ) -> BaseAESEncryptionAlg : \"\"\"Initialize an encryption wrapper (an instance of a `BaseAESEncryptionAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseAESEncryptionAlg` instance initialized with the current key \"\"\" alg_class = self . encryption_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): # pragma: no cover return alg_class ( self . cryptography_key ) # pragma: no cover raise UnsupportedAlg ( alg ) # pragma: no cover def key_management_wrapper ( self , alg : Optional [ str ] = None ) -> BaseKeyManagementAlg : \"\"\"Initialize a key management wrapper (an instance of a `BaseKeyManagementAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseKeyManagementAlg` instance initialized with the current key \"\"\" alg_class = self . key_management_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): return alg_class ( self . cryptography_key ) raise UnsupportedAlg ( alg ) # pragma: no cover @property def kid ( self ) -> Optional [ str ]: \"\"\"Return the JWK key ID (kid), if present.\"\"\" kid = self . get ( \"kid\" ) if kid is not None and not isinstance ( kid , str ): # pragma: no branch raise TypeError ( f \"invalid kid type { type ( kid ) } \" , kid ) return kid @cached_property def use ( self ) -> Optional [ str ]: \"\"\"Return the key use. If no `alg` parameter is present, this returns the `use` parameter from this JWK. If an `alg` parameter is present, the use is deduced from this alg. To check for the presence of the `use` parameter, use `jwk.get('use')`. \"\"\" if self . alg : return self . _get_alg_class ( self . alg ) . use else : return self . get ( \"use\" ) @cached_property def key_ops ( self ) -> Tuple [ str , ... ]: \"\"\"Return the key operations. If no `alg` parameter is present, this returns the `key_ops` parameter from this JWK. If an `alg` parameter is present, the key operations are deduced from this alg. To check for the presence of the `key_ops` parameter, use `jwk.get('key_ops')`. \"\"\" key_ops : Tuple [ str , ... ] if self . use == \"sig\" : if self . is_symmetric : key_ops = ( \"sign\" , \"verify\" ) elif self . is_private : key_ops = ( \"sign\" ,) else : key_ops = ( \"verify\" ,) elif self . use == \"enc\" : if self . is_symmetric : if self . alg : alg_class = self . _get_alg_class ( self . alg ) if issubclass ( alg_class , BaseKeyManagementAlg ): key_ops = ( \"wrapKey\" , \"unwrapKey\" ) elif issubclass ( alg_class , BaseAESEncryptionAlg ): key_ops = ( \"encrypt\" , \"decrypt\" ) else : key_ops = ( \"wrapKey\" , \"unwrapKey\" , \"encrypt\" , \"decrypt\" ) elif self . is_private : key_ops = ( \"unwrapKey\" ,) else : key_ops = ( \"wrapKey\" ,) else : key_ops = self . get ( \"key_ops\" , ()) return tuple ( key_ops ) def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : # pragma: no cover raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"unwrapKey\" ) and not self . is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" ) def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS ) def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS ) def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS ) def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } if \"key_ops\" in self : key_ops = list ( self . key_ops ) if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) else : key_ops = None return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) ) def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,)) def sign ( self , data : Union [ bytes , SupportsBytes ], alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" wrapper = self . signature_wrapper ( alg ) signature = wrapper . sign ( data ) return BinaPy ( signature ) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" if not self . is_symmetric and self . is_private : warnings . warn ( \"You are trying to validate a signature with a private key. \" \"Signature should always be verified with a public key.\" ) public_jwk = self . public_jwk () else : public_jwk = self if algs is None and alg : algs = [ alg ] for alg in algs or ( None ,): wrapper = public_jwk . signature_wrapper ( alg ) if wrapper . verify ( data , signature ): return True return False def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext with Authenticated Encryption using this key. Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data (`aad`). This returns a tuple with 3 raw data, in order: - the encrypted Data - the Initialization Vector that was used to encrypt data - the generated Authentication Tag Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same. Returns: a tuple (ciphertext, iv, authentication_tag), as raw data \"\"\" raise NotImplementedError # pragma: no cover def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt iv: the Initialization Vector (IV) that was used for encryption tag: the Authentication Tag that will be verified while decrypting data aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover def sender_key ( self , enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]]: \"\"\"Used by encrypted token senders to produce a Content Encryption Key. Returns a tuple with 3 items: - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone! - the encrypted CEK, as bytes. You must send this to your recipient. This may be `None` for Key Management algs which derive a CEK instead of generating one. - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well. For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only do this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: a tuple (cek, wrapped_cek, additional_headers_map) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk if not self . is_symmetric and self . is_private : warnings . warn ( \"You are using a private key for sender key wrapping. Key wrapping should always be done using the recipient public key.\" ) key_alg_wrapper = self . public_jwk () . key_management_wrapper ( alg ) else : key_alg_wrapper = self . key_management_wrapper ( alg ) enc_alg_class = select_alg_class ( SymmetricJwk . ENCRYPTION_ALGORITHMS , alg = enc ) cek_headers : Dict [ str , Any ] = {} if isinstance ( key_alg_wrapper , BaseRsaKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key ( cek ) elif isinstance ( key_alg_wrapper , EcdhEs ): epk = epk or Jwk . from_cryptography_key ( key_alg_wrapper . generate_ephemeral_key () ) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( key_alg_wrapper , BaseEcdhEs_AesKw ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key_with_epk ( cek , epk . cryptography_key , alg = key_alg_wrapper . name , ** headers ) else : cek = key_alg_wrapper . sender_key ( epk . cryptography_key , alg = enc_alg_class . name , key_size = enc_alg_class . key_size , ** headers , ) wrapped_cek = BinaPy ( b \"\" ) elif isinstance ( key_alg_wrapper , BaseAesKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key ( cek ) elif isinstance ( key_alg_wrapper , BaseAesGcmKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek iv = key_alg_wrapper . generate_iv () wrapped_cek , tag = key_alg_wrapper . wrap_key ( cek , iv = iv ) cek_headers = { \"iv\" : iv . to ( \"b64u\" ) . ascii (), \"tag\" : tag . to ( \"b64u\" ) . ascii (), } elif isinstance ( key_alg_wrapper , DirectKeyUse ): cek = key_alg_wrapper . direct_key ( enc_alg_class ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { key_alg_wrapper } \" ) # pragma: no cover return SymmetricJwk . from_bytes ( cek ), wrapped_cek , cek_headers def recipient_key ( self , wrapped_cek : Union [ bytes , SupportsBytes ], enc : str , * , alg : Optional [ str ] = None , ** headers : Any , ) -> Jwk : \"\"\"Used by token recipients to obtain the CEK, which then allows decryption of the payload. Args: wrapped_cek: the wrapped CEK enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to unwrap the CEK **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk if not self . is_symmetric and not self . is_private : warnings . warn ( \"You are using a public key for recipient key unwrapping. Key wrapping should always be done using the recipient private key.\" ) key_alg_wrapper = self . key_management_wrapper ( alg ) enc_alg_class = select_alg_class ( SymmetricJwk . ENCRYPTION_ALGORITHMS , alg = enc ) if isinstance ( key_alg_wrapper , BaseRsaKeyWrap ): cek = key_alg_wrapper . unwrap_key ( wrapped_cek ) elif isinstance ( key_alg_wrapper , EcdhEs ): epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . cryptography_key if isinstance ( key_alg_wrapper , BaseEcdhEs_AesKw ): cek = key_alg_wrapper . unwrap_key_with_epk ( wrapped_cek , epk , alg = key_alg_wrapper . name ) else : cek = key_alg_wrapper . recipient_key ( epk , alg = enc_alg_class . name , key_size = enc_alg_class . key_size , ** headers , ) elif isinstance ( key_alg_wrapper , BaseAesKeyWrap ): cek = key_alg_wrapper . unwrap_key ( wrapped_cek ) elif isinstance ( key_alg_wrapper , BaseAesGcmKeyWrap ): iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = key_alg_wrapper . unwrap_key ( wrapped_cek , tag = tag , iv = iv ) elif isinstance ( key_alg_wrapper , DirectKeyUse ): cek = key_alg_wrapper . direct_key ( enc_alg_class ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { key_alg_wrapper } \" ) # pragma: no cover return SymmetricJwk . from_bytes ( cek ) @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key , ** kwargs ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" ) def _to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError @classmethod def from_pem_key ( cls , data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any , ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8. **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: a Jwk instance from the loaded key \"\"\" data = data . encode () if isinstance ( data , str ) else data password = password . encode ( \"UTF-8\" ) if isinstance ( password , str ) else password try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception as private_exc : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) from private_exc return cls . from_cryptography_key ( cryptography_key , ** kwargs ) def to_pem ( self , password : Union [ bytes , str , None ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. This password should be bytes. A `str` is also accepted, and will be encoded to `bytes` using UTF-8 before it is used as encryption key. Args: password: password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded with UTF-8. Returns: the PEM serialized key \"\"\" password = ( str ( password ) . encode ( \"UTF-8\" ) if isinstance ( password , str ) else password ) if self . is_private : encryption : serialization . KeySerializationEncryption if password : encryption = serialization . BestAvailableEncryption ( password ) else : encryption = serialization . NoEncryption () return self . cryptography_key . private_bytes ( # type: ignore[no-any-return] serialization . Encoding . PEM , serialization . PrivateFormat . PKCS8 , encryption , ) else : if password : raise ValueError ( \"Public keys cannot be encrypted when serialized in PEM format.\" ) return self . cryptography_key . public_bytes ( # type: ignore[no-any-return] serialization . Encoding . PEM , serialization . PublicFormat . SubjectPublicKeyInfo , ) @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generate a Private Key and return it as a `Jwk` instance. This method is implemented by subclasses for specific Key Types and returns an instance of that subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs ) @classmethod def generate_for_alg ( cls , alg : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key for usage with a specific alg and return the resulting Jwk. Args: alg: a signature or key management alg **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk \"\"\" for kty , jwk_class in cls . subclasses . items (): alg_class : Optional [ Type [ BaseAlg ]] try : alg_class = jwk_class . _get_alg_class ( alg ) if issubclass ( jwk_class , BaseAESEncryptionAlg ): kwargs . setdefault ( \"key_size\" , alg_class . key_size ) return jwk_class . generate ( alg = alg , ** kwargs ) except UnsupportedAlg : continue raise UnsupportedAlg ( alg ) def copy ( self ) -> Jwk : \"\"\"Creates a copy of this key. Returns: a copy of this key, with the same value \"\"\" return Jwk ( super () . copy ()) def with_kid_thumbprint ( self , force : bool = False ) -> Jwk : \"\"\"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if `force` is `True`, this erases the previous \"kid\". - if `force` is `False` (default), do nothing. Args: force: whether to overwrite a previously existing kid Returns: a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`). \"\"\" if self . get ( \"kid\" ) is not None and not force : return self jwk = self . copy () jwk [ \"kid\" ] = self . thumbprint () return jwk def with_usage_parameters ( self , alg : Optional [ str ] = None , with_alg : bool = True , with_use : bool = True , with_key_ops : bool = True , ) -> Jwk : \"\"\"Copy this Jwk and add the `use` and `key_ops` parameters. The returned jwk `alg` parameter will be the one passed as parameter to this method, or as dfault the one declared as `alg` parameter in this Jwk. The `use` (Public Key Use) param is deduced based on this `alg` value. The `key_ops` (Key Operations) param is deduced based on the key `use` and if the key is public, private, or symmetric. Args: alg: the alg to use, if not present in this Jwk with_alg: whether to include an `alg` parameter with_use: whether to include a `use` parameter with_key_ops: whether to include a `key_ops` parameter Returns: a Jwk with the same key, with `alg`, `use` and `key_ops` parameters. \"\"\" alg = alg or self . alg if not alg : raise ExpectedAlgRequired ( \"An algorithm is required to set the usage parameters\" ) self . _get_alg_class ( alg ) # raises an exception if alg is not supported jwk = self . copy () if with_alg : jwk [ \"alg\" ] = alg if with_use : jwk [ \"use\" ] = jwk . use if with_key_ops : jwk [ \"key_ops\" ] = jwk . key_ops return jwk def minimize ( self ) -> Jwk : \"\"\"Strips out any optional or non-standard parameter from that key. This will remove `alg`, `use`, `key_ops`, optional parameters from RSA keys, and other unknown parameters. \"\"\" jwk = self . copy () for key in self . keys (): if key == \"kty\" or key in self . PARAMS and self . PARAMS [ key ] . is_required : continue del jwk [ key ] return jwk def check ( self , * , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None , kty : Optional [ str ] = None , ) -> Jwk : \"\"\"Check this key for type, privateness and/or symmetricness. Raise a ValueError if it not as expected. Args: is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing kty: the expected key type, if any Returns: this key, if all checks passed Raises: ValueError: if any check fails \"\"\" if is_private is not None : if is_private is True and self . is_private is False : raise ValueError ( \"This key is public while a private key is expected.\" ) elif is_private is False and self . is_private is True : raise ValueError ( \"This key is private while a public key is expected.\" ) if is_symmetric is not None : if is_symmetric is True and self . is_symmetric is False : raise ValueError ( \"This key is asymmetric while a symmetric key is expected.\" ) if is_symmetric is False and self . is_symmetric is True : raise ValueError ( \"This key is symmetric while an asymmetric key is expected.\" ) if kty is not None : if self . kty != kty : raise ValueError ( f \"This key has kty= { self . kty } while a kty= { kty } is expected.\" ) return self","title":"Jwk"},{"location":"api/#jwskate.jwk.base.Jwk.subclasses","text":"1 subclasses : Dict [ str , Type [ Jwk ]] = {} A dict of 'kty' values to subclasses implementing each specific Key Type","title":"subclasses"},{"location":"api/#jwskate.jwk.base.Jwk.cryptography_key_types","text":"1 cryptography_key_types : Dict [ Any , Type [ Jwk ]] = {} A dict of cryptography key classes to its specific 'kty' value","title":"cryptography_key_types"},{"location":"api/#jwskate.jwk.base.Jwk.PARAMS","text":"1 PARAMS : Mapping [ str , JwkParameter ] A dict of parameters. Key is parameter name, value is a tuple (description, is_private, is_required, kind)","title":"PARAMS"},{"location":"api/#jwskate.jwk.base.Jwk.KTY","text":"1 KTY : ClassVar [ str ] The Key Type associated with this JWK.","title":"KTY"},{"location":"api/#jwskate.jwk.base.Jwk.__init_subclass__","text":"1 __init_subclass__ () -> None Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk. Source code in jwskate/jwk/base.py 111 112 113 114 115 116 117 118 119 120 def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows `__new__` to pick the appropriate subclass when creating a Jwk. \"\"\" Jwk . subclasses [ cls . KTY ] = cls for klass in cls . CRYPTOGRAPHY_PRIVATE_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls for klass in cls . CRYPTOGRAPHY_PUBLIC_KEY_CLASSES : Jwk . cryptography_key_types [ klass ] = cls","title":"__init_subclass__()"},{"location":"api/#jwskate.jwk.base.Jwk.__new__","text":"1 2 3 __new__ ( key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ) Overridden __new__ to make the Jwk constructor smarter. The Jwk constructor will accept a dict with the parsed Jwk content another Jwk, which will be used as-is instead of creating a copy an instance from a cryptography public or private key class Parameters: Name Type Description Default key Union [ Jwk , Dict [ str , Any ], Any ] a dict containing JWK parameters, or another Jwk instance, or a cryptography key required **kwargs Any additional members to include in the Jwk {} Source code in jwskate/jwk/base.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def __new__ ( cls , key : Union [ Jwk , Dict [ str , Any ], Any ], ** kwargs : Any ): # type: ignore \"\"\"Overridden `__new__` to make the Jwk constructor smarter. The Jwk constructor will accept: - a `dict` with the parsed Jwk content - another Jwk, which will be used as-is instead of creating a copy - an instance from a `cryptography` public or private key class Args: key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key **kwargs: additional members to include in the Jwk \"\"\" if cls == Jwk : if isinstance ( key , Jwk ): return cls . from_cryptography_key ( key . cryptography_key , ** kwargs ) if isinstance ( key , dict ): kty : Optional [ str ] = key . get ( \"kty\" ) if kty is None : raise InvalidJwk ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise InvalidJwk ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) elif isinstance ( key , str ): return cls . from_json ( key ) else : return cls . from_cryptography_key ( key , ** kwargs ) return super () . __new__ ( cls , key , ** kwargs )","title":"__new__()"},{"location":"api/#jwskate.jwk.base.Jwk._get_alg_class","text":"1 _get_alg_class ( alg : str ) -> Type [ BaseAlg ] Given an alg identifier, return the matching JWA wrapper. Parameters: Name Type Description Default alg str an alg identifier required Returns: Type Description Type [ BaseAlg ] the matching JWA wrapper Source code in jwskate/jwk/base.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @classmethod def _get_alg_class ( cls , alg : str ) -> Type [ BaseAlg ]: \"\"\"Given an alg identifier, return the matching JWA wrapper. Args: alg: an alg identifier Returns: the matching JWA wrapper \"\"\" alg_class : Optional [ Type [ BaseAlg ]] alg_class = cls . SIGNATURE_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class alg_class = cls . KEY_MANAGEMENT_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class alg_class = cls . ENCRYPTION_ALGORITHMS . get ( alg ) if alg_class is not None : return alg_class raise UnsupportedAlg ( alg )","title":"_get_alg_class()"},{"location":"api/#jwskate.jwk.base.Jwk.is_private","text":"1 is_private () -> bool Return True if the key is private, False otherwise. Returns: Type Description bool True if the key is private, False otherwise Source code in jwskate/jwk/base.py 197 198 199 200 201 202 203 204 @property def is_private ( self ) -> bool : \"\"\"Return `True` if the key is private, `False` otherwise. Returns: `True` if the key is private, `False` otherwise \"\"\" return True","title":"is_private()"},{"location":"api/#jwskate.jwk.base.Jwk.is_symmetric","text":"1 is_symmetric () -> bool Return True if the key is symmetric, False otherwise. Source code in jwskate/jwk/base.py 206 207 208 209 @property def is_symmetric ( self ) -> bool : \"\"\"Return `True` if the key is symmetric, `False` otherwise.\"\"\" return False","title":"is_symmetric()"},{"location":"api/#jwskate.jwk.base.Jwk.__getattr__","text":"1 __getattr__ ( param : str ) -> Any Allow access to key parameters as attributes. This is a convenience to allow jwk.param instead of jwk['param'] . Parameters: Name Type Description Default param str the parameter name to access required Return the param value Raises: Type Description AttributeError if the param is not found Source code in jwskate/jwk/base.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def __getattr__ ( self , param : str ) -> Any : \"\"\"Allow access to key parameters as attributes. This is a convenience to allow `jwk.param` instead of `jwk['param']`. Args: param: the parameter name to access Return: the param value Raises: AttributeError: if the param is not found \"\"\" value = self . get ( param ) if value is None : raise AttributeError ( param ) return value","title":"__getattr__()"},{"location":"api/#jwskate.jwk.base.Jwk.__setitem__","text":"1 __setitem__ ( key : str , value : Any ) -> None Override base method to avoid modifying cryptographic key attributes. Parameters: Name Type Description Default key str name of the attribute to set required value Any value to set required Raises: Type Description RuntimeError when trying to modify cryptographic attributes Source code in jwskate/jwk/base.py 230 231 232 233 234 235 236 237 238 239 240 241 242 def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Override base method to avoid modifying cryptographic key attributes. Args: key: name of the attribute to set value: value to set Raises: RuntimeError: when trying to modify cryptographic attributes \"\"\" if key in self . PARAMS : raise RuntimeError ( \"JWK key attributes cannot be modified.\" ) super () . __setitem__ ( key , value )","title":"__setitem__()"},{"location":"api/#jwskate.jwk.base.Jwk.thumbprint","text":"1 thumbprint ( hashalg : str = 'sha-256' ) -> str Return the key thumbprint as specified by RFC 7638. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'sha-256' Returns: Type Description str the calculated thumbprint Source code in jwskate/jwk/base.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def thumbprint ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Return the key thumbprint as specified by RFC 7638. Args: hashalg: A hash function (defaults to SHA256) Returns: the calculated thumbprint \"\"\" alg = self . IANA_HASH_FUNCTION_NAMES . get ( hashalg ) if not alg : raise ValueError ( f \"Unsupported hash alg { hashalg } \" ) t = { \"kty\" : self . get ( \"kty\" )} for name , param in self . PARAMS . items (): if param . is_required and not param . is_private : t [ name ] = self . get ( name ) return ( BinaPy . serialize_to ( \"json\" , t , separators = ( \",\" , \":\" ), sort_keys = True ) . to ( alg ) . to ( \"b64u\" ) . ascii () )","title":"thumbprint()"},{"location":"api/#jwskate.jwk.base.Jwk.thumbprint_uri","text":"1 thumbprint_uri ( hashalg : str = 'sha-256' ) -> str Returns the JWK thumbprint URI for this key. Parameters: Name Type Description Default hashalg str the IANA registered name for the hash alg to use 'sha-256' Returns: Type Description str the JWK thumbprint uri for this Jwk Source code in jwskate/jwk/base.py 269 270 271 272 273 274 275 276 277 278 279 280 def thumbprint_uri ( self , hashalg : str = \"sha-256\" ) -> str : \"\"\"Returns the JWK thumbprint URI for this key. Args: hashalg: the IANA registered name for the hash alg to use Returns: the JWK thumbprint uri for this Jwk \"\"\" return ( f \"urn:ietf:params:oauth:jwk-thumbprint: { hashalg } : { self . thumbprint ( hashalg ) } \" )","title":"thumbprint_uri()"},{"location":"api/#jwskate.jwk.base.Jwk.kty","text":"1 kty () -> str Return the Key Type. Returns: Type Description str the key type Source code in jwskate/jwk/base.py 282 283 284 285 286 287 288 289 @property def kty ( self ) -> str : \"\"\"Return the Key Type. Returns: the key type \"\"\" return self . KTY","title":"kty()"},{"location":"api/#jwskate.jwk.base.Jwk.alg","text":"1 alg () -> Optional [ str ] Return the configured key alg, if any. Returns: Type Description Optional [ str ] the key alg Source code in jwskate/jwk/base.py 291 292 293 294 295 296 297 298 299 300 301 @property def alg ( self ) -> Optional [ str ]: \"\"\"Return the configured key alg, if any. Returns: the key alg \"\"\" alg = self . get ( \"alg\" ) if alg is not None and not isinstance ( alg , str ): # pragma: no branch raise TypeError ( f \"Invalid alg type { type ( alg ) } \" , alg ) return alg","title":"alg()"},{"location":"api/#jwskate.jwk.base.Jwk.signature_class","text":"1 2 3 signature_class ( alg : Optional [ str ] = None , ) -> Type [ BaseSignatureAlg ] Return the appropriate signature algorithm class (a BaseSignatureAlg subclass) to use with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description Type [ BaseSignatureAlg ] the appropriate BaseSignatureAlg subclass Source code in jwskate/jwk/base.py 303 304 305 306 307 308 309 310 311 312 313 314 def signature_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseSignatureAlg ]: \"\"\"Return the appropriate signature algorithm class (a `BaseSignatureAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseSignatureAlg` subclass \"\"\" return select_alg_class ( self . SIGNATURE_ALGORITHMS , jwk_alg = self . alg , alg = alg )","title":"signature_class()"},{"location":"api/#jwskate.jwk.base.Jwk.encryption_class","text":"1 2 3 encryption_class ( alg : Optional [ str ] = None , ) -> Type [ BaseAESEncryptionAlg ] Return the appropriate encryption algorithm class (a BaseAESEncryptionAlg subclass) to use with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description Type [ BaseAESEncryptionAlg ] the appropriate BaseAESEncryptionAlg subclass Source code in jwskate/jwk/base.py 316 317 318 319 320 321 322 323 324 325 326 327 def encryption_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseAESEncryptionAlg ]: \"\"\"Return the appropriate encryption algorithm class (a `BaseAESEncryptionAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseAESEncryptionAlg` subclass \"\"\" return select_alg_class ( self . ENCRYPTION_ALGORITHMS , jwk_alg = self . alg , alg = alg )","title":"encryption_class()"},{"location":"api/#jwskate.jwk.base.Jwk.key_management_class","text":"1 2 3 key_management_class ( alg : Optional [ str ] = None , ) -> Type [ BaseKeyManagementAlg ] Return the appropriate key management algorithm class (a BaseKeyManagementAlg subclass) to use with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description Type [ BaseKeyManagementAlg ] the appropriate BaseKeyManagementAlg subclass Source code in jwskate/jwk/base.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 def key_management_class ( self , alg : Optional [ str ] = None ) -> Type [ BaseKeyManagementAlg ]: \"\"\"Return the appropriate key management algorithm class (a `BaseKeyManagementAlg` subclass) to use with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: the appropriate `BaseKeyManagementAlg` subclass \"\"\" return select_alg_class ( self . KEY_MANAGEMENT_ALGORITHMS , jwk_alg = self . alg , alg = alg )","title":"key_management_class()"},{"location":"api/#jwskate.jwk.base.Jwk.signature_wrapper","text":"1 2 3 signature_wrapper ( alg : Optional [ str ] = None , ) -> BaseSignatureAlg Initialize a key management wrapper (an instance of a BaseKeyManagementAlg subclass) with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description BaseSignatureAlg a BaseKeyManagementAlg instance initialized with the current key Source code in jwskate/jwk/base.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def signature_wrapper ( self , alg : Optional [ str ] = None ) -> BaseSignatureAlg : \"\"\"Initialize a key management wrapper (an instance of a `BaseKeyManagementAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseKeyManagementAlg` instance initialized with the current key \"\"\" alg_class = self . signature_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): return alg_class ( self . cryptography_key ) raise UnsupportedAlg ( alg ) # pragma: no cover","title":"signature_wrapper()"},{"location":"api/#jwskate.jwk.base.Jwk.encryption_wrapper","text":"1 2 3 encryption_wrapper ( alg : Optional [ str ] = None , ) -> BaseAESEncryptionAlg Initialize an encryption wrapper (an instance of a BaseAESEncryptionAlg subclass) with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description BaseAESEncryptionAlg a BaseAESEncryptionAlg instance initialized with the current key Source code in jwskate/jwk/base.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def encryption_wrapper ( self , alg : Optional [ str ] = None ) -> BaseAESEncryptionAlg : \"\"\"Initialize an encryption wrapper (an instance of a `BaseAESEncryptionAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseAESEncryptionAlg` instance initialized with the current key \"\"\" alg_class = self . encryption_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): # pragma: no cover return alg_class ( self . cryptography_key ) # pragma: no cover raise UnsupportedAlg ( alg ) # pragma: no cover","title":"encryption_wrapper()"},{"location":"api/#jwskate.jwk.base.Jwk.key_management_wrapper","text":"1 2 3 key_management_wrapper ( alg : Optional [ str ] = None , ) -> BaseKeyManagementAlg Initialize a key management wrapper (an instance of a BaseKeyManagementAlg subclass) with this key. If this key doesn't have an alg parameter, you must supply one as parameter to this method. Parameters: Name Type Description Default alg Optional [ str ] the algorithm identifier, if not already present in this Jwk None Returns: Type Description BaseKeyManagementAlg a BaseKeyManagementAlg instance initialized with the current key Source code in jwskate/jwk/base.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def key_management_wrapper ( self , alg : Optional [ str ] = None ) -> BaseKeyManagementAlg : \"\"\"Initialize a key management wrapper (an instance of a `BaseKeyManagementAlg` subclass) with this key. If this key doesn't have an `alg` parameter, you must supply one as parameter to this method. Args: alg: the algorithm identifier, if not already present in this Jwk Returns: a `BaseKeyManagementAlg` instance initialized with the current key \"\"\" alg_class = self . key_management_class ( alg ) if issubclass ( alg_class , BaseSymmetricAlg ): return alg_class ( self . key ) elif issubclass ( alg_class , BaseAsymmetricAlg ): return alg_class ( self . cryptography_key ) raise UnsupportedAlg ( alg ) # pragma: no cover","title":"key_management_wrapper()"},{"location":"api/#jwskate.jwk.base.Jwk.kid","text":"1 kid () -> Optional [ str ] Return the JWK key ID (kid), if present. Source code in jwskate/jwk/base.py 400 401 402 403 404 405 406 @property def kid ( self ) -> Optional [ str ]: \"\"\"Return the JWK key ID (kid), if present.\"\"\" kid = self . get ( \"kid\" ) if kid is not None and not isinstance ( kid , str ): # pragma: no branch raise TypeError ( f \"invalid kid type { type ( kid ) } \" , kid ) return kid","title":"kid()"},{"location":"api/#jwskate.jwk.base.Jwk.use","text":"1 use () -> Optional [ str ] Return the key use. If no alg parameter is present, this returns the use parameter from this JWK. If an alg parameter is present, the use is deduced from this alg. To check for the presence of the use parameter, use jwk.get('use') . Source code in jwskate/jwk/base.py 408 409 410 411 412 413 414 415 416 417 418 419 @cached_property def use ( self ) -> Optional [ str ]: \"\"\"Return the key use. If no `alg` parameter is present, this returns the `use` parameter from this JWK. If an `alg` parameter is present, the use is deduced from this alg. To check for the presence of the `use` parameter, use `jwk.get('use')`. \"\"\" if self . alg : return self . _get_alg_class ( self . alg ) . use else : return self . get ( \"use\" )","title":"use()"},{"location":"api/#jwskate.jwk.base.Jwk.key_ops","text":"1 key_ops () -> Tuple [ str , ... ] Return the key operations. If no alg parameter is present, this returns the key_ops parameter from this JWK. If an alg parameter is present, the key operations are deduced from this alg. To check for the presence of the key_ops parameter, use jwk.get('key_ops') . Source code in jwskate/jwk/base.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 @cached_property def key_ops ( self ) -> Tuple [ str , ... ]: \"\"\"Return the key operations. If no `alg` parameter is present, this returns the `key_ops` parameter from this JWK. If an `alg` parameter is present, the key operations are deduced from this alg. To check for the presence of the `key_ops` parameter, use `jwk.get('key_ops')`. \"\"\" key_ops : Tuple [ str , ... ] if self . use == \"sig\" : if self . is_symmetric : key_ops = ( \"sign\" , \"verify\" ) elif self . is_private : key_ops = ( \"sign\" ,) else : key_ops = ( \"verify\" ,) elif self . use == \"enc\" : if self . is_symmetric : if self . alg : alg_class = self . _get_alg_class ( self . alg ) if issubclass ( alg_class , BaseKeyManagementAlg ): key_ops = ( \"wrapKey\" , \"unwrapKey\" ) elif issubclass ( alg_class , BaseAESEncryptionAlg ): key_ops = ( \"encrypt\" , \"decrypt\" ) else : key_ops = ( \"wrapKey\" , \"unwrapKey\" , \"encrypt\" , \"decrypt\" ) elif self . is_private : key_ops = ( \"unwrapKey\" ,) else : key_ops = ( \"wrapKey\" ,) else : key_ops = self . get ( \"key_ops\" , ()) return tuple ( key_ops )","title":"key_ops()"},{"location":"api/#jwskate.jwk.base.Jwk._validate","text":"1 _validate () -> None Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the is_private flag to True . Raises: Type Description TypeError if the key type doesn't match the subclass InvalidJwk if the JWK misses required members or has invalid members Source code in jwskate/jwk/base.py 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def _validate ( self ) -> None : \"\"\"Internal method used to validate a Jwk. It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`. Raises: TypeError: if the key type doesn't match the subclass InvalidJwk: if the JWK misses required members or has invalid members \"\"\" if self . get ( \"kty\" ) != self . KTY : raise TypeError ( f \"This key 'kty' { self . get ( 'kty' ) } doesn't match this Jwk subclass intended 'kty' { self . KTY } !\" ) jwk_is_private = False for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and value is not None : jwk_is_private = True if not param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required public param { param . description } ( { name } )\" ) if value is None : pass elif param . kind == \"b64u\" : if not isinstance ( value , str ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a string with a Base64URL-encoded value\" ) if not BinaPy ( value ) . check ( \"b64u\" ): raise InvalidJwk ( f \"Parameter { param . description } ( { name } ) must be a Base64URL-encoded value\" ) elif param . kind == \"unsupported\" : if value is not None : # pragma: no cover raise InvalidJwk ( f \"Unsupported JWK param ' { name } '\" ) elif param . kind == \"name\" : pass else : assert ( False ), f \"Unsupported param ' { name } ' type ' { param . kind } '\" # pragma: no cover # if at least one of the supplied parameter was private, then all required private parameters must be provided if jwk_is_private : for name , param in self . PARAMS . items (): value = self . get ( name ) if param . is_private and param . is_required and value is None : raise InvalidJwk ( f \"Missing required private param { param . description } ( { name } )\" ) # if key is used for signing, it must be private for op in self . get ( \"key_ops\" , []): if op in ( \"sign\" , \"unwrapKey\" ) and not self . is_private : raise InvalidJwk ( f \"Key Operation is ' { op } ' but the key is public\" )","title":"_validate()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_signing_algorithms","text":"1 supported_signing_algorithms () -> List [ str ] Return the list of Signature algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 518 519 520 521 522 523 524 def supported_signing_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Signature algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . SIGNATURE_ALGORITHMS )","title":"supported_signing_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_key_management_algorithms","text":"1 supported_key_management_algorithms () -> List [ str ] Return the list of Key Management algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 526 527 528 529 530 531 532 def supported_key_management_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Key Management algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . KEY_MANAGEMENT_ALGORITHMS )","title":"supported_key_management_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.supported_encryption_algorithms","text":"1 supported_encryption_algorithms () -> List [ str ] Return the list of Encryption algorithms that can be used with this key. Returns: Type Description List [ str ] a list of supported algs Source code in jwskate/jwk/base.py 534 535 536 537 538 539 540 def supported_encryption_algorithms ( self ) -> List [ str ]: \"\"\"Return the list of Encryption algorithms that can be used with this key. Returns: a list of supported algs \"\"\" return list ( self . ENCRYPTION_ALGORITHMS )","title":"supported_encryption_algorithms()"},{"location":"api/#jwskate.jwk.base.Jwk.public_jwk","text":"1 public_jwk () -> Jwk Return the public Jwk associated with this key. Returns: Type Description Jwk a Jwk with the public key Source code in jwskate/jwk/base.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def public_jwk ( self ) -> Jwk : \"\"\"Return the public Jwk associated with this key. Returns: a Jwk with the public key \"\"\" if not self . is_private : return self params = { name : self . get ( name ) for name , param in self . PARAMS . items () if not param . is_private } if \"key_ops\" in self : key_ops = list ( self . key_ops ) if \"sign\" in key_ops : key_ops . remove ( \"sign\" ) key_ops . append ( \"verify\" ) if \"unwrapKey\" in key_ops : key_ops . remove ( \"unwrapKey\" ) key_ops . append ( \"wrapKey\" ) else : key_ops = None return Jwk ( dict ( kty = self . kty , kid = self . get ( \"kid\" ), alg = self . get ( \"alg\" ), use = self . get ( \"use\" ), key_ops = key_ops , ** params , ) )","title":"public_jwk()"},{"location":"api/#jwskate.jwk.base.Jwk.as_jwks","text":"1 as_jwks () -> JwkSet Return a JwkSet with this key as single element. Returns: Type Description JwkSet a JwsSet with this single key Source code in jwskate/jwk/base.py 579 580 581 582 583 584 585 586 587 def as_jwks ( self ) -> JwkSet : \"\"\"Return a JwkSet with this key as single element. Returns: a JwsSet with this single key \"\"\" from .jwks import JwkSet return JwkSet ( keys = ( self ,))","title":"as_jwks()"},{"location":"api/#jwskate.jwk.base.Jwk.sign","text":"1 2 3 4 sign ( data : Union [ bytes , SupportsBytes ], alg : Optional [ str ] = None , ) -> BinaPy Sign a data using this Jwk, and return the generated signature. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the data to sign required alg Optional [ str ] the alg to use (if this key doesn't have an alg parameter) None Returns: Type Description BinaPy the generated signature Source code in jwskate/jwk/base.py 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def sign ( self , data : Union [ bytes , SupportsBytes ], alg : Optional [ str ] = None ) -> BinaPy : \"\"\"Sign a data using this Jwk, and return the generated signature. Args: data: the data to sign alg: the alg to use (if this key doesn't have an `alg` parameter) Returns: the generated signature \"\"\" wrapper = self . signature_wrapper ( alg ) signature = wrapper . sign ( data ) return BinaPy ( signature )","title":"sign()"},{"location":"api/#jwskate.jwk.base.Jwk.verify","text":"1 2 3 4 5 6 7 verify ( data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> bool Verify a signature using this Jwk, and return True if valid. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the data to verify required signature Union [ bytes , SupportsBytes ] the signature to verify required alg Optional [ str ] the allowed signature alg, if there is only one None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate/jwk/base.py 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify a signature using this Jwk, and return `True` if valid. Args: data: the data to verify signature: the signature to verify alg: the allowed signature alg, if there is only one algs: the allowed signature algs, if there are several Returns: `True` if the signature matches, `False` otherwise \"\"\" if not self . is_symmetric and self . is_private : warnings . warn ( \"You are trying to validate a signature with a private key. \" \"Signature should always be verified with a public key.\" ) public_jwk = self . public_jwk () else : public_jwk = self if algs is None and alg : algs = [ alg ] for alg in algs or ( None ,): wrapper = public_jwk . signature_wrapper ( alg ) if wrapper . verify ( data , signature ): return True return False","title":"verify()"},{"location":"api/#jwskate.jwk.base.Jwk.encrypt","text":"1 2 3 4 5 6 7 encrypt ( plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None ) -> Tuple [ BinaPy , BinaPy , BinaPy ] Encrypt a plaintext with Authenticated Encryption using this key. Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data ( aad ). This returns a tuple with 3 raw data, in order: - the encrypted Data - the Initialization Vector that was used to encrypt data - the generated Authentication Tag Parameters: Name Type Description Default plaintext Union [ bytes , SupportsBytes ] the data to encrypt. required aad Optional [ bytes ] the Additional Authenticated Data (AAD) to include in the authentication tag None alg Optional [ str ] the alg to use to encrypt the data None iv Optional [ bytes ] the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same. None Returns: Type Description Tuple [ BinaPy , BinaPy , BinaPy ] a tuple (ciphertext, iv, authentication_tag), as raw data Source code in jwskate/jwk/base.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , aad : Optional [ bytes ] = None , alg : Optional [ str ] = None , iv : Optional [ bytes ] = None , ) -> Tuple [ BinaPy , BinaPy , BinaPy ]: \"\"\"Encrypt a plaintext with Authenticated Encryption using this key. Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data (`aad`). This returns a tuple with 3 raw data, in order: - the encrypted Data - the Initialization Vector that was used to encrypt data - the generated Authentication Tag Args: plaintext: the data to encrypt. aad: the Additional Authenticated Data (AAD) to include in the authentication tag alg: the alg to use to encrypt the data iv: the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same. Returns: a tuple (ciphertext, iv, authentication_tag), as raw data \"\"\" raise NotImplementedError # pragma: no cover","title":"encrypt()"},{"location":"api/#jwskate.jwk.base.Jwk.decrypt","text":"1 2 3 4 5 6 7 8 decrypt ( ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None ) -> BinaPy Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Parameters: Name Type Description Default ciphertext Union [ bytes , SupportsBytes ] the data to decrypt required iv Union [ bytes , SupportsBytes ] the Initialization Vector (IV) that was used for encryption required tag Union [ bytes , SupportsBytes ] the Authentication Tag that will be verified while decrypting data required aad Union [ bytes , SupportsBytes , None] the Additional Authentication Data (AAD) to verify the Tag against None alg Optional [ str ] the alg to use for decryption None Returns: Type Description BinaPy the clear-text data Source code in jwskate/jwk/base.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , alg : Optional [ str ] = None , ) -> BinaPy : \"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result. This is implemented by subclasses. Args: ciphertext: the data to decrypt iv: the Initialization Vector (IV) that was used for encryption tag: the Authentication Tag that will be verified while decrypting data aad: the Additional Authentication Data (AAD) to verify the Tag against alg: the alg to use for decryption Returns: the clear-text data \"\"\" raise NotImplementedError # pragma: no cover","title":"decrypt()"},{"location":"api/#jwskate.jwk.base.Jwk.sender_key","text":"1 2 3 4 5 6 7 8 sender_key ( enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]] Used by encrypted token senders to produce a Content Encryption Key. Returns a tuple with 3 items: the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone! the encrypted CEK, as bytes. You must send this to your recipient. This may be None for Key Management algs which derive a CEK instead of generating one. extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well. For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead of letting jwskate generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting jwskate generate an appropriate value for you. Only do this if you know what you are doing! Parameters: Name Type Description Default enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to produce the CEK None cek Optional [ bytes ] CEK to use (leave None to have an adequate random value generated automatically) None epk Optional [ Jwk ] EPK to use (leave None to have an adequate ephemeral key generated automatically) None **headers Any additional headers to include for the CEK derivation {} Returns: Type Description Tuple [ Jwk , BinaPy , Mapping [ str , Any ]] a tuple (cek, wrapped_cek, additional_headers_map) Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate/jwk/base.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 def sender_key ( self , enc : str , * , alg : Optional [ str ] = None , cek : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ** headers : Any , ) -> Tuple [ Jwk , BinaPy , Mapping [ str , Any ]]: \"\"\"Used by encrypted token senders to produce a Content Encryption Key. Returns a tuple with 3 items: - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone! - the encrypted CEK, as bytes. You must send this to your recipient. This may be `None` for Key Management algs which derive a CEK instead of generating one. - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well. For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead of letting `jwskate` generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting `jwskate` generate an appropriate value for you. Only do this if you know what you are doing! Args: enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to produce the CEK cek: CEK to use (leave `None` to have an adequate random value generated automatically) epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically) **headers: additional headers to include for the CEK derivation Returns: a tuple (cek, wrapped_cek, additional_headers_map) Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk if not self . is_symmetric and self . is_private : warnings . warn ( \"You are using a private key for sender key wrapping. Key wrapping should always be done using the recipient public key.\" ) key_alg_wrapper = self . public_jwk () . key_management_wrapper ( alg ) else : key_alg_wrapper = self . key_management_wrapper ( alg ) enc_alg_class = select_alg_class ( SymmetricJwk . ENCRYPTION_ALGORITHMS , alg = enc ) cek_headers : Dict [ str , Any ] = {} if isinstance ( key_alg_wrapper , BaseRsaKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key ( cek ) elif isinstance ( key_alg_wrapper , EcdhEs ): epk = epk or Jwk . from_cryptography_key ( key_alg_wrapper . generate_ephemeral_key () ) cek_headers = { \"epk\" : epk . public_jwk ()} if isinstance ( key_alg_wrapper , BaseEcdhEs_AesKw ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key_with_epk ( cek , epk . cryptography_key , alg = key_alg_wrapper . name , ** headers ) else : cek = key_alg_wrapper . sender_key ( epk . cryptography_key , alg = enc_alg_class . name , key_size = enc_alg_class . key_size , ** headers , ) wrapped_cek = BinaPy ( b \"\" ) elif isinstance ( key_alg_wrapper , BaseAesKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek wrapped_cek = key_alg_wrapper . wrap_key ( cek ) elif isinstance ( key_alg_wrapper , BaseAesGcmKeyWrap ): if cek : enc_alg_class . check_key ( cek ) else : cek = enc_alg_class . generate_key () assert cek iv = key_alg_wrapper . generate_iv () wrapped_cek , tag = key_alg_wrapper . wrap_key ( cek , iv = iv ) cek_headers = { \"iv\" : iv . to ( \"b64u\" ) . ascii (), \"tag\" : tag . to ( \"b64u\" ) . ascii (), } elif isinstance ( key_alg_wrapper , DirectKeyUse ): cek = key_alg_wrapper . direct_key ( enc_alg_class ) wrapped_cek = BinaPy ( b \"\" ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { key_alg_wrapper } \" ) # pragma: no cover return SymmetricJwk . from_bytes ( cek ), wrapped_cek , cek_headers","title":"sender_key()"},{"location":"api/#jwskate.jwk.base.Jwk.recipient_key","text":"1 2 3 4 5 6 7 recipient_key ( wrapped_cek : Union [ bytes , SupportsBytes ], enc : str , * , alg : Optional [ str ] = None , ** headers : Any ) -> Jwk Used by token recipients to obtain the CEK, which then allows decryption of the payload. Parameters: Name Type Description Default wrapped_cek Union [ bytes , SupportsBytes ] the wrapped CEK required enc str the encryption algorithm to use with the CEK required alg Optional [ str ] the Key Management algorithm to use to unwrap the CEK None **headers Any additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) {} Returns: Type Description Jwk the clear-text CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the requested alg identifier is not supported Source code in jwskate/jwk/base.py 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 def recipient_key ( self , wrapped_cek : Union [ bytes , SupportsBytes ], enc : str , * , alg : Optional [ str ] = None , ** headers : Any , ) -> Jwk : \"\"\"Used by token recipients to obtain the CEK, which then allows decryption of the payload. Args: wrapped_cek: the wrapped CEK enc: the encryption algorithm to use with the CEK alg: the Key Management algorithm to use to unwrap the CEK **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs) Returns: the clear-text CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the requested alg identifier is not supported \"\"\" from jwskate import SymmetricJwk if not self . is_symmetric and not self . is_private : warnings . warn ( \"You are using a public key for recipient key unwrapping. Key wrapping should always be done using the recipient private key.\" ) key_alg_wrapper = self . key_management_wrapper ( alg ) enc_alg_class = select_alg_class ( SymmetricJwk . ENCRYPTION_ALGORITHMS , alg = enc ) if isinstance ( key_alg_wrapper , BaseRsaKeyWrap ): cek = key_alg_wrapper . unwrap_key ( wrapped_cek ) elif isinstance ( key_alg_wrapper , EcdhEs ): epk = headers . get ( \"epk\" ) if epk is None : raise ValueError ( \"No EPK in the headers!\" ) epk_jwk = Jwk ( epk ) if epk_jwk . is_private : raise ValueError ( \"The EPK present in the header is private.\" ) epk = epk_jwk . cryptography_key if isinstance ( key_alg_wrapper , BaseEcdhEs_AesKw ): cek = key_alg_wrapper . unwrap_key_with_epk ( wrapped_cek , epk , alg = key_alg_wrapper . name ) else : cek = key_alg_wrapper . recipient_key ( epk , alg = enc_alg_class . name , key_size = enc_alg_class . key_size , ** headers , ) elif isinstance ( key_alg_wrapper , BaseAesKeyWrap ): cek = key_alg_wrapper . unwrap_key ( wrapped_cek ) elif isinstance ( key_alg_wrapper , BaseAesGcmKeyWrap ): iv = headers . get ( \"iv\" ) if iv is None : raise ValueError ( \"No 'iv' in headers!\" ) iv = BinaPy ( iv ) . decode_from ( \"b64u\" ) tag = headers . get ( \"tag\" ) if tag is None : raise ValueError ( \"No 'tag' in headers!\" ) tag = BinaPy ( tag ) . decode_from ( \"b64u\" ) cek = key_alg_wrapper . unwrap_key ( wrapped_cek , tag = tag , iv = iv ) elif isinstance ( key_alg_wrapper , DirectKeyUse ): cek = key_alg_wrapper . direct_key ( enc_alg_class ) else : raise UnsupportedAlg ( f \"Unsupported Key Management Alg { key_alg_wrapper } \" ) # pragma: no cover return SymmetricJwk . from_bytes ( cek )","title":"recipient_key()"},{"location":"api/#jwskate.jwk.base.Jwk.from_cryptography_key","text":"1 2 3 from_cryptography_key ( cryptography_key : Any , ** kwargs : Any ) -> Jwk Initialize a Jwk from a key from the cryptography library. The input key can be any private or public key supported by cryptography. Parameters: Name Type Description Default cryptography_key Any a cryptography key instance required **kwargs Any additional members to include in the Jwk (e.g. kid, use) {} Returns: Type Description Jwk the matching Jwk instance Raises: Type Description TypeError if the key type is not supported Source code in jwskate/jwk/base.py 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 @classmethod def from_cryptography_key ( cls , cryptography_key : Any , ** kwargs : Any ) -> Jwk : \"\"\"Initialize a Jwk from a key from the `cryptography` library. The input key can be any private or public key supported by cryptography. Args: cryptography_key: a `cryptography` key instance **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: the matching `Jwk` instance Raises: TypeError: if the key type is not supported \"\"\" for klass in cryptography_key . __class__ . mro (): jwk_class = cls . cryptography_key_types . get ( klass ) if jwk_class : return jwk_class . from_cryptography_key ( cryptography_key , ** kwargs ) raise TypeError ( f \"Unsupported Jwk class for this Key Type: { cryptography_key } \" )","title":"from_cryptography_key()"},{"location":"api/#jwskate.jwk.base.Jwk._to_cryptography_key","text":"1 _to_cryptography_key () -> Any Return a key from the cryptography library that matches this Jwk. This is implemented by subclasses. Returns: Type Description Any a cryptography key instance initialized from the current key Source code in jwskate/jwk/base.py 907 908 909 910 911 912 913 914 915 def _to_cryptography_key ( self ) -> Any : \"\"\"Return a key from the `cryptography` library that matches this Jwk. This is implemented by subclasses. Returns: a `cryptography`key instance initialized from the current key \"\"\" raise NotImplementedError","title":"_to_cryptography_key()"},{"location":"api/#jwskate.jwk.base.Jwk.from_pem_key","text":"1 2 3 4 5 from_pem_key ( data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any ) -> Jwk Load a Jwk from a PEM encoded private or public key. Parameters: Name Type Description Default data Union [ bytes , str ] the PEM encoded data to load required password Union [ bytes , str , None] the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8. None **kwargs Any additional members to include in the Jwk (e.g. kid, use) {} Returns: Type Description Jwk a Jwk instance from the loaded key Source code in jwskate/jwk/base.py 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 @classmethod def from_pem_key ( cls , data : Union [ bytes , str ], password : Union [ bytes , str , None ] = None , ** kwargs : Any , ) -> Jwk : \"\"\"Load a Jwk from a PEM encoded private or public key. Args: data: the PEM encoded data to load password: the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8. **kwargs: additional members to include in the Jwk (e.g. kid, use) Returns: a Jwk instance from the loaded key \"\"\" data = data . encode () if isinstance ( data , str ) else data password = password . encode ( \"UTF-8\" ) if isinstance ( password , str ) else password try : cryptography_key = serialization . load_pem_private_key ( data , password ) except Exception as private_exc : try : cryptography_key = serialization . load_pem_public_key ( data ) if password is not None : raise ValueError ( \"A public key was loaded from PEM, while a password was provided for decryption.\" \"Only private keys are encrypted in PEM.\" ) except Exception : raise ValueError ( \"The provided data is not a private or a public PEM encoded key.\" ) from private_exc return cls . from_cryptography_key ( cryptography_key , ** kwargs )","title":"from_pem_key()"},{"location":"api/#jwskate.jwk.base.Jwk.to_pem","text":"1 to_pem ( password : Union [ bytes , str , None ] = None ) -> bytes Serialize this key to PEM format. For private keys, you can provide a password for encryption. This password should be bytes. A str is also accepted, and will be encoded to bytes using UTF-8 before it is used as encryption key. Parameters: Name Type Description Default password Union [ bytes , str , None] password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded with UTF-8. None Returns: Type Description bytes the PEM serialized key Source code in jwskate/jwk/base.py 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 def to_pem ( self , password : Union [ bytes , str , None ] = None ) -> bytes : \"\"\"Serialize this key to PEM format. For private keys, you can provide a password for encryption. This password should be bytes. A `str` is also accepted, and will be encoded to `bytes` using UTF-8 before it is used as encryption key. Args: password: password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded with UTF-8. Returns: the PEM serialized key \"\"\" password = ( str ( password ) . encode ( \"UTF-8\" ) if isinstance ( password , str ) else password ) if self . is_private : encryption : serialization . KeySerializationEncryption if password : encryption = serialization . BestAvailableEncryption ( password ) else : encryption = serialization . NoEncryption () return self . cryptography_key . private_bytes ( # type: ignore[no-any-return] serialization . Encoding . PEM , serialization . PrivateFormat . PKCS8 , encryption , ) else : if password : raise ValueError ( \"Public keys cannot be encrypted when serialized in PEM format.\" ) return self . cryptography_key . public_bytes ( # type: ignore[no-any-return] serialization . Encoding . PEM , serialization . PublicFormat . SubjectPublicKeyInfo , )","title":"to_pem()"},{"location":"api/#jwskate.jwk.base.Jwk.generate","text":"1 generate ( ** kwargs : Any ) -> Jwk Generate a Private Key and return it as a Jwk instance. This method is implemented by subclasses for specific Key Types and returns an instance of that subclass. Parameters: Name Type Description Default **kwargs Any specific parameters depending on the type of key, or additional members to include in the Jwk {} Returns: Type Description Jwk a Jwk instance with a generated key Source code in jwskate/jwk/base.py 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 @classmethod def generate ( cls , ** kwargs : Any ) -> Jwk : \"\"\"Generate a Private Key and return it as a `Jwk` instance. This method is implemented by subclasses for specific Key Types and returns an instance of that subclass. Args: **kwargs: specific parameters depending on the type of key, or additional members to include in the Jwk Returns: a Jwk instance with a generated key \"\"\" raise NotImplementedError","title":"generate()"},{"location":"api/#jwskate.jwk.base.Jwk.generate_for_kty","text":"1 generate_for_kty ( kty : str , ** kwargs : Any ) -> Jwk Generate a key with a specific type and return the resulting Jwk. Parameters: Name Type Description Default kty str key type to generate required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Raises: Type Description UnsupportedKeyType if the key type is not supported Source code in jwskate/jwk/base.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 @classmethod def generate_for_kty ( cls , kty : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key with a specific type and return the resulting Jwk. Args: kty: key type to generate **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk Raises: UnsupportedKeyType: if the key type is not supported \"\"\" jwk_class = cls . subclasses . get ( kty ) if jwk_class is None : raise UnsupportedKeyType ( \"Unsupported Key Type:\" , kty ) return jwk_class . generate ( ** kwargs )","title":"generate_for_kty()"},{"location":"api/#jwskate.jwk.base.Jwk.generate_for_alg","text":"1 generate_for_alg ( alg : str , ** kwargs : Any ) -> Jwk Generate a key for usage with a specific alg and return the resulting Jwk. Parameters: Name Type Description Default alg str a signature or key management alg required **kwargs Any specific parameters depending on the key type, or additional members to include in the Jwk {} Returns: Type Description Jwk the resulting Jwk Source code in jwskate/jwk/base.py 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 @classmethod def generate_for_alg ( cls , alg : str , ** kwargs : Any ) -> Jwk : \"\"\"Generate a key for usage with a specific alg and return the resulting Jwk. Args: alg: a signature or key management alg **kwargs: specific parameters depending on the key type, or additional members to include in the Jwk Returns: the resulting Jwk \"\"\" for kty , jwk_class in cls . subclasses . items (): alg_class : Optional [ Type [ BaseAlg ]] try : alg_class = jwk_class . _get_alg_class ( alg ) if issubclass ( jwk_class , BaseAESEncryptionAlg ): kwargs . setdefault ( \"key_size\" , alg_class . key_size ) return jwk_class . generate ( alg = alg , ** kwargs ) except UnsupportedAlg : continue raise UnsupportedAlg ( alg )","title":"generate_for_alg()"},{"location":"api/#jwskate.jwk.base.Jwk.copy","text":"1 copy () -> Jwk Creates a copy of this key. Returns: Type Description Jwk a copy of this key, with the same value Source code in jwskate/jwk/base.py 1048 1049 1050 1051 1052 1053 1054 def copy ( self ) -> Jwk : \"\"\"Creates a copy of this key. Returns: a copy of this key, with the same value \"\"\" return Jwk ( super () . copy ())","title":"copy()"},{"location":"api/#jwskate.jwk.base.Jwk.with_kid_thumbprint","text":"1 with_kid_thumbprint ( force : bool = False ) -> Jwk Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if force is True , this erases the previous \"kid\". - if force is False (default), do nothing. Parameters: Name Type Description Default force bool whether to overwrite a previously existing kid False Returns: Type Description Jwk a copy of this key with a \"kid\" (either the previous one or the existing one, depending on force ). Source code in jwskate/jwk/base.py 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def with_kid_thumbprint ( self , force : bool = False ) -> Jwk : \"\"\"Includes the JWK thumbprint as \"kid\". If key already has a \"kid\": - if `force` is `True`, this erases the previous \"kid\". - if `force` is `False` (default), do nothing. Args: force: whether to overwrite a previously existing kid Returns: a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`). \"\"\" if self . get ( \"kid\" ) is not None and not force : return self jwk = self . copy () jwk [ \"kid\" ] = self . thumbprint () return jwk","title":"with_kid_thumbprint()"},{"location":"api/#jwskate.jwk.base.Jwk.with_usage_parameters","text":"1 2 3 4 5 6 with_usage_parameters ( alg : Optional [ str ] = None , with_alg : bool = True , with_use : bool = True , with_key_ops : bool = True , ) -> Jwk Copy this Jwk and add the use and key_ops parameters. The returned jwk alg parameter will be the one passed as parameter to this method, or as dfault the one declared as alg parameter in this Jwk. The use (Public Key Use) param is deduced based on this alg value. The key_ops (Key Operations) param is deduced based on the key use and if the key is public, private, or symmetric. Parameters: Name Type Description Default alg Optional [ str ] the alg to use, if not present in this Jwk None with_alg bool whether to include an alg parameter True with_use bool whether to include a use parameter True with_key_ops bool whether to include a key_ops parameter True Returns: Type Description Jwk a Jwk with the same key, with alg , use and key_ops parameters. Source code in jwskate/jwk/base.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 def with_usage_parameters ( self , alg : Optional [ str ] = None , with_alg : bool = True , with_use : bool = True , with_key_ops : bool = True , ) -> Jwk : \"\"\"Copy this Jwk and add the `use` and `key_ops` parameters. The returned jwk `alg` parameter will be the one passed as parameter to this method, or as dfault the one declared as `alg` parameter in this Jwk. The `use` (Public Key Use) param is deduced based on this `alg` value. The `key_ops` (Key Operations) param is deduced based on the key `use` and if the key is public, private, or symmetric. Args: alg: the alg to use, if not present in this Jwk with_alg: whether to include an `alg` parameter with_use: whether to include a `use` parameter with_key_ops: whether to include a `key_ops` parameter Returns: a Jwk with the same key, with `alg`, `use` and `key_ops` parameters. \"\"\" alg = alg or self . alg if not alg : raise ExpectedAlgRequired ( \"An algorithm is required to set the usage parameters\" ) self . _get_alg_class ( alg ) # raises an exception if alg is not supported jwk = self . copy () if with_alg : jwk [ \"alg\" ] = alg if with_use : jwk [ \"use\" ] = jwk . use if with_key_ops : jwk [ \"key_ops\" ] = jwk . key_ops return jwk","title":"with_usage_parameters()"},{"location":"api/#jwskate.jwk.base.Jwk.minimize","text":"1 minimize () -> Jwk Strips out any optional or non-standard parameter from that key. This will remove alg , use , key_ops , optional parameters from RSA keys, and other unknown parameters. Source code in jwskate/jwk/base.py 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 def minimize ( self ) -> Jwk : \"\"\"Strips out any optional or non-standard parameter from that key. This will remove `alg`, `use`, `key_ops`, optional parameters from RSA keys, and other unknown parameters. \"\"\" jwk = self . copy () for key in self . keys (): if key == \"kty\" or key in self . PARAMS and self . PARAMS [ key ] . is_required : continue del jwk [ key ] return jwk","title":"minimize()"},{"location":"api/#jwskate.jwk.base.Jwk.check","text":"1 2 3 4 5 6 check ( * , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None , kty : Optional [ str ] = None ) -> Jwk Check this key for type, privateness and/or symmetricness. Raise a ValueError if it not as expected. Parameters: Name Type Description Default is_private Optional [ bool ] if True , check if the key is private, if False , check if it is public, if None , do nothing None is_symmetric Optional [ bool ] if True , check if the key is symmetric, if False , check if it is asymmetric, if None , do nothing None kty Optional [ str ] the expected key type, if any None Returns: Type Description Jwk this key, if all checks passed Raises: Type Description ValueError if any check fails Source code in jwskate/jwk/base.py 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 def check ( self , * , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None , kty : Optional [ str ] = None , ) -> Jwk : \"\"\"Check this key for type, privateness and/or symmetricness. Raise a ValueError if it not as expected. Args: is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing kty: the expected key type, if any Returns: this key, if all checks passed Raises: ValueError: if any check fails \"\"\" if is_private is not None : if is_private is True and self . is_private is False : raise ValueError ( \"This key is public while a private key is expected.\" ) elif is_private is False and self . is_private is True : raise ValueError ( \"This key is private while a public key is expected.\" ) if is_symmetric is not None : if is_symmetric is True and self . is_symmetric is False : raise ValueError ( \"This key is asymmetric while a symmetric key is expected.\" ) if is_symmetric is False and self . is_symmetric is True : raise ValueError ( \"This key is symmetric while an asymmetric key is expected.\" ) if kty is not None : if self . kty != kty : raise ValueError ( f \"This key has kty= { self . kty } while a kty= { kty } is expected.\" ) return self","title":"check()"},{"location":"api/#jwskate.jwk.select_alg_class","text":"1 2 3 4 5 6 select_alg_class ( supported_algs : Mapping [ str , T ], * , jwk_alg : Optional [ str ] = None , alg : Optional [ str ] = None ) -> T Internal helper method to choose the appropriate alg class to use for cryptographic operations. Given: - a mapping of supported algs names to wrapper classes - a preferred alg name (usually the one mentioned in a JWK) - and/or a user-specified alg this returns the wrapper class to use. This checks the coherency between the user specified alg and the jwk_alg , and will emit a warning if the user specified alg is different from the jwk_alg . Parameters: Name Type Description Default supported_algs Mapping [ str , T ] a mapping of supported alg names to alg wrapper required jwk_alg Optional [ str ] the alg from the JWK, if any None alg Optional [ str ] a user specified alg None Returns: Type Description T the alg to use Warnings A warning is emitted if jwk_alg is supplied and alg doesn't match its value. Raises: Type Description UnsupportedAlg if the requested alg is not supported ValueError if supported_algs is empty Source code in jwskate/jwk/alg.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def select_alg_class ( supported_algs : Mapping [ str , T ], * , jwk_alg : Optional [ str ] = None , alg : Optional [ str ] = None , ) -> T : \"\"\"Internal helper method to choose the appropriate alg class to use for cryptographic operations. Given: - a mapping of supported algs names to wrapper classes - a preferred alg name (usually the one mentioned in a JWK) - and/or a user-specified alg this returns the wrapper class to use. This checks the coherency between the user specified `alg` and the `jwk_alg`, and will emit a warning if the user specified alg is different from the `jwk_alg`. Args: supported_algs: a mapping of supported alg names to alg wrapper jwk_alg: the alg from the JWK, if any alg: a user specified alg Returns: the alg to use Warnings: A warning is emitted if `jwk_alg` is supplied and `alg` doesn't match its value. Raises: UnsupportedAlg: if the requested alg is not supported ValueError: if supported_algs is empty \"\"\" if not supported_algs : raise ValueError ( \"No possible algorithms to choose from!\" ) choosen_alg : str if jwk_alg is not None : if alg is not None : if jwk_alg != alg : warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) choosen_alg = alg else : choosen_alg = jwk_alg elif alg is not None : choosen_alg = alg else : raise ExpectedAlgRequired ( \"This key doesn't have an 'alg' parameter, so you need to provide the expected signing alg(s) for each operation.\" ) try : return supported_algs [ choosen_alg ] except KeyError : raise UnsupportedAlg ( f \"Alg { choosen_alg } is not supported. Supported algs: { list ( supported_algs ) } .\" )","title":"select_alg_class()"},{"location":"api/#jwskate.jwk.select_alg_classes","text":"1 2 3 4 5 6 7 select_alg_classes ( supported_algs : Mapping [ str , T ], * , jwk_alg : Optional [ str ] = None , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> List [ T ] Internal helper method to select several appropriate algs classes to use on cryptographic operations. This method is typically used to get the list of valid algorithms when checking a signature, when several algorithms are allowed. Given: - a mapping of supported algorithms name to wrapper classes - an alg parameter from a JWK - and/or a user-specified alg - and/or a user specified list of usable algs this returns a list of supported alg wrapper classes that matches what the user specified, or, as default, the alg parameter from the JWK. This checks the coherency between the user specified alg and the jwk_alg , and will emit a warning if the user specified alg is different from the jwk_alg . Parameters: Name Type Description Default supported_algs Mapping [ str , T ] a mapping of alg names to alg wrappers required jwk_alg Optional [ str ] the alg from the JWK, if any None alg Optional [ str ] a user specified alg to use, if any None algs Optional [ Iterable [ str ]] a user specified list of algs to use, if several are allowed None Returns: Type Description List [ T ] a list of possible algs to check Raises: Type Description ValueError if both 'alg' and 'algs' parameters are used UnsupportedAlg if none of the requested alg are supported Warnings if the requested 'alg' is different that the 'jwk_alg', or the 'jwk_alg' is not in the 'algs' Source code in jwskate/jwk/alg.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def select_alg_classes ( supported_algs : Mapping [ str , T ], * , jwk_alg : Optional [ str ] = None , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> List [ T ]: \"\"\"Internal helper method to select several appropriate algs classes to use on cryptographic operations. This method is typically used to get the list of valid algorithms when checking a signature, when several algorithms are allowed. Given: - a mapping of supported algorithms name to wrapper classes - an alg parameter from a JWK - and/or a user-specified alg - and/or a user specified list of usable algs this returns a list of supported alg wrapper classes that matches what the user specified, or, as default, the alg parameter from the JWK. This checks the coherency between the user specified `alg` and the `jwk_alg`, and will emit a warning if the user specified alg is different from the `jwk_alg`. Args: supported_algs: a mapping of alg names to alg wrappers jwk_alg: the alg from the JWK, if any alg: a user specified alg to use, if any algs: a user specified list of algs to use, if several are allowed Returns: a list of possible algs to check Raises: ValueError: if both 'alg' and 'algs' parameters are used UnsupportedAlg: if none of the requested alg are supported Warnings: if the requested 'alg' is different that the 'jwk_alg', or the 'jwk_alg' is not in the 'algs' \"\"\" if alg and algs : raise ValueError ( \"Please use either parameter 'alg' or 'algs', not both.\" ) if not supported_algs : raise ValueError ( \"No possible algorithms to choose from!\" ) if jwk_alg is not None : if ( alg and alg != jwk_alg ) or ( algs and jwk_alg not in algs ): warnings . warn ( \"This key has an 'alg' parameter, you should use that alg for each operation.\" ) possible_algs : List [ str ] = [] if alg : possible_algs = [ alg ] elif algs : possible_algs = list ( algs ) elif jwk_alg : possible_algs = [ jwk_alg ] if possible_algs : possible_supported_algs = [ supported_algs [ alg ] for alg in possible_algs if alg in supported_algs ] if possible_supported_algs : return possible_supported_algs else : raise UnsupportedAlg ( f \"None of the user-specified alg(s) are supported. { possible_algs } \" ) raise ExpectedAlgRequired ( \"This key doesn't have an 'alg' parameter, so you need to provide the expected signing alg(s) for each operation.\" )","title":"select_alg_classes()"},{"location":"api/#jwskate.jwk.to_jwk","text":"1 2 3 4 5 6 7 to_jwk ( key : Any , * , kty : Optional [ str ] = None , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None ) -> Jwk Convert any supported kind of key to a Jwk, and optionally check if that key is private or symmetric. The key can be any type supported by Jwk: - a cryptography key instance - a bytes, to initialize a symmetric key - a JWK, as a dict or as a JSON formatted string - an existing Jwk instance If the supplied param is already a Jwk, it is left untouched. Parameters: Name Type Description Default key Any the key material required kty Optional [ str ] the expected key type None is_private Optional [ bool ] if True , check if the key is private, if False , check if it is public, if None , do nothing None is_symmetric Optional [ bool ] if True , check if the key is symmetric, if False , check if it is asymmetric, if None , do nothing None Returns: Type Description Jwk a Jwk key Source code in jwskate/jwk/base.py 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 def to_jwk ( key : Any , * , kty : Optional [ str ] = None , is_private : Optional [ bool ] = None , is_symmetric : Optional [ bool ] = None , ) -> Jwk : \"\"\"Convert any supported kind of key to a Jwk, and optionally check if that key is private or symmetric. The key can be any type supported by Jwk: - a `cryptography` key instance - a bytes, to initialize a symmetric key - a JWK, as a dict or as a JSON formatted string - an existing Jwk instance If the supplied param is already a Jwk, it is left untouched. Args: key: the key material kty: the expected key type is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing Returns: a Jwk key \"\"\" jwk = key if isinstance ( key , Jwk ) else Jwk ( key ) return jwk . check ( kty = kty , is_private = is_private , is_symmetric = is_symmetric )","title":"to_jwk()"},{"location":"api/#jwskate.jwt","text":"This module contains all Json Web Key (Jwk) related classes and utilities.","title":"jwt"},{"location":"api/#jwskate.jwt.JwtSigner","text":"A helper class to easily sign JWTs with standardised claims. The standardised claims include \u00ecat : issued at date exp : expiration date nbf : not before date: iss : issuer identifier sub : subject identifier aud : audience identifier jti : JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling JwtSigner.sign() . This can be used as an alternative to Jwt.sign() when a single issuer issues multiple tokens. Parameters: Name Type Description Default issuer str the issuer string to use as \u00ecss claim for signed tokens. required jwk Jwk the private Jwk to use to sign tokens. required alg Optional [ str ] the signing alg to use to sign tokens. None default_lifetime int the default lifetime, in seconds, to use for claim exp . This can be overridden when calling .sign() 60 default_leeway Optional [ int ] the default leeway, in seconds, to use for claim nbf . If None, no nbf claim is included. This can be overridden when calling .sign() None Source code in jwskate/jwt/signer.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class JwtSigner : \"\"\"A helper class to easily sign JWTs with standardised claims. The standardised claims include: - `\u00ecat`: issued at date - `exp`: expiration date - `nbf`: not before date: - `iss`: issuer identifier - `sub`: subject identifier - `aud`: audience identifier - `jti`: JWT token ID The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling `JwtSigner.sign()`. This can be used as an alternative to `Jwt.sign()` when a single issuer issues multiple tokens. Args: issuer: the issuer string to use as `\u00ecss` claim for signed tokens. jwk: the private Jwk to use to sign tokens. alg: the signing alg to use to sign tokens. default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden when calling `.sign()` default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is included. This can be overridden when calling `.sign()` \"\"\" def __init__ ( self , issuer : str , jwk : Jwk , alg : Optional [ str ] = None , default_lifetime : int = 60 , default_leeway : Optional [ int ] = None , ): self . issuer = issuer self . jwk = jwk self . alg = jwk . alg or alg self . default_lifetime = default_lifetime self . default_leeway = default_leeway def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = Jwt . timestamp () lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers ) def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ())","title":"JwtSigner"},{"location":"api/#jwskate.jwt.signer.JwtSigner.sign","text":"1 2 3 4 5 6 7 8 sign ( subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim iat , nbf and exp will reflect the current time when the token is signed. exp includes lifetime seconds in the future, and nbf includes leeway seconds in the past. Parameters: Name Type Description Default subject Optional [ str ] the subject to include in claim sub . (Default value = None) None audience Union [ str , Iterable [ str ], None] the audience identifier(s) to include in claim aud . None extra_claims Optional [ Dict [ str , Any ]] additional claims to include in the signed token. (Default value = None) None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the header part. (Default value = None) None lifetime Optional [ int ] lifetime, in seconds, to use for the exp claim. If None, use the default_lifetime defined at initialization time. None leeway Optional [ int ] leeway, in seconds, to use for the nbf claim. If None, use the default_leeway defined at initialization time. None Returns: Type Description SignedJwt the resulting signed token. Source code in jwskate/jwt/signer.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def sign ( self , subject : Optional [ str ] = None , audience : Union [ str , Iterable [ str ], None ] = None , extra_claims : Optional [ Dict [ str , Any ]] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , lifetime : Optional [ int ] = None , leeway : Optional [ int ] = None , ) -> SignedJwt : \"\"\"Sign a Jwt. Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf` includes `leeway` seconds in the past. Args: subject: the subject to include in claim `sub`. (Default value = None) audience: the audience identifier(s) to include in claim `aud`. extra_claims: additional claims to include in the signed token. (Default value = None) extra_headers: additional headers to include in the header part. (Default value = None) lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time. leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time. Returns: the resulting signed token. \"\"\" now = Jwt . timestamp () lifetime = lifetime or self . default_lifetime exp = now + lifetime leeway = leeway or self . default_leeway nbf = ( now - leeway ) if leeway is not None else None jti = self . generate_jti () extra_claims = extra_claims or {} claims = { key : value for key , value in dict ( extra_claims , iss = self . issuer , aud = audience , sub = subject , iat = now , exp = exp , nbf = nbf , jti = jti , ) . items () if value is not None } return Jwt . sign ( claims , jwk = self . jwk , alg = self . alg , extra_headers = extra_headers )","title":"sign()"},{"location":"api/#jwskate.jwt.signer.JwtSigner.generate_jti","text":"1 generate_jti () -> str Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: Type Description str A unique value suitable for use as JWT Token ID (jti) claim. Source code in jwskate/jwt/signer.py 104 105 106 107 108 109 110 111 112 def generate_jti ( self ) -> str : \"\"\"Generate Jwt Token ID (jti) values. Default uses UUID4. Can be overridden in subclasses. Returns: A unique value suitable for use as JWT Token ID (jti) claim. \"\"\" return str ( uuid . uuid4 ())","title":"generate_jti()"},{"location":"api/#jwskate.jwt.ExpiredJwt","text":"Bases: ValueError Raised when trying to validate an expired JWT token. Source code in jwskate/jwt/signed.py 14 15 class ExpiredJwt ( ValueError ): \"\"\"Raised when trying to validate an expired JWT token.\"\"\"","title":"ExpiredJwt"},{"location":"api/#jwskate.jwt.InvalidJwt","text":"Bases: ValueError Raised when an invalid Jwt is parsed. Source code in jwskate/jwt/base.py 18 19 class InvalidJwt ( ValueError ): \"\"\"Raised when an invalid Jwt is parsed.\"\"\"","title":"InvalidJwt"},{"location":"api/#jwskate.jwt.InvalidSignature","text":"Bases: ValueError Raised when trying to validate a JWT with an invalid signature. Source code in jwskate/jwt/signed.py 18 19 class InvalidSignature ( ValueError ): \"\"\"Raised when trying to validate a JWT with an invalid signature.\"\"\"","title":"InvalidSignature"},{"location":"api/#jwskate.jwt.Jwt","text":"Bases: BaseCompactToken Represents a Json Web Token. Source code in jwskate/jwt/base.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 class Jwt ( BaseCompactToken ): \"\"\"Represents a Json Web Token.\"\"\" def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 4 : from ..jwe import JweCompact return JweCompact ( value ) return super () . __new__ ( cls ) @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = to_jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) extra_headers = extra_headers or {} headers = dict ( alg = alg , ** extra_headers ) if jwk . kid : headers [ \"kid\" ] = jwk . kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature ))) @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , * , sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , sign_extra_headers : Optional [ Dict [ str , Any ]] = None , enc_extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JweCompact : \"\"\"Sign a JWT, then encrypt it as JWE payload. This is a convenience method to do both the signing and encryption, in appropriate order. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature sign_extra_headers: additional headers for the inner signed JWT enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption enc_extra_headers: additional headers for the outer encrypted JWE Returns: the resulting JWE token, with the signed JWT as payload \"\"\" enc_extra_headers = enc_extra_headers or {} enc_extra_headers . setdefault ( \"cty\" , \"JWT\" ) inner_jwt = cls . sign ( claims , jwk = sign_jwk , alg = sign_alg , extra_headers = sign_extra_headers ) jwe = JweCompact . encrypt ( inner_jwt , enc_jwk , enc = enc , alg = enc_alg , extra_headers = enc_extra_headers ) return jwe @classmethod def decrypt_nested_jwt ( cls , jwe : Union [ str , JweCompact ], jwk : Union [ Jwk , Dict [ str , Any ]] ) -> Jwt : \"\"\"Convenience method to decrypt a nested JWT. It will return a [Jwt] instance. Args: jwe: the JWE containing a nested Token jwk: the decryption key Returns: the inner token Raises: InvalidJwt: if the inner JWT is not valid \"\"\" if not isinstance ( jwe , JweCompact ): jwe = JweCompact ( jwe ) cleartext = jwe . decrypt ( jwk ) return Jwt ( cleartext ) @classmethod def decrypt_and_verify ( cls , jwt : Union [ str , JweCompact ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sig_jwk : Union [ Jwk , Dict [ str , Any ], None ], sig_alg : Optional [ str ] = None , sig_algs : Optional [ Iterable [ str ]] = None , ) -> SignedJwt : \"\"\"Decrypt then verify the signature of a JWT nested in a JWE. This can only be used with signed then encrypted Jwt, such as those produce by `Jwt.sign_and_encrypt()`. Args: jwt: the JWE containing a nested signed JWT enc_jwk: the decryption key sig_jwk: the signature verification key sig_alg: the signature verification alg, if only 1 is allowed sig_algs: the signature verifications algs, if several are allowed Returns: the nested signed JWT, in clear-text, signature already verified Raises: InvalidJwt: if the JWT is not valid InvalidSignature: if the nested JWT signature is not valid \"\"\" from .signed import InvalidSignature , SignedJwt nested_jwt = cls . decrypt_nested_jwt ( jwt , enc_jwk ) if not isinstance ( nested_jwt , SignedJwt ): raise ValueError ( \"Nested JWT is not signed\" , nested_jwt ) if sig_jwk : if nested_jwt . verify_signature ( sig_jwk , sig_alg , sig_algs ): return nested_jwt raise InvalidSignature () @classmethod def timestamp ( cls , delta_seconds : int = 0 ) -> int : \"\"\"Return an integer timestamp that is suitable for use in Jwt tokens `iat`, `exp` and `nbf` claims. A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds. By default, the current timestamp is returned. You can include `delta_seconds` to have a timestamp a number of seconds in the future (if positive) or in the past (if negative). Args: delta_seconds: number of seconds in the future or in the past compared to current time Returns: An integer timestamp \"\"\" return int ( datetime . now ( timezone . utc ) . timestamp ()) + delta_seconds @classmethod def timestamp_to_datetime ( cls , timestamp : int ) -> datetime : \"\"\"Convert a JWT timestamp to a `datetime`. Returned datetime is always in the UTC timezone. Args: timestamp: a timestamp from a JWT token Returns: the corresponding `datetime` in UTC timezone \"\"\" return datetime . fromtimestamp ( timestamp , tz = timezone . utc )","title":"Jwt"},{"location":"api/#jwskate.jwt.base.Jwt.__new__","text":"1 __new__ ( value : Union [ bytes , str ]) Allow parsing both Signed and Encrypted JWTs. This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT. Parameters: Name Type Description Default value Union [ bytes , str ] the token value required Source code in jwskate/jwt/base.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def __new__ ( cls , value : Union [ bytes , str ]): # type: ignore \"\"\"Allow parsing both Signed and Encrypted JWTs. This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT. Args: value: the token value \"\"\" if not isinstance ( value , bytes ): value = value . encode ( \"ascii\" ) if cls == Jwt : if value . count ( b \".\" ) == 2 : from .signed import SignedJwt return super () . __new__ ( SignedJwt ) elif value . count ( b \".\" ) == 4 : from ..jwe import JweCompact return JweCompact ( value ) return super () . __new__ ( cls )","title":"__new__()"},{"location":"api/#jwskate.jwt.base.Jwt.sign","text":"1 2 3 4 5 6 sign ( claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> SignedJwt Sign a JSON payload with a Jwk and returns the resulting SignedJwt . This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use .unprotected() instead. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signing required alg Optional [ str ] the alg to use for signing None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the Jwt None Returns: Type Description SignedJwt the resulting token Source code in jwskate/jwt/base.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @classmethod def sign ( cls , claims : Dict [ str , Any ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Sign a JSON payload with a `Jwk` and returns the resulting `SignedJwt`. This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use `.unprotected()` instead. Args: claims: the payload to sign jwk: the Jwk to use for signing alg: the alg to use for signing extra_headers: additional headers to include in the Jwt Returns: the resulting token \"\"\" from .signed import SignedJwt jwk = to_jwk ( jwk ) alg = alg or jwk . get ( \"alg\" ) if alg is None : raise ValueError ( \"a signing alg is required\" ) extra_headers = extra_headers or {} headers = dict ( alg = alg , ** extra_headers ) if jwk . kid : headers [ \"kid\" ] = jwk . kid headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = jwk . sign ( signed_value , alg = alg ) . to ( \"b64u\" ) return SignedJwt ( b \".\" . join (( signed_value , signature )))","title":"sign()"},{"location":"api/#jwskate.jwt.base.Jwt.unprotected","text":"1 2 3 4 unprotected ( claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> SignedJwt Generate a JWT that is not signed and not encrypted (with alg=none). Parameters: Name Type Description Default claims Dict [ str , Any ] the claims to set in the token. required extra_headers Optional [ Dict [ str , Any ]] additional headers to insert in the token. None Returns: Type Description SignedJwt the resulting token Source code in jwskate/jwt/base.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @classmethod def unprotected ( cls , claims : Dict [ str , Any ], extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> \"SignedJwt\" : \"\"\"Generate a JWT that is not signed and not encrypted (with alg=none). Args: claims: the claims to set in the token. extra_headers: additional headers to insert in the token. Returns: the resulting token \"\"\" from .signed import SignedJwt headers = dict ( extra_headers or {}, alg = \"none\" ) headers_part = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) claims_part = BinaPy . serialize_to ( \"json\" , claims ) . to ( \"b64u\" ) signed_value = b \".\" . join (( headers_part , claims_part )) signature = b \"\" return SignedJwt ( b \".\" . join (( signed_value , signature )))","title":"unprotected()"},{"location":"api/#jwskate.jwt.base.Jwt.sign_and_encrypt","text":"1 2 3 4 5 6 7 8 9 10 11 sign_and_encrypt ( claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , * , sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , sign_extra_headers : Optional [ Dict [ str , Any ]] = None , enc_extra_headers : Optional [ Dict [ str , Any ]] = None ) -> JweCompact Sign a JWT, then encrypt it as JWE payload. This is a convenience method to do both the signing and encryption, in appropriate order. Parameters: Name Type Description Default claims Dict [ str , Any ] the payload to encrypt required sign_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for signature required sign_alg Optional [ str ] the alg to use for signature None sign_extra_headers Optional [ Dict [ str , Any ]] additional headers for the inner signed JWT None enc_jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use for encryption required enc_alg Optional [ str ] the alg to use for CEK encryption None enc str the alg to use for payload encryption required enc_extra_headers Optional [ Dict [ str , Any ]] additional headers for the outer encrypted JWE None Returns: Type Description JweCompact the resulting JWE token, with the signed JWT as payload Source code in jwskate/jwt/base.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @classmethod def sign_and_encrypt ( cls , claims : Dict [ str , Any ], sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], enc : str , * , sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , sign_extra_headers : Optional [ Dict [ str , Any ]] = None , enc_extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JweCompact : \"\"\"Sign a JWT, then encrypt it as JWE payload. This is a convenience method to do both the signing and encryption, in appropriate order. Args: claims: the payload to encrypt sign_jwk: the Jwk to use for signature sign_alg: the alg to use for signature sign_extra_headers: additional headers for the inner signed JWT enc_jwk: the Jwk to use for encryption enc_alg: the alg to use for CEK encryption enc: the alg to use for payload encryption enc_extra_headers: additional headers for the outer encrypted JWE Returns: the resulting JWE token, with the signed JWT as payload \"\"\" enc_extra_headers = enc_extra_headers or {} enc_extra_headers . setdefault ( \"cty\" , \"JWT\" ) inner_jwt = cls . sign ( claims , jwk = sign_jwk , alg = sign_alg , extra_headers = sign_extra_headers ) jwe = JweCompact . encrypt ( inner_jwt , enc_jwk , enc = enc , alg = enc_alg , extra_headers = enc_extra_headers ) return jwe","title":"sign_and_encrypt()"},{"location":"api/#jwskate.jwt.base.Jwt.decrypt_nested_jwt","text":"1 2 3 4 decrypt_nested_jwt ( jwe : Union [ str , JweCompact ], jwk : Union [ Jwk , Dict [ str , Any ]], ) -> Jwt Convenience method to decrypt a nested JWT. It will return a [Jwt] instance. Parameters: Name Type Description Default jwe Union [ str , JweCompact ] the JWE containing a nested Token required jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required Returns: Type Description Jwt the inner token Raises: Type Description InvalidJwt if the inner JWT is not valid Source code in jwskate/jwt/base.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 @classmethod def decrypt_nested_jwt ( cls , jwe : Union [ str , JweCompact ], jwk : Union [ Jwk , Dict [ str , Any ]] ) -> Jwt : \"\"\"Convenience method to decrypt a nested JWT. It will return a [Jwt] instance. Args: jwe: the JWE containing a nested Token jwk: the decryption key Returns: the inner token Raises: InvalidJwt: if the inner JWT is not valid \"\"\" if not isinstance ( jwe , JweCompact ): jwe = JweCompact ( jwe ) cleartext = jwe . decrypt ( jwk ) return Jwt ( cleartext )","title":"decrypt_nested_jwt()"},{"location":"api/#jwskate.jwt.base.Jwt.decrypt_and_verify","text":"1 2 3 4 5 6 7 decrypt_and_verify ( jwt : Union [ str , JweCompact ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sig_jwk : Union [ Jwk , Dict [ str , Any ], None ], sig_alg : Optional [ str ] = None , sig_algs : Optional [ Iterable [ str ]] = None , ) -> SignedJwt Decrypt then verify the signature of a JWT nested in a JWE. This can only be used with signed then encrypted Jwt, such as those produce by Jwt.sign_and_encrypt() . Parameters: Name Type Description Default jwt Union [ str , JweCompact ] the JWE containing a nested signed JWT required enc_jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required sig_jwk Union [ Jwk , Dict [ str , Any ], None] the signature verification key required sig_alg Optional [ str ] the signature verification alg, if only 1 is allowed None sig_algs Optional [ Iterable [ str ]] the signature verifications algs, if several are allowed None Returns: Type Description SignedJwt the nested signed JWT, in clear-text, signature already verified Raises: Type Description InvalidJwt if the JWT is not valid InvalidSignature if the nested JWT signature is not valid Source code in jwskate/jwt/base.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 @classmethod def decrypt_and_verify ( cls , jwt : Union [ str , JweCompact ], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sig_jwk : Union [ Jwk , Dict [ str , Any ], None ], sig_alg : Optional [ str ] = None , sig_algs : Optional [ Iterable [ str ]] = None , ) -> SignedJwt : \"\"\"Decrypt then verify the signature of a JWT nested in a JWE. This can only be used with signed then encrypted Jwt, such as those produce by `Jwt.sign_and_encrypt()`. Args: jwt: the JWE containing a nested signed JWT enc_jwk: the decryption key sig_jwk: the signature verification key sig_alg: the signature verification alg, if only 1 is allowed sig_algs: the signature verifications algs, if several are allowed Returns: the nested signed JWT, in clear-text, signature already verified Raises: InvalidJwt: if the JWT is not valid InvalidSignature: if the nested JWT signature is not valid \"\"\" from .signed import InvalidSignature , SignedJwt nested_jwt = cls . decrypt_nested_jwt ( jwt , enc_jwk ) if not isinstance ( nested_jwt , SignedJwt ): raise ValueError ( \"Nested JWT is not signed\" , nested_jwt ) if sig_jwk : if nested_jwt . verify_signature ( sig_jwk , sig_alg , sig_algs ): return nested_jwt raise InvalidSignature ()","title":"decrypt_and_verify()"},{"location":"api/#jwskate.jwt.base.Jwt.timestamp","text":"1 timestamp ( delta_seconds : int = 0 ) -> int Return an integer timestamp that is suitable for use in Jwt tokens iat , exp and nbf claims. A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds. By default, the current timestamp is returned. You can include delta_seconds to have a timestamp a number of seconds in the future (if positive) or in the past (if negative). Parameters: Name Type Description Default delta_seconds int number of seconds in the future or in the past compared to current time 0 Returns: Type Description int An integer timestamp Source code in jwskate/jwt/base.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @classmethod def timestamp ( cls , delta_seconds : int = 0 ) -> int : \"\"\"Return an integer timestamp that is suitable for use in Jwt tokens `iat`, `exp` and `nbf` claims. A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds. By default, the current timestamp is returned. You can include `delta_seconds` to have a timestamp a number of seconds in the future (if positive) or in the past (if negative). Args: delta_seconds: number of seconds in the future or in the past compared to current time Returns: An integer timestamp \"\"\" return int ( datetime . now ( timezone . utc ) . timestamp ()) + delta_seconds","title":"timestamp()"},{"location":"api/#jwskate.jwt.base.Jwt.timestamp_to_datetime","text":"1 timestamp_to_datetime ( timestamp : int ) -> datetime Convert a JWT timestamp to a datetime . Returned datetime is always in the UTC timezone. Parameters: Name Type Description Default timestamp int a timestamp from a JWT token required Returns: Type Description datetime the corresponding datetime in UTC timezone Source code in jwskate/jwt/base.py 234 235 236 237 238 239 240 241 242 243 244 245 246 @classmethod def timestamp_to_datetime ( cls , timestamp : int ) -> datetime : \"\"\"Convert a JWT timestamp to a `datetime`. Returned datetime is always in the UTC timezone. Args: timestamp: a timestamp from a JWT token Returns: the corresponding `datetime` in UTC timezone \"\"\" return datetime . fromtimestamp ( timestamp , tz = timezone . utc )","title":"timestamp_to_datetime()"},{"location":"api/#jwskate.jwt.InvalidClaim","text":"Bases: ValueError Raised when trying to validate a JWT with unexpected claims. Source code in jwskate/jwt/signed.py 22 23 class InvalidClaim ( ValueError ): \"\"\"Raised when trying to validate a JWT with unexpected claims.\"\"\"","title":"InvalidClaim"},{"location":"api/#jwskate.jwt.SignedJwt","text":"Bases: Jwt Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use Jwt.sign . Parameters: Name Type Description Default value Union [ bytes , str ] the token value. required Source code in jwskate/jwt/signed.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 class SignedJwt ( Jwt ): \"\"\"Represent a Signed Json Web Token (JWT), as defined in RFC7519. A signed JWT contains a JSON object as payload, which represents claims. To sign a JWT, use [Jwt.sign][jwskate.jwt.Jwt.sign]. Args: value: the token value. \"\"\" def __init__ ( self , value : Union [ bytes , str ]) -> None : super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJwt ( \"A JWT must contain a header, a payload and a signature, separated by dots\" , value , ) header , payload , signature = self . value . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT header: it must be a Base64URL-encoded JSON object\" ) try : self . claims = BinaPy ( payload ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwt ( \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\" ) @cached_property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = to_jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs ) def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Args: leeway: additional number of seconds for leeway. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < ( datetime . now ( timezone . utc ) + timedelta ( seconds = leeway )) @cached_property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = Jwt . timestamp_to_datetime ( exp ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp ) @cached_property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = Jwt . timestamp_to_datetime ( iat ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat ) @cached_property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = Jwt . timestamp_to_datetime ( nbf ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf ) @cached_property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss )) @cached_property def audiences ( self ) -> List [ str ]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return [] if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud )) @cached_property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub )) @cached_property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti )) def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default ) def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode () def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signature alg to use to verify the signature. algs: allowed signature algs, if several issuer: the expected issuer for this token. audience: the expected audience for this token. check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg , algs ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audiences ) if check_exp : expired = self . is_expired () if expired is True : raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) elif expired is None : raise InvalidClaim ( \"exp\" , \"This token misses a 'exp' claim.\" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim )","title":"SignedJwt"},{"location":"api/#jwskate.jwt.signed.SignedJwt.signed_part","text":"1 signed_part () -> bytes Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: Type Description bytes the signed part as bytes Source code in jwskate/jwt/signed.py 68 69 70 71 72 73 74 75 76 77 @cached_property def signed_part ( self ) -> bytes : \"\"\"Return the actual signed data from this token. The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot. Returns: the signed part as bytes \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ])","title":"signed_part()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.verify_signature","text":"1 2 3 4 5 verify_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool Verify this JWT signature using a given key and algorithm(s). Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private Jwk to use to verify the signature required alg Optional [ str ] the alg to use to verify the signature, if only 1 is allowed None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several None Returns: Type Description bool True if the token signature is verified, False otherwise Source code in jwskate/jwt/signed.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWT signature using a given key and algorithm(s). Args: jwk: the private Jwk to use to verify the signature alg: the alg to use to verify the signature, if only 1 is allowed algs: the allowed signature algs, if there are several Returns: `True` if the token signature is verified, `False` otherwise \"\"\" jwk = to_jwk ( jwk ) return jwk . verify ( data = self . signed_part , signature = self . signature , alg = alg , algs = algs )","title":"verify_signature()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.is_expired","text":"1 is_expired ( leeway : int = 0 ) -> Optional [ bool ] Check if this token is expired, based on its exp claim. Parameters: Name Type Description Default leeway int additional number of seconds for leeway. 0 Returns: Type Description Optional [ bool ] True if the token is expired, False if it's not, None if there is no exp claim. Source code in jwskate/jwt/signed.py 101 102 103 104 105 106 107 108 109 110 111 112 113 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\"Check if this token is expired, based on its `exp` claim. Args: leeway: additional number of seconds for leeway. Returns: `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim. \"\"\" exp = self . expires_at if exp is None : return None return exp < ( datetime . now ( timezone . utc ) + timedelta ( seconds = leeway ))","title":"is_expired()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.expires_at","text":"1 expires_at () -> Optional [ datetime ] Get the \"Expires At\" (exp) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the exp claim, or None if there is no exp claim Raises: Type Description AttributeError if the exp claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @cached_property def expires_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Expires At\" (exp) date from this token. Returns: a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim Raises: AttributeError: if the `exp` claim cannot be parsed to a date \"\"\" exp = self . get_claim ( \"exp\" ) if not exp : return None try : exp_dt = Jwt . timestamp_to_datetime ( exp ) return exp_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `exp `claim\" , exp )","title":"expires_at()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.issued_at","text":"1 issued_at () -> Optional [ datetime ] Get the \"Issued At\" (iat) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the iat claim, or None if there is no iat claim Raises: Type Description AttributeError if the iss claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 @cached_property def issued_at ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Issued At\" (iat) date from this token. Returns: a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim Raises: AttributeError: if the `iss` claim cannot be parsed to a date \"\"\" iat = self . get_claim ( \"iat\" ) if not iat : return None try : iat_dt = Jwt . timestamp_to_datetime ( iat ) return iat_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `iat `claim\" , iat )","title":"issued_at()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.not_before","text":"1 not_before () -> Optional [ datetime ] Get the \"Not Before\" (nbf) date from this token. Returns: Type Description Optional [ datetime ] a datetime initialized from the nbf claim, or None if there is no nbf claim Raises: Type Description AttributeError if the nbf claim cannot be parsed to a date Source code in jwskate/jwt/signed.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 @cached_property def not_before ( self ) -> Optional [ datetime ]: \"\"\"Get the \"Not Before\" (nbf) date from this token. Returns: a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim Raises: AttributeError: if the `nbf` claim cannot be parsed to a date \"\"\" nbf = self . get_claim ( \"nbf\" ) if not nbf : return None try : nbf_dt = Jwt . timestamp_to_datetime ( nbf ) return nbf_dt except ( TypeError , OSError ): raise AttributeError ( \"invalid `nbf `claim\" , nbf )","title":"not_before()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.issuer","text":"1 issuer () -> Optional [ str ] Get the Issuer (iss) claim from this token. Returns: Type Description Optional [ str ] the issuer, as str , or None if there is no \u00ecss claim Raises: Type Description AttributeError if the \u00ecss claim value is not a string Source code in jwskate/jwt/signed.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 @cached_property def issuer ( self ) -> Optional [ str ]: \"\"\"Get the Issuer (iss) claim from this token. Returns: the issuer, as `str`, or `None` if there is no `\u00ecss` claim Raises: AttributeError: if the `\u00ecss` claim value is not a string \"\"\" iss = self . get_claim ( \"iss\" ) if iss is None or isinstance ( iss , str ): return iss raise AttributeError ( \"iss has an unexpected type\" , type ( iss ))","title":"issuer()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.audiences","text":"1 audiences () -> List [ str ] Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a list anyway. Returns: Type Description List [ str ] the list of audiences from this token, from the aud claim. Raises: Type Description AttributeError if the audience is an unexpected type Source code in jwskate/jwt/signed.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 @cached_property def audiences ( self ) -> List [ str ]: \"\"\"Get the audience(s) (aud) claim from this token. If this token has a single audience, this will return a `list` anyway. Returns: the list of audiences from this token, from the `aud` claim. Raises: AttributeError: if the audience is an unexpected type \"\"\" aud = self . get_claim ( \"aud\" ) if aud is None : return [] if isinstance ( aud , str ): return [ aud ] if isinstance ( aud , list ): return aud raise AttributeError ( \"aud has an unexpected type\" , type ( aud ))","title":"audiences()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.subject","text":"1 subject () -> Optional [ str ] Get the Subject (sub) from this token claims. Returns: Type Description Optional [ str ] the subject, as str , or None if there is no sub claim Raises: Type Description AttributeError if the sub value is not a string Source code in jwskate/jwt/signed.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @cached_property def subject ( self ) -> Optional [ str ]: \"\"\"Get the Subject (sub) from this token claims. Returns: the subject, as `str`, or `None` if there is no `sub` claim Raises: AttributeError: if the `sub` value is not a string \"\"\" sub = self . get_claim ( \"sub\" ) if sub is None or isinstance ( sub , str ): return sub raise AttributeError ( \"sub has an unexpected type\" , type ( sub ))","title":"subject()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.jwt_token_id","text":"1 jwt_token_id () -> Optional [ str ] Get the JWT Token ID (jti) from this token claims. Returns: Type Description Optional [ str ] the token identifier, as str , or None if there is no jti claim Raises: Type Description AttributeError if the jti value is not a string Source code in jwskate/jwt/signed.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @cached_property def jwt_token_id ( self ) -> Optional [ str ]: \"\"\"Get the JWT Token ID (jti) from this token claims. Returns: the token identifier, as `str`, or `None` if there is no `jti` claim Raises: AttributeError: if the `jti` value is not a string \"\"\" jti = self . get_claim ( \"jti\" ) if jti is None or isinstance ( jti , str ): return jti raise AttributeError ( \"jti has an unexpected type\" , type ( jti ))","title":"jwt_token_id()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.get_claim","text":"1 get_claim ( key : str , default : Any = None ) -> Any Get a claim from this Jwt. Parameters: Name Type Description Default key str the claim name. required default Any a default value if the claim is not found None Returns: Type Description Any the claim value if found, or default if not found Source code in jwskate/jwt/signed.py 238 239 240 241 242 243 244 245 246 247 248 def get_claim ( self , key : str , default : Any = None ) -> Any : \"\"\"Get a claim from this Jwt. Args: key: the claim name. default: a default value if the claim is not found Returns: the claim value if found, or `default` if not found \"\"\" return self . claims . get ( key , default )","title":"get_claim()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__getitem__","text":"1 __getitem__ ( item : str ) -> Any Allow claim access with subscription. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate/jwt/signed.py 250 251 252 253 254 255 256 257 258 259 260 261 262 def __getitem__ ( self , item : str ) -> Any : \"\"\"Allow claim access with subscription. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise KeyError ( item ) return value","title":"__getitem__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__getattr__","text":"1 __getattr__ ( item : str ) -> Any Allow claim access as attributes. Parameters: Name Type Description Default item str the claim name required Returns: Type Description Any the claim value Source code in jwskate/jwt/signed.py 264 265 266 267 268 269 270 271 272 273 274 275 276 def __getattr__ ( self , item : str ) -> Any : \"\"\"Allow claim access as attributes. Args: item: the claim name Returns: the claim value \"\"\" value = self . get_claim ( item ) if value is None : raise AttributeError ( item ) return value","title":"__getattr__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__str__","text":"1 __str__ () -> str Return the Jwt serialized value, as str . Returns: Type Description str the serialized token value. Source code in jwskate/jwt/signed.py 278 279 280 281 282 283 284 def __str__ ( self ) -> str : \"\"\"Return the Jwt serialized value, as `str`. Returns: the serialized token value. \"\"\" return self . value . decode ()","title":"__str__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__bytes__","text":"1 __bytes__ () -> bytes Return the Jwt serialized value, as bytes . Returns: Type Description bytes the serialized token value. Source code in jwskate/jwt/signed.py 286 287 288 289 290 291 292 def __bytes__ ( self ) -> bytes : \"\"\"Return the Jwt serialized value, as `bytes`. Returns: the serialized token value. \"\"\" return self . value","title":"__bytes__()"},{"location":"api/#jwskate.jwt.signed.SignedJwt.validate","text":"1 2 3 4 5 6 7 8 9 10 validate ( jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any ) -> None Validate a SignedJwt signature and expected claims. This verifies the signature using the provided jwk and alg , then checks the token issuer, audience and expiration date. This can also check custom claims using extra kwargs , whose values can be: a static value ( str , int , etc.): the value from the token will be compared \"as-is\" a callable, taking the claim value as parameter: if that callable returns True , the claim is considered as valid Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the signing key to use to verify the signature. required alg Optional [ str ] the signature alg to use to verify the signature. None algs Optional [ Iterable [ str ]] allowed signature algs, if several None issuer Optional [ str ] the expected issuer for this token. None audience Union [None, str ] the expected audience for this token. None check_exp bool \u00ecf True (default), check that the token is not expired. True **kwargs Any additional claims to check {} Returns: Type Description None Raises exceptions if any validation check fails. Raises: Type Description InvalidSignature if the signature is not valid InvalidClaim if a claim doesn't validate ExpiredJwt if the expiration date is passed Source code in jwskate/jwt/signed.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def validate ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , issuer : Optional [ str ] = None , audience : Union [ None , str ] = None , check_exp : bool = True , ** kwargs : Any , ) -> None : \"\"\"Validate a `SignedJwt` signature and expected claims. This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date. This can also check custom claims using extra `kwargs`, whose values can be: - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\" - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid Args: jwk: the signing key to use to verify the signature. alg: the signature alg to use to verify the signature. algs: allowed signature algs, if several issuer: the expected issuer for this token. audience: the expected audience for this token. check_exp: \u00ecf `True` (default), check that the token is not expired. **kwargs: additional claims to check Returns: Raises exceptions if any validation check fails. Raises: InvalidSignature: if the signature is not valid InvalidClaim: if a claim doesn't validate ExpiredJwt: if the expiration date is passed \"\"\" if not self . verify_signature ( jwk , alg , algs ): raise InvalidSignature ( \"Signature is not valid.\" ) if issuer is not None : if self . issuer != issuer : raise InvalidClaim ( \"iss\" , \"Unexpected issuer\" , self . issuer ) if audience is not None : if self . audiences is None or audience not in self . audiences : raise InvalidClaim ( \"aud\" , \"Unexpected audience\" , self . audiences ) if check_exp : expired = self . is_expired () if expired is True : raise ExpiredJwt ( f \"This token expired at { self . expires_at } \" ) elif expired is None : raise InvalidClaim ( \"exp\" , \"This token misses a 'exp' claim.\" ) for key , value in kwargs . items (): claim = self . get_claim ( key ) if callable ( value ): if not value ( claim ): raise InvalidClaim ( key , f \"value of claim { key } doesn't validate with the provided validator\" , claim , ) elif claim != value : raise InvalidClaim ( key , f \"unexpected value for claim { key } \" , claim )","title":"validate()"},{"location":"api/#jwskate.jws","text":"This module implements JWS token handling.","title":"jws"},{"location":"api/#jwskate.jws.JwsJsonFlat","text":"Bases: JwsSignature Represent a JWS with a single signature in JSON flat format. Source code in jwskate/jws/json.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 class JwsJsonFlat ( JwsSignature ): \"\"\"Represent a JWS with a single signature in JSON flat format.\"\"\" @cached_property def payload ( self ) -> bytes : \"\"\"The JWS payload, decoded. Returns: The raw JWS payload. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) @cached_property def jws_signature ( self ) -> JwsSignature : \"\"\"The JWS signature. Returns: The JWS signature. \"\"\" content = { \"protected\" : self [ \"protected\" ], \"signature\" : self [ \"signature\" ], } header = self . get ( \"header\" ) if header : content [ \"header\" ] = self . header return JwsSignature ( content ) @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> JwsJsonFlat : \"\"\"Signs a payload into a JWS in JSON flat format. Args: payload: the data to sign. jwk: the key to use alg: the signature alg to use extra_protected_headers: additional protected headers to include header: the unprotected header to include **kwargs: extra attributes to include in the JWS Returns: The JWS with the payload, signature, header and extra claims. \"\"\" signature = super () . sign ( payload , jwk , alg , extra_protected_headers , header , ** kwargs ) signature [ \"payload\" ] = BinaPy ( payload ) . to ( \"b64u\" ) . ascii () return cls ( signature ) def generalize ( self ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON general format from this JWS in JSON flat. Returns: A JwsJsonGeneral with the same payload and signature. \"\"\" content = self . copy () protected = content . pop ( \"protected\" ) header = content . pop ( \"header\" , None ) signature = content . pop ( \"signature\" ) jws_signature = { \"protected\" : protected , \"signature\" : signature } if header is not None : jws_signature [ \"header\" ] = header content [ \"signatures\" ] = [ jws_signature ] return JwsJsonGeneral ( content ) def signed_part ( self ) -> bytes : \"\"\"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot (`.`). Returns: The signed data part. \"\"\" return JwsSignature . assemble_signed_part ( self . protected , self . payload ) def compact ( self ) -> JwsCompact : \"\"\"Create a JWS in compact format from this JWS JSON. Returns: A `JwsCompact` with the same payload and signature. \"\"\" return JwsCompact . from_parts ( self . signed_part (), self . signature ) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWS signature with a given key. Args: jwk: the key to use to validate this signature. alg: the signature alg, if only 1 is allowed. algs: the allowed signature algs, if there are several. Returns: `True` if the signature is verified, `False` otherwise. \"\"\" return self . jws_signature . verify ( self . payload , jwk , alg = alg , algs = algs )","title":"JwsJsonFlat"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.payload","text":"1 payload () -> bytes The JWS payload, decoded. Returns: Type Description bytes The raw JWS payload. Source code in jwskate/jws/json.py 20 21 22 23 24 25 26 27 28 29 30 @cached_property def payload ( self ) -> bytes : \"\"\"The JWS payload, decoded. Returns: The raw JWS payload. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" )","title":"payload()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.jws_signature","text":"1 jws_signature () -> JwsSignature The JWS signature. Returns: Type Description JwsSignature The JWS signature. Source code in jwskate/jws/json.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @cached_property def jws_signature ( self ) -> JwsSignature : \"\"\"The JWS signature. Returns: The JWS signature. \"\"\" content = { \"protected\" : self [ \"protected\" ], \"signature\" : self [ \"signature\" ], } header = self . get ( \"header\" ) if header : content [ \"header\" ] = self . header return JwsSignature ( content )","title":"jws_signature()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.sign","text":"1 2 3 4 5 6 7 8 9 10 sign ( payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ] ] = None , header : Optional [ Any ] = None , ** kwargs : Any ) -> JwsJsonFlat Signs a payload into a JWS in JSON flat format. Parameters: Name Type Description Default payload bytes the data to sign. required jwk Union [ Jwk , Dict [ str , Any ]] the key to use required alg Optional [ str ] the signature alg to use None extra_protected_headers Optional [ Mapping [ str , Any ]] additional protected headers to include None header Optional [ Any ] the unprotected header to include None **kwargs Any extra attributes to include in the JWS {} Returns: Type Description JwsJsonFlat The JWS with the payload, signature, header and extra claims. Source code in jwskate/jws/json.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @classmethod def sign ( cls , payload : bytes , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Any ] = None , ** kwargs : Any , ) -> JwsJsonFlat : \"\"\"Signs a payload into a JWS in JSON flat format. Args: payload: the data to sign. jwk: the key to use alg: the signature alg to use extra_protected_headers: additional protected headers to include header: the unprotected header to include **kwargs: extra attributes to include in the JWS Returns: The JWS with the payload, signature, header and extra claims. \"\"\" signature = super () . sign ( payload , jwk , alg , extra_protected_headers , header , ** kwargs ) signature [ \"payload\" ] = BinaPy ( payload ) . to ( \"b64u\" ) . ascii () return cls ( signature )","title":"sign()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.generalize","text":"1 generalize () -> JwsJsonGeneral Create a JWS in JSON general format from this JWS in JSON flat. Returns: Type Description JwsJsonGeneral A JwsJsonGeneral with the same payload and signature. Source code in jwskate/jws/json.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def generalize ( self ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON general format from this JWS in JSON flat. Returns: A JwsJsonGeneral with the same payload and signature. \"\"\" content = self . copy () protected = content . pop ( \"protected\" ) header = content . pop ( \"header\" , None ) signature = content . pop ( \"signature\" ) jws_signature = { \"protected\" : protected , \"signature\" : signature } if header is not None : jws_signature [ \"header\" ] = header content [ \"signatures\" ] = [ jws_signature ] return JwsJsonGeneral ( content )","title":"generalize()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.signed_part","text":"1 signed_part () -> bytes The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot ( . ). Returns: Type Description bytes The signed data part. Source code in jwskate/jws/json.py 93 94 95 96 97 98 99 100 101 def signed_part ( self ) -> bytes : \"\"\"The signed part from this JWS, as bytes. This is a concatenation of the protected header and the payload, separated by a dot (`.`). Returns: The signed data part. \"\"\" return JwsSignature . assemble_signed_part ( self . protected , self . payload )","title":"signed_part()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.compact","text":"1 compact () -> JwsCompact Create a JWS in compact format from this JWS JSON. Returns: Type Description JwsCompact A JwsCompact with the same payload and signature. Source code in jwskate/jws/json.py 103 104 105 106 107 108 109 def compact ( self ) -> JwsCompact : \"\"\"Create a JWS in compact format from this JWS JSON. Returns: A `JwsCompact` with the same payload and signature. \"\"\" return JwsCompact . from_parts ( self . signed_part (), self . signature )","title":"compact()"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.verify_signature","text":"1 2 3 4 5 6 verify_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> bool Verify this JWS signature with a given key. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the key to use to validate this signature. required alg Optional [ str ] the signature alg, if only 1 is allowed. None algs Optional [ Iterable [ str ]] the allowed signature algs, if there are several. None Returns: Type Description bool True if the signature is verified, False otherwise. Source code in jwskate/jws/json.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify this JWS signature with a given key. Args: jwk: the key to use to validate this signature. alg: the signature alg, if only 1 is allowed. algs: the allowed signature algs, if there are several. Returns: `True` if the signature is verified, `False` otherwise. \"\"\" return self . jws_signature . verify ( self . payload , jwk , alg = alg , algs = algs )","title":"verify_signature()"},{"location":"api/#jwskate.jws.InvalidJws","text":"Bases: ValueError Raised when an invalid Jws is parsed. Source code in jwskate/jws/compact.py 19 20 class InvalidJws ( ValueError ): \"\"\"Raised when an invalid Jws is parsed.\"\"\"","title":"InvalidJws"},{"location":"api/#jwskate.jws.JwsCompact","text":"Bases: BaseCompactToken Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Parameters: Name Type Description Default value Union [ bytes , str ] the JWS token value required Source code in jwskate/jws/compact.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class JwsCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Args: value: the JWS token value \"\"\" def __init__ ( self , value : Union [ bytes , str ]): super () . __init__ ( value ) if self . value . count ( b \".\" ) != 2 : raise InvalidJws ( \"A JWS must contain a header, a payload and a signature, separated by dots\" ) header , payload , signature = BinaPy ( self . value ) . split ( b \".\" ) try : self . headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) except ValueError : raise InvalidJws ( \"Invalid JWS header: it must be a Base64URL-encoded JSON object\" ) try : self . payload = BinaPy ( payload ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . signature = BinaPy ( signature ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJws ( \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def sign ( cls , payload : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JwsCompact : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = to_jwk ( jwk ) if not isinstance ( payload , bytes ): payload = bytes ( payload ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature ) @classmethod def from_parts ( cls , signed_part : Union [ bytes , SupportsBytes , str ], signature : Union [ bytes , SupportsBytes , str ], ) -> JwsCompact : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if isinstance ( signed_part , str ): signed_part = signed_part . encode ( \"ascii\" ) if not isinstance ( signed_part , bytes ): signed_part = bytes ( signed_part ) if isinstance ( signature , str ): signature = signature . encode ( \"ascii\" ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . to ( \"b64u\" )))) @cached_property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ]) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = to_jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg = alg , algs = algs ) def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . value . split ( b \".\" ) content = { \"payload\" : payload . decode (), \"protected\" : protected . decode (), \"signature\" : signature . decode (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content ) def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize ()","title":"JwsCompact"},{"location":"api/#jwskate.jws.compact.JwsCompact.sign","text":"1 2 3 4 5 6 sign ( payload : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JwsCompact Sign a payload and returns the resulting JwsCompact. Parameters: Name Type Description Default payload Union [ bytes , SupportsBytes ] the payload to sign required jwk Union [ Jwk , Dict [ str , Any ]] the jwk to use to sign this payload required alg Optional [ str ] the alg to use None extra_headers Optional [ Dict [ str , Any ]] additional headers to add to the Jws Headers None Returns: Type Description JwsCompact the resulting token Source code in jwskate/jws/compact.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @classmethod def sign ( cls , payload : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , ) -> JwsCompact : \"\"\"Sign a payload and returns the resulting JwsCompact. Args: payload: the payload to sign jwk: the jwk to use to sign this payload alg: the alg to use extra_headers: additional headers to add to the Jws Headers Returns: the resulting token \"\"\" jwk = to_jwk ( jwk ) if not isinstance ( payload , bytes ): payload = bytes ( payload ) headers = dict ( extra_headers or {}, alg = alg ) kid = jwk . get ( \"kid\" ) if kid : headers [ \"kid\" ] = kid signed_part = JwsSignature . assemble_signed_part ( headers , payload ) signature = jwk . sign ( signed_part , alg = alg ) return cls . from_parts ( signed_part , signature )","title":"sign()"},{"location":"api/#jwskate.jws.compact.JwsCompact.from_parts","text":"1 2 3 4 from_parts ( signed_part : Union [ bytes , SupportsBytes , str ], signature : Union [ bytes , SupportsBytes , str ], ) -> JwsCompact Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Parameters: Name Type Description Default signed_part Union [ bytes , SupportsBytes , str ] the signed part required signature Union [ bytes , SupportsBytes , str ] the signature value required Returns: Type Description JwsCompact the resulting token Source code in jwskate/jws/compact.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @classmethod def from_parts ( cls , signed_part : Union [ bytes , SupportsBytes , str ], signature : Union [ bytes , SupportsBytes , str ], ) -> JwsCompact : \"\"\"Constructs a JWS token based on its signed part and signature values. Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot. Args: signed_part: the signed part signature: the signature value Returns: the resulting token \"\"\" if isinstance ( signed_part , str ): signed_part = signed_part . encode ( \"ascii\" ) if not isinstance ( signed_part , bytes ): signed_part = bytes ( signed_part ) if isinstance ( signature , str ): signature = signature . encode ( \"ascii\" ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) return cls ( b \".\" . join (( signed_part , BinaPy ( signature ) . to ( \"b64u\" ))))","title":"from_parts()"},{"location":"api/#jwskate.jws.compact.JwsCompact.signed_part","text":"1 signed_part () -> bytes Returns the signed part (header + payload) from this JwsCompact. Returns: Type Description bytes the signed part Source code in jwskate/jws/compact.py 123 124 125 126 127 128 129 130 @cached_property def signed_part ( self ) -> bytes : \"\"\"Returns the signed part (header + payload) from this JwsCompact. Returns: the signed part \"\"\" return b \".\" . join ( self . value . split ( b \".\" , 2 )[: 2 ])","title":"signed_part()"},{"location":"api/#jwskate.jws.compact.JwsCompact.verify_signature","text":"1 2 3 4 5 6 verify_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> bool Verify the signature from this JwsCompact using a Jwk. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the Jwk to use to validate this signature required alg Optional [ str ] the alg to use, if there is only 1 allowed None algs Optional [ Iterable [ str ]] the allowed algs, if here are several None Returns: Type Description bool True if the signature matches, False otherwise Source code in jwskate/jws/compact.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signature from this JwsCompact using a Jwk. Args: jwk: the Jwk to use to validate this signature alg: the alg to use, if there is only 1 allowed algs: the allowed algs, if here are several Returns: `True` if the signature matches, `False` otherwise \"\"\" jwk = to_jwk ( jwk ) return jwk . verify ( self . signed_part , self . signature , alg = alg , algs = algs )","title":"verify_signature()"},{"location":"api/#jwskate.jws.compact.JwsCompact.flat_json","text":"1 flat_json ( unprotected_header : Any = None ) -> JwsJsonFlat Create a JWS in JSON flat format based on this Compact JWS. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonFlat the resulting token Source code in jwskate/jws/compact.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def flat_json ( self , unprotected_header : Any = None ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format based on this Compact JWS. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" from .json import JwsJsonFlat protected , payload , signature = self . value . split ( b \".\" ) content = { \"payload\" : payload . decode (), \"protected\" : protected . decode (), \"signature\" : signature . decode (), } if unprotected_header is not None : content [ \"header\" ] = unprotected_header return JwsJsonFlat ( content )","title":"flat_json()"},{"location":"api/#jwskate.jws.compact.JwsCompact.general_json","text":"1 2 3 general_json ( unprotected_header : Any = None , ) -> JwsJsonGeneral Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Parameters: Name Type Description Default unprotected_header Any optional unprotected header to include in the JWS JSON None Returns: Type Description JwsJsonGeneral the resulting token Source code in jwskate/jws/compact.py 174 175 176 177 178 179 180 181 182 183 184 185 186 def general_json ( self , unprotected_header : Any = None ) -> JwsJsonGeneral : \"\"\"Create a JWS in JSON General format based on this JWS Compact. The resulting token will have a single signature which is the one from this token. Args: unprotected_header: optional unprotected header to include in the JWS JSON Returns: the resulting token \"\"\" jws = self . flat_json ( unprotected_header ) return jws . generalize ()","title":"general_json()"},{"location":"api/#jwskate.jws.JwsJsonGeneral","text":"Bases: BaseJsonDict Represents a JWS in JSON general format (possibly with multiple signatures). Source code in jwskate/jws/json.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 class JwsJsonGeneral ( BaseJsonDict ): \"\"\"Represents a JWS in JSON general format (possibly with multiple signatures).\"\"\" @cached_property def payload ( self ) -> bytes : \"\"\"The raw signed data. Returns: The signed data. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" ) @classmethod def sign ( cls , payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , ], Union [ Jwk , Mapping [ str , Any ]], ], ) -> JwsJsonGeneral : \"\"\"Sign a payload with several keys and return the resulting JWS in JSON general format. Args: payload: the data to sign *signature_parameters: each of those parameter can be: - a `(jwk, alg, extra_protected_headers, header)` tuple - a `(jwk, alg, extra_protected_headers)` tuple, - a `(jwk, alg)` tuple, - a `jwk` with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. Returns: A JwsJsonGeneral with the generated signatures. \"\"\" jws = cls ({ \"payload\" : BinaPy ( payload ) . to ( \"b64u\" ) . ascii ()}) for parameters in signature_parameters : jws . add_signature ( * parameters ) return jws @cached_property def signatures ( self ) -> List [ JwsSignature ]: \"\"\"The list of `JwsSignature` from this JWS. Returns: The list of signatures from this JWS. \"\"\" signatures = self . get ( \"signatures\" ) if signatures is None : raise AttributeError ( \"This Jws JSON does not contain a 'signatures' member\" ) return [ JwsSignature ( sig ) for sig in signatures ] def add_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral : \"\"\"Add a new signature in this JWS. Args: jwk: the private key to use alg: the signature algorithm extra_protected_headers: additional headers to include, as a {key: value} mapping header: the raw unprotected header to include in the signature Returns: the same JWS with the new signature included. \"\"\" self . setdefault ( \"signatures\" , []) self [ \"signatures\" ] . append ( JwsSignature . sign ( self . payload , jwk , alg , extra_protected_headers , header ) ) return self def signed_part ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> bytes : \"\"\"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (`.`). You can select the specific signature with the `signature_chooser` parameter. By default, the first signature is selected. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: The raw signed part from the chosen signature. \"\"\" signature = signature_chooser ( self . signatures ) return JwsSignature . assemble_signed_part ( signature . protected , self . payload ) def compact ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsCompact : \"\"\"Create a compact JWS from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsCompact with the payload and the chosen signature from this JWS. \"\"\" return JwsCompact . from_parts ( self . signed_part ( signature_chooser ), self . payload ) def flatten ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsJsonFlat with the payload and the chosen signature from this JWS. \"\"\" signature = signature_chooser ( self . signatures ) return JwsJsonFlat . from_parts ( payload = self [ \"payload\" ], protected = signature . protected , header = signature . header , signature = signature . signature , ) def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns `True` if at least one signature verifies. Args: jwk: the public key to use alg: the signature algorithm to use, if only 1 is allowed. algs: the allowed signature algorithms, if there are several. Returns: `True` if any of the signature verifies with the given key, `False` otherwise. \"\"\" for signature in self . signatures : if signature . verify ( self . payload , jwk , alg = alg , algs = algs ): return True return False","title":"JwsJsonGeneral"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.payload","text":"1 payload () -> bytes The raw signed data. Returns: Type Description bytes The signed data. Source code in jwskate/jws/json.py 134 135 136 137 138 139 140 141 142 143 144 @cached_property def payload ( self ) -> bytes : \"\"\"The raw signed data. Returns: The signed data. \"\"\" payload = self . get ( \"payload\" ) if payload is None : raise AttributeError ( \"This Jws JSON does not contain a 'payload' member\" ) return BinaPy ( payload ) . decode_from ( \"b64u\" )","title":"payload()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.sign","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sign ( payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str ], Union [ Jwk , Mapping [ str , Any ]], ] ) -> JwsJsonGeneral Sign a payload with several keys and return the resulting JWS in JSON general format. Parameters: Name Type Description Default payload bytes the data to sign required *signature_parameters Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]]], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]]], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str ], Union [ Jwk , Mapping [ str , Any ]]] each of those parameter can be: - a (jwk, alg, extra_protected_headers, header) tuple - a (jwk, alg, extra_protected_headers) tuple, - a (jwk, alg) tuple, - a jwk with jwk being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. () Returns: Type Description JwsJsonGeneral A JwsJsonGeneral with the generated signatures. Source code in jwskate/jws/json.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 @classmethod def sign ( cls , payload : bytes , * signature_parameters : Union [ Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , Optional [ Mapping [ str , Any ]], ], Tuple [ Union [ Jwk , Mapping [ str , Any ]], str , ], Union [ Jwk , Mapping [ str , Any ]], ], ) -> JwsJsonGeneral : \"\"\"Sign a payload with several keys and return the resulting JWS in JSON general format. Args: payload: the data to sign *signature_parameters: each of those parameter can be: - a `(jwk, alg, extra_protected_headers, header)` tuple - a `(jwk, alg, extra_protected_headers)` tuple, - a `(jwk, alg)` tuple, - a `jwk` with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature. Returns: A JwsJsonGeneral with the generated signatures. \"\"\" jws = cls ({ \"payload\" : BinaPy ( payload ) . to ( \"b64u\" ) . ascii ()}) for parameters in signature_parameters : jws . add_signature ( * parameters ) return jws","title":"sign()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.signatures","text":"1 signatures () -> List [ JwsSignature ] The list of JwsSignature from this JWS. Returns: Type Description List [ JwsSignature ] The list of signatures from this JWS. Source code in jwskate/jws/json.py 188 189 190 191 192 193 194 195 196 197 198 @cached_property def signatures ( self ) -> List [ JwsSignature ]: \"\"\"The list of `JwsSignature` from this JWS. Returns: The list of signatures from this JWS. \"\"\" signatures = self . get ( \"signatures\" ) if signatures is None : raise AttributeError ( \"This Jws JSON does not contain a 'signatures' member\" ) return [ JwsSignature ( sig ) for sig in signatures ]","title":"signatures()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.add_signature","text":"1 2 3 4 5 6 7 8 add_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ] ] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral Add a new signature in this JWS. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the private key to use required alg Optional [ str ] the signature algorithm None extra_protected_headers Optional [ Mapping [ str , Any ]] additional headers to include, as a {key: value} mapping None header Optional [ Mapping [ str , Any ]] the raw unprotected header to include in the signature None Returns: Type Description JwsJsonGeneral the same JWS with the new signature included. Source code in jwskate/jws/json.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def add_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None , extra_protected_headers : Optional [ Mapping [ str , Any ]] = None , header : Optional [ Mapping [ str , Any ]] = None , ) -> JwsJsonGeneral : \"\"\"Add a new signature in this JWS. Args: jwk: the private key to use alg: the signature algorithm extra_protected_headers: additional headers to include, as a {key: value} mapping header: the raw unprotected header to include in the signature Returns: the same JWS with the new signature included. \"\"\" self . setdefault ( \"signatures\" , []) self [ \"signatures\" ] . append ( JwsSignature . sign ( self . payload , jwk , alg , extra_protected_headers , header ) ) return self","title":"add_signature()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.signed_part","text":"1 2 3 4 5 signed_part ( signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ] ) -> bytes Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot ( . ). You can select the specific signature with the signature_chooser parameter. By default, the first signature is selected. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description bytes The raw signed part from the chosen signature. Source code in jwskate/jws/json.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def signed_part ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> bytes : \"\"\"Return the signed part from a given signature. The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (`.`). You can select the specific signature with the `signature_chooser` parameter. By default, the first signature is selected. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: The raw signed part from the chosen signature. \"\"\" signature = signature_chooser ( self . signatures ) return JwsSignature . assemble_signed_part ( signature . protected , self . payload )","title":"signed_part()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.compact","text":"1 2 3 4 5 compact ( signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ] ) -> JwsCompact Create a compact JWS from a specific signature from this JWS. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description JwsCompact A JwsCompact with the payload and the chosen signature from this JWS. Source code in jwskate/jws/json.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def compact ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsCompact : \"\"\"Create a compact JWS from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsCompact with the payload and the chosen signature from this JWS. \"\"\" return JwsCompact . from_parts ( self . signed_part ( signature_chooser ), self . payload )","title":"compact()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.flatten","text":"1 2 3 4 5 flatten ( signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ] ) -> JwsJsonFlat Create a JWS in JSON flat format from a specific signature from this JWS. Parameters: Name Type Description Default signature_chooser Callable [[ List [ JwsSignature ]], JwsSignature ] a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. lambda sigs: sigs[0] Returns: Type Description JwsJsonFlat A JwsJsonFlat with the payload and the chosen signature from this JWS. Source code in jwskate/jws/json.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def flatten ( self , signature_chooser : Callable [ [ List [ JwsSignature ]], JwsSignature ] = lambda sigs : sigs [ 0 ], ) -> JwsJsonFlat : \"\"\"Create a JWS in JSON flat format from a specific signature from this JWS. Args: signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature. Returns: A JwsJsonFlat with the payload and the chosen signature from this JWS. \"\"\" signature = signature_chooser ( self . signatures ) return JwsJsonFlat . from_parts ( payload = self [ \"payload\" ], protected = signature . protected , header = signature . header , signature = signature . signature , )","title":"flatten()"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.verify_signature","text":"1 2 3 4 5 6 verify_signature ( jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None ) -> bool Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns True if at least one signature verifies. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the public key to use required alg Optional [ str ] the signature algorithm to use, if only 1 is allowed. None algs Optional [ Iterable [ str ]] the allowed signature algorithms, if there are several. None Returns: Type Description bool True if any of the signature verifies with the given key, False otherwise. Source code in jwskate/jws/json.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 def verify_signature ( self , jwk : Union [ Jwk , Dict [ str , Any ]], * , alg : Optional [ str ] = None , algs : Optional [ Iterable [ str ]] = None , ) -> bool : \"\"\"Verify the signatures from this JWS. It will try to validate each signature with the given key, and returns `True` if at least one signature verifies. Args: jwk: the public key to use alg: the signature algorithm to use, if only 1 is allowed. algs: the allowed signature algorithms, if there are several. Returns: `True` if any of the signature verifies with the given key, `False` otherwise. \"\"\" for signature in self . signatures : if signature . verify ( self . payload , jwk , alg = alg , algs = algs ): return True return False","title":"verify_signature()"},{"location":"api/#jwskate.jwe","text":"This module implements Json Web Encryption as described in RFC7516 .","title":"jwe"},{"location":"api/#jwskate.jwe.InvalidJwe","text":"Bases: ValueError Raised when an invalid JWE token is parsed. Source code in jwskate/jwe/compact.py 20 21 class InvalidJwe ( ValueError ): \"\"\"Raised when an invalid JWE token is parsed.\"\"\"","title":"InvalidJwe"},{"location":"api/#jwskate.jwe.JweCompact","text":"Bases: BaseCompactToken Represents a Json Web Encryption object, in compact representation, as defined in RFC7516. Parameters: Name Type Description Default value Union [ bytes , str ] the compact representation for this Jwe required Source code in jwskate/jwe/compact.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class JweCompact ( BaseCompactToken ): \"\"\"Represents a Json Web Encryption object, in compact representation, as defined in RFC7516. Args: value: the compact representation for this Jwe \"\"\" def __init__ ( self , value : Union [ bytes , str ]): super () . __init__ ( value ) if self . value . count ( b \".\" ) != 4 : raise InvalidJwe ( \"Invalid JWE: a JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots.\" ) header , cek , iv , ciphertext , auth_tag = self . value . split ( b \".\" ) try : headers = BinaPy ( header ) . decode_from ( \"b64u\" ) . parse_from ( \"json\" ) enc = headers . get ( \"enc\" ) if enc is None or not isinstance ( enc , str ): raise InvalidJwe ( \"Invalid JWE header: this JWE doesn't have a valid 'enc' header.\" ) self . headers = headers self . additional_authenticated_data = header except ValueError : raise InvalidJwe ( \"Invalid JWE header: it must be a Base64URL-encoded JSON object.\" ) try : self . wrapped_cek = BinaPy ( cek ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE CEK: it must be a Base64URL-encoded binary data (bytes).\" ) try : self . initialization_vector = BinaPy ( iv ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE IV: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . ciphertext = BinaPy ( ciphertext ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data (bytes)\" ) try : self . authentication_tag = BinaPy ( auth_tag ) . decode_from ( \"b64u\" ) except ValueError : raise InvalidJwe ( \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data (bytes)\" ) @classmethod def from_parts ( cls , * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ), BinaPy ( cek ) . to ( \"b64u\" ), BinaPy ( iv ) . to ( \"b64u\" ), BinaPy ( ciphertext ) . to ( \"b64u\" ), BinaPy ( tag ) . to ( \"b64u\" ), ) ) ) @cached_property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" return self . get_header ( \"enc\" ) # type: ignore[no-any-return] # header has been checked at init time @classmethod def encrypt ( cls , plaintext : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext into a JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use for encryption enc: the encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" extra_headers = extra_headers or {} jwk = to_jwk ( jwk ) alg = select_alg_class ( jwk . KEY_MANAGEMENT_ALGORITHMS , jwk_alg = jwk . alg , alg = alg ) . name cek_jwk , wrapped_cek , cek_headers = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) if jwk . kid is not None : headers [ \"kid\" ] = jwk . kid aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) PBES2_ALGORITHMS : Mapping [ str , Type [ BasePbes2 ]] = { alg . name : alg for alg in [ Pbes2_HS256_A128KW , Pbes2_HS384_A192KW , Pbes2_HS512_A256KW ] } def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> BinaPy : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext @classmethod def encrypt_with_password ( cls , plaintext : Union [ SupportsBytes , bytes ], password : Union [ SupportsBytes , bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '. \" f \"Value must be one of { list ( cls . PBES2_ALGORITHMS . keys ()) } .\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000.\" ) wrapped_cek = wrapper . wrap_key ( cek , salt = salt , count = count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . to ( \"b64u\" ) . ascii (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag ) def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '. \" f \"Value must be one of { list ( self . PBES2_ALGORITHMS . keys ()) } .\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2s' header is missing.\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2c' header is missing.\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise InvalidJwe ( \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt = salt , count = p2c ) return SymmetricJwk . from_bytes ( cek ) def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"JweCompact"},{"location":"api/#jwskate.jwe.compact.JweCompact.from_parts","text":"1 2 3 4 5 6 7 8 from_parts ( * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes ) -> JweCompact Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Parameters: Name Type Description Default headers Mapping [ str , Any ] the headers (as a mapping of name: value) required cek bytes the raw cek required iv bytes the raw iv required ciphertext bytes the raw ciphertext required tag bytes the authentication tag required Returns: Type Description JweCompact the initialized JweCompact instance Source code in jwskate/jwe/compact.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @classmethod def from_parts ( cls , * , headers : Mapping [ str , Any ], cek : bytes , iv : bytes , ciphertext : bytes , tag : bytes , ) -> \"JweCompact\" : \"\"\"Initialize a JWE from its different parts (header, cek, iv, ciphertext, tag). Args: headers: the headers (as a mapping of name: value) cek: the raw cek iv: the raw iv ciphertext: the raw ciphertext tag: the authentication tag Returns: the initialized JweCompact instance \"\"\" return cls ( b \".\" . join ( ( BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ), BinaPy ( cek ) . to ( \"b64u\" ), BinaPy ( iv ) . to ( \"b64u\" ), BinaPy ( ciphertext ) . to ( \"b64u\" ), BinaPy ( tag ) . to ( \"b64u\" ), ) ) )","title":"from_parts()"},{"location":"api/#jwskate.jwe.compact.JweCompact.enc","text":"1 enc () -> str Return the enc from the JWE header. The enc header contains the identifier of the CEK encryption algorithm. Returns: Type Description str the enc value Raises: Type Description AttributeError if there is no enc header or it is not a string Source code in jwskate/jwe/compact.py 116 117 118 119 120 121 122 123 124 125 126 127 128 @cached_property def enc ( self ) -> str : \"\"\"Return the `enc` from the JWE header. The `enc` header contains the identifier of the CEK encryption algorithm. Returns: the enc value Raises: AttributeError: if there is no enc header or it is not a string \"\"\" return self . get_header ( \"enc\" ) # type: ignore[no-any-return]","title":"enc()"},{"location":"api/#jwskate.jwe.compact.JweCompact.encrypt","text":"1 2 3 4 5 6 7 8 9 10 11 encrypt ( plaintext : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None ) -> JweCompact Encrypt an arbitrary plaintext into a JweCompact. Parameters: Name Type Description Default plaintext Union [ bytes , SupportsBytes ] the raw plaintext to encrypt required jwk Union [ Jwk , Dict [ str , Any ]] the public or symmetric key to use for encryption required enc str the encryption algorithm to use required alg Optional [ str ] the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk None extra_headers Optional [ Dict [ str , Any ]] additional headers to include in the generated token None cek Optional [ bytes ] the CEK to force use, for algorithms relying on a random CEK. Leave None to have a safe value generated by jwskate . None iv Optional [ bytes ] the IV to force use. Leave None to have a safe value generated by jwskate . None epk Optional [ Jwk ] the EPK to force use. Leave None to have a safe value generated by jwskate . None Returns: Type Description JweCompact the generated JweCompact instance Source code in jwskate/jwe/compact.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 @classmethod def encrypt ( cls , plaintext : Union [ bytes , SupportsBytes ], jwk : Union [ Jwk , Dict [ str , Any ]], * , enc : str , alg : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , Any ]] = None , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , epk : Optional [ Jwk ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt an arbitrary plaintext into a JweCompact. Args: plaintext: the raw plaintext to encrypt jwk: the public or symmetric key to use for encryption enc: the encryption algorithm to use alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk extra_headers: additional headers to include in the generated token cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`. iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`. epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`. Returns: the generated JweCompact instance \"\"\" extra_headers = extra_headers or {} jwk = to_jwk ( jwk ) alg = select_alg_class ( jwk . KEY_MANAGEMENT_ALGORITHMS , jwk_alg = jwk . alg , alg = alg ) . name cek_jwk , wrapped_cek , cek_headers = jwk . sender_key ( enc = enc , alg = alg , cek = cek , epk = epk , ** extra_headers ) headers = dict ( extra_headers , ** cek_headers , alg = alg , enc = enc ) if jwk . kid is not None : headers [ \"kid\" ] = jwk . kid aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext , aad = aad , iv = iv , alg = enc ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag )","title":"encrypt()"},{"location":"api/#jwskate.jwe.compact.JweCompact.unwrap_cek","text":"1 2 3 unwrap_cek ( jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk Unwrap the CEK from this JWE token using the provided key or password. Parameters: Name Type Description Default jwk_or_password Union [ Jwk , Dict [ str , Any ], bytes , str ] the decryption JWK or password required Returns: Type Description Jwk the unwrapped CEK, as a SymmetricJwk Source code in jwskate/jwe/compact.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def unwrap_cek ( self , jwk_or_password : Union [ Jwk , Dict [ str , Any ], bytes , str ] ) -> Jwk : \"\"\"Unwrap the CEK from this JWE token using the provided key or password. Args: jwk_or_password: the decryption JWK or password Returns: the unwrapped CEK, as a SymmetricJwk \"\"\" if isinstance ( jwk_or_password , ( bytes , str )): password = jwk_or_password return self . unwrap_cek_with_password ( password ) jwk = Jwk ( jwk_or_password ) cek = jwk . recipient_key ( self . wrapped_cek , ** self . headers ) return cek","title":"unwrap_cek()"},{"location":"api/#jwskate.jwe.compact.JweCompact.decrypt","text":"1 decrypt ( jwk : Union [ Jwk , Dict [ str , Any ]]) -> BinaPy Decrypts this Jwe payload using a JWK. Parameters: Name Type Description Default jwk Union [ Jwk , Dict [ str , Any ]] the decryption key required Returns: Type Description BinaPy the decrypted payload Source code in jwskate/jwe/compact.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def decrypt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], ) -> BinaPy : \"\"\"Decrypts this Jwe payload using a JWK. Args: jwk: the decryption key Returns: the decrypted payload \"\"\" cek_jwk = self . unwrap_cek ( jwk ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"decrypt()"},{"location":"api/#jwskate.jwe.compact.JweCompact.encrypt_with_password","text":"1 2 3 4 5 6 7 8 9 10 11 encrypt_with_password ( plaintext : Union [ SupportsBytes , bytes ], password : Union [ SupportsBytes , bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None ) -> JweCompact Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Parameters: Name Type Description Default plaintext Union [ SupportsBytes , bytes ] the data to encrypt required password Union [ SupportsBytes , bytes , str ] the password to use required alg str the Key Management alg to use required enc str the Payload Encryption alg to use required salt Optional [ bytes ] the salt to use. Leave None (default) to have jwskate generate a safe random value None count int the number of PBES2 iterations (recommended minimum 1000) 2000 cek Optional [ bytes ] the CEK to force use. Leave None (default) to have jwskate generate a safe random value None iv Optional [ bytes ] the IV to force use. Leave None (default) to have jwskate generate a safe random value None Returns: Type Description JweCompact the resulting JweCompact Raises: Type Description UnsupportedAlg if the key management alg is not supported ValueError if the count parameter is not a positive integer Source code in jwskate/jwe/compact.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 @classmethod def encrypt_with_password ( cls , plaintext : Union [ SupportsBytes , bytes ], password : Union [ SupportsBytes , bytes , str ], * , alg : str , enc : str , salt : Optional [ bytes ] = None , count : int = 2000 , cek : Optional [ bytes ] = None , iv : Optional [ bytes ] = None , ) -> \"JweCompact\" : \"\"\"Encrypt a payload with a password and return the resulting JweCompact. This performs symmetric encryption using PBES2. Args: plaintext: the data to encrypt password: the password to use alg: the Key Management alg to use enc: the Payload Encryption alg to use salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value count: the number of PBES2 iterations (recommended minimum 1000) cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value Returns: the resulting JweCompact Raises: UnsupportedAlg: if the key management alg is not supported ValueError: if the `count` parameter is not a positive integer \"\"\" keyalg = cls . PBES2_ALGORITHMS . get ( alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { alg } '. \" f \"Value must be one of { list ( cls . PBES2_ALGORITHMS . keys ()) } .\" ) if cek is None : cek_jwk = SymmetricJwk . generate_for_alg ( enc ) cek = cek_jwk . key else : cek_jwk = SymmetricJwk . from_bytes ( cek ) wrapper = keyalg ( password ) if salt is None : salt = wrapper . generate_salt () if count < 1 : raise ValueError ( \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\" ) if count < 1000 : warnings . warn ( \"PBES2 iteration count should be > 1000.\" ) wrapped_cek = wrapper . wrap_key ( cek , salt = salt , count = count ) headers = dict ( alg = alg , enc = enc , p2s = BinaPy ( salt ) . to ( \"b64u\" ) . ascii (), p2c = count ) aad = BinaPy . serialize_to ( \"json\" , headers ) . to ( \"b64u\" ) ciphertext , iv , tag = cek_jwk . encrypt ( plaintext = plaintext , aad = aad , alg = enc , iv = iv ) return cls . from_parts ( headers = headers , cek = wrapped_cek , iv = iv , ciphertext = ciphertext , tag = tag )","title":"encrypt_with_password()"},{"location":"api/#jwskate.jwe.compact.JweCompact.unwrap_cek_with_password","text":"1 2 3 unwrap_cek_with_password ( password : Union [ bytes , str ] ) -> Jwk Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Parameters: Name Type Description Default password Union [ bytes , str ] the decryption password required Returns: Type Description Jwk the CEK, as a SymmetricJwk instance Raises: Type Description UnsupportedAlg if the token key management algorithm is not supported AttributeError if the token misses the PBES2-related headers Source code in jwskate/jwe/compact.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def unwrap_cek_with_password ( self , password : Union [ bytes , str ]) -> Jwk : \"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens. Args: password: the decryption password Returns: the CEK, as a SymmetricJwk instance Raises: UnsupportedAlg: if the token key management algorithm is not supported AttributeError: if the token misses the PBES2-related headers \"\"\" keyalg = self . PBES2_ALGORITHMS . get ( self . alg ) if keyalg is None : raise UnsupportedAlg ( f \"Unsupported password-based encryption algorithm ' { self . alg } '. \" f \"Value must be one of { list ( self . PBES2_ALGORITHMS . keys ()) } .\" ) p2s = self . headers . get ( \"p2s\" ) if p2s is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2s' header is missing.\" ) salt = BinaPy ( p2s ) . decode_from ( \"b64u\" ) p2c = self . headers . get ( \"p2c\" ) if p2c is None : raise InvalidJwe ( \"Invalid JWE: a required 'p2c' header is missing.\" ) if not isinstance ( p2c , int ) or p2c < 1 : raise InvalidJwe ( \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\" ) wrapper = keyalg ( password ) cek = wrapper . unwrap_key ( self . wrapped_cek , salt = salt , count = p2c ) return SymmetricJwk . from_bytes ( cek )","title":"unwrap_cek_with_password()"},{"location":"api/#jwskate.jwe.compact.JweCompact.decrypt_with_password","text":"1 decrypt_with_password ( password : Union [ bytes , str ]) -> bytes Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Parameters: Name Type Description Default password Union [ bytes , str ] the password to use required Returns: Type Description bytes the unencrypted payload Source code in jwskate/jwe/compact.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def decrypt_with_password ( self , password : Union [ bytes , str ]) -> bytes : \"\"\"Decrypt the JWE token with a password. This only works for tokens encrypted with a password. Args: password: the password to use Returns: the unencrypted payload \"\"\" cek_jwk = self . unwrap_cek_with_password ( password ) plaintext = cek_jwk . decrypt ( ciphertext = self . ciphertext , iv = self . initialization_vector , tag = self . authentication_tag , aad = self . additional_authenticated_data , alg = self . enc , ) return plaintext","title":"decrypt_with_password()"},{"location":"api/#jwskate.jwa","text":"This module implements the Json Web Algorithms as defined in RFC7518 . Each algorithm is represented as a wrapper around a symmetric or asymmetric key, and exposes the cryptographic operations as methods. The cryptographic operations themselves are delegated to cryptography .","title":"jwa"},{"location":"api/#jwskate.jwa.P_256","text":"1 2 3 4 5 P_256 = EllipticCurve ( name = \"P-256\" , cryptography_curve = ec . SECP256R1 (), coordinate_size = 32 , ) P-256 curve","title":"P_256"},{"location":"api/#jwskate.jwa.Ed25519","text":"1 2 3 4 5 6 7 Ed25519 = OKPCurve ( name = \"Ed25519\" , description = \"Ed25519 signature algorithm key pairs\" , cryptography_private_key_class = ed25519 . Ed25519PrivateKey , cryptography_public_key_class = ed25519 . Ed25519PublicKey , use = \"sig\" , ) Ed25519 curve.","title":"Ed25519"},{"location":"api/#jwskate.jwa.P_384","text":"1 2 3 4 5 P_384 = EllipticCurve ( name = \"P-384\" , cryptography_curve = ec . SECP384R1 (), coordinate_size = 48 , ) P-384 curve","title":"P_384"},{"location":"api/#jwskate.jwa.Ed448","text":"1 2 3 4 5 6 7 Ed448 = OKPCurve ( name = \"Ed448\" , description = \"Ed448 signature algorithm key pairs\" , cryptography_private_key_class = ed448 . Ed448PrivateKey , cryptography_public_key_class = ed448 . Ed448PublicKey , use = \"sig\" , ) Ed448 curve.","title":"Ed448"},{"location":"api/#jwskate.jwa.P_521","text":"1 2 3 4 5 P_521 = EllipticCurve ( name = \"P-521\" , cryptography_curve = ec . SECP521R1 (), coordinate_size = 66 , ) P-521 curve","title":"P_521"},{"location":"api/#jwskate.jwa.X25519","text":"1 2 3 4 5 6 7 X25519 = OKPCurve ( name = \"X25519\" , description = \"X25519 function key pairs\" , cryptography_private_key_class = x25519 . X25519PrivateKey , cryptography_public_key_class = x25519 . X25519PublicKey , use = \"enc\" , ) X25519 curve.","title":"X25519"},{"location":"api/#jwskate.jwa.secp256k1","text":"1 2 3 4 5 secp256k1 = EllipticCurve ( name = \"secp256k1\" , cryptography_curve = ec . SECP256K1 (), coordinate_size = 32 , ) secp256k1 curve","title":"secp256k1"},{"location":"api/#jwskate.jwa.X448","text":"1 2 3 4 5 6 7 X448 = OKPCurve ( name = \"X448\" , description = \"X448 function key pairs\" , cryptography_private_key_class = x448 . X448PrivateKey , cryptography_public_key_class = x448 . X448PublicKey , use = \"enc\" , ) X448 curve.","title":"X448"},{"location":"api/#jwskate.jwa.BaseAesKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Base class for AES KW algorithms. Source code in jwskate/jwa/key_mgmt/aeskw.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class BaseAesKeyWrap ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Base class for AES KW algorithms.\"\"\" key_size : int \"\"\"Required AES key size in bits.\"\"\" @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits.\" ) def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey )) def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" if not isinstance ( cipherkey , bytes ): cipherkey = bytes ( cipherkey ) return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey ))","title":"BaseAesKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.key_size","text":"1 key_size : int Required AES key size in bits.","title":"key_size"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.check_key","text":"1 check_key ( key : bytes ) -> None Check that a key is valid for usage with this algorithm. To be valid, a key must be bytes and be of appropriate length (128, 192 or 256 bits). Parameters: Name Type Description Default key bytes a key to check required Raises: Type Description ValueError if the key is not appropriate Source code in jwskate/jwa/key_mgmt/aeskw.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is valid for usage with this algorithm. To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits). Args: key: a key to check Raises: ValueError: if the key is not appropriate \"\"\" if not isinstance ( key , bytes ) or len ( key ) * 8 != cls . key_size : raise ValueError ( f \"Key must be { cls . key_size } bits.\" )","title":"check_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.wrap_key","text":"1 wrap_key ( plainkey : bytes ) -> BinaPy Wrap a key. Parameters: Name Type Description Default plainkey bytes the key to wrap. required Returns: Name Type Description BinaPy BinaPy the wrapped key. Source code in jwskate/jwa/key_mgmt/aeskw.py 31 32 33 34 35 36 37 38 39 40 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a key. Args: plainkey: the key to wrap. Returns: BinaPy: the wrapped key. \"\"\" return BinaPy ( keywrap . aes_key_wrap ( self . key , plainkey ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.unwrap_key","text":"1 2 3 unwrap_key ( cipherkey : Union [ bytes , SupportsBytes ] ) -> BinaPy Unwrap a key. Parameters: Name Type Description Default cipherkey Union [ bytes , SupportsBytes ] the wrapped key. required Returns: Name Type Description BinaPy BinaPy the unwrapped key. Source code in jwskate/jwa/key_mgmt/aeskw.py 42 43 44 45 46 47 48 49 50 51 52 53 54 def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Unwrap a key. Args: cipherkey: the wrapped key. Returns: BinaPy: the unwrapped key. \"\"\" if not isinstance ( cipherkey , bytes ): cipherkey = bytes ( cipherkey ) return BinaPy ( keywrap . aes_key_unwrap ( self . key , cipherkey ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.DirectKeyUse","text":"Bases: BaseKeyManagementAlg , BaseSymmetricAlg Direct use of a shared symmetric key as the CEK. Source code in jwskate/jwa/key_mgmt/dir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DirectKeyUse ( BaseKeyManagementAlg , BaseSymmetricAlg ): \"\"\"Direct use of a shared symmetric key as the CEK.\"\"\" name = \"dir\" description = __doc__ def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"DirectKeyUse"},{"location":"api/#jwskate.jwa.key_mgmt.dir.DirectKeyUse.direct_key","text":"1 direct_key ( aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy Check that the current key is appropriate for a given alg and return that same key. Parameters: Name Type Description Default aesalg Type [ BaseSymmetricAlg ] the AES encryption alg to use required Returns: Type Description BinaPy the current configured key, as-is Source code in jwskate/jwa/key_mgmt/dir.py 16 17 18 19 20 21 22 23 24 25 26 def direct_key ( self , aesalg : Type [ BaseSymmetricAlg ]) -> BinaPy : \"\"\"Check that the current key is appropriate for a given alg and return that same key. Args: aesalg: the AES encryption alg to use Returns: the current configured key, as-is \"\"\" aesalg . check_key ( self . key ) return BinaPy ( self . key )","title":"direct_key()"},{"location":"api/#jwskate.jwa.BaseAesGcmKeyWrap","text":"Bases: BaseAESGCM , BaseKeyManagementAlg Base class for AES-GCM Key wrapping algorithms. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class BaseAesGcmKeyWrap ( BaseAESGCM , BaseKeyManagementAlg ): \"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\" use = \"enc\" key_size : int \"\"\"Required key size, in bits.\"\"\" tag_size : int = 16 \"\"\"Authentication tag size, in bits.\"\"\" iv_size : int = 96 \"\"\"Initialisation Vector size, in bits.\"\"\" def wrap_key ( self , plainkey : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a symmetric key, which is typically used as Content Encryption Key (CEK). This method is used by the sender of the encrypted message. This needs a random Initialisation Vector (`iv`) of the appropriate size, which you can generate using the classmethod `generate_iv()`. Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv = iv ) def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ], * , tag : Union [ bytes , SupportsBytes ], iv : Union [ bytes , SupportsBytes ] ) -> BinaPy : \"\"\"Unwrap a symmetric key. This method is used by the recipient of an encrypted message. This requires: - the same IV that was provided during encryption - the same Authentication Tag that was generated during encryption Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , auth_tag = tag , iv = iv )","title":"BaseAesGcmKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.key_size","text":"1 key_size : int Required key size, in bits.","title":"key_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.tag_size","text":"1 tag_size : int = 16 Authentication tag size, in bits.","title":"tag_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.iv_size","text":"1 iv_size : int = 96 Initialisation Vector size, in bits.","title":"iv_size"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.wrap_key","text":"1 2 3 4 5 wrap_key ( plainkey : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ] ) -> Tuple [ BinaPy , BinaPy ] Wrap a symmetric key, which is typically used as Content Encryption Key (CEK). This method is used by the sender of the encrypted message. This needs a random Initialisation Vector ( iv ) of the appropriate size, which you can generate using the classmethod generate_iv() . Parameters: Name Type Description Default plainkey Union [ bytes , SupportsBytes ] the key to wrap required iv Union [ bytes , SupportsBytes ] the Initialisation Vector to use required Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple (wrapped_key, authentication_tag) Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def wrap_key ( self , plainkey : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ] ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Wrap a symmetric key, which is typically used as Content Encryption Key (CEK). This method is used by the sender of the encrypted message. This needs a random Initialisation Vector (`iv`) of the appropriate size, which you can generate using the classmethod `generate_iv()`. Args: plainkey: the key to wrap iv: the Initialisation Vector to use Returns: a tuple (wrapped_key, authentication_tag) \"\"\" return self . encrypt ( plainkey , iv = iv )","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.unwrap_key","text":"1 2 3 4 5 6 unwrap_key ( cipherkey : Union [ bytes , SupportsBytes ], * , tag : Union [ bytes , SupportsBytes ], iv : Union [ bytes , SupportsBytes ] ) -> BinaPy Unwrap a symmetric key. This method is used by the recipient of an encrypted message. This requires: - the same IV that was provided during encryption - the same Authentication Tag that was generated during encryption Parameters: Name Type Description Default cipherkey Union [ bytes , SupportsBytes ] the wrapped key required tag Union [ bytes , SupportsBytes ] the authentication tag required iv Union [ bytes , SupportsBytes ] the Initialisation Vector required Returns: Type Description BinaPy the unwrapped key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ], * , tag : Union [ bytes , SupportsBytes ], iv : Union [ bytes , SupportsBytes ] ) -> BinaPy : \"\"\"Unwrap a symmetric key. This method is used by the recipient of an encrypted message. This requires: - the same IV that was provided during encryption - the same Authentication Tag that was generated during encryption Args: cipherkey: the wrapped key tag: the authentication tag iv: the Initialisation Vector Returns: the unwrapped key. \"\"\" return self . decrypt ( cipherkey , auth_tag = tag , iv = iv )","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.BaseHMACSigAlg","text":"Bases: BaseSymmetricAlg , BaseSignatureAlg Base class for HMAC signature algorithms. Source code in jwskate/jwa/signature/hmac.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class BaseHMACSigAlg ( BaseSymmetricAlg , BaseSignatureAlg ): \"\"\"Base class for HMAC signature algorithms.\"\"\" mac : Type [ hmac . HMAC ] = hmac . HMAC hashing_alg : hashes . HashAlgorithm min_key_size : int def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) if self . read_only : raise NotImplementedError m = self . mac ( self . key , self . hashing_alg ) m . update ( data ) signature = m . finalize () return BinaPy ( signature ) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) candidate_signature = self . sign ( data ) return candidate_signature == signature","title":"BaseHMACSigAlg"},{"location":"api/#jwskate.jwa.PrivateKeyRequired","text":"Bases: AttributeError Raised when a cryptographic operation requires a private key, and a public key has been provided instead. Source code in jwskate/jwa/base.py 12 13 class PrivateKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a private key, and a public key has been provided instead.\"\"\"","title":"PrivateKeyRequired"},{"location":"api/#jwskate.jwa.EllipticCurve","text":"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a cryptography.ec.EllipticCurve , and a coordinate size. Source code in jwskate/jwa/ec.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @dataclass class EllipticCurve : \"\"\"A descriptive class for Elliptic Curves. Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size. \"\"\" name : str \"\"\" Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` or `enc` fields in JOSE headers.\"\"\" cryptography_curve : ec . EllipticCurve \"\"\"`cryptography` curve instance.\"\"\" coordinate_size : int \"\"\"Coordinate size, in bytes.\"\"\" instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key: an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" ) @classmethod def get_jwk_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from the given `cryptography` key. Key must be an instance of `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a dict of JWK parameters matching that key Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) public_numbers : ec . EllipticCurvePublicNumbers if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () y = BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters","title":"EllipticCurve"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.name","text":"1 name : str Curve name as defined in IANA JOSE . This name will appear in alg or enc fields in JOSE headers.","title":"name"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.cryptography_curve","text":"1 cryptography_curve : ec . EllipticCurve cryptography curve instance.","title":"cryptography_curve"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.coordinate_size","text":"1 coordinate_size : int Coordinate size, in bytes.","title":"coordinate_size"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.instances","text":"1 instances : ClassVar [ Dict [ str , EllipticCurve ]] = {} Registry of subclasses, in a {name: instance} mapping.","title":"instances"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.__post_init__","text":"1 __post_init__ () -> None Automatically register subclasses in the instance registry. Source code in jwskate/jwa/ec.py 33 34 35 def __post_init__ ( self ) -> None : \"\"\"Automatically register subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self","title":"__post_init__()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.generate","text":"1 generate () -> Tuple [ int , int , int ] Generate a new EC key on this curve. Returns: Type Description Tuple [ int , int , int ] a tuple of 4 int s: x and y coordinates (public key) and d (private key) Source code in jwskate/jwa/ec.py 37 38 39 40 41 42 43 44 45 46 47 48 def generate ( self ) -> Tuple [ int , int , int ]: \"\"\"Generate a new EC key on this curve. Returns: a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key) \"\"\" key = ec . generate_private_key ( self . cryptography_curve ) pn = key . private_numbers () # type: ignore x = pn . public_numbers . x y = pn . public_numbers . y d = pn . private_value return x , y , d","title":"generate()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_curve","text":"1 2 3 4 5 6 get_curve ( key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey , ] ) -> EllipticCurve Get the appropriate EllipticCurve instance for a given cryptography EllipticCurvePublicKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] an Elliptic Curve private or public key from cryptography . required Returns: Type Description EllipticCurve the appropriate instance of EllipticCurve for the given key. Raises: Type Description NotImplementedError if the curve is not supported Source code in jwskate/jwa/ec.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def get_curve ( cls , key : Union [ ec . EllipticCurvePublicKey , ec . EllipticCurvePrivateKey ] ) -> \"EllipticCurve\" : \"\"\"Get the appropriate `EllipticCurve` instance for a given `cryptography` `EllipticCurvePublicKey`. Args: key: an Elliptic Curve private or public key from `cryptography`. Returns: the appropriate instance of EllipticCurve for the given key. Raises: NotImplementedError: if the curve is not supported \"\"\" for c in cls . instances . values (): if c . cryptography_curve . name == key . curve . name : return c raise NotImplementedError ( f \"Unsupported Curve { key . curve . name } \" )","title":"get_curve()"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_jwk_parameters","text":"1 2 3 4 5 6 get_jwk_parameters ( key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey , ] ) -> Dict [ str , Any ] Extract all private and public parameters from the given cryptography key. Key must be an instance of EllipticCurvePrivateKey or EllipticCurvePublicKey . Parameters: Name Type Description Default key Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] an Elliptic Curve public or private key from cryptography . required Returns: Type Description Dict [ str , Any ] a dict of JWK parameters matching that key Raises: Type Description TypeError if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey Source code in jwskate/jwa/ec.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @classmethod def get_jwk_parameters ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> Dict [ str , Any ]: \"\"\"Extract all private and public parameters from the given `cryptography` key. Key must be an instance of `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`. Args: key: an Elliptic Curve public or private key from `cryptography`. Returns: a dict of JWK parameters matching that key Raises: TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey \"\"\" if not isinstance ( key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey )): raise TypeError ( \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\" ) crv = cls . get_curve ( key ) public_numbers : ec . EllipticCurvePublicNumbers if isinstance ( key , ec . EllipticCurvePrivateKey ): public_numbers = key . public_key () . public_numbers () elif isinstance ( key , ec . EllipticCurvePublicKey ): public_numbers = key . public_numbers () x = BinaPy . from_int ( public_numbers . x , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () y = BinaPy . from_int ( public_numbers . y , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () parameters = { \"kty\" : \"EC\" , \"crv\" : crv . name , \"x\" : x , \"y\" : y } if isinstance ( key , ec . EllipticCurvePrivateKey ): pn = key . private_numbers () # type: ignore d = ( BinaPy . from_int ( pn . private_value , crv . coordinate_size ) . to ( \"b64u\" ) . ascii () ) parameters [ \"d\" ] = d return parameters","title":"get_jwk_parameters()"},{"location":"api/#jwskate.jwa.BaseRsaKeyWrap","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ rsa . RSAPrivateKey , rsa . RSAPublicKey ] Base class for RSA Key Wrapping algorithms. Parameters: Name Type Description Default key Union [ rsa . RSAPublicKey , rsa . RSAPrivateKey ] the private or public key to use required Source code in jwskate/jwa/key_mgmt/rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class BaseRsaKeyWrap ( BaseKeyManagementAlg , BaseAsymmetricAlg [ rsa . RSAPrivateKey , rsa . RSAPublicKey ], ): \"\"\"Base class for RSA Key Wrapping algorithms. Args: key: the private or public key to use \"\"\" padding : Any name : str description : str private_key_class = rsa . RSAPrivateKey public_key_class = rsa . RSAPublicKey def __init__ ( self , key : Union [ rsa . RSAPublicKey , rsa . RSAPrivateKey ]): self . key = key def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" if self . read_only : raise NotImplementedError ( \"Due to security reasons, this algorithm is only usable for decryption.\" ) with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding )) def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" if not isinstance ( cipherkey , bytes ): cipherkey = bytes ( cipherkey ) with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"BaseRsaKeyWrap"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.wrap_key","text":"1 wrap_key ( plainkey : bytes ) -> BinaPy Wrap a symmetric key using this algorithm. Parameters: Name Type Description Default plainkey bytes the symmetric key to wrap required Returns: Type Description BinaPy the wrapped key Raises: Type Description PublicKeyRequired if this algorithm is initialized with a private key instead of a public key Source code in jwskate/jwa/key_mgmt/rsa.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def wrap_key ( self , plainkey : bytes ) -> BinaPy : \"\"\"Wrap a symmetric key using this algorithm. Args: plainkey: the symmetric key to wrap Returns: the wrapped key Raises: PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key \"\"\" if self . read_only : raise NotImplementedError ( \"Due to security reasons, this algorithm is only usable for decryption.\" ) with self . public_key_required () as key : return BinaPy ( key . encrypt ( plainkey , self . padding ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.unwrap_key","text":"1 2 3 unwrap_key ( cipherkey : Union [ bytes , SupportsBytes ] ) -> BinaPy Unwrap a symmetric key with this alg. Parameters: Name Type Description Default cipherkey Union [ bytes , SupportsBytes ] the wrapped key required Returns: Type Description BinaPy the unwrapped clear-text key Raises: Type Description PrivateKeyRequired if this alg is initialized with a public key instead of a private key Source code in jwskate/jwa/key_mgmt/rsa.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def unwrap_key ( self , cipherkey : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Unwrap a symmetric key with this alg. Args: cipherkey: the wrapped key Returns: the unwrapped clear-text key Raises: PrivateKeyRequired: if this alg is initialized with a public key instead of a private key \"\"\" if not isinstance ( cipherkey , bytes ): cipherkey = bytes ( cipherkey ) with self . private_key_required () as key : return BinaPy ( key . decrypt ( cipherkey , self . padding ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.BaseRSASigAlg","text":"Bases: BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ] , BaseSignatureAlg Base class for RSA based signature algorithms. Source code in jwskate/jwa/signature/rsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class BaseRSASigAlg ( BaseAsymmetricAlg [ asymmetric . rsa . RSAPrivateKey , asymmetric . rsa . RSAPublicKey ], BaseSignatureAlg , ): \"\"\"Base class for RSA based signature algorithms.\"\"\" hashing_alg : hashes . HashAlgorithm padding_alg : padding . AsymmetricPadding = padding . PKCS1v15 () min_key_size : int = 2048 private_key_class = asymmetric . rsa . RSAPrivateKey public_key_class = asymmetric . rsa . RSAPublicKey def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Sign arbitrary data. Args: data: the data to sign Returns: the generated signature Raises: NotImplementedError: for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired: if the configured key is not private \"\"\" if self . read_only : raise NotImplementedError if not isinstance ( data , bytes ): data = bytes ( data ) with self . private_key_required () as key : return BinaPy ( key . sign ( data , self . padding_alg , self . hashing_alg )) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : \"\"\"Verify a signature against some data. Args: data: the data to verify signature: the signature Returns: `True` if the signature is valid, `False` otherwise \"\"\" if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) with self . public_key_required () as key : try : key . verify ( signature , data , self . padding_alg , self . hashing_alg , ) return True except exceptions . InvalidSignature : return False","title":"BaseRSASigAlg"},{"location":"api/#jwskate.jwa.signature.rsa.BaseRSASigAlg.sign","text":"1 sign ( data : Union [ bytes , SupportsBytes ]) -> BinaPy Sign arbitrary data. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the data to sign required Returns: Type Description BinaPy the generated signature Raises: Type Description NotImplementedError for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired if the configured key is not private Source code in jwskate/jwa/signature/rsa.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Sign arbitrary data. Args: data: the data to sign Returns: the generated signature Raises: NotImplementedError: for algorithms that are considered insecure, only signature verification is available PrivateKeyRequired: if the configured key is not private \"\"\" if self . read_only : raise NotImplementedError if not isinstance ( data , bytes ): data = bytes ( data ) with self . private_key_required () as key : return BinaPy ( key . sign ( data , self . padding_alg , self . hashing_alg ))","title":"sign()"},{"location":"api/#jwskate.jwa.signature.rsa.BaseRSASigAlg.verify","text":"1 2 3 4 verify ( data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], ) -> bool Verify a signature against some data. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the data to verify required signature Union [ bytes , SupportsBytes ] the signature required Returns: Type Description bool True if the signature is valid, False otherwise Source code in jwskate/jwa/signature/rsa.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : \"\"\"Verify a signature against some data. Args: data: the data to verify signature: the signature Returns: `True` if the signature is valid, `False` otherwise \"\"\" if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) with self . public_key_required () as key : try : key . verify ( signature , data , self . padding_alg , self . hashing_alg , ) return True except exceptions . InvalidSignature : return False","title":"verify()"},{"location":"api/#jwskate.jwa.EdDsa","text":"Bases: BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ]] , BaseSignatureAlg EdDSA signature algorithms. Source code in jwskate/jwa/signature/eddsa.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class EdDsa ( BaseAsymmetricAlg [ Union [ ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ], Union [ ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ], ], BaseSignatureAlg , ): \"\"\"EdDSA signature algorithms.\"\"\" private_key_class = ( ed25519 . Ed25519PrivateKey , ed448 . Ed448PrivateKey ) public_key_class = ( ed25519 . Ed25519PublicKey , ed448 . Ed448PublicKey ) name = \"EdDSA\" description = __doc__ def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) with self . private_key_required () as key : return BinaPy ( key . sign ( data )) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) with self . public_key_required () as key : try : key . verify ( signature , data ) return True except exceptions . InvalidSignature : return False","title":"EdDsa"},{"location":"api/#jwskate.jwa.BasePbes2","text":"Bases: BaseKeyManagementAlg Base class for PBES2 based algorithms. PBES2 derives a cryptographic key from a human-provided password. Parameters: Name Type Description Default password Union [ SupportsBytes , bytes , str ] the encryption/decryption password to use required Source code in jwskate/jwa/key_mgmt/pbes2.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class BasePbes2 ( BaseKeyManagementAlg ): \"\"\"Base class for PBES2 based algorithms. PBES2 derives a cryptographic key from a human-provided password. Args: password: the encryption/decryption password to use \"\"\" kwalg : Type [ BaseAesKeyWrap ] hash_alg : hashes . HashAlgorithm def __init__ ( self , password : Union [ SupportsBytes , bytes , str ]): if isinstance ( password , str ): password = password . encode ( \"utf-8\" ) if not isinstance ( password , bytes ): password = bytes ( password ) self . password = password def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size ) def derive ( self , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive an encryption key based on the configured password, a given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password )) def wrap_key ( self , plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey )) def unwrap_key ( self , cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"BasePbes2"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.generate_salt","text":"1 generate_salt ( size : int = 12 ) -> BinaPy Generate a salt that is suitable for use for encryption. Parameters: Name Type Description Default size int size of the generated salt, in bytes 12 Returns: Type Description BinaPy the generated salt Raises: Type Description ValueError if the salt is less than 8 bytes long Source code in jwskate/jwa/key_mgmt/pbes2.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def generate_salt ( self , size : int = 12 ) -> BinaPy : \"\"\"Generate a salt that is suitable for use for encryption. Args: size: size of the generated salt, in bytes Returns: the generated salt Raises: ValueError: if the salt is less than 8 bytes long \"\"\" if size < 8 : raise ValueError ( \"salts used for PBES2 must be at least 8 bytes long\" ) return BinaPy . random ( size )","title":"generate_salt()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.derive","text":"1 derive ( * , salt : bytes , count : int ) -> BinaPy Derive an encryption key based on the configured password, a given salt and the number of PBKDF iterations. Parameters: Name Type Description Default salt bytes the generated salt required count int number of PBKDF iterations required Returns: Type Description BinaPy the generated encryption/decryption key Source code in jwskate/jwa/key_mgmt/pbes2.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def derive ( self , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Derive an encryption key based on the configured password, a given salt and the number of PBKDF iterations. Args: salt: the generated salt count: number of PBKDF iterations Returns: the generated encryption/decryption key \"\"\" full_salt = self . name . encode () + b \" \\0 \" + salt pbkdf = pbkdf2 . PBKDF2HMAC ( algorithm = self . hash_alg , length = self . kwalg . key_size // 8 , salt = full_salt , iterations = count , ) return BinaPy ( pbkdf . derive ( self . password ))","title":"derive()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.wrap_key","text":"1 2 3 wrap_key ( plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy Wrap a key using this alg. Parameters: Name Type Description Default plainkey bytes the key to wrap required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the wrapped key Source code in jwskate/jwa/key_mgmt/pbes2.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def wrap_key ( self , plainkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Wrap a key using this alg. Args: plainkey: the key to wrap salt: the salt to use count: the number of PBKDF iterations Returns: the wrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . wrap_key ( plainkey ))","title":"wrap_key()"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.unwrap_key","text":"1 2 3 unwrap_key ( cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy Unwrap a key using this alg. Parameters: Name Type Description Default cipherkey bytes the wrapped key required salt bytes the salt to use required count int the number of PBKDF iterations required Returns: Type Description BinaPy the unwrapped key Source code in jwskate/jwa/key_mgmt/pbes2.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def unwrap_key ( self , cipherkey : bytes , * , salt : bytes , count : int ) -> BinaPy : \"\"\"Unwrap a key using this alg. Args: cipherkey: the wrapped key salt: the salt to use count: the number of PBKDF iterations Returns: the unwrapped key \"\"\" aes_key = self . derive ( salt = salt , count = count ) return BinaPy ( self . kwalg ( aes_key ) . unwrap_key ( cipherkey ))","title":"unwrap_key()"},{"location":"api/#jwskate.jwa.BaseECSignatureAlg","text":"Bases: BaseAsymmetricAlg [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] , BaseSignatureAlg Base class for Elliptic Curve signature algorithms. Source code in jwskate/jwa/signature/ec.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class BaseECSignatureAlg ( BaseAsymmetricAlg [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ], BaseSignatureAlg , ): \"\"\"Base class for Elliptic Curve signature algorithms.\"\"\" curve : EllipticCurve hashing_alg : hashes . HashAlgorithm public_key_class = ec . EllipticCurvePublicKey private_key_class = ec . EllipticCurvePrivateKey @classmethod def check_key ( cls , key : Union [ ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ] ) -> None : # noqa: D102 if key . curve . name != cls . curve . cryptography_curve . name : raise ValueError ( f \"This key is on curve { key . curve . name } . An EC key on curve { cls . curve . name } is expected.\" ) def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) with self . private_key_required () as key : dss_sig = key . sign ( data , ec . ECDSA ( self . hashing_alg )) r , s = asymmetric . utils . decode_dss_signature ( dss_sig ) return BinaPy . from_int ( r , self . curve . coordinate_size ) + BinaPy . from_int ( s , self . curve . coordinate_size ) def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : # noqa: D102 if not isinstance ( data , bytes ): data = bytes ( data ) if not isinstance ( signature , bytes ): signature = bytes ( signature ) with self . public_key_required () as key : if len ( signature ) != self . curve . coordinate_size * 2 : raise ValueError ( f \"Invalid signature length { len ( signature ) } bytes, expected { self . curve . coordinate_size * 2 } bytes\" ) r_bytes , s_bytes = ( signature [: self . curve . coordinate_size ], signature [ self . curve . coordinate_size :], ) r = int . from_bytes ( r_bytes , \"big\" , signed = False ) s = int . from_bytes ( s_bytes , \"big\" , signed = False ) dss_signature = asymmetric . utils . encode_dss_signature ( r , s ) try : key . verify ( dss_signature , data , ec . ECDSA ( self . hashing_alg ), ) return True except exceptions . InvalidSignature : return False","title":"BaseECSignatureAlg"},{"location":"api/#jwskate.jwa.EcdhEs","text":"Bases: BaseKeyManagementAlg , BaseAsymmetricAlg [ Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ]] Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF. Source code in jwskate/jwa/key_mgmt/ecdh.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class EcdhEs ( BaseKeyManagementAlg , BaseAsymmetricAlg [ Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ], ): \"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\" name = \"ECDH-ES\" description = __doc__ public_key_class = ( ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ) private_key_class = ( ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ) @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , key_size : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo key_size: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( key_size or key_size , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo ) @classmethod def ecdh ( cls , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" if isinstance ( private_key , ec . EllipticCurvePrivateKey ) and isinstance ( public_key , ec . EllipticCurvePublicKey ): shared_key = private_key . exchange ( ec . ECDH (), public_key ) elif isinstance ( private_key , x25519 . X25519PrivateKey ) and isinstance ( public_key , x25519 . X25519PublicKey ): shared_key = private_key . exchange ( public_key ) elif isinstance ( private_key , x448 . X448PrivateKey ) and isinstance ( public_key , x448 . X448PublicKey ): shared_key = private_key . exchange ( public_key ) else : raise ValueError ( \"Invalid or unsupported private/public key combination for ECDH\" , type ( private_key ), type ( public_key ), ) return BinaPy ( shared_key ) @classmethod def derive ( cls , * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], otherinfo : bytes , key_size : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter key_size: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = key_size // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key )) def generate_ephemeral_key ( self , ) -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ]: \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" if isinstance ( self . key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ) ): return ec . generate_private_key ( self . key . curve ) elif isinstance ( self . key , ( x25519 . X25519PrivateKey , x25519 . X25519PublicKey )): return x25519 . X25519PrivateKey . generate () elif isinstance ( self . key , ( x448 . X448PublicKey , x448 . X448PrivateKey )): return x448 . X448PrivateKey . generate () def sender_key ( self , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = ephemeral_private_key , public_key = key , otherinfo = otherinfo , key_size = key_size , ) return cek def recipient_key ( self , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = key , public_key = ephemeral_public_key , otherinfo = otherinfo , key_size = key_size , ) return cek","title":"EcdhEs"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.otherinfo","text":"1 2 3 otherinfo ( alg : str , apu : bytes , apv : bytes , key_size : int ) -> BinaPy Build the \"otherinfo\" parameter for Concat KDF Hash. Parameters: Name Type Description Default alg str identifier for the encryption alg required apu bytes Agreement PartyUInfo required apv bytes Agreement PartyVInfo required key_size int length of the generated key required Returns: Type Description BinaPy the \"otherinfo\" value Source code in jwskate/jwa/key_mgmt/ecdh.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @classmethod def otherinfo ( cls , alg : str , apu : bytes , apv : bytes , key_size : int ) -> BinaPy : \"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash. Args: alg: identifier for the encryption alg apu: Agreement PartyUInfo apv: Agreement PartyVInfo key_size: length of the generated key Returns: the \"otherinfo\" value \"\"\" algorithm_id = BinaPy . from_int ( len ( alg ), length = 4 ) + BinaPy ( alg ) partyuinfo = BinaPy . from_int ( len ( apu ), length = 4 ) + apu partyvinfo = BinaPy . from_int ( len ( apv ), length = 4 ) + apv supppubinfo = BinaPy . from_int ( key_size or key_size , length = 4 ) otherinfo = b \"\" . join (( algorithm_id , partyuinfo , partyvinfo , supppubinfo )) return BinaPy ( otherinfo )","title":"otherinfo()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.ecdh","text":"1 2 3 4 5 6 7 8 9 10 11 12 ecdh ( private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ], ) -> BinaPy This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Parameters: Name Type Description Default private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] a private EC key required public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] a public EC key required Returns: Type Description BinaPy a shared key Source code in jwskate/jwa/key_mgmt/ecdh.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @classmethod def ecdh ( cls , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ) -> BinaPy : \"\"\"This does an Elliptic Curve Diffie Hellman key exchange. This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key. Args: private_key: a private EC key public_key: a public EC key Returns: a shared key \"\"\" if isinstance ( private_key , ec . EllipticCurvePrivateKey ) and isinstance ( public_key , ec . EllipticCurvePublicKey ): shared_key = private_key . exchange ( ec . ECDH (), public_key ) elif isinstance ( private_key , x25519 . X25519PrivateKey ) and isinstance ( public_key , x25519 . X25519PublicKey ): shared_key = private_key . exchange ( public_key ) elif isinstance ( private_key , x448 . X448PrivateKey ) and isinstance ( public_key , x448 . X448PublicKey ): shared_key = private_key . exchange ( public_key ) else : raise ValueError ( \"Invalid or unsupported private/public key combination for ECDH\" , type ( private_key ), type ( public_key ), ) return BinaPy ( shared_key )","title":"ecdh()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.derive","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 derive ( * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ], otherinfo : bytes , key_size : int ) -> BinaPy Derive a key using ECDH and Concat KDF Hash. Parameters: Name Type Description Default private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the private key required public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the public key required otherinfo bytes the Concat KDF \"otherinfo\" parameter required key_size int the expected CEK key size required Returns: Type Description BinaPy the derived key Source code in jwskate/jwa/key_mgmt/ecdh.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 @classmethod def derive ( cls , * , private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], otherinfo : bytes , key_size : int , ) -> BinaPy : \"\"\"Derive a key using ECDH and Concat KDF Hash. Args: private_key: the private key public_key: the public key otherinfo: the Concat KDF \"otherinfo\" parameter key_size: the expected CEK key size Returns: the derived key \"\"\" shared_key = cls . ecdh ( private_key , public_key ) ckdf = ConcatKDFHash ( algorithm = hashes . SHA256 (), length = key_size // 8 , otherinfo = otherinfo ) return BinaPy ( ckdf . derive ( shared_key ))","title":"derive()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.generate_ephemeral_key","text":"1 2 3 4 5 generate_ephemeral_key () -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ] Generate an ephemeral key that is suitable for use with this algorithm. Returns: Type Description Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] a generated EllipticCurvePrivateKey, on the same curve as this algorithm key Source code in jwskate/jwa/key_mgmt/ecdh.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_ephemeral_key ( self , ) -> Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ]: \"\"\"Generate an ephemeral key that is suitable for use with this algorithm. Returns: a generated EllipticCurvePrivateKey, on the same curve as this algorithm key \"\"\" if isinstance ( self . key , ( ec . EllipticCurvePrivateKey , ec . EllipticCurvePublicKey ) ): return ec . generate_private_key ( self . key . curve ) elif isinstance ( self . key , ( x25519 . X25519PrivateKey , x25519 . X25519PublicKey )): return x25519 . X25519PrivateKey . generate () elif isinstance ( self . key , ( x448 . X448PublicKey , x448 . X448PrivateKey )): return x448 . X448PrivateKey . generate ()","title":"generate_ephemeral_key()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.sender_key","text":"1 2 3 4 5 6 7 8 9 10 11 sender_key ( ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ], * , alg : str , key_size : int , ** headers : Any ) -> BinaPy Compute a CEK for encryption of a message. This method is meant for usage by a sender. Parameters: Name Type Description Default ephemeral_private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the EPK to use for this key required alg str the content encryption algorithm identifier required key_size int the expected CEK size required **headers Any additional headers to include for CEK derivation {} Returns: Type Description BinaPy the CEK for encryption by the sender Source code in jwskate/jwa/key_mgmt/ecdh.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def sender_key ( self , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender. Args: ephemeral_private_key: the EPK to use for this key alg: the content encryption algorithm identifier key_size: the expected CEK size **headers: additional headers to include for CEK derivation Returns: the CEK for encryption by the sender \"\"\" with self . public_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = ephemeral_private_key , public_key = key , otherinfo = otherinfo , key_size = key_size , ) return cek","title":"sender_key()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.recipient_key","text":"1 2 3 4 5 6 7 8 9 10 11 recipient_key ( ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ], * , alg : str , key_size : int , ** headers : Any ) -> BinaPy Compute a shared key. This method is meant for use by the recipient of an encrypted message. Parameters: Name Type Description Default ephemeral_public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the EPK, as received from sender required alg str the content encryption algorithm identifier required key_size int the CEK size required **headers Any additional headers as received from sender {} Returns: Type Description BinaPy the CEK for decryption by the recipient Source code in jwskate/jwa/key_mgmt/ecdh.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def recipient_key ( self , ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], * , alg : str , key_size : int , ** headers : Any , ) -> BinaPy : \"\"\"Compute a shared key. This method is meant for use by the recipient of an encrypted message. Args: ephemeral_public_key: the EPK, as received from sender alg: the content encryption algorithm identifier key_size: the CEK size **headers: additional headers as received from sender Returns: the CEK for decryption by the recipient \"\"\" with self . private_key_required () as key : apu = BinaPy ( headers . get ( \"apu\" , b \"\" )) . decode_from ( \"b64u\" ) apv = BinaPy ( headers . get ( \"apv\" , b \"\" )) . decode_from ( \"b64u\" ) otherinfo = self . otherinfo ( alg , apu , apv , key_size ) cek = self . derive ( private_key = key , public_key = ephemeral_public_key , otherinfo = otherinfo , key_size = key_size , ) return cek","title":"recipient_key()"},{"location":"api/#jwskate.jwa.PublicKeyRequired","text":"Bases: AttributeError Raised when a cryptographic operation requires a public key, and a private key has been provided instead. Source code in jwskate/jwa/base.py 16 17 class PublicKeyRequired ( AttributeError ): \"\"\"Raised when a cryptographic operation requires a public key, and a private key has been provided instead.\"\"\"","title":"PublicKeyRequired"},{"location":"api/#jwskate.jwa.BaseAlg","text":"Base class for all algorithms. An algorithm has a name and a description , whose reference is found in IANA JOSE registry . Source code in jwskate/jwa/base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class BaseAlg : \"\"\"Base class for all algorithms. An algorithm has a `name` and a `description`, whose reference is found in [IANA JOSE registry][IANA]. [IANA]: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms \"\"\" use : str \"\"\"Alg use ('sig' or 'enc')\"\"\" name : str \"\"\"Technical name of the algorithm\"\"\" description : str \"\"\"Description of the algorithm (human readable)\"\"\" read_only : bool = False \"\"\"For algs that are considered insecure, set to True to allow only signature verification or decryption of existing data, but don't allow new signatures or encryption.\"\"\" def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name","title":"BaseAlg"},{"location":"api/#jwskate.jwa.base.BaseAlg.use","text":"1 use : str Alg use ('sig' or 'enc')","title":"use"},{"location":"api/#jwskate.jwa.base.BaseAlg.name","text":"1 name : str Technical name of the algorithm","title":"name"},{"location":"api/#jwskate.jwa.base.BaseAlg.description","text":"1 description : str Description of the algorithm (human readable)","title":"description"},{"location":"api/#jwskate.jwa.base.BaseAlg.read_only","text":"1 read_only : bool = False For algs that are considered insecure, set to True to allow only signature verification or decryption of existing data, but don't allow new signatures or encryption.","title":"read_only"},{"location":"api/#jwskate.jwa.base.BaseAlg.__repr__","text":"1 __repr__ () -> str Use the name of the alg as repr. Source code in jwskate/jwa/base.py 39 40 41 def __repr__ ( self ) -> str : \"\"\"Use the name of the alg as repr.\"\"\" return self . name","title":"__repr__()"},{"location":"api/#jwskate.jwa.HS256","text":"Bases: BaseHMACSigAlg HMAC using SHA-256. Source code in jwskate/jwa/signature/hmac.py 42 43 44 45 46 47 48 class HS256 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-256.\"\"\" name = \"HS256\" description = __doc__ hashing_alg = hashes . SHA256 () min_key_size = 256","title":"HS256"},{"location":"api/#jwskate.jwa.BaseSymmetricAlg","text":"Bases: BaseAlg Base class for Symmetric algorithms (using a raw bytes key). Parameters: Name Type Description Default key bytes the key to use for cryptographic operations required Source code in jwskate/jwa/base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class BaseSymmetricAlg ( BaseAlg ): \"\"\"Base class for Symmetric algorithms (using a raw bytes key). Args: key: the key to use for cryptographic operations \"\"\" def __init__ ( self , key : bytes ): self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"BaseSymmetricAlg"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.check_key","text":"1 check_key ( key : bytes ) -> None Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description None Returns None . Raises an exception if the key is not suitable Source code in jwskate/jwa/base.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a given key is suitable for this alg class. This raises an exception if the key is not suitable. This method must be implemented by subclasses as required. Args: key: the key to check for this alg class Returns: Returns `None`. Raises an exception if the key is not suitable \"\"\" pass","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.supports_key","text":"1 supports_key ( key : bytes ) -> bool Return True if the given key is suitable for this alg class, or False otherwise. This is a convenience wrapper around check_key(key) . Parameters: Name Type Description Default key bytes the key to check for this alg class required Returns: Type Description bool True if the key is suitable for this alg class, False otherwise Source code in jwskate/jwa/base.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @classmethod def supports_key ( cls , key : bytes ) -> bool : \"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise. This is a convenience wrapper around `check_key(key)`. Args: key: the key to check for this alg class Returns: `True` if the key is suitable for this alg class, `False` otherwise \"\"\" try : cls . check_key ( key ) return True except Exception : return False","title":"supports_key()"},{"location":"api/#jwskate.jwa.OKPCurve","text":"Represent an Octet Key Pair (OKP) Curve. Source code in jwskate/jwa/okp.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @dataclass class OKPCurve : \"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\" name : str \"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve). This name will appear in `alg` headers.\"\"\" description : str \"\"\"Curve description (human readable).\"\"\" cryptography_private_key_class : Type [ Any ] \"\"\"`cryptography` private key class.\"\"\" cryptography_public_key_class : Type [ Any ] \"\"\"`cryptography` public key class.\"\"\" use : str \"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\" instances : ClassVar [ Dict [ str , OKPCurve ]] = {} \"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\" def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key: `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" )","title":"OKPCurve"},{"location":"api/#jwskate.jwa.okp.OKPCurve.name","text":"1 name : str Curve name as defined in IANA JOSE . This name will appear in alg headers.","title":"name"},{"location":"api/#jwskate.jwa.okp.OKPCurve.description","text":"1 description : str Curve description (human readable).","title":"description"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_private_key_class","text":"1 cryptography_private_key_class : Type [ Any ] cryptography private key class.","title":"cryptography_private_key_class"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_public_key_class","text":"1 cryptography_public_key_class : Type [ Any ] cryptography public key class.","title":"cryptography_public_key_class"},{"location":"api/#jwskate.jwa.okp.OKPCurve.use","text":"1 use : str Curve usage ( 'sig' or ' enc' ).","title":"use"},{"location":"api/#jwskate.jwa.okp.OKPCurve.instances","text":"1 instances : ClassVar [ Dict [ str , OKPCurve ]] = {} Registry of subclasses, in a {name: instance} mapping.","title":"instances"},{"location":"api/#jwskate.jwa.okp.OKPCurve.__post_init__","text":"1 __post_init__ () -> None Automatically registers subclasses in the instance registry. Source code in jwskate/jwa/okp.py 69 70 71 def __post_init__ ( self ) -> None : \"\"\"Automatically registers subclasses in the instance registry.\"\"\" self . instances [ self . name ] = self","title":"__post_init__()"},{"location":"api/#jwskate.jwa.okp.OKPCurve.generate","text":"1 generate () -> Tuple [ bytes , bytes ] Generate a new private key on this curve. Returns: Type Description Tuple [ bytes , bytes ] a tuple of x (public part), and d (private part), as bytes Source code in jwskate/jwa/okp.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def generate ( self ) -> Tuple [ bytes , bytes ]: \"\"\"Generate a new private key on this curve. Returns: a tuple of `x` (public part), and `d` (private part), as bytes \"\"\" key = self . cryptography_private_key_class . generate () x = key . public_key () . public_bytes ( serialization . Encoding . Raw , serialization . PublicFormat . Raw ) d = key . private_bytes ( serialization . Encoding . Raw , serialization . PrivateFormat . Raw , serialization . NoEncryption (), ) return x , d","title":"generate()"},{"location":"api/#jwskate.jwa.okp.OKPCurve.get_curve","text":"1 2 3 get_curve ( key : Union [ PublicKeyProtocol , PrivateKeyProtocol ] ) -> OKPCurve Return the appropriate OKPCurve instance for a given cryptography private or public key. Parameters: Name Type Description Default key Union [ PublicKeyProtocol , PrivateKeyProtocol ] cryptography private or public OKP key. required Returns: Name Type Description OKPCurve OKPCurve the appropriate OKPCurve for the given key Raises: Type Description NotImplementedError if the required OKP curve is not supported Source code in jwskate/jwa/okp.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @classmethod def get_curve ( cls , key : Union [ PublicKeyProtocol , PrivateKeyProtocol ]) -> OKPCurve : \"\"\"Return the appropriate `OKPCurve` instance for a given `cryptography` private or public key. Args: key: `cryptography` private or public OKP key. Returns: OKPCurve: the appropriate `OKPCurve` for the given key Raises: NotImplementedError: if the required OKP curve is not supported \"\"\" for c in cls . instances . values (): if isinstance ( key , ( c . cryptography_private_key_class , c . cryptography_public_key_class ) ): return c raise NotImplementedError ( f \"Unsupported OKP key { type ( key ) } \" )","title":"get_curve()"},{"location":"api/#jwskate.jwa.HS384","text":"Bases: BaseHMACSigAlg HMAC using SHA-384. Source code in jwskate/jwa/signature/hmac.py 51 52 53 54 55 56 57 class HS384 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-384.\"\"\" name = \"HS384\" description = __doc__ hashing_alg = hashes . SHA384 () min_key_size = 384","title":"HS384"},{"location":"api/#jwskate.jwa.A128KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 128-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 57 58 59 60 61 62 class A128KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\" name = \"A128KW\" description = __doc__ key_size = 128","title":"A128KW"},{"location":"api/#jwskate.jwa.HS512","text":"Bases: BaseHMACSigAlg HMAC using SHA-512. Source code in jwskate/jwa/signature/hmac.py 60 61 62 63 64 65 66 class HS512 ( BaseHMACSigAlg ): # noqa: D415 \"\"\"HMAC using SHA-512.\"\"\" name = \"HS512\" description = __doc__ hashing_alg = hashes . SHA512 () min_key_size = 512","title":"HS512"},{"location":"api/#jwskate.jwa.A192KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 192-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 65 66 67 68 69 70 class A192KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\" name = \"A192KW\" description = __doc__ key_size = 192","title":"A192KW"},{"location":"api/#jwskate.jwa.A128GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 128-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 68 69 70 71 72 73 class A128GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\" name = \"A128GCMKW\" description = __doc__ key_size = 128","title":"A128GCMKW"},{"location":"api/#jwskate.jwa.RsaEsPcks1v1_5","text":"Bases: BaseRsaKeyWrap RSAES-PKCS1-v1_5. Source code in jwskate/jwa/key_mgmt/rsa.py 70 71 72 73 74 75 76 77 class RsaEsPcks1v1_5 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES-PKCS1-v1_5.\"\"\" name = \"RSA1_5\" description = __doc__ read_only = True padding = padding . PKCS1v15 ()","title":"RsaEsPcks1v1_5"},{"location":"api/#jwskate.jwa.A256KW","text":"Bases: BaseAesKeyWrap AES Key Wrap with default initial value using 256-bit key. Source code in jwskate/jwa/key_mgmt/aeskw.py 73 74 75 76 77 78 class A256KW ( BaseAesKeyWrap ): \"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\" name = \"A256KW\" description = __doc__ key_size = 256","title":"A256KW"},{"location":"api/#jwskate.jwa.A192GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 192-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 76 77 78 79 80 81 class A192GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\" name = \"A192GCMKW\" description = __doc__ key_size = 192","title":"A192GCMKW"},{"location":"api/#jwskate.jwa.ES256","text":"Bases: BaseECSignatureAlg ECDSA using P-256 and SHA-256. Source code in jwskate/jwa/signature/ec.py 78 79 80 81 82 83 84 class ES256 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-256 and SHA-256.\"\"\" name = \"ES256\" description = __doc__ curve = P_256 hashing_alg = hashes . SHA256 ()","title":"ES256"},{"location":"api/#jwskate.jwa.RS256","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256. Source code in jwskate/jwa/signature/rsa.py 78 79 80 81 82 83 class RS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256.\"\"\" name = \"RS256\" description = __doc__ hashing_alg = hashes . SHA256 ()","title":"RS256"},{"location":"api/#jwskate.jwa.RsaEsOaep","text":"Bases: BaseRsaKeyWrap RSAES OAEP using default parameters. Source code in jwskate/jwa/key_mgmt/rsa.py 80 81 82 83 84 85 86 87 88 89 90 class RsaEsOaep ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using default parameters.\"\"\" name = \"RSA-OAEP\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA1 ()), algorithm = hashes . SHA1 (), label = None , )","title":"RsaEsOaep"},{"location":"api/#jwskate.jwa.A256GCMKW","text":"Bases: BaseAesGcmKeyWrap Key wrapping with AES GCM using 256-bit key. Source code in jwskate/jwa/key_mgmt/aesgcmkw.py 84 85 86 87 88 89 class A256GCMKW ( BaseAesGcmKeyWrap ): \"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\" name = \"A256GCMKW\" description = __doc__ key_size = 256","title":"A256GCMKW"},{"location":"api/#jwskate.jwa.RS384","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-384. Source code in jwskate/jwa/signature/rsa.py 86 87 88 89 90 91 class RS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-384.\"\"\" name = \"RS384\" description = __doc__ hashing_alg = hashes . SHA384 ()","title":"RS384"},{"location":"api/#jwskate.jwa.ES384","text":"Bases: BaseECSignatureAlg ECDSA using P-384 and SHA-384. Source code in jwskate/jwa/signature/ec.py 87 88 89 90 91 92 93 class ES384 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-384 and SHA-384.\"\"\" name = \"ES384\" description = __doc__ curve = P_384 hashing_alg = hashes . SHA384 ()","title":"ES384"},{"location":"api/#jwskate.jwa.BaseAsymmetricAlg","text":"Bases: Generic [ Kpriv , Kpub ] , BaseAlg Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Source code in jwskate/jwa/base.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class BaseAsymmetricAlg ( Generic [ Kpriv , Kpub ], BaseAlg ): \"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key. The available cryptographic operations will depend on the alg and the provided key type. Args: key: the key to use. \"\"\" private_key_class : Union [ Type [ Kpriv ], Tuple [ Type [ Kpriv ], ... ]] public_key_class : Union [ Type [ Kpub ], Tuple [ Type [ Kpub ], ... ]] def __init__ ( self , key : Union [ Kpriv , Kpub ]): self . check_key ( key ) self . key = key @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\" @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore","title":"BaseAsymmetricAlg"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.check_key","text":"1 check_key ( key : Union [ Kpriv , Kpub ]) -> None Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Parameters: Name Type Description Default key Union [ Kpriv , Kpub ] the key to use. required Returns: Type Description None Returns None. Raises an exception if the key is not suitable. Raises: Type Description Exception if the key is not suitable for use with this alg class Source code in jwskate/jwa/base.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @classmethod def check_key ( cls , key : Union [ Kpriv , Kpub ]) -> None : \"\"\"Check that a given key is suitable for this alg class. This must be implemented by subclasses as required. Args: key: the key to use. Returns: Returns None. Raises an exception if the key is not suitable. Raises: Exception: if the key is not suitable for use with this alg class \"\"\"","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.private_key_required","text":"1 private_key_required () -> Iterator [ Kpriv ] A context manager that checks if this alg is initialised with a private key. Yields: Type Description Iterator [ Kpriv ] the private key Raises: Type Description PrivateKeyRequired if the configured key is not private Source code in jwskate/jwa/base.py 126 127 128 129 130 131 132 133 134 135 136 137 138 @contextmanager def private_key_required ( self ) -> Iterator [ Kpriv ]: \"\"\"A context manager that checks if this alg is initialised with a private key. Yields: the private key Raises: PrivateKeyRequired: if the configured key is not private \"\"\" if not isinstance ( self . key , self . private_key_class ): raise PrivateKeyRequired () yield self . key # type: ignore","title":"private_key_required()"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.public_key_required","text":"1 public_key_required () -> Iterator [ Kpub ] A context manager that checks if this alg is initialised with a public key. Yields: Type Description Iterator [ Kpub ] The public key Raises: Type Description PublicKeyRequired if the configured key is private Source code in jwskate/jwa/base.py 140 141 142 143 144 145 146 147 148 149 150 151 152 @contextmanager def public_key_required ( self ) -> Iterator [ Kpub ]: \"\"\"A context manager that checks if this alg is initialised with a public key. Yields: The public key Raises: PublicKeyRequired: if the configured key is private \"\"\" if not isinstance ( self . key , self . public_key_class ): raise PublicKeyRequired () yield self . key # type: ignore","title":"public_key_required()"},{"location":"api/#jwskate.jwa.RsaEsOaepSha256","text":"Bases: BaseRsaKeyWrap RSAES OAEP using SHA-256 and MGF1 with SHA-256. Source code in jwskate/jwa/key_mgmt/rsa.py 93 94 95 96 97 98 99 100 101 102 103 class RsaEsOaepSha256 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256.\"\"\" name = \"RSA-OAEP-256\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA256 ()), algorithm = hashes . SHA256 (), label = None , )","title":"RsaEsOaepSha256"},{"location":"api/#jwskate.jwa.A128GCM","text":"Bases: BaseAESGCM AES GCM using 128-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 94 95 96 97 98 99 class A128GCM ( BaseAESGCM ): \"\"\"AES GCM using 128-bit key.\"\"\" name = \"A128GCM\" description = __doc__ key_size = 128","title":"A128GCM"},{"location":"api/#jwskate.jwa.RS512","text":"Bases: BaseRSASigAlg RSASSA-PKCS1-v1_5 using SHA-256. Source code in jwskate/jwa/signature/rsa.py 94 95 96 97 98 99 class RS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PKCS1-v1_5 using SHA-256.\"\"\" name = \"RS512\" description = __doc__ hashing_alg = hashes . SHA512 ()","title":"RS512"},{"location":"api/#jwskate.jwa.Pbes2_HS256_A128KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-256 and \"A128KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 96 97 98 99 100 101 102 class Pbes2_HS256_A128KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\" name = \"PBES2-HS256+A128KW\" description = __doc__ kwalg = A128KW hash_alg = hashes . SHA256 ()","title":"Pbes2_HS256_A128KW"},{"location":"api/#jwskate.jwa.ES512","text":"Bases: BaseECSignatureAlg ECDSA using P-521 and SHA-512. Source code in jwskate/jwa/signature/ec.py 96 97 98 99 100 101 102 class ES512 ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using P-521 and SHA-512.\"\"\" name = \"ES512\" description = __doc__ curve = P_521 hashing_alg = hashes . SHA512 ()","title":"ES512"},{"location":"api/#jwskate.jwa.A192GCM","text":"Bases: BaseAESGCM AES GCM using 192-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 102 103 104 105 106 107 class A192GCM ( BaseAESGCM ): \"\"\"AES GCM using 192-bit key.\"\"\" name = \"A192GCM\" description = __doc__ key_size = 192","title":"A192GCM"},{"location":"api/#jwskate.jwa.PS256","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-256 and MGF1 with SHA-256. Source code in jwskate/jwa/signature/rsa.py 102 103 104 105 106 107 108 class PS256 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256.\"\"\" name = \"PS256\" description = __doc__ hashing_alg = hashes . SHA256 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA256 ()), salt_length = 256 // 8 )","title":"PS256"},{"location":"api/#jwskate.jwa.Pbes2_HS384_A192KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-384 and \"A192KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 105 106 107 108 109 110 111 class Pbes2_HS384_A192KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\" name = \"PBES2-HS384+A192KW\" description = __doc__ kwalg = A192KW hash_alg = hashes . SHA384 ()","title":"Pbes2_HS384_A192KW"},{"location":"api/#jwskate.jwa.ES256K","text":"Bases: BaseECSignatureAlg ECDSA using secp256k1 and SHA-256. Source code in jwskate/jwa/signature/ec.py 105 106 107 108 109 110 111 class ES256K ( BaseECSignatureAlg ): # noqa: D415 \"\"\"ECDSA using secp256k1 and SHA-256.\"\"\" name = \"ES256k\" description = __doc__ curve = secp256k1 hashing_alg = hashes . SHA256 ()","title":"ES256K"},{"location":"api/#jwskate.jwa.RsaEsOaepSha384","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-384 and MGF1 with SHA-384. Source code in jwskate/jwa/key_mgmt/rsa.py 106 107 108 109 110 111 112 113 114 115 116 class RsaEsOaepSha384 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384.\"\"\" name = \"RSA-OAEP-384\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA384 ()), algorithm = hashes . SHA384 (), label = None , )","title":"RsaEsOaepSha384"},{"location":"api/#jwskate.jwa.A256GCM","text":"Bases: BaseAESGCM AES GCM using 256-bit key. Source code in jwskate/jwa/encryption/aesgcm.py 110 111 112 113 114 115 class A256GCM ( BaseAESGCM ): \"\"\"AES GCM using 256-bit key.\"\"\" name = \"A256GCM\" description = __doc__ key_size = 256","title":"A256GCM"},{"location":"api/#jwskate.jwa.PS384","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-384 and MGF1 with SHA-384. Source code in jwskate/jwa/signature/rsa.py 111 112 113 114 115 116 117 class PS384 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384.\"\"\" name = \"PS384\" description = __doc__ hashing_alg = hashes . SHA384 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA384 ()), salt_length = 384 // 8 )","title":"PS384"},{"location":"api/#jwskate.jwa.Pbes2_HS512_A256KW","text":"Bases: BasePbes2 PBES2 with HMAC SHA-512 and \"A256KW\" wrapping. Source code in jwskate/jwa/key_mgmt/pbes2.py 114 115 116 117 118 119 120 class Pbes2_HS512_A256KW ( BasePbes2 ): \"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\" name = \"PBES2-HS512+A256KW\" description = __doc__ kwalg = A256KW hash_alg = hashes . SHA512 ()","title":"Pbes2_HS512_A256KW"},{"location":"api/#jwskate.jwa.RsaEsOaepSha512","text":"Bases: BaseRsaKeyWrap RSA-OAEP using SHA-512 and MGF1 with SHA-512. Source code in jwskate/jwa/key_mgmt/rsa.py 119 120 121 122 123 124 125 126 127 128 129 class RsaEsOaepSha512 ( BaseRsaKeyWrap ): # noqa: D415 \"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512.\"\"\" name = \"RSA-OAEP-512\" description = __doc__ padding = padding . OAEP ( mgf = padding . MGF1 ( algorithm = hashes . SHA512 ()), algorithm = hashes . SHA512 (), label = None , )","title":"RsaEsOaepSha512"},{"location":"api/#jwskate.jwa.PS512","text":"Bases: BaseRSASigAlg RSASSA-PSS using SHA-512 and MGF1 with SHA-512. Source code in jwskate/jwa/signature/rsa.py 120 121 122 123 124 125 126 class PS512 ( BaseRSASigAlg ): # noqa: D415 \"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512.\"\"\" name = \"PS512\" description = __doc__ hashing_alg = hashes . SHA512 () padding_alg = padding . PSS ( mgf = padding . MGF1 ( hashes . SHA512 ()), salt_length = 512 // 8 )","title":"PS512"},{"location":"api/#jwskate.jwa.BaseSignatureAlg","text":"Bases: BaseAlg Base class for signature algorithms. Source code in jwskate/jwa/base.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 class BaseSignatureAlg ( BaseAlg ): \"\"\"Base class for signature algorithms.\"\"\" use = \"sig\" def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError","title":"BaseSignatureAlg"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.sign","text":"1 sign ( data : Union [ bytes , SupportsBytes ]) -> BinaPy Sign arbitrary data, return the signature. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] raw data to sign required Returns: Type Description BinaPy the raw signature Source code in jwskate/jwa/base.py 160 161 162 163 164 165 166 167 168 169 def sign ( self , data : Union [ bytes , SupportsBytes ]) -> BinaPy : \"\"\"Sign arbitrary data, return the signature. Args: data: raw data to sign Returns: the raw signature \"\"\" raise NotImplementedError","title":"sign()"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.verify","text":"1 2 3 4 verify ( data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ], ) -> bool Verify a signature against some data. Parameters: Name Type Description Default data Union [ bytes , SupportsBytes ] the raw data to verify required signature Union [ bytes , SupportsBytes ] the raw signature required Returns: Type Description bool True if the signature matches, False otherwise. Source code in jwskate/jwa/base.py 171 172 173 174 175 176 177 178 179 180 181 182 183 def verify ( self , data : Union [ bytes , SupportsBytes ], signature : Union [ bytes , SupportsBytes ] ) -> bool : \"\"\"Verify a signature against some data. Args: data: the raw data to verify signature: the raw signature Returns: `True` if the signature matches, `False` otherwise. \"\"\" raise NotImplementedError","title":"verify()"},{"location":"api/#jwskate.jwa.A128CBC_HS256","text":"Bases: BaseAesCbcHmacSha2 AES_128_CBC_HMAC_SHA_256. Source code in jwskate/jwa/encryption/aescbchmac.py 162 163 164 165 166 167 168 169 170 class A128CBC_HS256 ( BaseAesCbcHmacSha2 ): \"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\" name = \"A128CBC-HS256\" description = __doc__ mac_key_size = 128 aes_key_size = 128 tag_size = 16 hash_alg = hashes . SHA256 ()","title":"A128CBC_HS256"},{"location":"api/#jwskate.jwa.A192CBC_HS384","text":"Bases: BaseAesCbcHmacSha2 AES_192_CBC_HMAC_SHA_384. Source code in jwskate/jwa/encryption/aescbchmac.py 173 174 175 176 177 178 179 180 181 class A192CBC_HS384 ( BaseAesCbcHmacSha2 ): \"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\" name = \"A192CBC-HS384\" description = __doc__ mac_key_size = 192 aes_key_size = 192 tag_size = 24 hash_alg = hashes . SHA384 ()","title":"A192CBC_HS384"},{"location":"api/#jwskate.jwa.A256CBC_HS512","text":"Bases: BaseAesCbcHmacSha2 AES_256_CBC_HMAC_SHA_512. Source code in jwskate/jwa/encryption/aescbchmac.py 184 185 186 187 188 189 190 191 192 193 class A256CBC_HS512 ( BaseAesCbcHmacSha2 ): \"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\" name = \"A256CBC-HS512\" description = __doc__ key_size = 512 mac_key_size = 256 aes_key_size = 256 tag_size = 32 hash_alg = hashes . SHA512 ()","title":"A256CBC_HS512"},{"location":"api/#jwskate.jwa.BaseAESEncryptionAlg","text":"Bases: BaseSymmetricAlg Base class for AES encryption algorithms. Source code in jwskate/jwa/base.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 class BaseAESEncryptionAlg ( BaseSymmetricAlg ): \"\"\"Base class for AES encryption algorithms.\"\"\" use = \"enc\" key_size : int tag_size : int iv_size : int @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected key size of { cls . key_size } bits\" ) @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size ) @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size ) def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data, with [Authenticated Encryption (with optional Associated Data)][AEAD]. This needs: - the raw data to encrypt (`plaintext`) - a given random Initialisation Vector (`iv`) of the appropriate size - optional Additional Authentication Data (`aad`) And returns a tuple (ciphered_data, authentication_tag). Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag [AEAD]: https://wikipedia.org/wiki/Authenticated_encryption \"\"\" raise NotImplementedError def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], auth_tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , ) -> BinaPy : \"\"\"Decrypt and verify a ciphertext with Authenticated Encryption. This needs: - the raw encrypted Data (`ciphertext`) and Authentication Tag (`auth_tag`) that were produced by encryption, - the same Initialisation Vector (`iv`) and optional Additional Authentication Data that were provided for encryption. and returns the resulting clear text data. Args: ciphertext: the data to decrypt iv: the Initialisation Vector to use. Must be the same one used during encryption auth_tag: the authentication tag aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError @classmethod def init_random_key ( cls ) -> BaseAESEncryptionAlg : \"\"\"Initialize this alg with a random key. Returns: a subclass of BaseAESEncryptionAlg initialized with a randomly generated key \"\"\" return cls ( cls . generate_key ())","title":"BaseAESEncryptionAlg"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.check_key","text":"1 check_key ( key : bytes ) -> None Check that a key is suitable for this algorithm. Parameters: Name Type Description Default key bytes the key to check required Raises: Type Description ValueError if the key is not suitable Source code in jwskate/jwa/base.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @classmethod def check_key ( cls , key : bytes ) -> None : \"\"\"Check that a key is suitable for this algorithm. Args: key: the key to check Raises: ValueError: if the key is not suitable \"\"\" if len ( key ) * 8 != cls . key_size : raise ValueError ( f \"This key size of { len ( key ) * 8 } bits doesn't match the expected key size of { cls . key_size } bits\" )","title":"check_key()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_key","text":"1 generate_key () -> BinaPy Generate a key of an appropriate size for this AES alg subclass. Returns: Type Description BinaPy a random AES key Source code in jwskate/jwa/base.py 210 211 212 213 214 215 216 217 @classmethod def generate_key ( cls ) -> BinaPy : \"\"\"Generate a key of an appropriate size for this AES alg subclass. Returns: a random AES key \"\"\" return BinaPy . random_bits ( cls . key_size )","title":"generate_key()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_iv","text":"1 generate_iv () -> BinaPy Generate an Initialisation Vector of the appropriate size. Returns: Type Description BinaPy a random IV Source code in jwskate/jwa/base.py 219 220 221 222 223 224 225 226 @classmethod def generate_iv ( cls ) -> BinaPy : \"\"\"Generate an Initialisation Vector of the appropriate size. Returns: a random IV \"\"\" return BinaPy . random_bits ( cls . iv_size )","title":"generate_iv()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.encrypt","text":"1 2 3 4 5 6 encrypt ( plaintext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None ) -> Tuple [ BinaPy , BinaPy ] Encrypt arbitrary data, with Authenticated Encryption (with optional Associated Data) . This needs: - the raw data to encrypt ( plaintext ) - a given random Initialisation Vector ( iv ) of the appropriate size - optional Additional Authentication Data ( aad ) And returns a tuple (ciphered_data, authentication_tag). Parameters: Name Type Description Default plaintext Union [ bytes , SupportsBytes ] the data to encrypt required iv Union [ bytes , SupportsBytes ] the Initialisation Vector to use required aad Union [ bytes , SupportsBytes , None] the Additional Authentication Data None Returns: Type Description Tuple [ BinaPy , BinaPy ] a tuple of ciphered data and authentication tag Source code in jwskate/jwa/base.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def encrypt ( self , plaintext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , ) -> Tuple [ BinaPy , BinaPy ]: \"\"\"Encrypt arbitrary data, with [Authenticated Encryption (with optional Associated Data)][AEAD]. This needs: - the raw data to encrypt (`plaintext`) - a given random Initialisation Vector (`iv`) of the appropriate size - optional Additional Authentication Data (`aad`) And returns a tuple (ciphered_data, authentication_tag). Args: plaintext: the data to encrypt iv: the Initialisation Vector to use aad: the Additional Authentication Data Returns: a tuple of ciphered data and authentication tag [AEAD]: https://wikipedia.org/wiki/Authenticated_encryption \"\"\" raise NotImplementedError","title":"encrypt()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.decrypt","text":"1 2 3 4 5 6 7 decrypt ( ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], auth_tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None ) -> BinaPy Decrypt and verify a ciphertext with Authenticated Encryption. This needs: - the raw encrypted Data ( ciphertext ) and Authentication Tag ( auth_tag ) that were produced by encryption, - the same Initialisation Vector ( iv ) and optional Additional Authentication Data that were provided for encryption. and returns the resulting clear text data. Parameters: Name Type Description Default ciphertext Union [ bytes , SupportsBytes ] the data to decrypt required iv Union [ bytes , SupportsBytes ] the Initialisation Vector to use. Must be the same one used during encryption required auth_tag Union [ bytes , SupportsBytes ] the authentication tag required aad Union [ bytes , SupportsBytes , None] the Additional Authentication Data. Must be the same one used during encryption None Returns: Type Description BinaPy the deciphered data Source code in jwskate/jwa/base.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def decrypt ( self , ciphertext : Union [ bytes , SupportsBytes ], * , iv : Union [ bytes , SupportsBytes ], auth_tag : Union [ bytes , SupportsBytes ], aad : Union [ bytes , SupportsBytes , None ] = None , ) -> BinaPy : \"\"\"Decrypt and verify a ciphertext with Authenticated Encryption. This needs: - the raw encrypted Data (`ciphertext`) and Authentication Tag (`auth_tag`) that were produced by encryption, - the same Initialisation Vector (`iv`) and optional Additional Authentication Data that were provided for encryption. and returns the resulting clear text data. Args: ciphertext: the data to decrypt iv: the Initialisation Vector to use. Must be the same one used during encryption auth_tag: the authentication tag aad: the Additional Authentication Data. Must be the same one used during encryption Returns: the deciphered data \"\"\" raise NotImplementedError","title":"decrypt()"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.init_random_key","text":"1 init_random_key () -> BaseAESEncryptionAlg Initialize this alg with a random key. Returns: Type Description BaseAESEncryptionAlg a subclass of BaseAESEncryptionAlg initialized with a randomly generated key Source code in jwskate/jwa/base.py 281 282 283 284 285 286 287 288 @classmethod def init_random_key ( cls ) -> BaseAESEncryptionAlg : \"\"\"Initialize this alg with a random key. Returns: a subclass of BaseAESEncryptionAlg initialized with a randomly generated key \"\"\" return cls ( cls . generate_key ())","title":"init_random_key()"},{"location":"api/#jwskate.jwa.BaseEcdhEs_AesKw","text":"Bases: EcdhEs Base class for ECDH-ES+AESKW algorithms. Source code in jwskate/jwa/key_mgmt/ecdh.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class BaseEcdhEs_AesKw ( EcdhEs ): \"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\" kwalg : Type [ BaseAesKeyWrap ] def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey ) def unwrap_key_with_epk ( self , cipherkey : Union [ bytes , SupportsBytes ], ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"BaseEcdhEs_AesKw"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.wrap_key_with_epk","text":"1 2 3 4 5 6 7 8 9 wrap_key_with_epk ( plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey , ], ** headers : Any ) -> BinaPy Wraps a key for content encryption. Parameters: Name Type Description Default plainkey bytes the key to wrap required ephemeral_private_key Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ] the EPK to use required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the wrapped CEK Source code in jwskate/jwa/key_mgmt/ecdh.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def wrap_key_with_epk ( self , plainkey : bytes , ephemeral_private_key : Union [ ec . EllipticCurvePrivateKey , x25519 . X25519PrivateKey , x448 . X448PrivateKey ], ** headers : Any , ) -> BinaPy : \"\"\"Wraps a key for content encryption. Args: plainkey: the key to wrap ephemeral_private_key: the EPK to use **headers: additional headers for CEK derivation Returns: the wrapped CEK \"\"\" aes_key = self . sender_key ( ephemeral_private_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . wrap_key ( plainkey )","title":"wrap_key_with_epk()"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.unwrap_key_with_epk","text":"1 2 3 4 5 6 7 8 9 unwrap_key_with_epk ( cipherkey : Union [ bytes , SupportsBytes ], ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey , ], ** headers : Any ) -> BinaPy Unwrap a key for content decryption. Parameters: Name Type Description Default cipherkey Union [ bytes , SupportsBytes ] the wrapped key required ephemeral_public_key Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ] the EPK required **headers Any additional headers for CEK derivation {} Returns: Type Description BinaPy the unwrapped key Source code in jwskate/jwa/key_mgmt/ecdh.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def unwrap_key_with_epk ( self , cipherkey : Union [ bytes , SupportsBytes ], ephemeral_public_key : Union [ ec . EllipticCurvePublicKey , x25519 . X25519PublicKey , x448 . X448PublicKey ], ** headers : Any , ) -> BinaPy : \"\"\"Unwrap a key for content decryption. Args: cipherkey: the wrapped key ephemeral_public_key: the EPK **headers: additional headers for CEK derivation Returns: the unwrapped key \"\"\" aes_key = self . recipient_key ( ephemeral_public_key , key_size = self . kwalg . key_size , ** headers ) return self . kwalg ( aes_key ) . unwrap_key ( cipherkey )","title":"unwrap_key_with_epk()"},{"location":"api/#jwskate.jwa.EcdhEs_A128KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A128KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 267 268 269 270 271 272 class EcdhEs_A128KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\" name = \"ECDH-ES+A128KW\" description = __doc__ kwalg = A128KW","title":"EcdhEs_A128KW"},{"location":"api/#jwskate.jwa.EcdhEs_A192KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A192KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 275 276 277 278 279 280 class EcdhEs_A192KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\" name = \"ECDH-ES+A192KW\" description = __doc__ kwalg = A192KW","title":"EcdhEs_A192KW"},{"location":"api/#jwskate.jwa.EcdhEs_A256KW","text":"Bases: BaseEcdhEs_AesKw ECDH-ES using Concat KDF and \"A256KW\" wrapping. Source code in jwskate/jwa/key_mgmt/ecdh.py 283 284 285 286 287 288 class EcdhEs_A256KW ( BaseEcdhEs_AesKw ): \"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\" name = \"ECDH-ES+A256KW\" description = __doc__ kwalg = A256KW","title":"EcdhEs_A256KW"},{"location":"api/#jwskate.jwa.BaseKeyManagementAlg","text":"Bases: BaseAlg Base class for Key Management algorithms. Source code in jwskate/jwa/base.py 291 292 293 294 class BaseKeyManagementAlg ( BaseAlg ): \"\"\"Base class for Key Management algorithms.\"\"\" use = \"enc\"","title":"BaseKeyManagementAlg"},{"location":"api/#jwskate.jwa.MismatchingAuthTag","text":"Bases: cryptography . exceptions . InvalidTag Raised when trying to decrypt with an Authentication Tag that doesn't match the expected value. Source code in jwskate/jwa/base.py 297 298 class MismatchingAuthTag ( cryptography . exceptions . InvalidTag ): \"\"\"Raised when trying to decrypt with an Authentication Tag that doesn't match the expected value.\"\"\"","title":"MismatchingAuthTag"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Guillaume Pujol guill.p.linux@gmail.com Contributors \u00b6 None yet. Why not be the first?","title":"Authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Guillaume Pujol guill.p.linux@gmail.com","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/guillp/jwskate/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 JsonWebSkate could always use more documentation, whether as part of the official JsonWebSkate docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/guillp/jwskate/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up jwskate for local development. Fork the jwskate repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/jwskate.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/jwskate/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_jwskate ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass. ```","title":"contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/guillp/jwskate/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"JsonWebSkate could always use more documentation, whether as part of the official JsonWebSkate docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/guillp/jwskate/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up jwskate for local development. Fork the jwskate repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/jwskate.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/jwskate/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_jwskate ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass. ```","title":"Deploying"},{"location":"history/","text":"History \u00b6 0.1.0 (2021-11-15) \u00b6 First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2021-11-15","text":"First release on PyPI.","title":"0.1.0 (2021-11-15)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install jwskate , run this command in your terminal: 1 $ pip install jwskate This is the preferred method to install jwskate , as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for jwskate can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/jwskate Or download the tarball : 1 $ curl -OJL https://github.com/guillp/jwskate/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install jwskate , run this command in your terminal: 1 $ pip install jwskate This is the preferred method to install jwskate , as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for jwskate can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/jwskate Or download the tarball : 1 $ curl -OJL https://github.com/guillp/jwskate/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"From source"},{"location":"recipes/","text":"This is a collection of recipes related to jwskate usage. JWK \u00b6 Generate private/public key pairs \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from jwskate import Jwk private_jwk = ( Jwk . generate_for_alg ( \"ES256\" ) # select the signature or encryption alg here . with_kid_thumbprint () # optionally, include a RFC7638 compliant thumbprint as kid . with_usage_parameters () # optionally, include 'use' and 'key_ops' ) print ( private_jwk ) # { # \"kty\": \"EC\", # \"crv\": \"P-256\", # \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\", # \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\", # \"d\": \"Lce_08inNOEe6Q9xEGrR9T0CJNQa1o4EhGtDQYAI0N8\", # \"alg\": \"ES256\", # \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\", # \"use\": \"sig\", # \"key_ops\": [ # \"sign\" # ] # } public_jwk = private_jwk . public_jwk () print ( public_jwk . to_json ( indent = 2 )) # { # \"kty\": \"EC\", # \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\", # \"alg\": \"ES256\", # \"use\": \"sig\", # \"key_ops\": [ # \"verify\" # ], # \"crv\": \"P-256\", # \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\", # \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\" # } # let's expose this public key as a JWKS: print ( public_jwk . as_jwks () . to_json ( indent = 2 )) # { # \"keys\": [ # { # \"kty\": \"EC\", # \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\", # \"alg\": \"ES256\", # \"use\": \"sig\", # \"key_ops\": [ # \"verify\" # ], # \"crv\": \"P-256\", # \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\", # \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\" # } # ] # } Fetching a JWKS from a remote endpoint \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from jwskate import JwkSet import requests raw_jwks = requests . get ( \"https://www.googleapis.com/oauth2/v3/certs\" ) . json () jwkset = JwkSet ( raw_jwks ) print ( jwkset ) # { # \"keys\": [ # ... # ] # } # compared to a raw dict, a JwkSet offers convenience methods like: if jwkset . is_private : # returns True if the jwks contains at least one private key raise ValueError ( \"JWKS contains private keys!\" ) # an exposed JWKS should only contain public keys my_jwk = jwkset . get_jwk_by_kid ( \"my_key_id\" ) # gets a key by key id (kid) # select keys that is suitable for signature verification verification_jwks = jwkset . verification_keys () # select keys that are suitable for encryption encryption_jwks = jwkset . encryption_keys () Converting between PEM key, JWK and cryptography keys \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 from jwskate import Jwk # generate a sample JWK, any asymmetric type will do: private_jwk = ( Jwk . generate_for_alg ( \"ES256\" ) # generates the key . with_usage_parameters () # adds use and key_ops . with_kid_thumbprint () # adds the key thumbprint as kid ) print ( private_jwk . to_json ( indent = 2 )) # {'kty': 'EC', # 'crv': 'P-256', # 'x': '8xX1CEhDNNjEySUKLw88YeiVwEOW34BWm0hBkAxqlVU', # 'y': 'UfZ0JKT7MxdNMyqMKzKcAcYTcuqoXeplcJ3jNfnj3tM', # 'd': 'T45KDokOKyuhEA92ri5a951c5kjmQfGyh1SrEkonb4s', # 'alg': 'ES256', # 'use': 'sig', # 'key_ops': ['sign'], # 'kid': '_E8_LoT4QEwctEkGNbiP9dogVDz6Lq9i8G_fj9nnEo0'} # get the cryptography key that is wrapped in the Jwk: cryptography_private_key = private_jwk . cryptography_key print ( type ( cryptography_private_key )) # <class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePrivateKey'> # create the PEM for the private key (encrypted with a password) private_pem = private_jwk . to_pem ( \"Th1s_P@ssW0rD_iS_5o_5tr0nG!\" ) print ( private_pem . decode ()) # -----BEGIN ENCRYPTED PRIVATE KEY----- # MIHsMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAhFd4nINf0/8QICCAAw # DAYIKoZIhvcNAgkFADAdBglghkgBZQMEASoEEJNdsyMjSx3d6RqBBTuI5LoEgZD4 # qdPHcTZhKAuzQ9mkM1SlaZfiydWM2KFqPCYPLwoX+3kuCHPanMLlDxwOGN9XMRYl # hG3eO0Gu4eWdc/2QEcXIyBCbyKnSwhaHUSSfkhyK9eh8diHQw+blOIImIldLPxnp # +ABOhO6pCjQxM7I5op7RZuxLNWGLyAlfOOvawLfnM/wKLW6GXmlywu7PZ5qk9Bk= # -----END ENCRYPTED PRIVATE KEY----- # write this private PEM to a file: with open ( \"my_private_key.pem\" , \"wb\" ) as foutput : foutput . write ( private_pem ) # create the PEM for the public key (unencrypted) public_jwk = private_jwk . public_jwk () print ( public_jwk ) # { # \"kty\": \"EC\", # \"kid\": \"m-oFw9zA2YPFyqm265jbHnzXRa3SQ1ESdCE1AtAqO1U\", # \"alg\": \"ES256\", # \"use\": \"sig\", # \"key_ops\": [ # \"verify\" # ], # \"crv\": \"P-256\", # \"x\": \"VVbLOXwIgIFsYQSpnbLm5hr-ibfnIK0EeWYj2HXWvks\", # \"y\": \"7f24WIqwHGr-jU9dH8GHpPEHMtAuXiwsedFnS6xayhk\" # } # get the cryptography public key cryptography_public_key = public_jwk . cryptography_key print ( type ( cryptography_public_key )) # <class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePublicKey'> # get the public PEM public_pem = public_jwk . to_pem () print ( public_pem . decode ()) # -----BEGIN PUBLIC KEY----- # MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE8xX1CEhDNNjEySUKLw88YeiVwEOW # 34BWm0hBkAxqlVVR9nQkpPszF00zKowrMpwBxhNy6qhd6mVwneM1+ePe0w== # -----END PUBLIC KEY----- # write this public PEM to a file: with open ( \"my_public_key.pem\" , \"wb\" ) as foutput : foutput . write ( public_pem ) # read the private PEM from file and load it as a Jwk: with open ( \"my_private_key.pem\" , \"rb\" ) as finput : private_pem_from_file = finput . read () private_jwk_from_file = ( Jwk . from_pem_key ( private_pem_from_file , password = \"Th1s_P@ssW0rD_iS_5o_5tr0nG!\" ) . with_usage_parameters ( alg = \"ES256\" ) # adds back the alg, use and key_ops parameters . with_kid_thumbprint () # adds back the thumbprint as kid ) assert private_jwk_from_file == private_jwk # read the public PEM from file and load it as a Jwk: with open ( \"my_public_key.pem\" , \"rb\" ) as finput : public_pem_from_file = finput . read () public_jwk_from_file = ( Jwk . from_pem_key ( public_pem_from_file ) . with_usage_parameters ( alg = \"ES256\" ) # adds back the alg, use and key_ops parameters . with_kid_thumbprint () # adds back the thumbprint as kid ) assert public_jwk_from_file == public_jwk","title":"examples"},{"location":"recipes/#jwk","text":"","title":"JWK"},{"location":"recipes/#generate-privatepublic-key-pairs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from jwskate import Jwk private_jwk = ( Jwk . generate_for_alg ( \"ES256\" ) # select the signature or encryption alg here . with_kid_thumbprint () # optionally, include a RFC7638 compliant thumbprint as kid . with_usage_parameters () # optionally, include 'use' and 'key_ops' ) print ( private_jwk ) # { # \"kty\": \"EC\", # \"crv\": \"P-256\", # \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\", # \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\", # \"d\": \"Lce_08inNOEe6Q9xEGrR9T0CJNQa1o4EhGtDQYAI0N8\", # \"alg\": \"ES256\", # \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\", # \"use\": \"sig\", # \"key_ops\": [ # \"sign\" # ] # } public_jwk = private_jwk . public_jwk () print ( public_jwk . to_json ( indent = 2 )) # { # \"kty\": \"EC\", # \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\", # \"alg\": \"ES256\", # \"use\": \"sig\", # \"key_ops\": [ # \"verify\" # ], # \"crv\": \"P-256\", # \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\", # \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\" # } # let's expose this public key as a JWKS: print ( public_jwk . as_jwks () . to_json ( indent = 2 )) # { # \"keys\": [ # { # \"kty\": \"EC\", # \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\", # \"alg\": \"ES256\", # \"use\": \"sig\", # \"key_ops\": [ # \"verify\" # ], # \"crv\": \"P-256\", # \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\", # \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\" # } # ] # }","title":"Generate private/public key pairs"},{"location":"recipes/#fetching-a-jwks-from-a-remote-endpoint","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from jwskate import JwkSet import requests raw_jwks = requests . get ( \"https://www.googleapis.com/oauth2/v3/certs\" ) . json () jwkset = JwkSet ( raw_jwks ) print ( jwkset ) # { # \"keys\": [ # ... # ] # } # compared to a raw dict, a JwkSet offers convenience methods like: if jwkset . is_private : # returns True if the jwks contains at least one private key raise ValueError ( \"JWKS contains private keys!\" ) # an exposed JWKS should only contain public keys my_jwk = jwkset . get_jwk_by_kid ( \"my_key_id\" ) # gets a key by key id (kid) # select keys that is suitable for signature verification verification_jwks = jwkset . verification_keys () # select keys that are suitable for encryption encryption_jwks = jwkset . encryption_keys ()","title":"Fetching a JWKS from a remote endpoint"},{"location":"recipes/#converting-between-pem-key-jwk-and-cryptography-keys","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 from jwskate import Jwk # generate a sample JWK, any asymmetric type will do: private_jwk = ( Jwk . generate_for_alg ( \"ES256\" ) # generates the key . with_usage_parameters () # adds use and key_ops . with_kid_thumbprint () # adds the key thumbprint as kid ) print ( private_jwk . to_json ( indent = 2 )) # {'kty': 'EC', # 'crv': 'P-256', # 'x': '8xX1CEhDNNjEySUKLw88YeiVwEOW34BWm0hBkAxqlVU', # 'y': 'UfZ0JKT7MxdNMyqMKzKcAcYTcuqoXeplcJ3jNfnj3tM', # 'd': 'T45KDokOKyuhEA92ri5a951c5kjmQfGyh1SrEkonb4s', # 'alg': 'ES256', # 'use': 'sig', # 'key_ops': ['sign'], # 'kid': '_E8_LoT4QEwctEkGNbiP9dogVDz6Lq9i8G_fj9nnEo0'} # get the cryptography key that is wrapped in the Jwk: cryptography_private_key = private_jwk . cryptography_key print ( type ( cryptography_private_key )) # <class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePrivateKey'> # create the PEM for the private key (encrypted with a password) private_pem = private_jwk . to_pem ( \"Th1s_P@ssW0rD_iS_5o_5tr0nG!\" ) print ( private_pem . decode ()) # -----BEGIN ENCRYPTED PRIVATE KEY----- # MIHsMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAhFd4nINf0/8QICCAAw # DAYIKoZIhvcNAgkFADAdBglghkgBZQMEASoEEJNdsyMjSx3d6RqBBTuI5LoEgZD4 # qdPHcTZhKAuzQ9mkM1SlaZfiydWM2KFqPCYPLwoX+3kuCHPanMLlDxwOGN9XMRYl # hG3eO0Gu4eWdc/2QEcXIyBCbyKnSwhaHUSSfkhyK9eh8diHQw+blOIImIldLPxnp # +ABOhO6pCjQxM7I5op7RZuxLNWGLyAlfOOvawLfnM/wKLW6GXmlywu7PZ5qk9Bk= # -----END ENCRYPTED PRIVATE KEY----- # write this private PEM to a file: with open ( \"my_private_key.pem\" , \"wb\" ) as foutput : foutput . write ( private_pem ) # create the PEM for the public key (unencrypted) public_jwk = private_jwk . public_jwk () print ( public_jwk ) # { # \"kty\": \"EC\", # \"kid\": \"m-oFw9zA2YPFyqm265jbHnzXRa3SQ1ESdCE1AtAqO1U\", # \"alg\": \"ES256\", # \"use\": \"sig\", # \"key_ops\": [ # \"verify\" # ], # \"crv\": \"P-256\", # \"x\": \"VVbLOXwIgIFsYQSpnbLm5hr-ibfnIK0EeWYj2HXWvks\", # \"y\": \"7f24WIqwHGr-jU9dH8GHpPEHMtAuXiwsedFnS6xayhk\" # } # get the cryptography public key cryptography_public_key = public_jwk . cryptography_key print ( type ( cryptography_public_key )) # <class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePublicKey'> # get the public PEM public_pem = public_jwk . to_pem () print ( public_pem . decode ()) # -----BEGIN PUBLIC KEY----- # MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE8xX1CEhDNNjEySUKLw88YeiVwEOW # 34BWm0hBkAxqlVVR9nQkpPszF00zKowrMpwBxhNy6qhd6mVwneM1+ePe0w== # -----END PUBLIC KEY----- # write this public PEM to a file: with open ( \"my_public_key.pem\" , \"wb\" ) as foutput : foutput . write ( public_pem ) # read the private PEM from file and load it as a Jwk: with open ( \"my_private_key.pem\" , \"rb\" ) as finput : private_pem_from_file = finput . read () private_jwk_from_file = ( Jwk . from_pem_key ( private_pem_from_file , password = \"Th1s_P@ssW0rD_iS_5o_5tr0nG!\" ) . with_usage_parameters ( alg = \"ES256\" ) # adds back the alg, use and key_ops parameters . with_kid_thumbprint () # adds back the thumbprint as kid ) assert private_jwk_from_file == private_jwk # read the public PEM from file and load it as a Jwk: with open ( \"my_public_key.pem\" , \"rb\" ) as finput : public_pem_from_file = finput . read () public_jwk_from_file = ( Jwk . from_pem_key ( public_pem_from_file ) . with_usage_parameters ( alg = \"ES256\" ) # adds back the alg, use and key_ops parameters . with_kid_thumbprint () # adds back the thumbprint as kid ) assert public_jwk_from_file == public_jwk","title":"Converting between PEM key, JWK and cryptography keys"},{"location":"usage/","text":"Usage \u00b6 To use jwskate in a project, you can import all exposed objects from the root module: 1 from jwskate import * JWK \u00b6 Loading keys \u00b6 The Jwk class and its subclasses represent keys in JWK format. You can initialize a Jwk from: a dict representing the JWK content, already parsed from JSON: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) a string containing a JSON representation of the JWK: 1 2 3 4 5 6 7 8 from jwskate import Jwk jwk = Jwk ( '{\"kty\": \"EC\", \"crv\": \"P-256\",' 'x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",' 'y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",' 'd\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}' ) a cryptography key: 1 2 3 4 5 from jwskate import Jwk from cryptography.hazmat.primitives.asymmetric import ec key = ec . generate_private_key ( ec . SECP256R1 ) jwk = Jwk ( key ) a public or private key in PEM format, optionally protected by a password: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import Jwk public_jwk = Jwk . from_pem_key ( b \"\"\"-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsjtGIk8SxD+OEiBpP2/T JUAF0upwuKGMk6wH8Rwov88VvzJrVm2NCticTk5FUg+UG5r8JArrV4tJPRHQyvqK wF4NiksuvOjv3HyIf4oaOhZjT8hDne1Bfv+cFqZJ61Gk0MjANh/T5q9vxER/7TdU NHKpoRV+NVlKN5bEU/NQ5FQjVXicfswxh6Y6fl2PIFqT2CfjD+FkBPU1iT9qyJYH A38IRvwNtcitFgCeZwdGPoxiPPh1WHY8VxpUVBv/2JsUtrB/rAIbGqZoxAIWvijJ Pe9o1TY3VlOzk9ASZ1AeatvOir+iDVJ5OpKmLnzc46QgGPUsjIyo6Sje9dxpGtoG QQIDAQAB -----END PUBLIC KEY-----\"\"\" ) private_jwk = Jwk . from_pem_key ( b \"\"\"-----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAywYF71cKSo3xyi7/0S7N1blFCmBX4eZz0gXf+zyBfomuqhwr .... daBAqhoDEr4SoKju8pagw6lqm65XeARyWkxqFqAZbb2K3bWY3x9qZT6oubLrCDGD -----END RSA PRIVATE KEY-----\"\"\" , \"P@ssw0rd\" , ) Getting key parameters \u00b6 Once you have a Jwk instance, you can get its parameters either with subscription or attribute access: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert jwk . kty == \"EC\" assert jwk . crv == \"P-256\" assert jwk . x == \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" assert jwk [ \"x\" ] == jwk . x Those will return the exact (usually base64url-encoded) value exactly as expressed in the JWK. You can also get the real, decoded parameters with some special attributes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert ( jwk . x_coordinate == 41091394722340406951651919287101979028566994134304719828008599584440827098914 ) assert ( jwk . y_coordinate == 5099336126642036233987555101153084413345413137896124327269101893088581300336 ) assert ( jwk . ecc_private_key == 8342345011805978907621665437908035545366143771247820774310445528411160853919 ) The available special attributes vary depending on the key type. Generating keys \u00b6 Based on a Key Type \u00b6 You can generate a Jwk of a specific type (RSA, EC, etc.) using the class method Jwk.generate_for_kty() . It needs the key type as parameter, and type-specific parameters: 1 2 3 4 5 from jwskate import Jwk ec_jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) rsa_jwk = Jwk . generate_for_kty ( \"RSA\" , key_size = 4096 ) okp_jwk = Jwk . generate_for_kty ( \"OKP\" , crv = \"Ed25519\" ) You can include additional parameters such as \"use\" or \"key_ops\", or custom parameters which will be included in the generated key: 1 2 3 4 5 from jwskate import Jwk jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" , use = \"sig\" ) assert jwk . use == \"sig\" Based on intended algorithm \u00b6 You can generate a private key of the appropriate type for a given signature, key management or encryption algorithm by using the method Jwk.generate_for_alg() this way: 1 2 3 4 5 6 7 from jwskate import Jwk ec_jwk = Jwk . generate_for_alg ( \"ES512\" ) # key of type EC, with crv=P-521 rsa_jwk = Jwk . generate_for_alg ( \"RSA-OAEP-256\" , key_size = 4096 ) # RSA okp_jwk = Jwk . generate_for_alg ( \"EdDSA\" ) # EC, default to crv=P-256 okp_jwk = Jwk . generate_for_alg ( \"EdDSA\" , crv = \"P-521\" ) # EC, default to crv=P-256 okp_jwk = Jwk . generate_for_alg ( \"HS512\" ) Private and Public Keys \u00b6 You can check if a key is public or private with the is_private property: 1 2 3 4 5 6 7 8 9 10 11 12 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert jwk . is_private You can get the public key that match a given private key with the public_jwk() method. It returns a new Jwk instance that does not contain the private parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) public_jwk = jwk . public_jwk () assert \"d\" not in public_jwk # \"d\" would contain the private key assert not public_jwk . is_private Note that Symmetric keys are always considered private, so calling .public_jwk() will raise a ValueError . Dumping keys \u00b6 to JSON \u00b6 Jwk instances are dicts, so you can serialize it to JSON in the usual ways (with Python json module or any other means). You can also use the to_json() convenience method to serialize a Jwk: 1 2 3 4 5 6 7 8 9 10 11 12 13 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) jwk . to_json () # '{\"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\", \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\", \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}' to cryptography keys \u00b6 You can access the cryptography_key attribute to get a cryptography key instance that matches a Jwk : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) cryptography_key = jwk . cryptography_key assert ( str ( cryptography_key . __class__ ) == \"<class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePrivateKey'>\" ) Signing and verifying data \u00b6 You can sign arbitrary data, then validate the signature with a Jwk instance, using the sign() and verify() methods: 1 2 3 4 5 6 7 8 9 10 11 12 from jwskate import Jwk data = b \"Signing is easy!\" jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) signature = jwk . sign ( data , alg = \"ES256\" ) assert jwk . verify ( data , signature , alg = \"ES256\" ) assert not jwk . verify ( data , b \"this_is_a_wrong_signature_value_12345678012345678012345678012345\" , alg = \"ES256\" , ) Encrypting and Decrypting data \u00b6 Encryption or decryption require a symmetric key, which translates to an instance of SymmetricJwk , with kty='oct' . You can encrypt and decrypt arbitrary data with a Jwk instance, using the encrypt() and decrypt() methods: 1 2 3 4 5 6 7 8 9 from jwskate import Jwk data = b \"Encryption is easy!\" alg = \"A256GCM\" jwk = Jwk . generate_for_kty ( \"oct\" , key_size = 256 , alg = alg ) ciphertext , iv , tag = jwk . encrypt ( data ) assert jwk . decrypt ( ciphertext , iv = iv , tag = tag ) == data Authenticated encryption \u00b6 You can include Additional Authenticated Data ( aad ) in the encrypt() and decrypt() operations: 1 2 3 4 5 6 7 8 9 10 from jwskate import Jwk data = b \"Authenticated Encryption is easy!\" alg = \"A256GCM\" aad = b \"This is my auth tag\" jwk = Jwk . generate_for_kty ( \"oct\" , key_size = 256 , alg = alg ) ciphertext , iv , tag = jwk . encrypt ( data , aad = aad ) assert jwk . decrypt ( ciphertext , iv = iv , tag = tag , aad = aad ) == data Key Management \u00b6 Encrypting/decrypting arbitrary data requires a symmetric key. But it is possible to encrypt/decrypt or otherwise derive symmetric keys from asymmetric keys, using Key Management algorithms. Some of those Key Management algorithms rely on key wrapping, where a randomly-generated symmetric key (called a Content Encryption Key or CEK) is itself asymmetrically encrypted. It is also possible to use a symmetric key to \"wrap\" the CEK. Other algorithms rely on Diffie-Hellman, where the CEK is derived from a pair of keys, one private, the other public. You can use the methods sender_key() and receiver_key() to handle all the key management stuff for you. For sender_key() , which the message sender will use get a CEK, you just need to specify which encryption algorithm you will use with the CEK, and the key management algorithm you want to wrap or derive that CEK. It will return a tuple (plaintext_message, encrypted_cek, extra_headers) , with plaintext_message being the generated CEK (as an instance of SymmetricJwk ), encrypted_cek is the wrapped CEK value (which can be empty for Diffie-Hellman based algorithms), and extra_headers a dict of extra headers that are required for the key management algorithm (for example, epk for ECDH-ES based algorithms), You can use cleartext_cek to encrypt your message with a given Encryption algorithm. You must then send encrypted_cek and extra_headers to your recipient, along with the encrypted message, and both Key Management and Encryption algorithms identifiers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from jwskate import Jwk plaintext_message = b \"Key Management is easy!\" recipient_private_jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) # {'kty': 'EC', # 'crv': 'P-256', # 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE', # 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4', # 'd': 'Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E'} recipient_public_jwk = recipient_private_jwk . public_jwk () # {'kty': 'EC', # 'crv': 'P-256', # 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE', # 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4'} enc_alg = \"A256GCM\" km_alg = \"ECDH-ES\" plaintext_cek , encrypted_cek , extra_headers = recipient_public_jwk . sender_key ( enc = enc_alg , alg = km_alg ) # plaintext_cek: {'kty': 'oct', 'k': 'iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc'} # encrypted_cek: b'' # extra_headers: {'epk': {'kty': 'EC', # 'crv': 'P-256', # 'x': '_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg', # 'y': 'nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs'}} encrypted_message , iv , tag = plaintext_cek . encrypt ( plaintext_message , alg = enc_alg ) # encrypted_message: b'\\xb5J\\x16\\x08\\x82Xp\\x0f,\\x0eu\\xe5\\xd6\\xa6y\\xe0J\\xae\\xcbu\\xf8B\\xbd' # iv: b'K\"H\\xf3@\\tt\\\\\\xc78\\xc2D' # tag: b'\\xc4\\xee\\xcf`\\xfa\\\\\\x8e\\x9dn\\xc4>D\\xd8\\x1d\\x8c\\x1a' On recipient side, in order to decrypt the message, you will need to obtain the same symmetric CEK that was used to encrypt the message. That is done with recipient_key() . You need to provide it with the encrypted_cek received from the sender (possibly empty for Diffie-Hellman based algorithms), the Key Management algorithm that is used to wrap the CEK, the Encryption algorithm that is used to encrypt/decrypt the message, and the eventual extra headers depending on the Key Management algorithm. You can then use that CEK to decrypt the received message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from jwskate import Jwk # reusing the variables from above enc_alg = \"A256GCM\" km_alg = \"ECDH-ES\" plaintext_cek = { \"kty\" : \"oct\" , \"k\" : \"iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc\" } encrypted_cek = b \"\" extra_headers = { \"epk\" : { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg\" , \"y\" : \"nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs\" , } } recipient_private_jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE\" , \"y\" : \"Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4\" , \"d\" : \"Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E\" , } ) encrypted_message = b \" \\xb5 J \\x16\\x08\\x82 Xp \\x0f , \\x0e u \\xe5\\xd6\\xa6 y \\xe0 J \\xae\\xcb u \\xf8 B \\xbd \" iv = b 'K\"H \\xf3 @ \\t t \\\\\\xc7 8 \\xc2 D' tag = b \" \\xc4\\xee\\xcf ` \\xfa\\\\\\x8e\\x9d n \\xc4 >D \\xd8\\x1d\\x8c\\x1a \" # obtain the same CEK than the sender, based on our private key, and public data provided by sender cek = recipient_private_jwk . recipient_key ( encrypted_cek , enc = \"A256GCM\" , alg = \"ECDH-ES\" , ** extra_headers ) # and decrypt the message with that CEK (and the IV, Auth Tag and encryption alg identifier provided by sender) plaintext_message = cek . decrypt ( encrypted_message , iv = iv , tag = tag , alg = enc_alg ) assert plaintext_message == b \"Key Management is easy!\" JWS \u00b6 The JwsCompact class represents a syntactically valid JWS token in compact representation. Parsing tokens \u00b6 To parse an existing Jws token and access its content (without validating the signature yet), you simply need to create an instance of JwsCompact with the serialized token as value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import JwsCompact jws = JwsCompact ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\" \"SGVsbG8gV29ybGQh.\" \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\" \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\" \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\" \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\" \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\" ) jws . payload # b'Hello World!' jws . headers # {'alg': 'RS256', 'kid': 'JWK-ABCD'} jws . alg # 'RS256' jws . kid # 'JWK-ABCD' jws . signature # '\\xd5\\xeb\\x9cK\\xd6ZNp\\t\\xc9\\xf5M\\x87\\x12\\xc9\\xfe\\x98E7Z\\xde\\xc6m%\\xfar\\x17X\\x18\\xd4\"gR\\xdb\\xdc\\xf9\\xe4\\x1b\\xb1\\x1f\\xa3c\\x1a\\x99mIr\\xab\\x81\\x8cXC\\x1a\\x86\\n\\xc1\\x88\\xc6T\\x95\\xa0\\x81!)Wa\\x13U]\\xf4\\xd3\\xc9G,;#\\x8c\\xc1E\\xdc\\x15\\xbd\\xca\\x8cD\\xe0\\xcc\\xa8<B\\x8a\\xa6\\xc3C\\xfe[#\\x98\\xc0\\xa8Q\\t\\x00P\\x97f\\x8d\\x93\\xe2,e\\xc6\\xcf\\xb6y{fHJz\\xbd~uN\\ri\\xbe\\'\\x0c\\xe7\\xf6+)\\xf4\\xbc&}\\xe5\\xb7\\xdcV\\xe5\\x16\\x8d)B}\\xe0\\xa5K\\x96\\x8b\\xff\"w\\x05\\xb2\\x1d\\x9b\\x83\\x98\\xdd\\xa3T\\x84\\xa1Le\\x07b\\x08\\xd0\\x97e|+ \\x1e\\x88Iw\\x9f\\x1eZ1S\\xa1\\xe3m\\x1fW\\xa2\\\\g\\x998v\\xe50\\xbc\\xf9k\\x90!c\\xc8\\xd8\\xdc.6\\xe3\\xeb`\\x82>\\x81+\\xa7\\xf0\\xa5\\xe7]tP\\xf7\\x9a\\xd1EL\\xdc:)?\\xb6\\x12\\x04\\xde:Q\\x00\\xd3\\xdaP\\xa9na\\xa2\\xc0\\xa3\\xd9\\xdb\\x80\\x95\\x1f\\x85A' Verifying tokens \u00b6 To verify a Jws signature, you need the matching public key: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import JwsCompact jws = JwsCompact ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\" \"SGVsbG8gV29ybGQh.\" \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\" \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\" \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\" \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\" \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\" ) public_jwk = { \"kty\" : \"RSA\" , \"kid\" : \"JWK-ABCD\" , \"alg\" : \"RS256\" , \"n\" : \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\" , \"e\" : \"AQAB\" , } if jws . verify_signature ( public_jwk ): print ( \"Signature is verified.\" ) else : print ( \"Signature verification failed!\" ) Signing tokens \u00b6 To sign a Jws, you need its payload, the private key and alg to sign with, and provide those to JwsCompact.sign() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from jwskate import JwsCompact payload = b \"Hello World!\" private_jwk = { \"kty\" : \"RSA\" , \"kid\" : \"JWK-ABCD\" , \"alg\" : \"RS256\" , \"n\" : \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\" , \"e\" : \"AQAB\" , \"d\" : \"XCtpsCRQ1DBBm51yqdQ88C82lEjW30Xp0cy6iVEzBKZhmPGmI1PY8gnXWQ5PMlK3sLTM6yypDNvORoNlo6YXWJYA7LGlXEIczj2DOsJmF8T9-OEwGZixvNFDcmYnwWnlA6N_CQKmR0ziQr9ZAzZMCU5Tvr7f8cRZKdAALQEwk5FYpLnEbXOBduJtY9x2kddJSCJwRaEJhx0fG_pJAO3yLUZBY20dZK8UrxDoCgB9eiZV3N4uWGt367r1MDdaxGY6l6bC1HZCHkttBuTxfSUMCgooZevdU6ThQNpFrwZNY3KoP-OksEdqMs-neecfk_AQREkubDW2VPNFnaVEa38BKQ\" , \"p\" : \"8QNZGwUINpkuZi8l2ZfQzKVeOeNe3aQ7UW0wperM-63DFEJDRO1UyNC1n6yeo8_RxPZKSTlr6xZDoilQq23mopeF6O0ZmYz6E2VWJuma65V-A7tB-6xjqUXPlSkCNA6Ia8kMeCmNpKs0r0ijTBf_2y2GSsNH4EcP7XzcDEeJIh0\" , \"q\" : \"58nWgg-qRorRddwKM7qhLxJnEDsnCiYhbKJrP78OfBZ-839bNRvL5D5sfjJqxcKMQidgpYZVvVNL8oDEywcC5T7kKW0HK1JUdYiX9DuI40Mv9WzXQ8B8FBjp5wV4IX6_0KgyIiyoUiKpVHBvO0YFPUYuk0Ns4H9yEws93RWwhSc\" , \"dp\" : \"zFsLZcaphSnzVr9pd4urhqo9MBZjbMmBZnSQCE8ECe729ymMQlh-SFv3dHF4feuLsVcn-9iNceMJ6-jeNs1T_s89wxevWixYKrQFDa-MJW83T1CrDQvJ4VCJR69i5-Let43cXdLWACcO4AVWOQIsdpquQJw-SKPYlIUHS_4n_90\" , \"dq\" : \"fP79rNnhy3TlDBgDcG3-qjHUXo5nuTNi5wCXsaLInuZKw-k0OGmrBIUdYNizd744gRxXJCxTZGvdEwOaHJrFVvcZd7WSHiyh21g0CcNpSJVc8Y8mbyUIRJZC3RC3_egqbM2na4KFqvWCN0UC1wYloSuNxmCgAFj6HYb8b5NYxBU\" , \"qi\" : \"hxXfLYgwrfZBvZ27nrPsm6mLuoO-V2rKdOj3-YDJzf0gnVGBLl0DZbgydZ8WZmSLn2290mO_J8XY-Ss8PjLYbz3JXPDNLMJ-da3iEPKTvh6OfliM_dBxhaW8sq5afLMUR0H8NeabbWkfPz5h0W11CCBYxsyPC6CzniFYCYXfByU\" , } jws = JwsCompact . sign ( payload , jwk = private_jwk , alg = \"RS256\" ) str ( jws ) # 'eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.SGVsbG8gV29ybGQh.1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCsGIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixlxs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoUxlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedddFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ' JWE \u00b6 The JweCompact class represents a syntactically valid JWE token. Parsing and decrypting JWE tokens \u00b6 Provide the serialized token value to JweCompact , then use .deccrypt() with the private key to decrypt the token payload: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 from jwskate import JweCompact jwe = JweCompact ( \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\" \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\" \"ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\" \"Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\" \"mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\" \"1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\" \"6UklfCpIMfIjf7iGdXKHzg.\" \"48V1_ALb6US04U3b.\" \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\" \"SdiwkIr3ajwQzaBtQD_A.\" \"XFBoMYUZodetZdvTiFvSkQ\" ) # all 'raw' attributes are accessible: jwe . headers # {'alg': 'RSA-OAEP', 'enc': 'A256GCM'} jwe . alg # 'RSA-OAEP' jwe . enc # 'A256GCM' jwe . ciphertext # b\"\\xe5\\xec\\xa6\\xf15\\xbfs\\xc4\\xae+Im'z\\xe9`\\x8c\\xcex43\\xed0\\x0b\\xbe\\xdb\\xbaPoh2\\x8e/\\xa7;=\\xb5\\x7f\\xc4\\x15(R\\xf2 {\\x8f\\xa8\\xe2I\\xd8\\xb0\\x90\\x8a\\xf7j<\\x10\\xcd\\xa0m@?\\xc0\" jwe . wrapped_cek # b'8\\xa3\\x9a\\xc0:5\\xde\\x04i\\xda\\x88\\xda\\x1d^\\xcb\\x16\\x96\\\\\\x81^\\xd3\\xe85Y)<\\x8a8\\xc4\\xd8Rb\\xa8L%IF\\x07$\\x08\\xbfd\\x88\\xc4\\xf4\\xdc\\x91\\x9e\\x8a\\x9b\\x04u\\x8d\\xe6\\xc7\\xf7\\xad-\\xb6\\xd6J\\xb1k\\xd3\\x99\\x0b\\xcd\\xc4\\xab\\xe2\\xa2\\x80\\xab\\xb6\\r\\xed\\xefc\\xc1\\x04[\\xdby\\xdfk\\xa7=w\\xe4\\xad\\x9c\\x89\\x86\\xc8P\\xdbJ\\xfd8\\xb9[\\xb1\"\\x9eY\\x9a\\xcd`7\\x12\\x8a+`\\xda\\xd7\\x80|K\\x8a\\xf3U\\x19mu\\x8c\\x1a\\x9b\\xf9C\\xa7\\x95\\xe7d\\x06)A\\xd6\\xfb\\xe8WH(\\xb6\\x95\\x9a\\xa8\\x1f\\xc1~\\xd7Y\\x1co\\xdb}\\xb6\\x8b\\xeb\\xc3\\xc5\\x17\\xea7:?\\xb4D\\xca\\xce\\x95K\\xcd\\xf8\\xb0C\\'\\xb2<b\\xc1 \\xeez`\\x9e\\xde9\\xb7o\\xd27\\xbc\\xd7\\xce\\xb4\\xa6\\x96\\xa6j\\xfa7\\xe5H(E\\xd6\\xd8h\\x17(\\x87\\xd4\\x1c\\x7f)P\\xaf\\xae\\xa8s\\xab\\xc5Yt\\\\g\\xf6S\\xd8\\xb6\\xb0T%\\x93#-\\xdb\\xacc\\xe2\\xe9I%|*H1\\xf2#\\x7f\\xb8\\x86ur\\x87\\xce' jwe . initialization_vector # b'\\xe3\\xc5u\\xfc\\x02\\xdb\\xe9D\\xb4\\xe1M\\xdb' jwe . authentication_tag # b'\\\\Ph1\\x85\\x19\\xa1\\xd7\\xade\\xdb\\xd3\\x88[\\xd2\\x91' private_jwk = { \"kty\" : \"RSA\" , \"n\" : \"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW\" \"cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S\" \"psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a\" \"sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS\" \"tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj\" \"YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\" , \"e\" : \"AQAB\" , \"d\" : \"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N\" \"WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9\" \"3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk\" \"qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl\" \"t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd\" \"VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\" , \"p\" : \"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-\" \"SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf\" \"fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\" , \"q\" : \"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm\" \"UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX\" \"IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\" , \"dp\" : \"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL\" \"hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827\" \"rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\" , \"dq\" : \"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj\" \"ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB\" \"UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\" , \"qi\" : \"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7\" \"AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3\" \"eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\" , } payload = jwe . decrypt ( private_jwk ) assert payload == b \"The true sign of intelligence is not knowledge but imagination.\" # you can also decrypt only the CEK (returned as SymmetricJwk instance): cek = jwe . unwrap_cek ( private_jwk ) assert cek == { \"kty\" : \"oct\" , \"k\" : \"saH0gFSP4XM_tAP_a5rU9ooHbltwLiJpL4LLLnrqQPw\" } Encrypting JWE tokens \u00b6 To encrypt a JWE token, use JweCompact.encrypt() with the plaintext, public key, key management alg (alg) and encryption alg (enc): 1 2 3 4 5 6 7 8 9 from jwskate import JweCompact , Jwk plaintext = b \"Encrypting JWE is easy!\" private_jwk = Jwk . generate_for_kty ( \"EC\" ) public_jwk = private_jwk . public_jwk () jwe = JweCompact . encrypt ( plaintext , public_jwk , alg = \"ECDH-ES+A128KW\" , enc = \"A128GCM\" ) str ( jwe ) # 'eyJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTI1NiIsIngiOiI3a2VIdGxXdnVQQWVfYzR3d1hsNXFBZENHYzNKSk9KX0c5WThWU29Cc0tBIiwieSI6ImlyVFpRVzFlckZUSGd4WG1nUVdpcTVBYXdNOXNtamxybE96X2RTMmpld1kifSwiYWxnIjoiRUNESC1FUytBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.s7iUWLT2TG_kRnxuRvMxL5lY1oVRRVlI.kQaT5CM0HYfdwQ9H.49Trq2lpEtOEk8u_HP20TuJ80xpkqK8.RsQMBzvLj5i9bk4eew21gg' JWT \u00b6 JWT tokens are JWS tokens which contain a JSON object as payload. Some attributes of this JSON object are standardised to represent the token issuer, audience, and lifetime. The Jwt class and its subclasses represent a syntactically valid Jwt token. It then allows to access the JWT content and verify its signature. Note that a JWT token can optionally be encrypted. In that case, the signed JWT content will be the plaintext of a JWE token. Decrypting that JWE can then be achieved with the JweCompact class, then this plaintext can be manipulated with the Jwt class. Parsing JWT tokens \u00b6 To parse an existing JWT token, simply provide its value to Jwt . It exposes all the JWT attributes, and a verify_signature() method just like JwsCompact() . Claims can be accessed either: with the claims attribute, which is a dict of the parsed JSON content with subscription: jwt['attribute'] does a key lookup inside the claims dict, just like jwt.claims['attribute'] with attribute access: jwt.attribute does the same as jwt.claims['attribute'] . Note that attribute names containing special characters are not accessible this way due to Python syntax for attribute names. for 'special' standardised attributes, with their special attribute, which will parse and validate the attribute value. Example: jwt.expires_at returns a datetime initialised from the exp claim. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from jwskate import Jwt jwt = Jwt ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\" ) jwt . claims # {'acr': '2', # 'amr': ['pwd', 'otp'], # 'aud': 'client_id', # 'auth_time': 1629204560, # 'exp': 1629204620, # 'iat': 1629204560, # 'iss': 'https://myas.local', # 'nonce': 'nonce', # 'sub': '123456'} # example claim access via subscription: jwt [ \"acr\" ] # '2' # example claim access via attribute: jwt . sub # '123456' # example special claim access: jwt . expires_at # datetime.datetime(2021, 8, 17, 12, 50, 20, tzinfo=datetime.timezone.utc) # the raw 'exp' value is still accessible with the other means: jwt [ \"exp\" ] == jwt . exp == 1629204620 # True # other special attributes: jwt . audiences # always return a list # ['client_id'] jwt . issued_at # datetime.datetime(2021, 8, 17, 12, 49, 20, tzinfo=datetime.timezone.utc) jwt . not_before # this would be a datetime if there was a valid 'nbf' claim in the token None jwt . subject # makes sure that it is a string # '123456' jwt . issuer # makes sure that it is a string # 'https://myas.local' jwt . headers # {'alg': 'RS256', 'kid': 'my_key'} jwt . signature # b\"\\xc1G\\xe33(\\xe59'olQ\\x85?\\xc3\\xbc\\xc0g\\r\\x04\\xae\\xda\\x91\\xec\\x8eP\\x13/a\\xc3YrQT\\xb6\\x89\\x0e\\xcb\\x18KP\\xfcf\\xa3T\\xc7\\xa3P\\xd5\\xd4\\x11\\xd4U\\xde\\x80Y\\xf7\\x8aR|\\x93\\xc6_\\xfc\\xf8m\\xc4\\xfd\\xafn\\xe7\\x02_\\x0f'\\xe0\\x84\\xf0\\xe1\\ng\\xe4`\\x04o\\xa9\\t\\xe7W\\xfd\\xda!\\xb7\\xd3}@B\\xe1\\xfd\\x1b\\x1e\\xbd<w\\xfa\\xb4|@\\xfc\\xf1\\x12\\xee\\xef\\xbc\\x04H\\x83\\xc2V\\xa4\\x18\\xcbf\\xe4\\xe0R\\xeeq\\xce\\xb7\\xc8`oh+$\\xab;ag\\xceCl\\x12XX\\xb9Q\\xf2\\xa0T\\x93\\xf3@\\xf1\\xb5\\x80M\\x81-\\x8f\\x04\\xeb\\xc6\\x86^\\xfa\\xe0>\\xbc\\x1e\\x8d\\xc1K\\xf5\\x87\\xc0\\xcaF\\xc0\\xc5\\xfb\\xd1\\xd2Tw\\x96]p\\x1e\\xa0oT[\\xbc\\xe0\\xc6\\x867)\\xb0\\xc8W7\\xa6\\xbcl\\xec\\xd9\\x1fN\\x800QE\\xa7\\xc1\\x05W\\x80\\x905z\\t\\xd6\\xdd0\\xd2C\\x98|\\xdc\\x8d\\xab\\x1e\\xe65\\xfa,O\\xb7`,\\xbbs\\xb0\\x0c3[\\x96D)\\xca\\xdd\\xff\\x9a\\xcc\" # verifying the signature: assert jwt . verify_signature ( { \"kty\" : \"RSA\" , \"kid\" : \"my_key\" , \"alg\" : \"RS256\" , \"n\" : \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\" , \"e\" : \"AQAB\" , } ) # verifying expiration: assert jwt . is_expired () Validating JWT tokens \u00b6 To validate a JWT token, verifying the signature is usually not enough. You probably want to validate the issuer, audience, expiration date, and other claims. To make things easier, use SignedJwt.validate() . It raises exceptions if one of the check fails: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwt jwt = Jwt ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.\" \"eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\" ) jwk = { \"kty\" : \"RSA\" , \"kid\" : \"my_key\" , \"alg\" : \"RS256\" , \"n\" : \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\" , \"e\" : \"AQAB\" , } jwt . validate ( jwk , issuer = \"https://myas.local\" , audience = \"client_id\" ) # at the time you run this, it will probably raise a `jwskate.ExpiredJwt` exception Signing JWT tokens \u00b6 To sign a set of claims into a JWT, use Jwt.sign() . It takes the claims (as a dict), the signing key, and the signature alg to use (if the key doesn't have an 'alg' parameter). 1 2 3 4 5 6 7 8 from jwskate import Jwt , Jwk claims = { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" } jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) jwt = Jwt . sign ( claims , jwk , alg = \"ES256\" ) print ( jwt ) # eyJhbGciOiJFUzI1NiJ9.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.mqqXTljXQwNff0Sah88oFGBNWC9XpZxUj3WDa9-00UAyuEoL6cey-rHQNtmYgYgPRgI_HnWpRm5M4_a9qv9m0g JWT headers \u00b6 The default header will contain the signing algorithm identifier (alg) and the JWK Key Identifier (kid), if there was one in the used JWK. You can add additional headers by using the extra_headers parameter to Jwt.sign() : 1 2 3 4 5 6 7 8 9 10 from jwskate import Jwt , Jwk claims = { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" } jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) jwt = Jwt . sign ( claims , jwk , alg = \"ES256\" , extra_headers = { \"header1\" : \"value1\" }) print ( jwt ) # eyJoZWFkZXIxIjoidmFsdWUxIiwiYWxnIjoiRVMyNTYifQ.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.m0Bi8D6Rdi6HeH4J45JPSaeGPxjboAf_-efQ3mUAi6Gs0ipC0MXg9rd727IIINUsVfU0geUn7IwA1HjoTOsHvg print ( jwt . headers ) # {'header1': 'value1', 'alg': 'ES256'}","title":"usage"},{"location":"usage/#usage","text":"To use jwskate in a project, you can import all exposed objects from the root module: 1 from jwskate import *","title":"Usage"},{"location":"usage/#jwk","text":"","title":"JWK"},{"location":"usage/#loading-keys","text":"The Jwk class and its subclasses represent keys in JWK format. You can initialize a Jwk from: a dict representing the JWK content, already parsed from JSON: 1 2 3 4 5 6 7 8 9 10 11 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) a string containing a JSON representation of the JWK: 1 2 3 4 5 6 7 8 from jwskate import Jwk jwk = Jwk ( '{\"kty\": \"EC\", \"crv\": \"P-256\",' 'x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",' 'y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",' 'd\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}' ) a cryptography key: 1 2 3 4 5 from jwskate import Jwk from cryptography.hazmat.primitives.asymmetric import ec key = ec . generate_private_key ( ec . SECP256R1 ) jwk = Jwk ( key ) a public or private key in PEM format, optionally protected by a password: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import Jwk public_jwk = Jwk . from_pem_key ( b \"\"\"-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsjtGIk8SxD+OEiBpP2/T JUAF0upwuKGMk6wH8Rwov88VvzJrVm2NCticTk5FUg+UG5r8JArrV4tJPRHQyvqK wF4NiksuvOjv3HyIf4oaOhZjT8hDne1Bfv+cFqZJ61Gk0MjANh/T5q9vxER/7TdU NHKpoRV+NVlKN5bEU/NQ5FQjVXicfswxh6Y6fl2PIFqT2CfjD+FkBPU1iT9qyJYH A38IRvwNtcitFgCeZwdGPoxiPPh1WHY8VxpUVBv/2JsUtrB/rAIbGqZoxAIWvijJ Pe9o1TY3VlOzk9ASZ1AeatvOir+iDVJ5OpKmLnzc46QgGPUsjIyo6Sje9dxpGtoG QQIDAQAB -----END PUBLIC KEY-----\"\"\" ) private_jwk = Jwk . from_pem_key ( b \"\"\"-----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAywYF71cKSo3xyi7/0S7N1blFCmBX4eZz0gXf+zyBfomuqhwr .... daBAqhoDEr4SoKju8pagw6lqm65XeARyWkxqFqAZbb2K3bWY3x9qZT6oubLrCDGD -----END RSA PRIVATE KEY-----\"\"\" , \"P@ssw0rd\" , )","title":"Loading keys"},{"location":"usage/#getting-key-parameters","text":"Once you have a Jwk instance, you can get its parameters either with subscription or attribute access: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert jwk . kty == \"EC\" assert jwk . crv == \"P-256\" assert jwk . x == \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" assert jwk [ \"x\" ] == jwk . x Those will return the exact (usually base64url-encoded) value exactly as expressed in the JWK. You can also get the real, decoded parameters with some special attributes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert ( jwk . x_coordinate == 41091394722340406951651919287101979028566994134304719828008599584440827098914 ) assert ( jwk . y_coordinate == 5099336126642036233987555101153084413345413137896124327269101893088581300336 ) assert ( jwk . ecc_private_key == 8342345011805978907621665437908035545366143771247820774310445528411160853919 ) The available special attributes vary depending on the key type.","title":"Getting key parameters"},{"location":"usage/#generating-keys","text":"","title":"Generating keys"},{"location":"usage/#based-on-a-key-type","text":"You can generate a Jwk of a specific type (RSA, EC, etc.) using the class method Jwk.generate_for_kty() . It needs the key type as parameter, and type-specific parameters: 1 2 3 4 5 from jwskate import Jwk ec_jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) rsa_jwk = Jwk . generate_for_kty ( \"RSA\" , key_size = 4096 ) okp_jwk = Jwk . generate_for_kty ( \"OKP\" , crv = \"Ed25519\" ) You can include additional parameters such as \"use\" or \"key_ops\", or custom parameters which will be included in the generated key: 1 2 3 4 5 from jwskate import Jwk jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" , use = \"sig\" ) assert jwk . use == \"sig\"","title":"Based on a Key Type"},{"location":"usage/#based-on-intended-algorithm","text":"You can generate a private key of the appropriate type for a given signature, key management or encryption algorithm by using the method Jwk.generate_for_alg() this way: 1 2 3 4 5 6 7 from jwskate import Jwk ec_jwk = Jwk . generate_for_alg ( \"ES512\" ) # key of type EC, with crv=P-521 rsa_jwk = Jwk . generate_for_alg ( \"RSA-OAEP-256\" , key_size = 4096 ) # RSA okp_jwk = Jwk . generate_for_alg ( \"EdDSA\" ) # EC, default to crv=P-256 okp_jwk = Jwk . generate_for_alg ( \"EdDSA\" , crv = \"P-521\" ) # EC, default to crv=P-256 okp_jwk = Jwk . generate_for_alg ( \"HS512\" )","title":"Based on intended algorithm"},{"location":"usage/#private-and-public-keys","text":"You can check if a key is public or private with the is_private property: 1 2 3 4 5 6 7 8 9 10 11 12 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) assert jwk . is_private You can get the public key that match a given private key with the public_jwk() method. It returns a new Jwk instance that does not contain the private parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) public_jwk = jwk . public_jwk () assert \"d\" not in public_jwk # \"d\" would contain the private key assert not public_jwk . is_private Note that Symmetric keys are always considered private, so calling .public_jwk() will raise a ValueError .","title":"Private and Public Keys"},{"location":"usage/#dumping-keys","text":"","title":"Dumping keys"},{"location":"usage/#to-json","text":"Jwk instances are dicts, so you can serialize it to JSON in the usual ways (with Python json module or any other means). You can also use the to_json() convenience method to serialize a Jwk: 1 2 3 4 5 6 7 8 9 10 11 12 13 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) jwk . to_json () # '{\"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\", \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\", \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}'","title":"to JSON"},{"location":"usage/#to-cryptography-keys","text":"You can access the cryptography_key attribute to get a cryptography key instance that matches a Jwk : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwk jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\" , \"y\" : \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\" , \"d\" : \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\" , } ) cryptography_key = jwk . cryptography_key assert ( str ( cryptography_key . __class__ ) == \"<class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePrivateKey'>\" )","title":"to cryptography keys"},{"location":"usage/#signing-and-verifying-data","text":"You can sign arbitrary data, then validate the signature with a Jwk instance, using the sign() and verify() methods: 1 2 3 4 5 6 7 8 9 10 11 12 from jwskate import Jwk data = b \"Signing is easy!\" jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) signature = jwk . sign ( data , alg = \"ES256\" ) assert jwk . verify ( data , signature , alg = \"ES256\" ) assert not jwk . verify ( data , b \"this_is_a_wrong_signature_value_12345678012345678012345678012345\" , alg = \"ES256\" , )","title":"Signing and verifying data"},{"location":"usage/#encrypting-and-decrypting-data","text":"Encryption or decryption require a symmetric key, which translates to an instance of SymmetricJwk , with kty='oct' . You can encrypt and decrypt arbitrary data with a Jwk instance, using the encrypt() and decrypt() methods: 1 2 3 4 5 6 7 8 9 from jwskate import Jwk data = b \"Encryption is easy!\" alg = \"A256GCM\" jwk = Jwk . generate_for_kty ( \"oct\" , key_size = 256 , alg = alg ) ciphertext , iv , tag = jwk . encrypt ( data ) assert jwk . decrypt ( ciphertext , iv = iv , tag = tag ) == data","title":"Encrypting and Decrypting data"},{"location":"usage/#authenticated-encryption","text":"You can include Additional Authenticated Data ( aad ) in the encrypt() and decrypt() operations: 1 2 3 4 5 6 7 8 9 10 from jwskate import Jwk data = b \"Authenticated Encryption is easy!\" alg = \"A256GCM\" aad = b \"This is my auth tag\" jwk = Jwk . generate_for_kty ( \"oct\" , key_size = 256 , alg = alg ) ciphertext , iv , tag = jwk . encrypt ( data , aad = aad ) assert jwk . decrypt ( ciphertext , iv = iv , tag = tag , aad = aad ) == data","title":"Authenticated encryption"},{"location":"usage/#key-management","text":"Encrypting/decrypting arbitrary data requires a symmetric key. But it is possible to encrypt/decrypt or otherwise derive symmetric keys from asymmetric keys, using Key Management algorithms. Some of those Key Management algorithms rely on key wrapping, where a randomly-generated symmetric key (called a Content Encryption Key or CEK) is itself asymmetrically encrypted. It is also possible to use a symmetric key to \"wrap\" the CEK. Other algorithms rely on Diffie-Hellman, where the CEK is derived from a pair of keys, one private, the other public. You can use the methods sender_key() and receiver_key() to handle all the key management stuff for you. For sender_key() , which the message sender will use get a CEK, you just need to specify which encryption algorithm you will use with the CEK, and the key management algorithm you want to wrap or derive that CEK. It will return a tuple (plaintext_message, encrypted_cek, extra_headers) , with plaintext_message being the generated CEK (as an instance of SymmetricJwk ), encrypted_cek is the wrapped CEK value (which can be empty for Diffie-Hellman based algorithms), and extra_headers a dict of extra headers that are required for the key management algorithm (for example, epk for ECDH-ES based algorithms), You can use cleartext_cek to encrypt your message with a given Encryption algorithm. You must then send encrypted_cek and extra_headers to your recipient, along with the encrypted message, and both Key Management and Encryption algorithms identifiers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from jwskate import Jwk plaintext_message = b \"Key Management is easy!\" recipient_private_jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) # {'kty': 'EC', # 'crv': 'P-256', # 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE', # 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4', # 'd': 'Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E'} recipient_public_jwk = recipient_private_jwk . public_jwk () # {'kty': 'EC', # 'crv': 'P-256', # 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE', # 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4'} enc_alg = \"A256GCM\" km_alg = \"ECDH-ES\" plaintext_cek , encrypted_cek , extra_headers = recipient_public_jwk . sender_key ( enc = enc_alg , alg = km_alg ) # plaintext_cek: {'kty': 'oct', 'k': 'iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc'} # encrypted_cek: b'' # extra_headers: {'epk': {'kty': 'EC', # 'crv': 'P-256', # 'x': '_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg', # 'y': 'nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs'}} encrypted_message , iv , tag = plaintext_cek . encrypt ( plaintext_message , alg = enc_alg ) # encrypted_message: b'\\xb5J\\x16\\x08\\x82Xp\\x0f,\\x0eu\\xe5\\xd6\\xa6y\\xe0J\\xae\\xcbu\\xf8B\\xbd' # iv: b'K\"H\\xf3@\\tt\\\\\\xc78\\xc2D' # tag: b'\\xc4\\xee\\xcf`\\xfa\\\\\\x8e\\x9dn\\xc4>D\\xd8\\x1d\\x8c\\x1a' On recipient side, in order to decrypt the message, you will need to obtain the same symmetric CEK that was used to encrypt the message. That is done with recipient_key() . You need to provide it with the encrypted_cek received from the sender (possibly empty for Diffie-Hellman based algorithms), the Key Management algorithm that is used to wrap the CEK, the Encryption algorithm that is used to encrypt/decrypt the message, and the eventual extra headers depending on the Key Management algorithm. You can then use that CEK to decrypt the received message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from jwskate import Jwk # reusing the variables from above enc_alg = \"A256GCM\" km_alg = \"ECDH-ES\" plaintext_cek = { \"kty\" : \"oct\" , \"k\" : \"iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc\" } encrypted_cek = b \"\" extra_headers = { \"epk\" : { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg\" , \"y\" : \"nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs\" , } } recipient_private_jwk = Jwk ( { \"kty\" : \"EC\" , \"crv\" : \"P-256\" , \"x\" : \"10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE\" , \"y\" : \"Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4\" , \"d\" : \"Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E\" , } ) encrypted_message = b \" \\xb5 J \\x16\\x08\\x82 Xp \\x0f , \\x0e u \\xe5\\xd6\\xa6 y \\xe0 J \\xae\\xcb u \\xf8 B \\xbd \" iv = b 'K\"H \\xf3 @ \\t t \\\\\\xc7 8 \\xc2 D' tag = b \" \\xc4\\xee\\xcf ` \\xfa\\\\\\x8e\\x9d n \\xc4 >D \\xd8\\x1d\\x8c\\x1a \" # obtain the same CEK than the sender, based on our private key, and public data provided by sender cek = recipient_private_jwk . recipient_key ( encrypted_cek , enc = \"A256GCM\" , alg = \"ECDH-ES\" , ** extra_headers ) # and decrypt the message with that CEK (and the IV, Auth Tag and encryption alg identifier provided by sender) plaintext_message = cek . decrypt ( encrypted_message , iv = iv , tag = tag , alg = enc_alg ) assert plaintext_message == b \"Key Management is easy!\"","title":"Key Management"},{"location":"usage/#jws","text":"The JwsCompact class represents a syntactically valid JWS token in compact representation.","title":"JWS"},{"location":"usage/#parsing-tokens","text":"To parse an existing Jws token and access its content (without validating the signature yet), you simply need to create an instance of JwsCompact with the serialized token as value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import JwsCompact jws = JwsCompact ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\" \"SGVsbG8gV29ybGQh.\" \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\" \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\" \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\" \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\" \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\" ) jws . payload # b'Hello World!' jws . headers # {'alg': 'RS256', 'kid': 'JWK-ABCD'} jws . alg # 'RS256' jws . kid # 'JWK-ABCD' jws . signature # '\\xd5\\xeb\\x9cK\\xd6ZNp\\t\\xc9\\xf5M\\x87\\x12\\xc9\\xfe\\x98E7Z\\xde\\xc6m%\\xfar\\x17X\\x18\\xd4\"gR\\xdb\\xdc\\xf9\\xe4\\x1b\\xb1\\x1f\\xa3c\\x1a\\x99mIr\\xab\\x81\\x8cXC\\x1a\\x86\\n\\xc1\\x88\\xc6T\\x95\\xa0\\x81!)Wa\\x13U]\\xf4\\xd3\\xc9G,;#\\x8c\\xc1E\\xdc\\x15\\xbd\\xca\\x8cD\\xe0\\xcc\\xa8<B\\x8a\\xa6\\xc3C\\xfe[#\\x98\\xc0\\xa8Q\\t\\x00P\\x97f\\x8d\\x93\\xe2,e\\xc6\\xcf\\xb6y{fHJz\\xbd~uN\\ri\\xbe\\'\\x0c\\xe7\\xf6+)\\xf4\\xbc&}\\xe5\\xb7\\xdcV\\xe5\\x16\\x8d)B}\\xe0\\xa5K\\x96\\x8b\\xff\"w\\x05\\xb2\\x1d\\x9b\\x83\\x98\\xdd\\xa3T\\x84\\xa1Le\\x07b\\x08\\xd0\\x97e|+ \\x1e\\x88Iw\\x9f\\x1eZ1S\\xa1\\xe3m\\x1fW\\xa2\\\\g\\x998v\\xe50\\xbc\\xf9k\\x90!c\\xc8\\xd8\\xdc.6\\xe3\\xeb`\\x82>\\x81+\\xa7\\xf0\\xa5\\xe7]tP\\xf7\\x9a\\xd1EL\\xdc:)?\\xb6\\x12\\x04\\xde:Q\\x00\\xd3\\xdaP\\xa9na\\xa2\\xc0\\xa3\\xd9\\xdb\\x80\\x95\\x1f\\x85A'","title":"Parsing tokens"},{"location":"usage/#verifying-tokens","text":"To verify a Jws signature, you need the matching public key: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from jwskate import JwsCompact jws = JwsCompact ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\" \"SGVsbG8gV29ybGQh.\" \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\" \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\" \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\" \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\" \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\" ) public_jwk = { \"kty\" : \"RSA\" , \"kid\" : \"JWK-ABCD\" , \"alg\" : \"RS256\" , \"n\" : \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\" , \"e\" : \"AQAB\" , } if jws . verify_signature ( public_jwk ): print ( \"Signature is verified.\" ) else : print ( \"Signature verification failed!\" )","title":"Verifying tokens"},{"location":"usage/#signing-tokens","text":"To sign a Jws, you need its payload, the private key and alg to sign with, and provide those to JwsCompact.sign() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from jwskate import JwsCompact payload = b \"Hello World!\" private_jwk = { \"kty\" : \"RSA\" , \"kid\" : \"JWK-ABCD\" , \"alg\" : \"RS256\" , \"n\" : \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\" , \"e\" : \"AQAB\" , \"d\" : \"XCtpsCRQ1DBBm51yqdQ88C82lEjW30Xp0cy6iVEzBKZhmPGmI1PY8gnXWQ5PMlK3sLTM6yypDNvORoNlo6YXWJYA7LGlXEIczj2DOsJmF8T9-OEwGZixvNFDcmYnwWnlA6N_CQKmR0ziQr9ZAzZMCU5Tvr7f8cRZKdAALQEwk5FYpLnEbXOBduJtY9x2kddJSCJwRaEJhx0fG_pJAO3yLUZBY20dZK8UrxDoCgB9eiZV3N4uWGt367r1MDdaxGY6l6bC1HZCHkttBuTxfSUMCgooZevdU6ThQNpFrwZNY3KoP-OksEdqMs-neecfk_AQREkubDW2VPNFnaVEa38BKQ\" , \"p\" : \"8QNZGwUINpkuZi8l2ZfQzKVeOeNe3aQ7UW0wperM-63DFEJDRO1UyNC1n6yeo8_RxPZKSTlr6xZDoilQq23mopeF6O0ZmYz6E2VWJuma65V-A7tB-6xjqUXPlSkCNA6Ia8kMeCmNpKs0r0ijTBf_2y2GSsNH4EcP7XzcDEeJIh0\" , \"q\" : \"58nWgg-qRorRddwKM7qhLxJnEDsnCiYhbKJrP78OfBZ-839bNRvL5D5sfjJqxcKMQidgpYZVvVNL8oDEywcC5T7kKW0HK1JUdYiX9DuI40Mv9WzXQ8B8FBjp5wV4IX6_0KgyIiyoUiKpVHBvO0YFPUYuk0Ns4H9yEws93RWwhSc\" , \"dp\" : \"zFsLZcaphSnzVr9pd4urhqo9MBZjbMmBZnSQCE8ECe729ymMQlh-SFv3dHF4feuLsVcn-9iNceMJ6-jeNs1T_s89wxevWixYKrQFDa-MJW83T1CrDQvJ4VCJR69i5-Let43cXdLWACcO4AVWOQIsdpquQJw-SKPYlIUHS_4n_90\" , \"dq\" : \"fP79rNnhy3TlDBgDcG3-qjHUXo5nuTNi5wCXsaLInuZKw-k0OGmrBIUdYNizd744gRxXJCxTZGvdEwOaHJrFVvcZd7WSHiyh21g0CcNpSJVc8Y8mbyUIRJZC3RC3_egqbM2na4KFqvWCN0UC1wYloSuNxmCgAFj6HYb8b5NYxBU\" , \"qi\" : \"hxXfLYgwrfZBvZ27nrPsm6mLuoO-V2rKdOj3-YDJzf0gnVGBLl0DZbgydZ8WZmSLn2290mO_J8XY-Ss8PjLYbz3JXPDNLMJ-da3iEPKTvh6OfliM_dBxhaW8sq5afLMUR0H8NeabbWkfPz5h0W11CCBYxsyPC6CzniFYCYXfByU\" , } jws = JwsCompact . sign ( payload , jwk = private_jwk , alg = \"RS256\" ) str ( jws ) # 'eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.SGVsbG8gV29ybGQh.1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCsGIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixlxs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoUxlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedddFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ'","title":"Signing tokens"},{"location":"usage/#jwe","text":"The JweCompact class represents a syntactically valid JWE token.","title":"JWE"},{"location":"usage/#parsing-and-decrypting-jwe-tokens","text":"Provide the serialized token value to JweCompact , then use .deccrypt() with the private key to decrypt the token payload: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 from jwskate import JweCompact jwe = JweCompact ( \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\" \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\" \"ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\" \"Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\" \"mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\" \"1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\" \"6UklfCpIMfIjf7iGdXKHzg.\" \"48V1_ALb6US04U3b.\" \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\" \"SdiwkIr3ajwQzaBtQD_A.\" \"XFBoMYUZodetZdvTiFvSkQ\" ) # all 'raw' attributes are accessible: jwe . headers # {'alg': 'RSA-OAEP', 'enc': 'A256GCM'} jwe . alg # 'RSA-OAEP' jwe . enc # 'A256GCM' jwe . ciphertext # b\"\\xe5\\xec\\xa6\\xf15\\xbfs\\xc4\\xae+Im'z\\xe9`\\x8c\\xcex43\\xed0\\x0b\\xbe\\xdb\\xbaPoh2\\x8e/\\xa7;=\\xb5\\x7f\\xc4\\x15(R\\xf2 {\\x8f\\xa8\\xe2I\\xd8\\xb0\\x90\\x8a\\xf7j<\\x10\\xcd\\xa0m@?\\xc0\" jwe . wrapped_cek # b'8\\xa3\\x9a\\xc0:5\\xde\\x04i\\xda\\x88\\xda\\x1d^\\xcb\\x16\\x96\\\\\\x81^\\xd3\\xe85Y)<\\x8a8\\xc4\\xd8Rb\\xa8L%IF\\x07$\\x08\\xbfd\\x88\\xc4\\xf4\\xdc\\x91\\x9e\\x8a\\x9b\\x04u\\x8d\\xe6\\xc7\\xf7\\xad-\\xb6\\xd6J\\xb1k\\xd3\\x99\\x0b\\xcd\\xc4\\xab\\xe2\\xa2\\x80\\xab\\xb6\\r\\xed\\xefc\\xc1\\x04[\\xdby\\xdfk\\xa7=w\\xe4\\xad\\x9c\\x89\\x86\\xc8P\\xdbJ\\xfd8\\xb9[\\xb1\"\\x9eY\\x9a\\xcd`7\\x12\\x8a+`\\xda\\xd7\\x80|K\\x8a\\xf3U\\x19mu\\x8c\\x1a\\x9b\\xf9C\\xa7\\x95\\xe7d\\x06)A\\xd6\\xfb\\xe8WH(\\xb6\\x95\\x9a\\xa8\\x1f\\xc1~\\xd7Y\\x1co\\xdb}\\xb6\\x8b\\xeb\\xc3\\xc5\\x17\\xea7:?\\xb4D\\xca\\xce\\x95K\\xcd\\xf8\\xb0C\\'\\xb2<b\\xc1 \\xeez`\\x9e\\xde9\\xb7o\\xd27\\xbc\\xd7\\xce\\xb4\\xa6\\x96\\xa6j\\xfa7\\xe5H(E\\xd6\\xd8h\\x17(\\x87\\xd4\\x1c\\x7f)P\\xaf\\xae\\xa8s\\xab\\xc5Yt\\\\g\\xf6S\\xd8\\xb6\\xb0T%\\x93#-\\xdb\\xacc\\xe2\\xe9I%|*H1\\xf2#\\x7f\\xb8\\x86ur\\x87\\xce' jwe . initialization_vector # b'\\xe3\\xc5u\\xfc\\x02\\xdb\\xe9D\\xb4\\xe1M\\xdb' jwe . authentication_tag # b'\\\\Ph1\\x85\\x19\\xa1\\xd7\\xade\\xdb\\xd3\\x88[\\xd2\\x91' private_jwk = { \"kty\" : \"RSA\" , \"n\" : \"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW\" \"cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S\" \"psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a\" \"sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS\" \"tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj\" \"YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\" , \"e\" : \"AQAB\" , \"d\" : \"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N\" \"WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9\" \"3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk\" \"qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl\" \"t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd\" \"VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\" , \"p\" : \"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-\" \"SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf\" \"fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\" , \"q\" : \"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm\" \"UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX\" \"IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\" , \"dp\" : \"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL\" \"hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827\" \"rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\" , \"dq\" : \"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj\" \"ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB\" \"UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\" , \"qi\" : \"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7\" \"AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3\" \"eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\" , } payload = jwe . decrypt ( private_jwk ) assert payload == b \"The true sign of intelligence is not knowledge but imagination.\" # you can also decrypt only the CEK (returned as SymmetricJwk instance): cek = jwe . unwrap_cek ( private_jwk ) assert cek == { \"kty\" : \"oct\" , \"k\" : \"saH0gFSP4XM_tAP_a5rU9ooHbltwLiJpL4LLLnrqQPw\" }","title":"Parsing and decrypting JWE tokens"},{"location":"usage/#encrypting-jwe-tokens","text":"To encrypt a JWE token, use JweCompact.encrypt() with the plaintext, public key, key management alg (alg) and encryption alg (enc): 1 2 3 4 5 6 7 8 9 from jwskate import JweCompact , Jwk plaintext = b \"Encrypting JWE is easy!\" private_jwk = Jwk . generate_for_kty ( \"EC\" ) public_jwk = private_jwk . public_jwk () jwe = JweCompact . encrypt ( plaintext , public_jwk , alg = \"ECDH-ES+A128KW\" , enc = \"A128GCM\" ) str ( jwe ) # 'eyJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTI1NiIsIngiOiI3a2VIdGxXdnVQQWVfYzR3d1hsNXFBZENHYzNKSk9KX0c5WThWU29Cc0tBIiwieSI6ImlyVFpRVzFlckZUSGd4WG1nUVdpcTVBYXdNOXNtamxybE96X2RTMmpld1kifSwiYWxnIjoiRUNESC1FUytBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.s7iUWLT2TG_kRnxuRvMxL5lY1oVRRVlI.kQaT5CM0HYfdwQ9H.49Trq2lpEtOEk8u_HP20TuJ80xpkqK8.RsQMBzvLj5i9bk4eew21gg'","title":"Encrypting JWE tokens"},{"location":"usage/#jwt","text":"JWT tokens are JWS tokens which contain a JSON object as payload. Some attributes of this JSON object are standardised to represent the token issuer, audience, and lifetime. The Jwt class and its subclasses represent a syntactically valid Jwt token. It then allows to access the JWT content and verify its signature. Note that a JWT token can optionally be encrypted. In that case, the signed JWT content will be the plaintext of a JWE token. Decrypting that JWE can then be achieved with the JweCompact class, then this plaintext can be manipulated with the Jwt class.","title":"JWT"},{"location":"usage/#parsing-jwt-tokens","text":"To parse an existing JWT token, simply provide its value to Jwt . It exposes all the JWT attributes, and a verify_signature() method just like JwsCompact() . Claims can be accessed either: with the claims attribute, which is a dict of the parsed JSON content with subscription: jwt['attribute'] does a key lookup inside the claims dict, just like jwt.claims['attribute'] with attribute access: jwt.attribute does the same as jwt.claims['attribute'] . Note that attribute names containing special characters are not accessible this way due to Python syntax for attribute names. for 'special' standardised attributes, with their special attribute, which will parse and validate the attribute value. Example: jwt.expires_at returns a datetime initialised from the exp claim. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from jwskate import Jwt jwt = Jwt ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\" ) jwt . claims # {'acr': '2', # 'amr': ['pwd', 'otp'], # 'aud': 'client_id', # 'auth_time': 1629204560, # 'exp': 1629204620, # 'iat': 1629204560, # 'iss': 'https://myas.local', # 'nonce': 'nonce', # 'sub': '123456'} # example claim access via subscription: jwt [ \"acr\" ] # '2' # example claim access via attribute: jwt . sub # '123456' # example special claim access: jwt . expires_at # datetime.datetime(2021, 8, 17, 12, 50, 20, tzinfo=datetime.timezone.utc) # the raw 'exp' value is still accessible with the other means: jwt [ \"exp\" ] == jwt . exp == 1629204620 # True # other special attributes: jwt . audiences # always return a list # ['client_id'] jwt . issued_at # datetime.datetime(2021, 8, 17, 12, 49, 20, tzinfo=datetime.timezone.utc) jwt . not_before # this would be a datetime if there was a valid 'nbf' claim in the token None jwt . subject # makes sure that it is a string # '123456' jwt . issuer # makes sure that it is a string # 'https://myas.local' jwt . headers # {'alg': 'RS256', 'kid': 'my_key'} jwt . signature # b\"\\xc1G\\xe33(\\xe59'olQ\\x85?\\xc3\\xbc\\xc0g\\r\\x04\\xae\\xda\\x91\\xec\\x8eP\\x13/a\\xc3YrQT\\xb6\\x89\\x0e\\xcb\\x18KP\\xfcf\\xa3T\\xc7\\xa3P\\xd5\\xd4\\x11\\xd4U\\xde\\x80Y\\xf7\\x8aR|\\x93\\xc6_\\xfc\\xf8m\\xc4\\xfd\\xafn\\xe7\\x02_\\x0f'\\xe0\\x84\\xf0\\xe1\\ng\\xe4`\\x04o\\xa9\\t\\xe7W\\xfd\\xda!\\xb7\\xd3}@B\\xe1\\xfd\\x1b\\x1e\\xbd<w\\xfa\\xb4|@\\xfc\\xf1\\x12\\xee\\xef\\xbc\\x04H\\x83\\xc2V\\xa4\\x18\\xcbf\\xe4\\xe0R\\xeeq\\xce\\xb7\\xc8`oh+$\\xab;ag\\xceCl\\x12XX\\xb9Q\\xf2\\xa0T\\x93\\xf3@\\xf1\\xb5\\x80M\\x81-\\x8f\\x04\\xeb\\xc6\\x86^\\xfa\\xe0>\\xbc\\x1e\\x8d\\xc1K\\xf5\\x87\\xc0\\xcaF\\xc0\\xc5\\xfb\\xd1\\xd2Tw\\x96]p\\x1e\\xa0oT[\\xbc\\xe0\\xc6\\x867)\\xb0\\xc8W7\\xa6\\xbcl\\xec\\xd9\\x1fN\\x800QE\\xa7\\xc1\\x05W\\x80\\x905z\\t\\xd6\\xdd0\\xd2C\\x98|\\xdc\\x8d\\xab\\x1e\\xe65\\xfa,O\\xb7`,\\xbbs\\xb0\\x0c3[\\x96D)\\xca\\xdd\\xff\\x9a\\xcc\" # verifying the signature: assert jwt . verify_signature ( { \"kty\" : \"RSA\" , \"kid\" : \"my_key\" , \"alg\" : \"RS256\" , \"n\" : \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\" , \"e\" : \"AQAB\" , } ) # verifying expiration: assert jwt . is_expired ()","title":"Parsing JWT tokens"},{"location":"usage/#validating-jwt-tokens","text":"To validate a JWT token, verifying the signature is usually not enough. You probably want to validate the issuer, audience, expiration date, and other claims. To make things easier, use SignedJwt.validate() . It raises exceptions if one of the check fails: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from jwskate import Jwt jwt = Jwt ( \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.\" \"eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\" ) jwk = { \"kty\" : \"RSA\" , \"kid\" : \"my_key\" , \"alg\" : \"RS256\" , \"n\" : \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\" , \"e\" : \"AQAB\" , } jwt . validate ( jwk , issuer = \"https://myas.local\" , audience = \"client_id\" ) # at the time you run this, it will probably raise a `jwskate.ExpiredJwt` exception","title":"Validating JWT tokens"},{"location":"usage/#signing-jwt-tokens","text":"To sign a set of claims into a JWT, use Jwt.sign() . It takes the claims (as a dict), the signing key, and the signature alg to use (if the key doesn't have an 'alg' parameter). 1 2 3 4 5 6 7 8 from jwskate import Jwt , Jwk claims = { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" } jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) jwt = Jwt . sign ( claims , jwk , alg = \"ES256\" ) print ( jwt ) # eyJhbGciOiJFUzI1NiJ9.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.mqqXTljXQwNff0Sah88oFGBNWC9XpZxUj3WDa9-00UAyuEoL6cey-rHQNtmYgYgPRgI_HnWpRm5M4_a9qv9m0g","title":"Signing JWT tokens"},{"location":"usage/#jwt-headers","text":"The default header will contain the signing algorithm identifier (alg) and the JWK Key Identifier (kid), if there was one in the used JWK. You can add additional headers by using the extra_headers parameter to Jwt.sign() : 1 2 3 4 5 6 7 8 9 10 from jwskate import Jwt , Jwk claims = { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" } jwk = Jwk . generate_for_kty ( \"EC\" , crv = \"P-256\" ) jwt = Jwt . sign ( claims , jwk , alg = \"ES256\" , extra_headers = { \"header1\" : \"value1\" }) print ( jwt ) # eyJoZWFkZXIxIjoidmFsdWUxIiwiYWxnIjoiRVMyNTYifQ.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.m0Bi8D6Rdi6HeH4J45JPSaeGPxjboAf_-efQ3mUAi6Gs0ipC0MXg9rd727IIINUsVfU0geUn7IwA1HjoTOsHvg print ( jwt . headers ) # {'header1': 'value1', 'alg': 'ES256'}","title":"JWT headers"}]}