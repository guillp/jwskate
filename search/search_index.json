{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"home","text":"<p>{% include-markdown \"../README.md\" %}</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#jwskate.jwk","title":"jwskate.jwk","text":"<p>This module implements Json Web Key RFC7517.</p>"},{"location":"api/#jwskate.jwk.UnsupportedAlg","title":"UnsupportedAlg","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when a unsupported alg is requested.</p> Source code in <code>jwskate/jwk/alg.py</code> <pre><code>class UnsupportedAlg(ValueError):\n\"\"\"Raised when a unsupported alg is requested.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwk.JwkSet","title":"JwkSet","text":"<p>             Bases: <code>BaseJsonDict</code></p> <p>A set of JWK keys, with methods for easy management of keys.</p> <p>A JwkSet is a dict subclass, so you can do anything with a JwkSet that you can do with a dict. In addition, it provides a few helpers methods to get the keys, add or remove keys, and verify signatures using keys from this set.</p> <ul> <li>a <code>dict</code> from the parsed JSON object representing this JwkSet (in paramter <code>jwks</code>)</li> <li>a list of <code>Jwk</code> (in parameter <code>keys</code></li> <li>nothing, to initialize an empty JwkSet</li> </ul> <p>Parameters:</p> Name Type Description Default <code>jwks</code> <code>dict[str, Any] | None</code> <p>a dict, containing the JwkSet, parsed as a JSON object.</p> <code>None</code> <code>keys</code> <code>Iterable[Jwk | dict[str, Any]] | None</code> <p>a list of <code>Jwk</code>, that will be added to this JwkSet</p> <code>None</code> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>class JwkSet(BaseJsonDict):\n\"\"\"A set of JWK keys, with methods for easy management of keys.\n\n    A JwkSet is a dict subclass, so you can do anything with a JwkSet\n    that you can do with a dict. In addition, it provides a few helpers\n    methods to get the keys, add or remove keys, and verify signatures\n    using keys from this set.\n\n    - a `dict` from the parsed JSON object representing this JwkSet (in paramter `jwks`)\n    - a list of `Jwk` (in parameter `keys`\n    - nothing, to initialize an empty JwkSet\n\n    Args:\n        jwks: a dict, containing the JwkSet, parsed as a JSON object.\n        keys: a list of `Jwk`, that will be added to this JwkSet\n\n    \"\"\"\n\n    def __init__(\n        self,\n        jwks: dict[str, Any] | None = None,\n        keys: Iterable[Jwk | dict[str, Any]] | None = None,\n    ):\n        if jwks is None and keys is None:\n            keys = []\n\n        if jwks is not None:\n            keys = jwks.pop(\"keys\", [])\n            super().__init__(\n                jwks\n            )  # init the dict with all the dict content that is not keys\n        else:\n            super().__init__()\n\n        if keys is not None:\n            for jwk in keys:\n                self.add_jwk(jwk)\n\n    @property\n    def jwks(self) -&gt; list[Jwk]:\n\"\"\"Return the list of keys from this JwkSet, as `Jwk` instances.\n\n        Returns:\n            a list of `Jwk`\n\n        \"\"\"\n        return self.get(\"keys\", [])\n\n    def get_jwk_by_kid(self, kid: str) -&gt; Jwk:\n\"\"\"Return a Jwk from this JwkSet, based on its kid.\n\n        Args:\n          kid: the kid of the key to obtain\n\n        Returns:\n            the key with the matching Key ID\n\n        Raises:\n            KeyError: if no key matches\n\n        \"\"\"\n        jwk = next(filter(lambda j: j.get(\"kid\") == kid, self.jwks), None)\n        if isinstance(jwk, Jwk):\n            return jwk\n        raise KeyError(kid)\n\n    def __len__(self) -&gt; int:\n\"\"\"Return the number of Jwk in this JwkSet.\n\n        Returns:\n            the number of keys\n\n        \"\"\"\n        return len(self.jwks)\n\n    def add_jwk(\n        self,\n        key: Jwk | dict[str, Any] | Any,\n        kid: str | None = None,\n        use: str | None = None,\n    ) -&gt; str:\n\"\"\"Add a Jwk in this JwkSet.\n\n        Args:\n          key: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters)\n          kid: the kid to use, if `jwk` doesn't contain one\n          use: the defined use for the added Jwk\n\n        Returns:\n          the kid from the added Jwk (it may be generated if no kid is provided)\n\n        \"\"\"\n        key = to_jwk(key)\n\n        self.setdefault(\"keys\", [])\n\n        kid = key.get(\"kid\", kid)\n        if not kid:\n            kid = key.thumbprint()\n        key[\"kid\"] = kid\n        use = key.get(\"use\", use)\n        if use:\n            key[\"use\"] = use\n        self.jwks.append(key)\n\n        return kid\n\n    def remove_jwk(self, kid: str) -&gt; None:\n\"\"\"Remove a Jwk from this JwkSet, based on a `kid`.\n\n        Args:\n          kid: the `kid` from the key to be removed.\n\n        Raises:\n            KeyError: if no key matches\n\n        \"\"\"\n        try:\n            jwk = self.get_jwk_by_kid(kid)\n            self.jwks.remove(jwk)\n        except KeyError:\n            pass\n\n    @property\n    def is_private(self) -&gt; bool:\n\"\"\"True if the JwkSet contains at least one private key.\n\n        Returns:\n            `True` if this JwkSet contains at least one private key\n\n        \"\"\"\n        return any(key.is_private for key in self.jwks)\n\n    def public_jwks(self) -&gt; JwkSet:\n\"\"\"Return another JwkSet with the public keys associated with the current keys.\n\n        Returns:\n            a public JwkSet\n\n        \"\"\"\n        return JwkSet(keys=(key.public_jwk() for key in self.jwks))\n\n    def verification_keys(self) -&gt; list[Jwk]:\n\"\"\"Return the list of keys from this JWKS that are usable for signature verification.\n\n        To be usable for signature verification, a key must:\n\n        - be asymmetric\n        - be public\n        - be flagged for signature, either with `use=sig` or an `alg` that is compatible with signature\n\n        Returns:\n            a list of `Jwk` that are usable for signature verification\n\n        \"\"\"\n        return [\n            jwk\n            for jwk in self.jwks\n            if not jwk.is_symmetric and not jwk.is_private and jwk.use == \"sig\"\n        ]\n\n    def verify(\n        self,\n        data: bytes,\n        signature: bytes,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n        kid: str | None = None,\n    ) -&gt; bool:\n\"\"\"Verify a signature with the keys from this key set.\n\n        If a `kid` is provided, only that Key ID will be tried. Otherwise, all keys that are compatible with the\n        specified alg(s) will be tried.\n\n        Args:\n          data: the signed data to verify\n          signature: the signature to verify against the signed data\n          alg: alg to verify the signature, if there is only 1\n          algs: list of allowed signature algs, if there are several\n          kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys\n            from this key set may be tried.\n\n        Returns:\n          `True` if the signature validates with any of the tried keys, `False` otherwise\n\n        \"\"\"\n        if not alg and not algs:\n            raise ValueError(\"Please provide either 'alg' or 'algs' parameter\")\n\n        # if a kid is provided, try only the key matching `kid`\n        if kid is not None:\n            jwk = self.get_jwk_by_kid(kid)\n            return jwk.verify(data, signature, alg=alg, algs=algs)\n\n        # otherwise, try all keys which support the given alg(s)\n        if algs is None:\n            if alg is not None:\n                algs = (alg,)\n        else:\n            algs = list(algs)\n\n        for jwk in self.verification_keys():\n            for alg in algs or (None,):\n                if alg in jwk.supported_signing_algorithms():\n                    if jwk.verify(data, signature, alg=alg):\n                        return True\n\n        # no key matches, so consider the signature invalid\n        return False\n\n    def encryption_keys(self) -&gt; list[Jwk]:\n\"\"\"Return the list of keys from this JWKS that are usable for encryption.\n\n        To be usable for encryption, a key must:\n\n        - be asymmetric\n        - be public\n        - be flagged for encryption, either with `use=enc` or an `alg` parameter that is an encryption alg\n\n        Returns:\n            a list of `Jwk` that are suitable for encryption\n\n        \"\"\"\n        return [\n            jwk\n            for jwk in self.jwks\n            if not jwk.is_symmetric and not jwk.is_private and jwk.use == \"enc\"\n        ]\n</code></pre>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.jwks","title":"jwks  <code>property</code>","text":"<pre><code>jwks: list[Jwk]\n</code></pre> <p>Return the list of keys from this JwkSet, as <code>Jwk</code> instances.</p> <p>Returns:</p> Type Description <code>list[Jwk]</code> <p>a list of <code>Jwk</code></p>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.is_private","title":"is_private  <code>property</code>","text":"<pre><code>is_private: bool\n</code></pre> <p>True if the JwkSet contains at least one private key.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if this JwkSet contains at least one private key</p>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.get_jwk_by_kid","title":"get_jwk_by_kid","text":"<pre><code>get_jwk_by_kid(kid: str) -&gt; Jwk\n</code></pre> <p>Return a Jwk from this JwkSet, based on its kid.</p> <p>Parameters:</p> Name Type Description Default <code>kid</code> <code>str</code> <p>the kid of the key to obtain</p> required <p>Returns:</p> Type Description <code>Jwk</code> <p>the key with the matching Key ID</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if no key matches</p> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>def get_jwk_by_kid(self, kid: str) -&gt; Jwk:\n\"\"\"Return a Jwk from this JwkSet, based on its kid.\n\n    Args:\n      kid: the kid of the key to obtain\n\n    Returns:\n        the key with the matching Key ID\n\n    Raises:\n        KeyError: if no key matches\n\n    \"\"\"\n    jwk = next(filter(lambda j: j.get(\"kid\") == kid, self.jwks), None)\n    if isinstance(jwk, Jwk):\n        return jwk\n    raise KeyError(kid)\n</code></pre>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of Jwk in this JwkSet.</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of keys</p> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Return the number of Jwk in this JwkSet.\n\n    Returns:\n        the number of keys\n\n    \"\"\"\n    return len(self.jwks)\n</code></pre>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.add_jwk","title":"add_jwk","text":"<pre><code>add_jwk(\n    key: Jwk | dict[str, Any] | Any,\n    kid: str | None = None,\n    use: str | None = None,\n) -&gt; str\n</code></pre> <p>Add a Jwk in this JwkSet.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the Jwk to add (either a <code>Jwk</code> instance, or a dict containing the Jwk parameters)</p> required <code>kid</code> <code>str | None</code> <p>the kid to use, if <code>jwk</code> doesn't contain one</p> <code>None</code> <code>use</code> <code>str | None</code> <p>the defined use for the added Jwk</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the kid from the added Jwk (it may be generated if no kid is provided)</p> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>def add_jwk(\n    self,\n    key: Jwk | dict[str, Any] | Any,\n    kid: str | None = None,\n    use: str | None = None,\n) -&gt; str:\n\"\"\"Add a Jwk in this JwkSet.\n\n    Args:\n      key: the Jwk to add (either a `Jwk` instance, or a dict containing the Jwk parameters)\n      kid: the kid to use, if `jwk` doesn't contain one\n      use: the defined use for the added Jwk\n\n    Returns:\n      the kid from the added Jwk (it may be generated if no kid is provided)\n\n    \"\"\"\n    key = to_jwk(key)\n\n    self.setdefault(\"keys\", [])\n\n    kid = key.get(\"kid\", kid)\n    if not kid:\n        kid = key.thumbprint()\n    key[\"kid\"] = kid\n    use = key.get(\"use\", use)\n    if use:\n        key[\"use\"] = use\n    self.jwks.append(key)\n\n    return kid\n</code></pre>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.remove_jwk","title":"remove_jwk","text":"<pre><code>remove_jwk(kid: str) -&gt; None\n</code></pre> <p>Remove a Jwk from this JwkSet, based on a <code>kid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>kid</code> <code>str</code> <p>the <code>kid</code> from the key to be removed.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>if no key matches</p> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>def remove_jwk(self, kid: str) -&gt; None:\n\"\"\"Remove a Jwk from this JwkSet, based on a `kid`.\n\n    Args:\n      kid: the `kid` from the key to be removed.\n\n    Raises:\n        KeyError: if no key matches\n\n    \"\"\"\n    try:\n        jwk = self.get_jwk_by_kid(kid)\n        self.jwks.remove(jwk)\n    except KeyError:\n        pass\n</code></pre>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.public_jwks","title":"public_jwks","text":"<pre><code>public_jwks() -&gt; JwkSet\n</code></pre> <p>Return another JwkSet with the public keys associated with the current keys.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>a public JwkSet</p> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>def public_jwks(self) -&gt; JwkSet:\n\"\"\"Return another JwkSet with the public keys associated with the current keys.\n\n    Returns:\n        a public JwkSet\n\n    \"\"\"\n    return JwkSet(keys=(key.public_jwk() for key in self.jwks))\n</code></pre>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.verification_keys","title":"verification_keys","text":"<pre><code>verification_keys() -&gt; list[Jwk]\n</code></pre> <p>Return the list of keys from this JWKS that are usable for signature verification.</p> <p>To be usable for signature verification, a key must:</p> <ul> <li>be asymmetric</li> <li>be public</li> <li>be flagged for signature, either with <code>use=sig</code> or an <code>alg</code> that is compatible with signature</li> </ul> <p>Returns:</p> Type Description <code>list[Jwk]</code> <p>a list of <code>Jwk</code> that are usable for signature verification</p> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>def verification_keys(self) -&gt; list[Jwk]:\n\"\"\"Return the list of keys from this JWKS that are usable for signature verification.\n\n    To be usable for signature verification, a key must:\n\n    - be asymmetric\n    - be public\n    - be flagged for signature, either with `use=sig` or an `alg` that is compatible with signature\n\n    Returns:\n        a list of `Jwk` that are usable for signature verification\n\n    \"\"\"\n    return [\n        jwk\n        for jwk in self.jwks\n        if not jwk.is_symmetric and not jwk.is_private and jwk.use == \"sig\"\n    ]\n</code></pre>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.verify","title":"verify","text":"<pre><code>verify(\n    data: bytes,\n    signature: bytes,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n    kid: str | None = None,\n) -&gt; bool\n</code></pre> <p>Verify a signature with the keys from this key set.</p> <p>If a <code>kid</code> is provided, only that Key ID will be tried. Otherwise, all keys that are compatible with the specified alg(s) will be tried.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>the signed data to verify</p> required <code>signature</code> <code>bytes</code> <p>the signature to verify against the signed data</p> required <code>alg</code> <code>str | None</code> <p>alg to verify the signature, if there is only 1</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>list of allowed signature algs, if there are several</p> <code>None</code> <code>kid</code> <code>str | None</code> <p>the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys from this key set may be tried.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the signature validates with any of the tried keys, <code>False</code> otherwise</p> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>def verify(\n    self,\n    data: bytes,\n    signature: bytes,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n    kid: str | None = None,\n) -&gt; bool:\n\"\"\"Verify a signature with the keys from this key set.\n\n    If a `kid` is provided, only that Key ID will be tried. Otherwise, all keys that are compatible with the\n    specified alg(s) will be tried.\n\n    Args:\n      data: the signed data to verify\n      signature: the signature to verify against the signed data\n      alg: alg to verify the signature, if there is only 1\n      algs: list of allowed signature algs, if there are several\n      kid: the kid of the Jwk that will be used to validate the signature. If no kid is provided, multiple keys\n        from this key set may be tried.\n\n    Returns:\n      `True` if the signature validates with any of the tried keys, `False` otherwise\n\n    \"\"\"\n    if not alg and not algs:\n        raise ValueError(\"Please provide either 'alg' or 'algs' parameter\")\n\n    # if a kid is provided, try only the key matching `kid`\n    if kid is not None:\n        jwk = self.get_jwk_by_kid(kid)\n        return jwk.verify(data, signature, alg=alg, algs=algs)\n\n    # otherwise, try all keys which support the given alg(s)\n    if algs is None:\n        if alg is not None:\n            algs = (alg,)\n    else:\n        algs = list(algs)\n\n    for jwk in self.verification_keys():\n        for alg in algs or (None,):\n            if alg in jwk.supported_signing_algorithms():\n                if jwk.verify(data, signature, alg=alg):\n                    return True\n\n    # no key matches, so consider the signature invalid\n    return False\n</code></pre>"},{"location":"api/#jwskate.jwk.jwks.JwkSet.encryption_keys","title":"encryption_keys","text":"<pre><code>encryption_keys() -&gt; list[Jwk]\n</code></pre> <p>Return the list of keys from this JWKS that are usable for encryption.</p> <p>To be usable for encryption, a key must:</p> <ul> <li>be asymmetric</li> <li>be public</li> <li>be flagged for encryption, either with <code>use=enc</code> or an <code>alg</code> parameter that is an encryption alg</li> </ul> <p>Returns:</p> Type Description <code>list[Jwk]</code> <p>a list of <code>Jwk</code> that are suitable for encryption</p> Source code in <code>jwskate/jwk/jwks.py</code> <pre><code>def encryption_keys(self) -&gt; list[Jwk]:\n\"\"\"Return the list of keys from this JWKS that are usable for encryption.\n\n    To be usable for encryption, a key must:\n\n    - be asymmetric\n    - be public\n    - be flagged for encryption, either with `use=enc` or an `alg` parameter that is an encryption alg\n\n    Returns:\n        a list of `Jwk` that are suitable for encryption\n\n    \"\"\"\n    return [\n        jwk\n        for jwk in self.jwks\n        if not jwk.is_symmetric and not jwk.is_private and jwk.use == \"enc\"\n    ]\n</code></pre>"},{"location":"api/#jwskate.jwk.ExpectedAlgRequired","title":"ExpectedAlgRequired","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when the expected signature alg(s) must be provided.</p> Source code in <code>jwskate/jwk/alg.py</code> <pre><code>class ExpectedAlgRequired(ValueError):\n\"\"\"Raised when the expected signature alg(s) must be provided.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwk.MismatchingAlg","title":"MismatchingAlg","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when attempting a cryptographic operation with an unexpected algorithm.</p> <p>Signature verification or a decryption operation with an algorithm that does not match the algorithm specified in the key or the token.</p> Source code in <code>jwskate/jwk/alg.py</code> <pre><code>class MismatchingAlg(ValueError):\n\"\"\"Raised when attempting a cryptographic operation with an unexpected algorithm.\n\n    Signature verification or a decryption operation with an algorithm that does not match the\n    algorithm specified in the key or the token.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        target_alg: str,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; None:\n        self.target_alg = target_alg\n        self.alg = alg\n        self.algs = list(algs) if algs else None\n</code></pre>"},{"location":"api/#jwskate.jwk.RSAJwk","title":"RSAJwk","text":"<p>             Bases: <code>Jwk</code></p> <p>Represent an RSA key in JWK format.</p> <p>RSA (Rivest-Shamir-Adleman) keys have Key Type <code>\"RSA\"</code>.</p> Source code in <code>jwskate/jwk/rsa.py</code> <pre><code>class RSAJwk(Jwk):\n\"\"\"Represent an RSA key in JWK format.\n\n    RSA (Rivest-Shamir-Adleman) keys have Key Type `\"RSA\"`.\n\n    \"\"\"\n\n    KTY = KeyTypes.RSA\n    CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = (rsa.RSAPrivateKey,)\n    CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = (rsa.RSAPublicKey,)\n\n    PARAMS = {\n        \"n\": JwkParameter(\"Modulus\", is_private=False, is_required=True, kind=\"b64u\"),\n        \"e\": JwkParameter(\"Exponent\", is_private=False, is_required=True, kind=\"b64u\"),\n        \"d\": JwkParameter(\n            \"Private Exponent\", is_private=True, is_required=True, kind=\"b64u\"\n        ),\n        \"p\": JwkParameter(\n            \"First Prime Factor\", is_private=True, is_required=False, kind=\"b64u\"\n        ),\n        \"q\": JwkParameter(\n            \"Second Prime Factor\", is_private=True, is_required=False, kind=\"b64u\"\n        ),\n        \"dp\": JwkParameter(\n            \"First Factor CRT Exponent\", is_private=True, is_required=False, kind=\"b64u\"\n        ),\n        \"dq\": JwkParameter(\n            \"Second Factor CRT Exponent\",\n            is_private=True,\n            is_required=False,\n            kind=\"b64u\",\n        ),\n        \"qi\": JwkParameter(\n            \"First CRT Coefficient\", is_private=True, is_required=False, kind=\"b64u\"\n        ),\n        \"oth\": JwkParameter(\n            \"Other Primes Info\", is_private=True, is_required=False, kind=\"unsupported\"\n        ),\n    }\n\n    SIGNATURE_ALGORITHMS = {\n        sigalg.name: sigalg for sigalg in [RS256, RS384, RS512, PS256, PS384, PS512]\n    }\n\n    KEY_MANAGEMENT_ALGORITHMS = {\n        keyalg.name: keyalg\n        for keyalg in [\n            RsaEsPcks1v1_5,\n            RsaEsOaep,\n            RsaEsOaepSha256,\n            RsaEsOaepSha384,\n            RsaEsOaepSha512,\n        ]\n    }\n\n    @property\n    @override\n    def is_private(self) -&gt; bool:\n        return \"d\" in self\n\n    @classmethod\n    @override\n    def from_cryptography_key(cls, cryptography_key: Any, **kwargs: Any) -&gt; RSAJwk:\n        if isinstance(cryptography_key, rsa.RSAPrivateKey):\n            priv = cryptography_key.private_numbers()  # type: ignore[attr-defined]\n            pub = cryptography_key.public_key().public_numbers()\n            return cls.private(\n                n=pub.n,\n                e=pub.e,\n                d=priv.d,\n                p=priv.p,\n                q=priv.q,\n                dp=priv.dmp1,\n                dq=priv.dmq1,\n                qi=priv.iqmp,\n            )\n        elif isinstance(cryptography_key, rsa.RSAPublicKey):\n            pub = cryptography_key.public_numbers()\n            return cls.public(\n                n=pub.n,\n                e=pub.e,\n            )\n        else:\n            raise TypeError(\"A RSAPrivateKey or a RSAPublicKey is required.\")\n\n    @override\n    def _to_cryptography_key(self) -&gt; rsa.RSAPrivateKey | rsa.RSAPublicKey:\n        if self.is_private:\n            return rsa.RSAPrivateNumbers(\n                self.first_prime_factor,\n                self.second_prime_factor,\n                self.private_exponent,\n                self.first_factor_crt_exponent,\n                self.second_factor_crt_exponent,\n                self.first_crt_coefficient,\n                rsa.RSAPublicNumbers(self.exponent, self.modulus),\n            ).private_key()\n        else:\n            return rsa.RSAPublicNumbers(e=self.exponent, n=self.modulus).public_key()\n\n    @classmethod\n    def public(cls, *, n: int, e: int = 65537, **params: Any) -&gt; RSAJwk:\n\"\"\"Initialize a public `RsaJwk` from a modulus and an exponent.\n\n        Args:\n          n: the modulus\n          e: the exponent\n          **params: additional parameters to include in the `Jwk`\n\n        Returns:\n          a `RSAJwk` initialized from the provided parameters\n\n        \"\"\"\n        return cls(\n            dict(\n                kty=cls.KTY,\n                n=BinaPy.from_int(n).to(\"b64u\").ascii(),\n                e=BinaPy.from_int(e).to(\"b64u\").ascii(),\n                **params,\n            )\n        )\n\n    @classmethod\n    def private(\n        cls,\n        *,\n        n: int,\n        e: int = 65537,\n        d: int,\n        p: int | None = None,\n        q: int | None = None,\n        dp: int | None = None,\n        dq: int | None = None,\n        qi: int | None = None,\n        **params: Any,\n    ) -&gt; RSAJwk:\n\"\"\"Initialize a private `RSAJwk` from its required parameters.\n\n        Args:\n          n: the modulus\n          e: the exponent\n          d: the private exponent\n          p: the first prime factor\n          q: the second prime factor\n          dp: the first factor CRT exponent\n          dq: the second factor CRT exponent\n          qi: the first CRT coefficient\n          **params: additional parameters to include in the `Jwk`\n\n        Returns:\n            a `RSAJwk` initialized from the given parameters\n\n        \"\"\"\n        return cls(\n            dict(\n                kty=cls.KTY,\n                n=BinaPy.from_int(n).to(\"b64u\").ascii(),\n                e=BinaPy.from_int(e).to(\"b64u\").ascii(),\n                d=BinaPy.from_int(d).to(\"b64u\").ascii(),\n                p=BinaPy.from_int(p).to(\"b64u\").ascii() if p is not None else None,\n                q=BinaPy.from_int(q).to(\"b64u\").ascii() if q is not None else None,\n                dp=BinaPy.from_int(dp).to(\"b64u\").ascii() if dp is not None else None,\n                dq=BinaPy.from_int(dq).to(\"b64u\").ascii() if dq is not None else None,\n                qi=BinaPy.from_int(qi).to(\"b64u\").ascii() if qi is not None else None,\n                **params,\n            )\n        )\n\n    @classmethod\n    def from_prime_factors(cls, p: int, q: int, e: int = 65537) -&gt; RSAJwk:\n\"\"\"Initialise a `RSAJwk` from its prime factors and exponent.\n\n        Modulus and Private Exponent are mathematically calculated based on those factors.\n\n        Exponent is usually 65537 (default).\n\n        Args:\n            p: first prime factor\n            q: second prime factor\n            e: exponent\n\n        Returns:\n            a `RSAJwk`\n\n        \"\"\"\n        n = p * q\n        phi = (p - 1) * (q - 1)\n        d = pow(e, -1, phi)\n        return cls.private(n=n, e=e, d=d)\n\n    @cached_property\n    def key_size(self) -&gt; int:\n\"\"\"Key size, in bits.\"\"\"\n        return len(BinaPy(self.n).decode_from(\"b64u\")) * 8\n\n    @classmethod\n    def generate(cls, key_size: int = 4096, **params: Any) -&gt; RSAJwk:\n\"\"\"Generate a new random private `RSAJwk`.\n\n        Args:\n          key_size: the key size to use for the generated key, in bits\n          **params: additional parameters to include in the `Jwk`\n\n        Returns:\n          a generated `RSAJwk`\n\n        \"\"\"\n        private_key = rsa.generate_private_key(65537, key_size=key_size)\n        pn = private_key.private_numbers()\n        return cls.private(\n            n=pn.public_numbers.n,\n            e=pn.public_numbers.e,\n            d=pn.d,\n            p=pn.p,\n            q=pn.q,\n            dp=pn.dmp1,\n            dq=pn.dmq1,\n            qi=pn.iqmp,\n            **params,\n        )\n\n    @cached_property\n    def modulus(self) -&gt; int:\n\"\"\"Return the modulus `n` from this `Jwk`.\"\"\"\n        return BinaPy(self.n).decode_from(\"b64u\").to_int()\n\n    @cached_property\n    def exponent(self) -&gt; int:\n\"\"\"Return the public exponent `e` from this `Jwk`.\"\"\"\n        return BinaPy(self.e).decode_from(\"b64u\").to_int()\n\n    @cached_property\n    def private_exponent(self) -&gt; int:\n\"\"\"Return the private exponent `d` from this `Jwk`.\"\"\"\n        return BinaPy(self.d).decode_from(\"b64u\").to_int()\n\n    @cached_property\n    def prime_factors(self) -&gt; tuple[int, int]:\n\"\"\"Return the 2 prime factors `p` and `q` from this `Jwk`.\"\"\"\n        if \"p\" not in self or \"q\" not in self:\n            p, q = rsa.rsa_recover_prime_factors(\n                self.modulus, self.exponent, self.private_exponent\n            )\n            return (p, q) if p &lt; q else (q, p)\n        return (\n            BinaPy(self.p).decode_from(\"b64u\").to_int(),\n            BinaPy(self.q).decode_from(\"b64u\").to_int(),\n        )\n\n    @cached_property\n    def first_prime_factor(self) -&gt; int:\n\"\"\"Return the first prime factor `p` from this `Jwk`.\"\"\"\n        return self.prime_factors[0]\n\n    @cached_property\n    def second_prime_factor(self) -&gt; int:\n\"\"\"Return the second prime factor `q` from this `Jwk`.\"\"\"\n        return self.prime_factors[1]\n\n    @cached_property\n    def first_factor_crt_exponent(self) -&gt; int:\n\"\"\"Return the first factor CRT exponent `dp` from this `Jwk`.\"\"\"\n        if \"dp\" in self:\n            return BinaPy(self.dp).decode_from(\"b64u\").to_int()\n        return rsa.rsa_crt_dmp1(self.private_exponent, self.first_prime_factor)\n\n    @cached_property\n    def second_factor_crt_exponent(self) -&gt; int:\n\"\"\"Return the second factor CRT exponent `dq` from this `Jwk`.\"\"\"\n        if \"dq\" in self:\n            return BinaPy(self.dq).decode_from(\"b64u\").to_int()\n        return rsa.rsa_crt_dmq1(self.private_exponent, self.second_prime_factor)\n\n    @cached_property\n    def first_crt_coefficient(self) -&gt; int:\n\"\"\"Return the first CRT coefficient `qi` from this `Jwk`.\"\"\"\n        if \"qi\" in self:\n            return BinaPy(self.qi).decode_from(\"b64u\").to_int()\n        return rsa.rsa_crt_iqmp(self.first_prime_factor, self.second_prime_factor)\n\n    def with_optional_private_parameters(self) -&gt; RSAJwk:\n\"\"\"Compute the optional RSA private parameters.\n\n        This returns a new `Jwk` with those additional params included.\n\n        The optional parameters are:\n\n        - p: first prime factor\n        - q: second prime factor\n        - dp: first factor Chinese Remainder Theorem exponent\n        - dq: second factor Chinese Remainder Theorem exponent\n        - qi: first Chinese Remainder Theorem coefficient\n\n        \"\"\"\n        if not self.is_private:\n            raise ValueError(\n                \"Optional private parameters can only be computed for private RSA keys.\"\n            )\n\n        jwk = dict(self)\n\n        jwk.update(\n            {\n                \"p\": BinaPy.from_int(self.first_prime_factor).to(\"b64u\").ascii(),\n                \"q\": BinaPy.from_int(self.second_prime_factor).to(\"b64u\").ascii(),\n                \"dp\": BinaPy.from_int(self.first_factor_crt_exponent)\n                .to(\"b64u\")\n                .ascii(),\n                \"dq\": BinaPy.from_int(self.second_factor_crt_exponent)\n                .to(\"b64u\")\n                .ascii(),\n                \"qi\": BinaPy.from_int(self.first_crt_coefficient).to(\"b64u\").ascii(),\n            }\n        )\n\n        return RSAJwk(jwk)\n\n    def without_optional_private_parameters(self) -&gt; RSAJwk:\n\"\"\"Remove the optional private parameters and return another `Jwk` instance without them.\"\"\"\n        jwk = dict(self)\n        for param in \"p\", \"q\", \"dp\", \"dq\", \"qi\":\n            jwk.pop(param, None)\n\n        return RSAJwk(jwk)\n</code></pre>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.key_size","title":"key_size  <code>cached</code> <code>property</code>","text":"<pre><code>key_size: int\n</code></pre> <p>Key size, in bits.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.modulus","title":"modulus  <code>cached</code> <code>property</code>","text":"<pre><code>modulus: int\n</code></pre> <p>Return the modulus <code>n</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.exponent","title":"exponent  <code>cached</code> <code>property</code>","text":"<pre><code>exponent: int\n</code></pre> <p>Return the public exponent <code>e</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.private_exponent","title":"private_exponent  <code>cached</code> <code>property</code>","text":"<pre><code>private_exponent: int\n</code></pre> <p>Return the private exponent <code>d</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.prime_factors","title":"prime_factors  <code>cached</code> <code>property</code>","text":"<pre><code>prime_factors: tuple[int, int]\n</code></pre> <p>Return the 2 prime factors <code>p</code> and <code>q</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_prime_factor","title":"first_prime_factor  <code>cached</code> <code>property</code>","text":"<pre><code>first_prime_factor: int\n</code></pre> <p>Return the first prime factor <code>p</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.second_prime_factor","title":"second_prime_factor  <code>cached</code> <code>property</code>","text":"<pre><code>second_prime_factor: int\n</code></pre> <p>Return the second prime factor <code>q</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_factor_crt_exponent","title":"first_factor_crt_exponent  <code>cached</code> <code>property</code>","text":"<pre><code>first_factor_crt_exponent: int\n</code></pre> <p>Return the first factor CRT exponent <code>dp</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.second_factor_crt_exponent","title":"second_factor_crt_exponent  <code>cached</code> <code>property</code>","text":"<pre><code>second_factor_crt_exponent: int\n</code></pre> <p>Return the second factor CRT exponent <code>dq</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.first_crt_coefficient","title":"first_crt_coefficient  <code>cached</code> <code>property</code>","text":"<pre><code>first_crt_coefficient: int\n</code></pre> <p>Return the first CRT coefficient <code>qi</code> from this <code>Jwk</code>.</p>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.public","title":"public  <code>classmethod</code>","text":"<pre><code>public(*, n: int, e: int = 65537, **params: Any) -&gt; RSAJwk\n</code></pre> <p>Initialize a public <code>RsaJwk</code> from a modulus and an exponent.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the modulus</p> required <code>e</code> <code>int</code> <p>the exponent</p> <code>65537</code> <code>**params</code> <code>Any</code> <p>additional parameters to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>RSAJwk</code> <p>a <code>RSAJwk</code> initialized from the provided parameters</p> Source code in <code>jwskate/jwk/rsa.py</code> <pre><code>@classmethod\ndef public(cls, *, n: int, e: int = 65537, **params: Any) -&gt; RSAJwk:\n\"\"\"Initialize a public `RsaJwk` from a modulus and an exponent.\n\n    Args:\n      n: the modulus\n      e: the exponent\n      **params: additional parameters to include in the `Jwk`\n\n    Returns:\n      a `RSAJwk` initialized from the provided parameters\n\n    \"\"\"\n    return cls(\n        dict(\n            kty=cls.KTY,\n            n=BinaPy.from_int(n).to(\"b64u\").ascii(),\n            e=BinaPy.from_int(e).to(\"b64u\").ascii(),\n            **params,\n        )\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.private","title":"private  <code>classmethod</code>","text":"<pre><code>private(\n    *,\n    n: int,\n    e: int = 65537,\n    d: int,\n    p: int | None = None,\n    q: int | None = None,\n    dp: int | None = None,\n    dq: int | None = None,\n    qi: int | None = None,\n    **params: Any\n) -&gt; RSAJwk\n</code></pre> <p>Initialize a private <code>RSAJwk</code> from its required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the modulus</p> required <code>e</code> <code>int</code> <p>the exponent</p> <code>65537</code> <code>d</code> <code>int</code> <p>the private exponent</p> required <code>p</code> <code>int | None</code> <p>the first prime factor</p> <code>None</code> <code>q</code> <code>int | None</code> <p>the second prime factor</p> <code>None</code> <code>dp</code> <code>int | None</code> <p>the first factor CRT exponent</p> <code>None</code> <code>dq</code> <code>int | None</code> <p>the second factor CRT exponent</p> <code>None</code> <code>qi</code> <code>int | None</code> <p>the first CRT coefficient</p> <code>None</code> <code>**params</code> <code>Any</code> <p>additional parameters to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>RSAJwk</code> <p>a <code>RSAJwk</code> initialized from the given parameters</p> Source code in <code>jwskate/jwk/rsa.py</code> <pre><code>@classmethod\ndef private(\n    cls,\n    *,\n    n: int,\n    e: int = 65537,\n    d: int,\n    p: int | None = None,\n    q: int | None = None,\n    dp: int | None = None,\n    dq: int | None = None,\n    qi: int | None = None,\n    **params: Any,\n) -&gt; RSAJwk:\n\"\"\"Initialize a private `RSAJwk` from its required parameters.\n\n    Args:\n      n: the modulus\n      e: the exponent\n      d: the private exponent\n      p: the first prime factor\n      q: the second prime factor\n      dp: the first factor CRT exponent\n      dq: the second factor CRT exponent\n      qi: the first CRT coefficient\n      **params: additional parameters to include in the `Jwk`\n\n    Returns:\n        a `RSAJwk` initialized from the given parameters\n\n    \"\"\"\n    return cls(\n        dict(\n            kty=cls.KTY,\n            n=BinaPy.from_int(n).to(\"b64u\").ascii(),\n            e=BinaPy.from_int(e).to(\"b64u\").ascii(),\n            d=BinaPy.from_int(d).to(\"b64u\").ascii(),\n            p=BinaPy.from_int(p).to(\"b64u\").ascii() if p is not None else None,\n            q=BinaPy.from_int(q).to(\"b64u\").ascii() if q is not None else None,\n            dp=BinaPy.from_int(dp).to(\"b64u\").ascii() if dp is not None else None,\n            dq=BinaPy.from_int(dq).to(\"b64u\").ascii() if dq is not None else None,\n            qi=BinaPy.from_int(qi).to(\"b64u\").ascii() if qi is not None else None,\n            **params,\n        )\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.from_prime_factors","title":"from_prime_factors  <code>classmethod</code>","text":"<pre><code>from_prime_factors(\n    p: int, q: int, e: int = 65537\n) -&gt; RSAJwk\n</code></pre> <p>Initialise a <code>RSAJwk</code> from its prime factors and exponent.</p> <p>Modulus and Private Exponent are mathematically calculated based on those factors.</p> <p>Exponent is usually 65537 (default).</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>first prime factor</p> required <code>q</code> <code>int</code> <p>second prime factor</p> required <code>e</code> <code>int</code> <p>exponent</p> <code>65537</code> <p>Returns:</p> Type Description <code>RSAJwk</code> <p>a <code>RSAJwk</code></p> Source code in <code>jwskate/jwk/rsa.py</code> <pre><code>@classmethod\ndef from_prime_factors(cls, p: int, q: int, e: int = 65537) -&gt; RSAJwk:\n\"\"\"Initialise a `RSAJwk` from its prime factors and exponent.\n\n    Modulus and Private Exponent are mathematically calculated based on those factors.\n\n    Exponent is usually 65537 (default).\n\n    Args:\n        p: first prime factor\n        q: second prime factor\n        e: exponent\n\n    Returns:\n        a `RSAJwk`\n\n    \"\"\"\n    n = p * q\n    phi = (p - 1) * (q - 1)\n    d = pow(e, -1, phi)\n    return cls.private(n=n, e=e, d=d)\n</code></pre>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.generate","title":"generate  <code>classmethod</code>","text":"<pre><code>generate(key_size: int = 4096, **params: Any) -&gt; RSAJwk\n</code></pre> <p>Generate a new random private <code>RSAJwk</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key_size</code> <code>int</code> <p>the key size to use for the generated key, in bits</p> <code>4096</code> <code>**params</code> <code>Any</code> <p>additional parameters to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>RSAJwk</code> <p>a generated <code>RSAJwk</code></p> Source code in <code>jwskate/jwk/rsa.py</code> <pre><code>@classmethod\ndef generate(cls, key_size: int = 4096, **params: Any) -&gt; RSAJwk:\n\"\"\"Generate a new random private `RSAJwk`.\n\n    Args:\n      key_size: the key size to use for the generated key, in bits\n      **params: additional parameters to include in the `Jwk`\n\n    Returns:\n      a generated `RSAJwk`\n\n    \"\"\"\n    private_key = rsa.generate_private_key(65537, key_size=key_size)\n    pn = private_key.private_numbers()\n    return cls.private(\n        n=pn.public_numbers.n,\n        e=pn.public_numbers.e,\n        d=pn.d,\n        p=pn.p,\n        q=pn.q,\n        dp=pn.dmp1,\n        dq=pn.dmq1,\n        qi=pn.iqmp,\n        **params,\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.with_optional_private_parameters","title":"with_optional_private_parameters","text":"<pre><code>with_optional_private_parameters() -&gt; RSAJwk\n</code></pre> <p>Compute the optional RSA private parameters.</p> <p>This returns a new <code>Jwk</code> with those additional params included.</p> <p>The optional parameters are:</p> <ul> <li>p: first prime factor</li> <li>q: second prime factor</li> <li>dp: first factor Chinese Remainder Theorem exponent</li> <li>dq: second factor Chinese Remainder Theorem exponent</li> <li>qi: first Chinese Remainder Theorem coefficient</li> </ul> Source code in <code>jwskate/jwk/rsa.py</code> <pre><code>def with_optional_private_parameters(self) -&gt; RSAJwk:\n\"\"\"Compute the optional RSA private parameters.\n\n    This returns a new `Jwk` with those additional params included.\n\n    The optional parameters are:\n\n    - p: first prime factor\n    - q: second prime factor\n    - dp: first factor Chinese Remainder Theorem exponent\n    - dq: second factor Chinese Remainder Theorem exponent\n    - qi: first Chinese Remainder Theorem coefficient\n\n    \"\"\"\n    if not self.is_private:\n        raise ValueError(\n            \"Optional private parameters can only be computed for private RSA keys.\"\n        )\n\n    jwk = dict(self)\n\n    jwk.update(\n        {\n            \"p\": BinaPy.from_int(self.first_prime_factor).to(\"b64u\").ascii(),\n            \"q\": BinaPy.from_int(self.second_prime_factor).to(\"b64u\").ascii(),\n            \"dp\": BinaPy.from_int(self.first_factor_crt_exponent)\n            .to(\"b64u\")\n            .ascii(),\n            \"dq\": BinaPy.from_int(self.second_factor_crt_exponent)\n            .to(\"b64u\")\n            .ascii(),\n            \"qi\": BinaPy.from_int(self.first_crt_coefficient).to(\"b64u\").ascii(),\n        }\n    )\n\n    return RSAJwk(jwk)\n</code></pre>"},{"location":"api/#jwskate.jwk.rsa.RSAJwk.without_optional_private_parameters","title":"without_optional_private_parameters","text":"<pre><code>without_optional_private_parameters() -&gt; RSAJwk\n</code></pre> <p>Remove the optional private parameters and return another <code>Jwk</code> instance without them.</p> Source code in <code>jwskate/jwk/rsa.py</code> <pre><code>def without_optional_private_parameters(self) -&gt; RSAJwk:\n\"\"\"Remove the optional private parameters and return another `Jwk` instance without them.\"\"\"\n    jwk = dict(self)\n    for param in \"p\", \"q\", \"dp\", \"dq\", \"qi\":\n        jwk.pop(param, None)\n\n    return RSAJwk(jwk)\n</code></pre>"},{"location":"api/#jwskate.jwk.UnsupportedEllipticCurve","title":"UnsupportedEllipticCurve","text":"<p>             Bases: <code>KeyError</code></p> <p>Raised when an unsupported Elliptic Curve is requested.</p> Source code in <code>jwskate/jwk/ec.py</code> <pre><code>class UnsupportedEllipticCurve(KeyError):\n\"\"\"Raised when an unsupported Elliptic Curve is requested.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwk.UnsupportedOKPCurve","title":"UnsupportedOKPCurve","text":"<p>             Bases: <code>KeyError</code></p> <p>Raised when an unsupported OKP curve is requested.</p> Source code in <code>jwskate/jwk/okp.py</code> <pre><code>class UnsupportedOKPCurve(KeyError):\n\"\"\"Raised when an unsupported OKP curve is requested.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwk.SymmetricJwk","title":"SymmetricJwk","text":"<p>             Bases: <code>Jwk</code></p> <p>Represent a Symmetric key in JWK format.</p> <p>Symmetric keys have key type <code>\"oct\"</code>.</p> Source code in <code>jwskate/jwk/oct.py</code> <pre><code>class SymmetricJwk(Jwk):\n\"\"\"Represent a Symmetric key in JWK format.\n\n    Symmetric keys have key type `\"oct\"`.\n\n    \"\"\"\n\n    KTY = KeyTypes.OCT\n    CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = (bytes,)\n    CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = (bytes,)\n\n    PARAMS = {\n        \"k\": JwkParameter(\"Key Value\", is_private=True, is_required=True, kind=\"b64u\"),\n    }\n\n    SIGNATURE_ALGORITHMS = {sigalg.name: sigalg for sigalg in [HS256, HS384, HS512]}\n\n    KEY_MANAGEMENT_ALGORITHMS = {\n        keyalg.name: keyalg\n        for keyalg in [\n            A128KW,\n            A192KW,\n            A256KW,\n            A128GCMKW,\n            A192GCMKW,\n            A256GCMKW,\n            DirectKeyUse,\n        ]\n    }\n\n    ENCRYPTION_ALGORITHMS = {\n        keyalg.name: keyalg\n        for keyalg in [\n            A128CBC_HS256,\n            A192CBC_HS384,\n            A256CBC_HS512,\n            A128GCM,\n            A192GCM,\n            A256GCM,\n        ]\n    }\n\n    @property\n    @override\n    def is_symmetric(self) -&gt; bool:\n        return True\n\n    @override\n    def public_jwk(self) -&gt; Jwk:\n\"\"\"Raise an error since Symmetric Keys are always private.\n\n        Raises:\n            ValueError: symmetric keys are always private, it makes no sense to use them as public keys\n\n        \"\"\"\n        raise ValueError(\"Symmetric keys don't have a public key\")\n\n    @classmethod\n    def from_bytes(cls, k: bytes | str, **params: Any) -&gt; SymmetricJwk:\n\"\"\"Initialize a `SymmetricJwk` from a raw secret key.\n\n        The provided secret key is encoded and used as the `k` parameter for the returned `SymmetricKey`.\n\n        Args:\n          k: the key to use\n          **params: additional members to include in the `Jwk`\n\n        Returns:\n          the resulting `SymmetricJwk`\n\n        \"\"\"\n        return cls(dict(kty=cls.KTY, k=BinaPy(k).to(\"b64u\").ascii(), **params))\n\n    @classmethod\n    @override\n    def generate(\n        cls, *, alg: str | None = None, key_size: int | None = None, **params: Any\n    ) -&gt; SymmetricJwk:\n        if alg:\n            alg_class = cls._get_alg_class(alg)\n            # special cases for AES or HMAC based algs which require a specific key size\n            if issubclass(alg_class, (BaseAESEncryptionAlg, BaseAesKeyWrap)):\n                if key_size is not None and key_size != alg_class.key_size:\n                    raise ValueError(\n                        f\"Key for {alg} must be exactly {alg_class.key_size} bits. \"\n                        \"You should remove the `key_size` parameter to generate a key of the appropriate length.\"\n                    )\n                key_size = alg_class.key_size\n            elif issubclass(alg_class, BaseHMACSigAlg):\n                if key_size is not None and key_size &lt; alg_class.min_key_size:\n                    warnings.warn(\n                        f\"Symmetric keys to use with {alg} should be at least {alg_class.min_key_size} bits \"\n                        \"in order to make the key at least as hard to brute-force as the signature. \"\n                        f\"You requested a key size of {key_size} bits.\"\n                    )\n                else:\n                    key_size = alg_class.min_key_size\n\n        if key_size is None:\n            warnings.warn(\n                \"Please provide a key_size or an alg parameter for jwskate to know the number of bits to generate. \"\n                \"Defaulting to 128 bits.\"\n            )\n            key_size = 128\n\n        key = BinaPy.random_bits(key_size)\n        return cls.from_bytes(key, alg=alg, **params)\n\n    @classmethod\n    @override\n    def from_cryptography_key(\n        cls, cryptography_key: Any, **params: Any\n    ) -&gt; SymmetricJwk:\n        return cls.from_bytes(cryptography_key, **params)\n\n    @override\n    def _to_cryptography_key(self) -&gt; BinaPy:\n        return BinaPy(self.k).decode_from(\"b64u\")\n\n    @override\n    def thumbprint(self, hashalg: str = \"SHA256\") -&gt; str:\n        return (\n            BinaPy.serialize_to(\"json\", {\"k\": self.k, \"kty\": self.kty})\n            .to(\"sha256\")\n            .to(\"b64u\")\n            .ascii()\n        )\n\n    @override\n    def to_pem(self, password: bytes | str | None = None) -&gt; str:\n        raise TypeError(\"Symmetric keys are not serializable to PEM.\")\n\n    @property\n    def key(self) -&gt; BinaPy:\n\"\"\"Returns the raw symmetric key, from the `k` parameter, base64u-decoded.\"\"\"\n        return self.cryptography_key  # type: ignore[no-any-return]\n\n    @property\n    def key_size(self) -&gt; int:\n\"\"\"The key size, in bits.\"\"\"\n        return len(self.key) * 8\n\n    @override\n    def encrypt(\n        self,\n        plaintext: bytes | SupportsBytes,\n        *,\n        aad: bytes | None = None,\n        alg: str | None = None,\n        iv: bytes | None = None,\n    ) -&gt; tuple[BinaPy, BinaPy, BinaPy]:\n\"\"\"Encrypt arbitrary data using this key.\n\n        Supports Authenticated Encryption with Additional Authenticated Data (use parameter `aad` for Additional\n        Authenticated Data).\n\n        An *Initialization Vector* (IV) will be generated automatically.\n        You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing).\n\n        This returns the ciphertext, the authentication tag, and the generated IV.\n        If an IV was provided as parameter, the same IV is returned.\n\n        Args:\n          plaintext: the plaintext to encrypt\n          aad: the Additional Authentication Data, if any\n          alg: the encryption alg to use\n          iv: the IV to use, if you want a specific value\n\n        Returns:\n            a (ciphertext, authentication_tag, iv) tuple\n\n        \"\"\"\n        wrapper = self.encryption_wrapper(alg)\n        if iv is None:\n            iv = wrapper.generate_iv()\n\n        ciphertext, tag = wrapper.encrypt(plaintext, iv=iv, aad=aad)\n        return ciphertext, BinaPy(iv), tag\n\n    @override\n    def decrypt(\n        self,\n        ciphertext: bytes | SupportsBytes,\n        *,\n        iv: bytes | SupportsBytes,\n        tag: bytes | SupportsBytes,\n        aad: bytes | SupportsBytes | None = None,\n        alg: str | None = None,\n    ) -&gt; BinaPy:\n\"\"\"Decrypt arbitrary data, and verify Additional Authenticated Data.\n\n        Args:\n          ciphertext: the encrypted data\n          iv: the Initialization Vector (must be the same as generated during encryption)\n          tag: the authentication tag\n          aad: the Additional Authenticated Data (must be the same data used during encryption)\n          alg: the decryption alg (must be the same as used during encryption)\n\n        Returns:\n            the decrypted clear-text\n\n        \"\"\"\n        aad = b\"\" if aad is None else aad\n        if not isinstance(aad, bytes):\n            aad = bytes(aad)\n        if not isinstance(iv, bytes):\n            iv = bytes(iv)\n        if not isinstance(tag, bytes):\n            tag = bytes(tag)\n\n        wrapper = self.encryption_wrapper(alg)\n        plaintext: bytes = wrapper.decrypt(ciphertext, auth_tag=tag, iv=iv, aad=aad)\n\n        return BinaPy(plaintext)\n\n    @override\n    def supported_key_management_algorithms(self) -&gt; list[str]:\n        return [\n            name\n            for name, alg in self.KEY_MANAGEMENT_ALGORITHMS.items()\n            if issubclass(alg, BaseSymmetricAlg)\n            and alg.supports_key(self.cryptography_key)\n        ]\n\n    @override\n    def supported_encryption_algorithms(self) -&gt; list[str]:\n        return [\n            name\n            for name, alg in self.ENCRYPTION_ALGORITHMS.items()\n            if alg.supports_key(self.cryptography_key)\n        ]\n</code></pre>"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.key","title":"key  <code>property</code>","text":"<pre><code>key: BinaPy\n</code></pre> <p>Returns the raw symmetric key, from the <code>k</code> parameter, base64u-decoded.</p>"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.key_size","title":"key_size  <code>property</code>","text":"<pre><code>key_size: int\n</code></pre> <p>The key size, in bits.</p>"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.public_jwk","title":"public_jwk","text":"<pre><code>public_jwk() -&gt; Jwk\n</code></pre> <p>Raise an error since Symmetric Keys are always private.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>symmetric keys are always private, it makes no sense to use them as public keys</p> Source code in <code>jwskate/jwk/oct.py</code> <pre><code>@override\ndef public_jwk(self) -&gt; Jwk:\n\"\"\"Raise an error since Symmetric Keys are always private.\n\n    Raises:\n        ValueError: symmetric keys are always private, it makes no sense to use them as public keys\n\n    \"\"\"\n    raise ValueError(\"Symmetric keys don't have a public key\")\n</code></pre>"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(k: bytes | str, **params: Any) -&gt; SymmetricJwk\n</code></pre> <p>Initialize a <code>SymmetricJwk</code> from a raw secret key.</p> <p>The provided secret key is encoded and used as the <code>k</code> parameter for the returned <code>SymmetricKey</code>.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>bytes | str</code> <p>the key to use</p> required <code>**params</code> <code>Any</code> <p>additional members to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>SymmetricJwk</code> <p>the resulting <code>SymmetricJwk</code></p> Source code in <code>jwskate/jwk/oct.py</code> <pre><code>@classmethod\ndef from_bytes(cls, k: bytes | str, **params: Any) -&gt; SymmetricJwk:\n\"\"\"Initialize a `SymmetricJwk` from a raw secret key.\n\n    The provided secret key is encoded and used as the `k` parameter for the returned `SymmetricKey`.\n\n    Args:\n      k: the key to use\n      **params: additional members to include in the `Jwk`\n\n    Returns:\n      the resulting `SymmetricJwk`\n\n    \"\"\"\n    return cls(dict(kty=cls.KTY, k=BinaPy(k).to(\"b64u\").ascii(), **params))\n</code></pre>"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.encrypt","title":"encrypt","text":"<pre><code>encrypt(\n    plaintext: bytes | SupportsBytes,\n    *,\n    aad: bytes | None = None,\n    alg: str | None = None,\n    iv: bytes | None = None\n) -&gt; tuple[BinaPy, BinaPy, BinaPy]\n</code></pre> <p>Encrypt arbitrary data using this key.</p> <p>Supports Authenticated Encryption with Additional Authenticated Data (use parameter <code>aad</code> for Additional Authenticated Data).</p> <p>An Initialization Vector (IV) will be generated automatically. You can choose your own IV by providing the <code>iv</code> parameter (only use this if you know what you are doing).</p> <p>This returns the ciphertext, the authentication tag, and the generated IV. If an IV was provided as parameter, the same IV is returned.</p> <p>Parameters:</p> Name Type Description Default <code>plaintext</code> <code>bytes | SupportsBytes</code> <p>the plaintext to encrypt</p> required <code>aad</code> <code>bytes | None</code> <p>the Additional Authentication Data, if any</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the encryption alg to use</p> <code>None</code> <code>iv</code> <code>bytes | None</code> <p>the IV to use, if you want a specific value</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[BinaPy, BinaPy, BinaPy]</code> <p>a (ciphertext, authentication_tag, iv) tuple</p> Source code in <code>jwskate/jwk/oct.py</code> <pre><code>@override\ndef encrypt(\n    self,\n    plaintext: bytes | SupportsBytes,\n    *,\n    aad: bytes | None = None,\n    alg: str | None = None,\n    iv: bytes | None = None,\n) -&gt; tuple[BinaPy, BinaPy, BinaPy]:\n\"\"\"Encrypt arbitrary data using this key.\n\n    Supports Authenticated Encryption with Additional Authenticated Data (use parameter `aad` for Additional\n    Authenticated Data).\n\n    An *Initialization Vector* (IV) will be generated automatically.\n    You can choose your own IV by providing the `iv` parameter (only use this if you know what you are doing).\n\n    This returns the ciphertext, the authentication tag, and the generated IV.\n    If an IV was provided as parameter, the same IV is returned.\n\n    Args:\n      plaintext: the plaintext to encrypt\n      aad: the Additional Authentication Data, if any\n      alg: the encryption alg to use\n      iv: the IV to use, if you want a specific value\n\n    Returns:\n        a (ciphertext, authentication_tag, iv) tuple\n\n    \"\"\"\n    wrapper = self.encryption_wrapper(alg)\n    if iv is None:\n        iv = wrapper.generate_iv()\n\n    ciphertext, tag = wrapper.encrypt(plaintext, iv=iv, aad=aad)\n    return ciphertext, BinaPy(iv), tag\n</code></pre>"},{"location":"api/#jwskate.jwk.oct.SymmetricJwk.decrypt","title":"decrypt","text":"<pre><code>decrypt(\n    ciphertext: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes,\n    tag: bytes | SupportsBytes,\n    aad: bytes | SupportsBytes | None = None,\n    alg: str | None = None\n) -&gt; BinaPy\n</code></pre> <p>Decrypt arbitrary data, and verify Additional Authenticated Data.</p> <p>Parameters:</p> Name Type Description Default <code>ciphertext</code> <code>bytes | SupportsBytes</code> <p>the encrypted data</p> required <code>iv</code> <code>bytes | SupportsBytes</code> <p>the Initialization Vector (must be the same as generated during encryption)</p> required <code>tag</code> <code>bytes | SupportsBytes</code> <p>the authentication tag</p> required <code>aad</code> <code>bytes | SupportsBytes | None</code> <p>the Additional Authenticated Data (must be the same data used during encryption)</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the decryption alg (must be the same as used during encryption)</p> <code>None</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the decrypted clear-text</p> Source code in <code>jwskate/jwk/oct.py</code> <pre><code>@override\ndef decrypt(\n    self,\n    ciphertext: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes,\n    tag: bytes | SupportsBytes,\n    aad: bytes | SupportsBytes | None = None,\n    alg: str | None = None,\n) -&gt; BinaPy:\n\"\"\"Decrypt arbitrary data, and verify Additional Authenticated Data.\n\n    Args:\n      ciphertext: the encrypted data\n      iv: the Initialization Vector (must be the same as generated during encryption)\n      tag: the authentication tag\n      aad: the Additional Authenticated Data (must be the same data used during encryption)\n      alg: the decryption alg (must be the same as used during encryption)\n\n    Returns:\n        the decrypted clear-text\n\n    \"\"\"\n    aad = b\"\" if aad is None else aad\n    if not isinstance(aad, bytes):\n        aad = bytes(aad)\n    if not isinstance(iv, bytes):\n        iv = bytes(iv)\n    if not isinstance(tag, bytes):\n        tag = bytes(tag)\n\n    wrapper = self.encryption_wrapper(alg)\n    plaintext: bytes = wrapper.decrypt(ciphertext, auth_tag=tag, iv=iv, aad=aad)\n\n    return BinaPy(plaintext)\n</code></pre>"},{"location":"api/#jwskate.jwk.ECJwk","title":"ECJwk","text":"<p>             Bases: <code>Jwk</code></p> <p>Represent an Elliptic Curve key in JWK format.</p> <p>Elliptic Curve keys have Key Type <code>\"EC\"</code>.</p> Source code in <code>jwskate/jwk/ec.py</code> <pre><code>class ECJwk(Jwk):\n\"\"\"Represent an Elliptic Curve key in JWK format.\n\n    Elliptic Curve keys have Key Type `\"EC\"`.\n\n    \"\"\"\n\n    KTY = KeyTypes.EC\n\n    CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = (ec.EllipticCurvePrivateKey,)\n\n    CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = (ec.EllipticCurvePublicKey,)\n\n    PARAMS: Mapping[str, JwkParameter] = {\n        \"crv\": JwkParameter(\"Curve\", is_private=False, is_required=True, kind=\"name\"),\n        \"x\": JwkParameter(\n            \"X Coordinate\", is_private=False, is_required=True, kind=\"b64u\"\n        ),\n        \"y\": JwkParameter(\n            \"Y Coordinate\", is_private=False, is_required=True, kind=\"b64u\"\n        ),\n        \"d\": JwkParameter(\n            \"ECC Private Key\", is_private=True, is_required=True, kind=\"b64u\"\n        ),\n    }\n\n    CURVES: Mapping[str, EllipticCurve] = {\n        curve.name: curve for curve in [P_256, P_384, P_521, secp256k1]\n    }\n\n    SIGNATURE_ALGORITHMS: Mapping[str, type[BaseECSignatureAlg]] = {\n        sigalg.name: sigalg for sigalg in [ES256, ES384, ES512, ES256K]\n    }\n\n    KEY_MANAGEMENT_ALGORITHMS: Mapping[str, type[EcdhEs]] = {\n        keyalg.name: keyalg\n        for keyalg in [EcdhEs, EcdhEs_A128KW, EcdhEs_A192KW, EcdhEs_A256KW]\n    }\n\n    @property\n    @override\n    def is_private(self) -&gt; bool:\n        return \"d\" in self\n\n    @override\n    def _validate(self) -&gt; None:\n        self.get_curve(self.crv)\n        super()._validate()\n\n    @classmethod\n    def get_curve(cls, crv: str) -&gt; EllipticCurve:\n\"\"\"Get the EllipticCurve instance for a given curve identifier.\n\n        Args:\n          crv: the curve identifier\n\n        Returns:\n            the matching `EllipticCurve` instance\n\n        Raises:\n            UnsupportedEllipticCurve: if the curve identifier is not supported\n\n        \"\"\"\n        curve = cls.CURVES.get(crv)\n        if curve is None:\n            raise UnsupportedEllipticCurve(crv)\n        return curve\n\n    @property\n    def curve(self) -&gt; EllipticCurve:\n\"\"\"Get the `EllipticCurve` instance for this key.\n\n        Returns:\n            the `EllipticCurve` instance\n\n        \"\"\"\n        return self.get_curve(self.crv)\n\n    @classmethod\n    def public(cls, *, crv: str, x: int, y: int, **params: str) -&gt; ECJwk:\n\"\"\"Initialize a public `ECJwk` from its public parameters.\n\n        Args:\n          crv: the curve to use\n          x: the x coordinate\n          y: the y coordinate\n          **params: additional member to include in the Jwk\n\n        Returns:\n          an ECJwk initialized with the supplied parameters\n\n        \"\"\"\n        coord_size = cls.get_curve(crv).coordinate_size\n        return cls(\n            dict(\n                kty=cls.KTY,\n                crv=crv,\n                x=BinaPy.from_int(x, length=coord_size).to(\"b64u\").ascii(),\n                y=BinaPy.from_int(y, length=coord_size).to(\"b64u\").ascii(),\n                **{k: v for k, v in params.items() if v is not None},\n            )\n        )\n\n    @classmethod\n    def private(cls, *, crv: str, x: int, y: int, d: int, **params: Any) -&gt; ECJwk:\n\"\"\"Initialize a private ECJwk from its private parameters.\n\n        Args:\n          crv: the curve to use\n          x: the x coordinate\n          y: the y coordinate\n          d: the elliptic curve private key\n          **params: additional members to include in the JWK\n\n        Returns:\n          an ECJwk initialized with the supplied parameters\n\n        \"\"\"\n        coord_size = cls.get_curve(crv).coordinate_size\n        return cls(\n            dict(\n                kty=cls.KTY,\n                crv=crv,\n                x=BinaPy.from_int(x, coord_size).to(\"b64u\").ascii(),\n                y=BinaPy.from_int(y, coord_size).to(\"b64u\").ascii(),\n                d=BinaPy.from_int(d, coord_size).to(\"b64u\").ascii(),\n                **{k: v for k, v in params.items() if v is not None},\n            )\n        )\n\n    @classmethod\n    @override\n    def generate(\n        cls, *, crv: str | None = None, alg: str | None = None, **kwargs: Any\n    ) -&gt; ECJwk:\n        curve: EllipticCurve = P_256\n\n        if crv is None and alg is None:\n            raise ValueError(\n                \"No Curve identifier (crv) or Algorithm identifier (alg) have been provided \"\n                \"when generating an Elliptic Curve JWK. So there is no hint to determine which curve to use. \"\n                \"You must explicitly pass an 'alg' or 'crv' parameter to select the appropriate Curve.\"\n            )\n        elif crv:\n            curve = cls.get_curve(crv)\n        elif alg:\n            if alg in cls.SIGNATURE_ALGORITHMS:\n                curve = cls.SIGNATURE_ALGORITHMS[alg].curve\n            elif alg in cls.KEY_MANAGEMENT_ALGORITHMS:\n                warnings.warn(\n                    \"No Curve identifier (crv) specified when generating an Elliptic Curve Jwk for Key Management. \"\n                    \"Curve 'P-256' is used by default. You should explicitly pass a 'crv' parameter \"\n                    \"to select the appropriate Curve and avoid this warning.\"\n                )\n            else:\n                raise UnsupportedAlg(alg)\n\n        x, y, d = curve.generate()\n        return cls.private(\n            crv=curve.name,\n            alg=alg,\n            x=x,\n            y=y,\n            d=d,\n            **kwargs,\n        )\n\n    @classmethod\n    @override\n    def from_cryptography_key(cls, cryptography_key: Any, **kwargs: Any) -&gt; ECJwk:\n        parameters = EllipticCurve.get_jwk_parameters(cryptography_key)\n        return cls(parameters)\n\n    @override\n    def _to_cryptography_key(\n        self,\n    ) -&gt; ec.EllipticCurvePrivateKey | ec.EllipticCurvePublicKey:\n        if self.is_private:\n            return ec.EllipticCurvePrivateNumbers(\n                private_value=self.ecc_private_key,\n                public_numbers=ec.EllipticCurvePublicNumbers(\n                    x=self.x_coordinate,\n                    y=self.y_coordinate,\n                    curve=self.curve.cryptography_curve,\n                ),\n            ).private_key()\n        else:\n            return ec.EllipticCurvePublicNumbers(\n                x=self.x_coordinate,\n                y=self.y_coordinate,\n                curve=self.curve.cryptography_curve,\n            ).public_key()\n\n    @property\n    def coordinate_size(self) -&gt; int:\n\"\"\"The coordinate size to use with the key curve.\n\n        This is 32, 48, or 66 bits.\n\n        \"\"\"\n        return self.curve.coordinate_size\n\n    @cached_property\n    def x_coordinate(self) -&gt; int:\n\"\"\"Return the *x coordinate*, parameter `x` from this `ECJwk`.\"\"\"\n        return BinaPy(self.x).decode_from(\"b64u\").to_int()\n\n    @cached_property\n    def y_coordinate(self) -&gt; int:\n\"\"\"Return the *y coordinate*, parameter `y` from this `ECJwk`.\"\"\"\n        return BinaPy(self.y).decode_from(\"b64u\").to_int()\n\n    @cached_property\n    def ecc_private_key(self) -&gt; int:\n\"\"\"Return the *ECC private key*, parameter `d` from this `ECJwk`.\"\"\"\n        return BinaPy(self.d).decode_from(\"b64u\").to_int()\n\n    @override\n    def supported_signing_algorithms(self) -&gt; list[str]:\n        return [\n            name\n            for name, alg in self.SIGNATURE_ALGORITHMS.items()\n            if alg.curve == self.curve\n        ]\n\n    @override\n    def supported_key_management_algorithms(self) -&gt; list[str]:\n        return list(self.KEY_MANAGEMENT_ALGORITHMS)\n\n    @override\n    def supported_encryption_algorithms(self) -&gt; list[str]:\n        return list(self.ENCRYPTION_ALGORITHMS)\n</code></pre>"},{"location":"api/#jwskate.jwk.ec.ECJwk.curve","title":"curve  <code>property</code>","text":"<pre><code>curve: EllipticCurve\n</code></pre> <p>Get the <code>EllipticCurve</code> instance for this key.</p> <p>Returns:</p> Type Description <code>EllipticCurve</code> <p>the <code>EllipticCurve</code> instance</p>"},{"location":"api/#jwskate.jwk.ec.ECJwk.coordinate_size","title":"coordinate_size  <code>property</code>","text":"<pre><code>coordinate_size: int\n</code></pre> <p>The coordinate size to use with the key curve.</p> <p>This is 32, 48, or 66 bits.</p>"},{"location":"api/#jwskate.jwk.ec.ECJwk.x_coordinate","title":"x_coordinate  <code>cached</code> <code>property</code>","text":"<pre><code>x_coordinate: int\n</code></pre> <p>Return the x coordinate, parameter <code>x</code> from this <code>ECJwk</code>.</p>"},{"location":"api/#jwskate.jwk.ec.ECJwk.y_coordinate","title":"y_coordinate  <code>cached</code> <code>property</code>","text":"<pre><code>y_coordinate: int\n</code></pre> <p>Return the y coordinate, parameter <code>y</code> from this <code>ECJwk</code>.</p>"},{"location":"api/#jwskate.jwk.ec.ECJwk.ecc_private_key","title":"ecc_private_key  <code>cached</code> <code>property</code>","text":"<pre><code>ecc_private_key: int\n</code></pre> <p>Return the ECC private key, parameter <code>d</code> from this <code>ECJwk</code>.</p>"},{"location":"api/#jwskate.jwk.ec.ECJwk.get_curve","title":"get_curve  <code>classmethod</code>","text":"<pre><code>get_curve(crv: str) -&gt; EllipticCurve\n</code></pre> <p>Get the EllipticCurve instance for a given curve identifier.</p> <p>Parameters:</p> Name Type Description Default <code>crv</code> <code>str</code> <p>the curve identifier</p> required <p>Returns:</p> Type Description <code>EllipticCurve</code> <p>the matching <code>EllipticCurve</code> instance</p> <p>Raises:</p> Type Description <code>UnsupportedEllipticCurve</code> <p>if the curve identifier is not supported</p> Source code in <code>jwskate/jwk/ec.py</code> <pre><code>@classmethod\ndef get_curve(cls, crv: str) -&gt; EllipticCurve:\n\"\"\"Get the EllipticCurve instance for a given curve identifier.\n\n    Args:\n      crv: the curve identifier\n\n    Returns:\n        the matching `EllipticCurve` instance\n\n    Raises:\n        UnsupportedEllipticCurve: if the curve identifier is not supported\n\n    \"\"\"\n    curve = cls.CURVES.get(crv)\n    if curve is None:\n        raise UnsupportedEllipticCurve(crv)\n    return curve\n</code></pre>"},{"location":"api/#jwskate.jwk.ec.ECJwk.public","title":"public  <code>classmethod</code>","text":"<pre><code>public(*, crv: str, x: int, y: int, **params: str) -&gt; ECJwk\n</code></pre> <p>Initialize a public <code>ECJwk</code> from its public parameters.</p> <p>Parameters:</p> Name Type Description Default <code>crv</code> <code>str</code> <p>the curve to use</p> required <code>x</code> <code>int</code> <p>the x coordinate</p> required <code>y</code> <code>int</code> <p>the y coordinate</p> required <code>**params</code> <code>str</code> <p>additional member to include in the Jwk</p> <code>{}</code> <p>Returns:</p> Type Description <code>ECJwk</code> <p>an ECJwk initialized with the supplied parameters</p> Source code in <code>jwskate/jwk/ec.py</code> <pre><code>@classmethod\ndef public(cls, *, crv: str, x: int, y: int, **params: str) -&gt; ECJwk:\n\"\"\"Initialize a public `ECJwk` from its public parameters.\n\n    Args:\n      crv: the curve to use\n      x: the x coordinate\n      y: the y coordinate\n      **params: additional member to include in the Jwk\n\n    Returns:\n      an ECJwk initialized with the supplied parameters\n\n    \"\"\"\n    coord_size = cls.get_curve(crv).coordinate_size\n    return cls(\n        dict(\n            kty=cls.KTY,\n            crv=crv,\n            x=BinaPy.from_int(x, length=coord_size).to(\"b64u\").ascii(),\n            y=BinaPy.from_int(y, length=coord_size).to(\"b64u\").ascii(),\n            **{k: v for k, v in params.items() if v is not None},\n        )\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.ec.ECJwk.private","title":"private  <code>classmethod</code>","text":"<pre><code>private(\n    *, crv: str, x: int, y: int, d: int, **params: Any\n) -&gt; ECJwk\n</code></pre> <p>Initialize a private ECJwk from its private parameters.</p> <p>Parameters:</p> Name Type Description Default <code>crv</code> <code>str</code> <p>the curve to use</p> required <code>x</code> <code>int</code> <p>the x coordinate</p> required <code>y</code> <code>int</code> <p>the y coordinate</p> required <code>d</code> <code>int</code> <p>the elliptic curve private key</p> required <code>**params</code> <code>Any</code> <p>additional members to include in the JWK</p> <code>{}</code> <p>Returns:</p> Type Description <code>ECJwk</code> <p>an ECJwk initialized with the supplied parameters</p> Source code in <code>jwskate/jwk/ec.py</code> <pre><code>@classmethod\ndef private(cls, *, crv: str, x: int, y: int, d: int, **params: Any) -&gt; ECJwk:\n\"\"\"Initialize a private ECJwk from its private parameters.\n\n    Args:\n      crv: the curve to use\n      x: the x coordinate\n      y: the y coordinate\n      d: the elliptic curve private key\n      **params: additional members to include in the JWK\n\n    Returns:\n      an ECJwk initialized with the supplied parameters\n\n    \"\"\"\n    coord_size = cls.get_curve(crv).coordinate_size\n    return cls(\n        dict(\n            kty=cls.KTY,\n            crv=crv,\n            x=BinaPy.from_int(x, coord_size).to(\"b64u\").ascii(),\n            y=BinaPy.from_int(y, coord_size).to(\"b64u\").ascii(),\n            d=BinaPy.from_int(d, coord_size).to(\"b64u\").ascii(),\n            **{k: v for k, v in params.items() if v is not None},\n        )\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.OKPJwk","title":"OKPJwk","text":"<p>             Bases: <code>Jwk</code></p> <p>Represent an Octet Key Pair keys in JWK format.</p> <p>Octet Key Pair keys have Key Type <code>\"OKP\"</code>.</p> Source code in <code>jwskate/jwk/okp.py</code> <pre><code>class OKPJwk(Jwk):\n\"\"\"Represent an Octet Key Pair keys in JWK format.\n\n    Octet Key Pair keys have Key Type `\"OKP\"`.\n\n    \"\"\"\n\n    KTY = KeyTypes.OKP\n\n    CRYPTOGRAPHY_PRIVATE_KEY_CLASSES = (\n        ed25519.Ed25519PrivateKey,\n        ed448.Ed448PrivateKey,\n        x25519.X25519PrivateKey,\n        x448.X448PrivateKey,\n    )\n\n    CRYPTOGRAPHY_PUBLIC_KEY_CLASSES = (\n        ed25519.Ed25519PublicKey,\n        ed448.Ed448PublicKey,\n        x25519.X25519PublicKey,\n        x448.X448PublicKey,\n    )\n\n    PARAMS = {\n        \"crv\": JwkParameter(\"Curve\", is_private=False, is_required=True, kind=\"name\"),\n        \"x\": JwkParameter(\n            \"Public Key\", is_private=False, is_required=True, kind=\"b64u\"\n        ),\n        \"d\": JwkParameter(\n            \"Private Key\", is_private=True, is_required=True, kind=\"b64u\"\n        ),\n    }\n\n    CURVES: Mapping[str, OKPCurve] = {\n        curve.name: curve for curve in [Ed25519, Ed448, X448, X25519]\n    }\n\n    SIGNATURE_ALGORITHMS = {alg.name: alg for alg in (EdDsa,)}\n\n    KEY_MANAGEMENT_ALGORITHMS = {\n        keyalg.name: keyalg\n        for keyalg in [EcdhEs, EcdhEs_A128KW, EcdhEs_A192KW, EcdhEs_A256KW]\n    }\n\n    @property\n    @override\n    def is_private(self) -&gt; bool:\n        return \"d\" in self\n\n    @override\n    def _validate(self) -&gt; None:\n        if not isinstance(self.crv, str) or self.crv not in self.CURVES:\n            raise UnsupportedOKPCurve(self.crv)\n        super()._validate()\n\n    @classmethod\n    def get_curve(cls, crv: str) -&gt; OKPCurve:\n\"\"\"Get the `OKPCurve` instance from a curve identifier.\n\n        Args:\n          crv: a curve identifier\n\n        Returns:\n            the matching `OKPCurve` instance\n\n        Raises:\n            UnsupportedOKPCurve: if the curve is not supported\n\n        \"\"\"\n        curve = cls.CURVES.get(crv)\n        if curve is None:\n            raise UnsupportedOKPCurve(crv)\n        return curve\n\n    @property\n    def curve(self) -&gt; OKPCurve:\n\"\"\"Get the `OKPCurve` instance for this key.\"\"\"\n        return self.get_curve(self.crv)\n\n    @cached_property\n    def public_key(self) -&gt; bytes:\n\"\"\"Get the public key from this `Jwk`, from param `x`, base64url-decoded.\"\"\"\n        return BinaPy(self.x).decode_from(\"b64u\")\n\n    @cached_property\n    def private_key(self) -&gt; bytes:\n\"\"\"Get the private key from this `Jwk`, from param `d`, base64url-decoded.\"\"\"\n        return BinaPy(self.d).decode_from(\"b64u\")\n\n    @classmethod\n    def from_bytes(\n        cls,\n        private_key: bytes,\n        crv: str | None = None,\n        use: str | None = None,\n        **kwargs: Any,\n    ) -&gt; OKPJwk:\n\"\"\"Initialize an `OKPJwk` from its private key, as `bytes`.\n\n        The public key will be automatically derived from the supplied private key, according to the OKP curve.\n\n        The appropriate curve will be guessed based on the key length or supplied `crv`/`use` hints:\n\n        - 56 bytes will use `X448`\n        - 57 bytes will use `Ed448`\n        - 32 bytes will use `Ed25519` or `X25519`. Since there is no way to guess which one you want,\n          it needs a hint with either a `crv` or `use` parameter.\n\n        Args:\n            private_key: the 32, 56 or 57 bytes private key, as raw `bytes`\n            crv: the curve identifier to use\n            use: the key usage\n            **kwargs: additional members to include in the `Jwk`\n\n        Returns:\n            the matching `OKPJwk`\n\n        \"\"\"\n        if crv and use:\n            if (crv in (\"Ed25519\", \"Ed448\") and use != \"sig\") or (\n                crv in (\"X25519\", \"X448\") and use != \"enc\"\n            ):\n                raise ValueError(\n                    f\"Inconsistent `crv={crv}` and `use={use}` parameters. \"\n                    \"Ed25519 and Ed448 are used for signing (use='sig'). \"\n                    \"X25519 and X448 are used for encryption (use='enc'). \"\n                )\n        elif crv:\n            if crv in (\"Ed25519\", \"Ed448\"):\n                use = \"sig\"\n            elif crv in (\"X25519\", \"X448\"):\n                use = \"enc\"\n            else:\n                raise UnsupportedOKPCurve(crv)\n        elif use:\n            if use not in (\"sig\", \"enc\"):\n                raise ValueError(\n                    f\"Invalid `use={use}` parameter, it must be either 'sig' or 'enc'.\"\n                )\n\n        cryptography_key: Any\n        if len(private_key) == 32:\n            if use == \"sig\":\n                cryptography_key = ed25519.Ed25519PrivateKey.from_private_bytes(\n                    private_key\n                )\n            elif use == \"enc\":\n                cryptography_key = x25519.X25519PrivateKey.from_private_bytes(\n                    private_key\n                )\n            else:\n                raise ValueError(\n                    \"You provided a 32 bytes private key, which is appropriate for both Ed25519 and X25519 curves. \"\n                    \"There is no way to guess which curve you need, \"\n                    \"so please specify either `crv='Ed25519'` or `use='sig'` for an Ed25519 key, \"\n                    \"or either `crv='X25519'` or `use='enc'` for a X25519 key.\"\n                )\n        elif len(private_key) == 56:\n            cryptography_key = x448.X448PrivateKey.from_private_bytes(private_key)\n            if use and use != \"enc\":\n                raise ValueError(\n                    f\"Invalid `use='{use}'` parameter. Keys of length 56 bytes are only suitable for curve 'X448'.\"\n                )\n            use = \"enc\"\n        elif len(private_key) == 57:\n            cryptography_key = ed448.Ed448PrivateKey.from_private_bytes(private_key)\n            if use and use != \"sig\":\n                raise ValueError(\n                    f\"Invalid `use='{use}'` parameter. Keys of length 57 bytes are only suitable for curve 'Ed448'.\"\n                )\n            use = \"sig\"\n        else:\n            raise ValueError(\n                \"Invalid private key. It must be `bytes`, of length 32, 56 or 57 bytes.\"\n            )\n\n        return OKPJwk.from_cryptography_key(cryptography_key, use=use, **kwargs)\n\n    @classmethod\n    @override\n    def from_cryptography_key(cls, cryptography_key: Any, **kwargs: Any) -&gt; OKPJwk:\n        crv = OKPCurve.get_curve(cryptography_key)\n        if isinstance(cryptography_key, cls.CRYPTOGRAPHY_PRIVATE_KEY_CLASSES):\n            priv = cryptography_key.private_bytes(\n                encoding=serialization.Encoding.Raw,\n                format=serialization.PrivateFormat.Raw,\n                encryption_algorithm=serialization.NoEncryption(),\n            )\n            pub = cryptography_key.public_key().public_bytes(\n                encoding=serialization.Encoding.Raw,\n                format=serialization.PublicFormat.Raw,\n            )\n            return cls.private(\n                crv=crv.name,\n                x=pub,\n                d=priv,\n            )\n        elif isinstance(cryptography_key, cls.CRYPTOGRAPHY_PUBLIC_KEY_CLASSES):\n            pub = cryptography_key.public_bytes(\n                encoding=serialization.Encoding.Raw,\n                format=serialization.PublicFormat.Raw,\n            )\n            return cls.public(\n                crv=crv.name,\n                x=pub,\n            )\n        raise TypeError(\n            \"Unsupported key type\", type(cryptography_key)\n        )  # pragma: no-cover\n\n    @override\n    def _to_cryptography_key(self) -&gt; Any:\n        if self.curve.name == \"Ed25519\":\n            if self.is_private:\n                return ed25519.Ed25519PrivateKey.from_private_bytes(self.private_key)\n            else:\n                return ed25519.Ed25519PublicKey.from_public_bytes(self.public_key)\n        elif self.curve.name == \"Ed448\":\n            if self.is_private:\n                return ed448.Ed448PrivateKey.from_private_bytes(self.private_key)\n            else:\n                return ed448.Ed448PublicKey.from_public_bytes(self.public_key)\n        elif self.curve.name == \"X25519\":\n            if self.is_private:\n                return x25519.X25519PrivateKey.from_private_bytes(self.private_key)\n            else:\n                return x25519.X25519PublicKey.from_public_bytes(self.public_key)\n        elif self.curve.name == \"X448\":\n            if self.is_private:\n                return x448.X448PrivateKey.from_private_bytes(self.private_key)\n            else:\n                return x448.X448PublicKey.from_public_bytes(self.public_key)\n        else:\n            raise UnsupportedOKPCurve(self.curve)  # pragma: no cover\n\n    @classmethod\n    def public(cls, *, crv: str, x: bytes, **params: Any) -&gt; OKPJwk:\n\"\"\"Initialize a public `OKPJwk` based on the provided parameters.\n\n        Args:\n          crv: the key curve\n          x: the public key\n          **params: additional members to include in the `Jwk`\n\n        Returns:\n            the resulting `OKPJwk`\n\n        \"\"\"\n        return cls(dict(kty=cls.KTY, crv=crv, x=BinaPy(x).to(\"b64u\").ascii(), **params))\n\n    @classmethod\n    def private(cls, *, crv: str, x: bytes, d: bytes, **params: Any) -&gt; OKPJwk:\n\"\"\"Initialize a private `OKPJwk` based on the provided parameters.\n\n        Args:\n          crv: the OKP curve\n          x: the public key\n          d: the private key\n          **params: additional members to include in the `Jwk`\n\n        Returns:\n            the resulting `OKPJwk`\n\n        \"\"\"\n        return cls(\n            dict(\n                kty=cls.KTY,\n                crv=crv,\n                x=BinaPy(x).to(\"b64u\").ascii(),\n                d=BinaPy(d).to(\"b64u\").ascii(),\n                **params,\n            )\n        )\n\n    @classmethod\n    @override\n    def generate(\n        cls, *, crv: str | None = None, alg: str | None = None, **params: Any\n    ) -&gt; OKPJwk:\n        if crv:\n            curve = cls.get_curve(crv)\n        elif alg:\n            if alg in cls.SIGNATURE_ALGORITHMS:\n                curve = Ed25519\n            elif alg in cls.KEY_MANAGEMENT_ALGORITHMS:\n                curve = X25519\n            else:\n                raise UnsupportedAlg(alg)\n        else:\n            raise ValueError(\n                \"You must supply at least a Curve identifier (crv) or an Algorithm identifier (alg) \"\n                \"in order to generate an OKPJwk.\"\n            )\n\n        x, d = curve.generate()\n        return cls.private(crv=curve.name, x=x, d=d, alg=alg, **params)\n\n    @cached_property\n    @override\n    def use(self) -&gt; str | None:\n        if self.curve in (Ed25519, Ed448):\n            return \"sig\"\n        elif self.curve in (X25519, X448):\n            return \"enc\"\n        raise UnsupportedOKPCurve(self.curse)  # pragma: no-cover\n</code></pre>"},{"location":"api/#jwskate.jwk.okp.OKPJwk.curve","title":"curve  <code>property</code>","text":"<pre><code>curve: OKPCurve\n</code></pre> <p>Get the <code>OKPCurve</code> instance for this key.</p>"},{"location":"api/#jwskate.jwk.okp.OKPJwk.public_key","title":"public_key  <code>cached</code> <code>property</code>","text":"<pre><code>public_key: bytes\n</code></pre> <p>Get the public key from this <code>Jwk</code>, from param <code>x</code>, base64url-decoded.</p>"},{"location":"api/#jwskate.jwk.okp.OKPJwk.private_key","title":"private_key  <code>cached</code> <code>property</code>","text":"<pre><code>private_key: bytes\n</code></pre> <p>Get the private key from this <code>Jwk</code>, from param <code>d</code>, base64url-decoded.</p>"},{"location":"api/#jwskate.jwk.okp.OKPJwk.get_curve","title":"get_curve  <code>classmethod</code>","text":"<pre><code>get_curve(crv: str) -&gt; OKPCurve\n</code></pre> <p>Get the <code>OKPCurve</code> instance from a curve identifier.</p> <p>Parameters:</p> Name Type Description Default <code>crv</code> <code>str</code> <p>a curve identifier</p> required <p>Returns:</p> Type Description <code>OKPCurve</code> <p>the matching <code>OKPCurve</code> instance</p> <p>Raises:</p> Type Description <code>UnsupportedOKPCurve</code> <p>if the curve is not supported</p> Source code in <code>jwskate/jwk/okp.py</code> <pre><code>@classmethod\ndef get_curve(cls, crv: str) -&gt; OKPCurve:\n\"\"\"Get the `OKPCurve` instance from a curve identifier.\n\n    Args:\n      crv: a curve identifier\n\n    Returns:\n        the matching `OKPCurve` instance\n\n    Raises:\n        UnsupportedOKPCurve: if the curve is not supported\n\n    \"\"\"\n    curve = cls.CURVES.get(crv)\n    if curve is None:\n        raise UnsupportedOKPCurve(crv)\n    return curve\n</code></pre>"},{"location":"api/#jwskate.jwk.okp.OKPJwk.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(\n    private_key: bytes,\n    crv: str | None = None,\n    use: str | None = None,\n    **kwargs: Any\n) -&gt; OKPJwk\n</code></pre> <p>Initialize an <code>OKPJwk</code> from its private key, as <code>bytes</code>.</p> <p>The public key will be automatically derived from the supplied private key, according to the OKP curve.</p> <p>The appropriate curve will be guessed based on the key length or supplied <code>crv</code>/<code>use</code> hints:</p> <ul> <li>56 bytes will use <code>X448</code></li> <li>57 bytes will use <code>Ed448</code></li> <li>32 bytes will use <code>Ed25519</code> or <code>X25519</code>. Since there is no way to guess which one you want,   it needs a hint with either a <code>crv</code> or <code>use</code> parameter.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>the 32, 56 or 57 bytes private key, as raw <code>bytes</code></p> required <code>crv</code> <code>str | None</code> <p>the curve identifier to use</p> <code>None</code> <code>use</code> <code>str | None</code> <p>the key usage</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional members to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>OKPJwk</code> <p>the matching <code>OKPJwk</code></p> Source code in <code>jwskate/jwk/okp.py</code> <pre><code>@classmethod\ndef from_bytes(\n    cls,\n    private_key: bytes,\n    crv: str | None = None,\n    use: str | None = None,\n    **kwargs: Any,\n) -&gt; OKPJwk:\n\"\"\"Initialize an `OKPJwk` from its private key, as `bytes`.\n\n    The public key will be automatically derived from the supplied private key, according to the OKP curve.\n\n    The appropriate curve will be guessed based on the key length or supplied `crv`/`use` hints:\n\n    - 56 bytes will use `X448`\n    - 57 bytes will use `Ed448`\n    - 32 bytes will use `Ed25519` or `X25519`. Since there is no way to guess which one you want,\n      it needs a hint with either a `crv` or `use` parameter.\n\n    Args:\n        private_key: the 32, 56 or 57 bytes private key, as raw `bytes`\n        crv: the curve identifier to use\n        use: the key usage\n        **kwargs: additional members to include in the `Jwk`\n\n    Returns:\n        the matching `OKPJwk`\n\n    \"\"\"\n    if crv and use:\n        if (crv in (\"Ed25519\", \"Ed448\") and use != \"sig\") or (\n            crv in (\"X25519\", \"X448\") and use != \"enc\"\n        ):\n            raise ValueError(\n                f\"Inconsistent `crv={crv}` and `use={use}` parameters. \"\n                \"Ed25519 and Ed448 are used for signing (use='sig'). \"\n                \"X25519 and X448 are used for encryption (use='enc'). \"\n            )\n    elif crv:\n        if crv in (\"Ed25519\", \"Ed448\"):\n            use = \"sig\"\n        elif crv in (\"X25519\", \"X448\"):\n            use = \"enc\"\n        else:\n            raise UnsupportedOKPCurve(crv)\n    elif use:\n        if use not in (\"sig\", \"enc\"):\n            raise ValueError(\n                f\"Invalid `use={use}` parameter, it must be either 'sig' or 'enc'.\"\n            )\n\n    cryptography_key: Any\n    if len(private_key) == 32:\n        if use == \"sig\":\n            cryptography_key = ed25519.Ed25519PrivateKey.from_private_bytes(\n                private_key\n            )\n        elif use == \"enc\":\n            cryptography_key = x25519.X25519PrivateKey.from_private_bytes(\n                private_key\n            )\n        else:\n            raise ValueError(\n                \"You provided a 32 bytes private key, which is appropriate for both Ed25519 and X25519 curves. \"\n                \"There is no way to guess which curve you need, \"\n                \"so please specify either `crv='Ed25519'` or `use='sig'` for an Ed25519 key, \"\n                \"or either `crv='X25519'` or `use='enc'` for a X25519 key.\"\n            )\n    elif len(private_key) == 56:\n        cryptography_key = x448.X448PrivateKey.from_private_bytes(private_key)\n        if use and use != \"enc\":\n            raise ValueError(\n                f\"Invalid `use='{use}'` parameter. Keys of length 56 bytes are only suitable for curve 'X448'.\"\n            )\n        use = \"enc\"\n    elif len(private_key) == 57:\n        cryptography_key = ed448.Ed448PrivateKey.from_private_bytes(private_key)\n        if use and use != \"sig\":\n            raise ValueError(\n                f\"Invalid `use='{use}'` parameter. Keys of length 57 bytes are only suitable for curve 'Ed448'.\"\n            )\n        use = \"sig\"\n    else:\n        raise ValueError(\n            \"Invalid private key. It must be `bytes`, of length 32, 56 or 57 bytes.\"\n        )\n\n    return OKPJwk.from_cryptography_key(cryptography_key, use=use, **kwargs)\n</code></pre>"},{"location":"api/#jwskate.jwk.okp.OKPJwk.public","title":"public  <code>classmethod</code>","text":"<pre><code>public(*, crv: str, x: bytes, **params: Any) -&gt; OKPJwk\n</code></pre> <p>Initialize a public <code>OKPJwk</code> based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>crv</code> <code>str</code> <p>the key curve</p> required <code>x</code> <code>bytes</code> <p>the public key</p> required <code>**params</code> <code>Any</code> <p>additional members to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>OKPJwk</code> <p>the resulting <code>OKPJwk</code></p> Source code in <code>jwskate/jwk/okp.py</code> <pre><code>@classmethod\ndef public(cls, *, crv: str, x: bytes, **params: Any) -&gt; OKPJwk:\n\"\"\"Initialize a public `OKPJwk` based on the provided parameters.\n\n    Args:\n      crv: the key curve\n      x: the public key\n      **params: additional members to include in the `Jwk`\n\n    Returns:\n        the resulting `OKPJwk`\n\n    \"\"\"\n    return cls(dict(kty=cls.KTY, crv=crv, x=BinaPy(x).to(\"b64u\").ascii(), **params))\n</code></pre>"},{"location":"api/#jwskate.jwk.okp.OKPJwk.private","title":"private  <code>classmethod</code>","text":"<pre><code>private(\n    *, crv: str, x: bytes, d: bytes, **params: Any\n) -&gt; OKPJwk\n</code></pre> <p>Initialize a private <code>OKPJwk</code> based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>crv</code> <code>str</code> <p>the OKP curve</p> required <code>x</code> <code>bytes</code> <p>the public key</p> required <code>d</code> <code>bytes</code> <p>the private key</p> required <code>**params</code> <code>Any</code> <p>additional members to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>OKPJwk</code> <p>the resulting <code>OKPJwk</code></p> Source code in <code>jwskate/jwk/okp.py</code> <pre><code>@classmethod\ndef private(cls, *, crv: str, x: bytes, d: bytes, **params: Any) -&gt; OKPJwk:\n\"\"\"Initialize a private `OKPJwk` based on the provided parameters.\n\n    Args:\n      crv: the OKP curve\n      x: the public key\n      d: the private key\n      **params: additional members to include in the `Jwk`\n\n    Returns:\n        the resulting `OKPJwk`\n\n    \"\"\"\n    return cls(\n        dict(\n            kty=cls.KTY,\n            crv=crv,\n            x=BinaPy(x).to(\"b64u\").ascii(),\n            d=BinaPy(d).to(\"b64u\").ascii(),\n            **params,\n        )\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.UnsupportedKeyType","title":"UnsupportedKeyType","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when an unsupported Key Type is requested.</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>class UnsupportedKeyType(ValueError):\n\"\"\"Raised when an unsupported Key Type is requested.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwk.InvalidJwk","title":"InvalidJwk","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when an invalid JWK is encountered.</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>class InvalidJwk(ValueError):\n\"\"\"Raised when an invalid JWK is encountered.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwk.Jwk","title":"Jwk","text":"<p>             Bases: <code>BaseJsonDict</code></p> <p>Represents a Json Web Key (JWK), as specified in RFC7517.</p> <p>A JWK is a JSON object that represents a cryptographic key.  The members of the object represent properties of the key, also called parameters, which are name and value pairs.</p> <p>Just like a parsed JSON object, a <code>Jwk</code> is a <code>dict</code>, so you can do with a <code>Jwk</code> anything you can do with a <code>dict</code>. In addition, all keys parameters are exposed as attributes. There are subclasses of <code>Jwk</code> for each specific Key Type, but unless you are dealing with specific parameters for a given key type, you shouldn't have to use the subclasses directly since they all present a common interface for cryptographic operations.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict[str, Any] | Any</code> <p>a <code>dict</code> parsed from a JSON JWK, or a <code>cryptography key</code>, or another <code>Jwk</code>, or a <code>str</code> containing the JSON representation of a JWK, or raw <code>bytes</code></p> required <code>include_kid_thumbprint</code> <code>bool</code> <p>if <code>True</code> (default), and there is no kid in the provided params, generate a kid based on the key thumbprint</p> <code>False</code> Source code in <code>jwskate/jwk/base.py</code> <pre><code>class Jwk(BaseJsonDict):\n\"\"\"Represents a Json Web Key (JWK), as specified in RFC7517.\n\n    A JWK is a JSON object that represents a cryptographic key.  The\n    members of the object represent properties of the key, also called\n    parameters, which are name and value pairs.\n\n    Just like a parsed JSON object, a `Jwk` is a `dict`, so\n    you can do with a `Jwk` anything you can do with a `dict`. In\n    addition, all keys parameters are exposed as attributes. There are\n    subclasses of `Jwk` for each specific Key Type, but unless you are\n    dealing with specific parameters for a given key type, you shouldn't\n    have to use the subclasses directly since they all present a common\n    interface for cryptographic operations.\n\n    Args:\n        params: a `dict` parsed from a JSON JWK, or a `cryptography key`, or another `Jwk`, or a `str` containing the JSON representation of a JWK, or raw `bytes`\n        include_kid_thumbprint: if `True` (default), and there is no kid in the provided params, generate a kid based on the key thumbprint\n\n    \"\"\"\n\n    @classmethod\n    def generate_for_alg(cls, alg: str, **kwargs: Any) -&gt; Jwk:\n\"\"\"Generate a key for usage with a specific `alg` and return the resulting `Jwk`.\n\n        Args:\n            alg: a signature or key management algorithm identifier\n            **kwargs: specific parameters, depending on the key type, or additional members to include in the `Jwk`\n\n        Returns:\n            the generated `Jwk`\n\n        \"\"\"\n        for kty, jwk_class in cls.subclasses.items():\n            try:\n                jwk_class._get_alg_class(alg)\n                return jwk_class.generate(alg=alg, **kwargs)\n            except UnsupportedAlg:\n                continue\n\n        raise UnsupportedAlg(alg)\n\n    @classmethod\n    def generate_for_kty(cls, kty: str, **kwargs: Any) -&gt; Jwk:\n\"\"\"Generate a key with a specific type and return the resulting `Jwk`.\n\n        Args:\n          kty: key type to generate\n          **kwargs: specific parameters depending on the key type, or additional members to include in the `Jwk`\n\n        Returns:\n            the resulting `Jwk`\n\n        Raises:\n            UnsupportedKeyType: if the specified key type (`kty`) is not supported\n\n        \"\"\"\n        jwk_class = cls.subclasses.get(kty)\n        if jwk_class is None:\n            raise UnsupportedKeyType(\"Unsupported Key Type:\", kty)\n        return jwk_class.generate(**kwargs)\n\n    subclasses: dict[str, type[Jwk]] = {}\n\"\"\"A dict of 'kty' values to `Jwk` subclasses implementing each specific Key Type.\"\"\"\n    cryptography_key_types: dict[Any, type[Jwk]] = {}\n\"\"\"A dict of cryptography classes to equivalent `Jwk` subclasses.\"\"\"\n\n    PARAMS: Mapping[str, JwkParameter]\n\n    KTY: ClassVar[str]\n\n    CRYPTOGRAPHY_PRIVATE_KEY_CLASSES: ClassVar[Iterable[Any]]\n    CRYPTOGRAPHY_PUBLIC_KEY_CLASSES: ClassVar[Iterable[Any]]\n\n    SIGNATURE_ALGORITHMS: Mapping[str, type[BaseSignatureAlg]] = {}\n    KEY_MANAGEMENT_ALGORITHMS: Mapping[str, type[BaseKeyManagementAlg]] = {}\n    ENCRYPTION_ALGORITHMS: Mapping[str, type[BaseAESEncryptionAlg]] = {}\n\n    IANA_HASH_FUNCTION_NAMES: Mapping[str, str] = {\n        # IANA registered names to binapy hash name\n        \"sha-1\": \"sha1\",\n        \"sha-224\": \"sha224\",\n        \"sha-256\": \"sha256\",\n        \"sha-384\": \"sha384\",\n        \"sha-512\": \"sha512\",\n        \"shake128\": \"shake128\",\n        \"shake256\": \"shake256\",\n    }\n\n    def __init_subclass__(cls) -&gt; None:\n\"\"\"Automatically add subclasses to the registry.\n\n        This allows `__new__` to pick the appropriate subclass when creating a Jwk.\n\n        \"\"\"\n        Jwk.subclasses[cls.KTY] = cls\n        for klass in cls.CRYPTOGRAPHY_PRIVATE_KEY_CLASSES:\n            Jwk.cryptography_key_types[klass] = cls\n        for klass in cls.CRYPTOGRAPHY_PUBLIC_KEY_CLASSES:\n            Jwk.cryptography_key_types[klass] = cls\n\n    def __new__(cls, key: Jwk | dict[str, Any] | Any, **kwargs: Any) -&gt; Jwk:\n\"\"\"Overridden `__new__` to make the Jwk constructor smarter.\n\n        The Jwk constructor will accept:\n\n            - a `dict` with the parsed Jwk content\n            - another Jwk, which will be used as-is instead of creating a copy\n            - an instance from a `cryptography` public or private key class\n\n        Args:\n            key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key\n            **kwargs: additional members to include in the Jwk\n\n        \"\"\"\n        if cls == Jwk:\n            if isinstance(key, Jwk):\n                return cls.from_cryptography_key(key.cryptography_key, **kwargs)\n            if isinstance(key, dict):\n                kty: str | None = key.get(\"kty\")\n                if kty is None:\n                    raise InvalidJwk(\"A Json Web Key must have a Key Type (kty)\")\n\n                subclass = Jwk.subclasses.get(kty)\n                if subclass is None:\n                    raise InvalidJwk(\"Unsupported Key Type\", kty)\n                return super().__new__(subclass)  # type: ignore[type-var]\n            elif isinstance(key, str):\n                return cls.from_json(key)\n            else:\n                return cls.from_cryptography_key(key, **kwargs)\n        return super().__new__(cls, key, **kwargs)  # type: ignore[type-var]\n\n    def __init__(\n        self, params: dict[str, Any] | Any, include_kid_thumbprint: bool = False\n    ):\n        if isinstance(\n            params, dict\n        ):  # this is to avoid double init due to the __new__ above\n            super().__init__(\n                {key: val for key, val in params.items() if val is not None}\n            )\n            self._validate()\n            if self.get(\"kid\") is None and include_kid_thumbprint:\n                self[\"kid\"] = self.thumbprint()\n\n        try:\n            self.cryptography_key = self._to_cryptography_key()\n        except Exception as exc:\n            raise InvalidJwk(params) from exc\n\n    @classmethod\n    def _get_alg_class(cls, alg: str) -&gt; type[BaseAlg]:\n\"\"\"Given an alg identifier, return the matching JWA wrapper.\n\n        Args:\n            alg: an alg identifier\n\n        Returns:\n            the matching JWA wrapper\n\n        \"\"\"\n        alg_class: type[BaseAlg] | None\n\n        alg_class = cls.SIGNATURE_ALGORITHMS.get(alg)\n        if alg_class is not None:\n            return alg_class\n\n        alg_class = cls.KEY_MANAGEMENT_ALGORITHMS.get(alg)\n        if alg_class is not None:\n            return alg_class\n\n        alg_class = cls.ENCRYPTION_ALGORITHMS.get(alg)\n        if alg_class is not None:\n            return alg_class\n\n        raise UnsupportedAlg(alg)\n\n    @property\n    def is_private(self) -&gt; bool:\n\"\"\"Return `True` if the key is private, `False` otherwise.\n\n        Returns:\n            `True` if the key is private, `False` otherwise\n\n        \"\"\"\n        return True\n\n    @property\n    def is_symmetric(self) -&gt; bool:\n\"\"\"Return `True` if the key is symmetric, `False` otherwise.\"\"\"\n        return False\n\n    def __getattr__(self, param: str) -&gt; Any:\n\"\"\"Allow access to key parameters as attributes.\n\n        This is a convenience to allow `jwk.param` instead of `jwk['param']`.\n\n        Args:\n            param: the parameter name to access\n\n        Return:\n            the param value\n\n        Raises:\n            AttributeError: if the param is not found\n\n        \"\"\"\n        value = self.get(param)\n        if value is None:\n            raise AttributeError(param)\n        return value\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n\"\"\"Override base method to avoid modifying cryptographic key attributes.\n\n        Args:\n            key: name of the attribute to set\n            value: value to set\n\n        Raises:\n            RuntimeError: when trying to modify cryptographic attributes\n\n        \"\"\"\n        if key in self.PARAMS:\n            raise RuntimeError(\"JWK key attributes cannot be modified.\")\n        super().__setitem__(key, value)\n\n    @property\n    def kty(self) -&gt; str:\n\"\"\"Return the Key Type.\n\n        Returns:\n            the key type\n\n        \"\"\"\n        return self.KTY\n\n    @property\n    def alg(self) -&gt; str | None:\n\"\"\"Return the configured key alg, if any.\n\n        Returns:\n            the key alg\n\n        \"\"\"\n        alg = self.get(\"alg\")\n        if alg is not None and not isinstance(alg, str):  # pragma: no branch\n            raise TypeError(f\"Invalid alg type {type(alg)}\", alg)\n        return alg\n\n    @property\n    def kid(self) -&gt; str | None:\n\"\"\"Return the JWK key ID (kid), if present.\"\"\"\n        kid = self.get(\"kid\")\n        if kid is not None and not isinstance(kid, str):  # pragma: no branch\n            raise TypeError(f\"invalid kid type {type(kid)}\", kid)\n        return kid\n\n    @property\n    def use(self) -&gt; str | None:\n\"\"\"Return the key use.\n\n        If no `alg` parameter is present, this returns the `use` parameter from this JWK. If an\n        `alg` parameter is present, the use is deduced from this alg. To check for the presence of\n        the `use` parameter, use `jwk.get('use')`.\n\n        \"\"\"\n        if self.alg:\n            return self._get_alg_class(self.alg).use\n        else:\n            return self.get(\"use\")\n\n    @property\n    def key_ops(self) -&gt; tuple[str, ...]:\n\"\"\"Return the key operations.\n\n        If no `alg` parameter is present, this returns the `key_ops` parameter from this JWK. If an\n        `alg` parameter is present, the key operations are deduced from this alg. To check for the\n        presence of the `key_ops` parameter, use `jwk.get('key_ops')`.\n\n        \"\"\"\n        key_ops: tuple[str, ...]\n        if self.use == \"sig\":\n            if self.is_symmetric:\n                key_ops = (\"sign\", \"verify\")\n            elif self.is_private:\n                key_ops = (\"sign\",)\n            else:\n                key_ops = (\"verify\",)\n        elif self.use == \"enc\":\n            if self.is_symmetric:\n                if self.alg:\n                    alg_class = self._get_alg_class(self.alg)\n                    if issubclass(alg_class, BaseKeyManagementAlg):\n                        key_ops = (\"wrapKey\", \"unwrapKey\")\n                    elif issubclass(alg_class, BaseAESEncryptionAlg):\n                        key_ops = (\"encrypt\", \"decrypt\")\n                else:\n                    key_ops = (\"wrapKey\", \"unwrapKey\", \"encrypt\", \"decrypt\")\n            elif self.is_private:\n                key_ops = (\"unwrapKey\",)\n            else:\n                key_ops = (\"wrapKey\",)\n        else:\n            key_ops = self.get(\"key_ops\", ())\n\n        return tuple(key_ops)\n\n    def thumbprint(self, hashalg: str = \"sha-256\") -&gt; str:\n\"\"\"Return the key thumbprint as specified by RFC 7638.\n\n        Args:\n          hashalg: A hash function (defaults to SHA256)\n\n        Returns:\n            the calculated thumbprint\n\n        \"\"\"\n        alg = self.IANA_HASH_FUNCTION_NAMES.get(hashalg)\n        if not alg:\n            raise ValueError(f\"Unsupported hash alg {hashalg}\")\n\n        t = {\"kty\": self.get(\"kty\")}\n        for name, param in self.PARAMS.items():\n            if param.is_required and not param.is_private:\n                t[name] = self.get(name)\n\n        return (\n            BinaPy.serialize_to(\"json\", t, separators=(\",\", \":\"), sort_keys=True)\n            .to(alg)\n            .to(\"b64u\")\n            .ascii()\n        )\n\n    def thumbprint_uri(self, hashalg: str = \"sha-256\") -&gt; str:\n\"\"\"Return the JWK thumbprint URI for this key.\n\n        Args:\n            hashalg: the IANA registered name for the hash alg to use\n\n        Returns:\n             the JWK thumbprint uri for this Jwk\n\n        \"\"\"\n        return (\n            f\"urn:ietf:params:oauth:jwk-thumbprint:{hashalg}:{self.thumbprint(hashalg)}\"\n        )\n\n    def check(\n        self,\n        *,\n        is_private: bool | None = None,\n        is_symmetric: bool | None = None,\n        kty: str | None = None,\n    ) -&gt; Jwk:\n\"\"\"Check this key for type, privateness and/or symmetricness.\n\n        This raises a `ValueError` if the key is not as expected.\n\n        Args:\n            is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing\n            is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing\n            kty: the expected key type, if any\n\n        Returns:\n            this key, if all checks passed\n\n        Raises:\n            ValueError: if any check fails\n\n        \"\"\"\n        if is_private is not None:\n            if is_private is True and self.is_private is False:\n                raise ValueError(\"This key is public while a private key is expected.\")\n            elif is_private is False and self.is_private is True:\n                raise ValueError(\"This key is private while a public key is expected.\")\n\n        if is_symmetric is not None:\n            if is_symmetric is True and self.is_symmetric is False:\n                raise ValueError(\n                    \"This key is asymmetric while a symmetric key is expected.\"\n                )\n            if is_symmetric is False and self.is_symmetric is True:\n                raise ValueError(\n                    \"This key is symmetric while an asymmetric key is expected.\"\n                )\n\n        if kty is not None:\n            if self.kty != kty:\n                raise ValueError(\n                    f\"This key has kty={self.kty} while a kty={kty} is expected.\"\n                )\n\n        return self\n\n    def _validate(self) -&gt; None:\n\"\"\"Validate the content of this JWK.\n\n        It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`.\n\n        Raises:\n            TypeError: if the key type doesn't match the subclass\n            InvalidJwk: if the JWK misses required members or has invalid members\n\n        \"\"\"\n        if self.get(\"kty\") != self.KTY:\n            raise TypeError(\n                f\"This key 'kty' {self.get('kty')} doesn't match this Jwk subclass intended 'kty' {self.KTY}!\"\n            )\n\n        jwk_is_private = False\n        for name, param in self.PARAMS.items():\n            value = self.get(name)\n\n            if param.is_private and value is not None:\n                jwk_is_private = True\n\n            if not param.is_private and param.is_required and value is None:\n                raise InvalidJwk(\n                    f\"Missing required public param {param.description} ({name})\"\n                )\n\n            if value is None:\n                pass\n            elif param.kind == \"b64u\":\n                if not isinstance(value, str):\n                    raise InvalidJwk(\n                        f\"Parameter {param.description} ({name}) must be a string with a Base64URL-encoded value\"\n                    )\n                if not BinaPy(value).check(\"b64u\"):\n                    raise InvalidJwk(\n                        f\"Parameter {param.description} ({name}) must be a Base64URL-encoded value\"\n                    )\n            elif param.kind == \"unsupported\":\n                if value is not None:  # pragma: no cover\n                    raise InvalidJwk(f\"Unsupported JWK param '{name}'\")\n            elif param.kind == \"name\":\n                pass\n            else:\n                assert (\n                    False\n                ), f\"Unsupported param '{name}' type '{param.kind}'\"  # pragma: no cover\n\n        # if at least one of the supplied parameter was private, then all required private parameters must be provided\n        if jwk_is_private:\n            for name, param in self.PARAMS.items():\n                value = self.get(name)\n                if param.is_private and param.is_required and value is None:\n                    raise InvalidJwk(\n                        f\"Missing required private param {param.description} ({name})\"\n                    )\n\n        # if key is used for signing, it must be private\n        for op in self.get(\"key_ops\", []):\n            if op in (\"sign\", \"unwrapKey\") and not self.is_private:\n                raise InvalidJwk(f\"Key Operation is '{op}' but the key is public\")\n\n    def signature_class(self, alg: str | None = None) -&gt; type[BaseSignatureAlg]:\n\"\"\"Return the appropriate signature algorithm class to use with this key.\n\n        The returned class is a `BaseSignatureAlg` subclass.\n\n        If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n        Args:\n            alg: the algorithm identifier, if not already present in this Jwk\n\n        Returns:\n            the appropriate `BaseSignatureAlg` subclass\n\n        \"\"\"\n        return select_alg_class(self.SIGNATURE_ALGORITHMS, jwk_alg=self.alg, alg=alg)\n\n    def encryption_class(self, alg: str | None = None) -&gt; type[BaseAESEncryptionAlg]:\n\"\"\"Return the appropriate encryption algorithm class to use with this key.\n\n        The returned class is a subclass of `BaseAESEncryptionAlg`.\n\n        If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n        Args:\n            alg: the algorithm identifier, if not already present in this Jwk\n\n        Returns:\n            the appropriate `BaseAESEncryptionAlg` subclass\n\n        \"\"\"\n        return select_alg_class(self.ENCRYPTION_ALGORITHMS, jwk_alg=self.alg, alg=alg)\n\n    def key_management_class(\n        self, alg: str | None = None\n    ) -&gt; type[BaseKeyManagementAlg]:\n\"\"\"Return the appropriate key management algorithm class to use with this key.\n\n        If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n        Args:\n            alg: the algorithm identifier, if not already present in this Jwk\n\n        Returns:\n            the appropriate `BaseKeyManagementAlg` subclass\n\n        \"\"\"\n        return select_alg_class(\n            self.KEY_MANAGEMENT_ALGORITHMS, jwk_alg=self.alg, alg=alg\n        )\n\n    def signature_wrapper(self, alg: str | None = None) -&gt; BaseSignatureAlg:\n\"\"\"Initialize a  key management wrapper with this key.\n\n        This returns an instance of a `BaseSignatureAlg` subclass.\n\n        If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n        Args:\n            alg: the algorithm identifier, if not already present in this Jwk\n\n        Returns:\n            a `BaseSignatureAlg` instance initialized with the current key\n\n        \"\"\"\n        alg_class = self.signature_class(alg)\n        if issubclass(alg_class, BaseSymmetricAlg):\n            return alg_class(self.key)\n        elif issubclass(alg_class, BaseAsymmetricAlg):\n            return alg_class(self.cryptography_key)\n        raise UnsupportedAlg(alg)  # pragma: no cover\n\n    def encryption_wrapper(self, alg: str | None = None) -&gt; BaseAESEncryptionAlg:\n\"\"\"Initialize an encryption wrapper with this key.\n\n        This returns an instance of a `BaseAESEncryptionAlg` subclass.\n\n        If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n        Args:\n            alg: the algorithm identifier, if not already present in this Jwk\n\n        Returns:\n            a `BaseAESEncryptionAlg` instance initialized with the current key\n\n        \"\"\"\n        alg_class = self.encryption_class(alg)\n        if issubclass(alg_class, BaseSymmetricAlg):\n            return alg_class(self.key)\n        elif issubclass(alg_class, BaseAsymmetricAlg):  # pragma: no cover\n            return alg_class(self.cryptography_key)  # pragma: no cover\n        raise UnsupportedAlg(alg)  # pragma: no cover\n\n    def key_management_wrapper(self, alg: str | None = None) -&gt; BaseKeyManagementAlg:\n\"\"\"Initialize a key management wrapper with this key.\n\n        This returns an instance of a `BaseKeyManagementAlg` subclass.\n\n        If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n        Args:\n            alg: the algorithm identifier, if not already present in this Jwk\n\n        Returns:\n            a `BaseKeyManagementAlg` instance initialized with the current key\n\n        \"\"\"\n        alg_class = self.key_management_class(alg)\n        if issubclass(alg_class, BaseSymmetricAlg):\n            return alg_class(self.key)\n        elif issubclass(alg_class, BaseAsymmetricAlg):\n            return alg_class(self.cryptography_key)\n        raise UnsupportedAlg(alg)  # pragma: no cover\n\n    def supported_signing_algorithms(self) -&gt; list[str]:\n\"\"\"Return the list of Signature algorithms that can be used with this key.\n\n        Returns:\n          a list of supported algs\n\n        \"\"\"\n        return list(self.SIGNATURE_ALGORITHMS)\n\n    def supported_key_management_algorithms(self) -&gt; list[str]:\n\"\"\"Return the list of Key Management algorithms that can be used with this key.\n\n        Returns:\n            a list of supported algs\n\n        \"\"\"\n        return list(self.KEY_MANAGEMENT_ALGORITHMS)\n\n    def supported_encryption_algorithms(self) -&gt; list[str]:\n\"\"\"Return the list of Encryption algorithms that can be used with this key.\n\n        Returns:\n            a list of supported algs\n\n        \"\"\"\n        return list(self.ENCRYPTION_ALGORITHMS)\n\n    def sign(self, data: bytes | SupportsBytes, alg: str | None = None) -&gt; BinaPy:\n\"\"\"Sign a data using this Jwk, and return the generated signature.\n\n        Args:\n          data: the data to sign\n          alg: the alg to use (if this key doesn't have an `alg` parameter)\n\n        Returns:\n          the generated signature\n\n        \"\"\"\n        wrapper = self.signature_wrapper(alg)\n        signature = wrapper.sign(data)\n        return BinaPy(signature)\n\n    def verify(\n        self,\n        data: bytes | SupportsBytes,\n        signature: bytes | SupportsBytes,\n        *,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; bool:\n\"\"\"Verify a signature using this `Jwk`, and return `True` if valid.\n\n        Args:\n          data: the data to verify\n          signature: the signature to verify\n          alg: the allowed signature alg, if there is only one\n          algs: the allowed signature algs, if there are several\n\n        Returns:\n          `True` if the signature matches, `False` otherwise\n\n        \"\"\"\n        if not self.is_symmetric and self.is_private:\n            warnings.warn(\n                \"You are trying to validate a signature with a private key. \"\n                \"Signatures should always be verified with a public key.\"\n            )\n            public_jwk = self.public_jwk()\n        else:\n            public_jwk = self\n        if algs is None and alg:\n            algs = [alg]\n        for alg in algs or (None,):\n            wrapper = public_jwk.signature_wrapper(alg)\n            if wrapper.verify(data, signature):\n                return True\n\n        return False\n\n    def encrypt(\n        self,\n        plaintext: bytes | SupportsBytes,\n        *,\n        aad: bytes | None = None,\n        alg: str | None = None,\n        iv: bytes | None = None,\n    ) -&gt; tuple[BinaPy, BinaPy, BinaPy]:\n\"\"\"Encrypt a plaintext with Authenticated Encryption using this key.\n\n        Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data (`aad`).\n        This returns a tuple with 3 raw data, in order:\n        - the encrypted Data\n        - the Initialization Vector that was used to encrypt data\n        - the generated Authentication Tag\n\n        Args:\n          plaintext: the data to encrypt.\n          aad: the Additional Authenticated Data (AAD) to include in the authentication tag\n          alg: the alg to use to encrypt the data\n          iv: the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same.\n\n        Returns:\n          a tuple (ciphertext, iv, authentication_tag), as raw data\n\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    def decrypt(\n        self,\n        ciphertext: bytes | SupportsBytes,\n        *,\n        iv: bytes | SupportsBytes,\n        tag: bytes | SupportsBytes,\n        aad: bytes | SupportsBytes | None = None,\n        alg: str | None = None,\n    ) -&gt; BinaPy:\n\"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result.\n\n        This is implemented by subclasses.\n\n        Args:\n          ciphertext: the data to decrypt\n          iv: the Initialization Vector (IV) that was used for encryption\n          tag: the Authentication Tag that will be verified while decrypting data\n          aad: the Additional Authentication Data (AAD) to verify the Tag against\n          alg: the alg to use for decryption\n\n        Returns:\n          the clear-text data\n\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    def sender_key(\n        self,\n        enc: str,\n        *,\n        alg: str | None = None,\n        cek: bytes | None = None,\n        epk: Jwk | None = None,\n        **headers: Any,\n    ) -&gt; tuple[Jwk, BinaPy, Mapping[str, Any]]:\n\"\"\"Produce a Content Encryption Key, to use for encryption.\n\n        This method is meant to be used by encrypted token senders. Recipients should use the matching method `Jwk.recipient_key()`.\n\n        Returns a tuple with 3 items:\n\n        - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone!\n        - the encrypted CEK, as bytes. You must send this to your recipient. This may be `None` for Key Management algs which derive a CEK instead of generating one.\n        - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well.\n\n        For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead\n        of letting `jwskate` generate a safe, unique random value for you.\n        Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself,\n        instead of letting `jwskate` generate an appropriate value for you.\n        Only do this if you know what you are doing!\n\n        Args:\n          enc: the encryption algorithm to use with the CEK\n          alg: the Key Management algorithm to use to produce the CEK\n          cek: CEK to use (leave `None` to have an adequate random value generated automatically)\n          epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically)\n          **headers: additional headers to include for the CEK derivation\n\n        Returns:\n          a tuple (cek, wrapped_cek, additional_headers_map)\n\n        Raises:\n            UnsupportedAlg: if the requested alg identifier is not supported\n\n        \"\"\"\n        from jwskate import SymmetricJwk\n\n        if not self.is_symmetric and self.is_private:\n            warnings.warn(\n                \"You are using a private key for sender key wrapping. Key wrapping should always be done using the recipient public key.\"\n            )\n            key_alg_wrapper = self.public_jwk().key_management_wrapper(alg)\n        else:\n            key_alg_wrapper = self.key_management_wrapper(alg)\n\n        enc_alg_class = select_alg_class(SymmetricJwk.ENCRYPTION_ALGORITHMS, alg=enc)\n\n        cek_headers: dict[str, Any] = {}\n\n        if isinstance(key_alg_wrapper, BaseRsaKeyWrap):\n            if cek:\n                enc_alg_class.check_key(cek)\n            else:\n                cek = enc_alg_class.generate_key()\n            assert cek\n            wrapped_cek = key_alg_wrapper.wrap_key(cek)\n\n        elif isinstance(key_alg_wrapper, EcdhEs):\n            epk = epk or Jwk.from_cryptography_key(\n                key_alg_wrapper.generate_ephemeral_key()\n            )\n            cek_headers = {\"epk\": epk.public_jwk()}\n            if isinstance(key_alg_wrapper, BaseEcdhEs_AesKw):\n                if cek:\n                    enc_alg_class.check_key(cek)\n                else:\n                    cek = enc_alg_class.generate_key()\n                assert cek\n                wrapped_cek = key_alg_wrapper.wrap_key_with_epk(\n                    cek, epk.cryptography_key, alg=key_alg_wrapper.name, **headers\n                )\n            else:\n                cek = key_alg_wrapper.sender_key(\n                    epk.cryptography_key,\n                    alg=enc_alg_class.name,\n                    key_size=enc_alg_class.key_size,\n                    **headers,\n                )\n                wrapped_cek = BinaPy(b\"\")\n\n        elif isinstance(key_alg_wrapper, BaseAesKeyWrap):\n            if cek:\n                enc_alg_class.check_key(cek)\n            else:\n                cek = enc_alg_class.generate_key()\n            assert cek\n            wrapped_cek = key_alg_wrapper.wrap_key(cek)\n\n        elif isinstance(key_alg_wrapper, BaseAesGcmKeyWrap):\n            if cek:\n                enc_alg_class.check_key(cek)\n            else:\n                cek = enc_alg_class.generate_key()\n            assert cek\n            iv = key_alg_wrapper.generate_iv()\n            wrapped_cek, tag = key_alg_wrapper.wrap_key(cek, iv=iv)\n            cek_headers = {\n                \"iv\": iv.to(\"b64u\").ascii(),\n                \"tag\": tag.to(\"b64u\").ascii(),\n            }\n\n        elif isinstance(key_alg_wrapper, DirectKeyUse):\n            cek = key_alg_wrapper.direct_key(enc_alg_class)\n            wrapped_cek = BinaPy(b\"\")\n        else:\n            raise UnsupportedAlg(\n                f\"Unsupported Key Management Alg {key_alg_wrapper}\"\n            )  # pragma: no cover\n\n        return SymmetricJwk.from_bytes(cek), wrapped_cek, cek_headers\n\n    def recipient_key(\n        self,\n        wrapped_cek: bytes | SupportsBytes,\n        enc: str,\n        *,\n        alg: str | None = None,\n        **headers: Any,\n    ) -&gt; Jwk:\n\"\"\"Produce a Content Encryption Key, to use for decryption.\n\n        This method is meant to be used by encrypted token recipient. Senders should use the matching method `Jwk.sender_key()`.\n\n        Args:\n          wrapped_cek: the wrapped CEK\n          enc: the encryption algorithm to use with the CEK\n          alg: the Key Management algorithm to use to unwrap the CEK\n          **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs)\n\n        Returns:\n          the clear-text CEK, as a SymmetricJwk instance\n\n        Raises:\n            UnsupportedAlg: if the requested alg identifier is not supported\n\n        \"\"\"\n        from jwskate import SymmetricJwk\n\n        if not self.is_symmetric and not self.is_private:\n            raise ValueError(\n                \"You are using a public key for recipient key unwrapping. Key unwrapping must always be done using the recipient private key.\"\n            )\n\n        key_alg_wrapper = self.key_management_wrapper(alg)\n        enc_alg_class = select_alg_class(SymmetricJwk.ENCRYPTION_ALGORITHMS, alg=enc)\n\n        if isinstance(key_alg_wrapper, BaseRsaKeyWrap):\n            cek = key_alg_wrapper.unwrap_key(wrapped_cek)\n\n        elif isinstance(key_alg_wrapper, EcdhEs):\n            epk = headers.get(\"epk\")\n            if epk is None:\n                raise ValueError(\"No EPK in the headers!\")\n            epk_jwk = Jwk(epk)\n            if epk_jwk.is_private:\n                raise ValueError(\"The EPK present in the header is private.\")\n            epk = epk_jwk.cryptography_key\n            if isinstance(key_alg_wrapper, BaseEcdhEs_AesKw):\n                cek = key_alg_wrapper.unwrap_key_with_epk(\n                    wrapped_cek, epk, alg=key_alg_wrapper.name\n                )\n            else:\n                cek = key_alg_wrapper.recipient_key(\n                    epk,\n                    alg=enc_alg_class.name,\n                    key_size=enc_alg_class.key_size,\n                    **headers,\n                )\n\n        elif isinstance(key_alg_wrapper, BaseAesKeyWrap):\n            cek = key_alg_wrapper.unwrap_key(wrapped_cek)\n\n        elif isinstance(key_alg_wrapper, BaseAesGcmKeyWrap):\n            iv = headers.get(\"iv\")\n            if iv is None:\n                raise ValueError(\"No 'iv' in headers!\")\n            iv = BinaPy(iv).decode_from(\"b64u\")\n            tag = headers.get(\"tag\")\n            if tag is None:\n                raise ValueError(\"No 'tag' in headers!\")\n            tag = BinaPy(tag).decode_from(\"b64u\")\n            cek = key_alg_wrapper.unwrap_key(wrapped_cek, tag=tag, iv=iv)\n\n        elif isinstance(key_alg_wrapper, DirectKeyUse):\n            cek = key_alg_wrapper.direct_key(enc_alg_class)\n\n        else:\n            raise UnsupportedAlg(\n                f\"Unsupported Key Management Alg {key_alg_wrapper}\"\n            )  # pragma: no cover\n\n        return SymmetricJwk.from_bytes(cek)\n\n    def public_jwk(self) -&gt; Jwk:\n\"\"\"Return the public Jwk associated with this key.\n\n        Returns:\n          a Jwk with the public key\n\n        \"\"\"\n        if not self.is_private:\n            return self\n\n        params = {\n            name: self.get(name)\n            for name, param in self.PARAMS.items()\n            if not param.is_private\n        }\n\n        if \"key_ops\" in self:\n            key_ops = list(self.key_ops)\n            if \"sign\" in key_ops:\n                key_ops.remove(\"sign\")\n                key_ops.append(\"verify\")\n            if \"unwrapKey\" in key_ops:\n                key_ops.remove(\"unwrapKey\")\n                key_ops.append(\"wrapKey\")\n        else:\n            key_ops = None\n\n        return Jwk(\n            dict(\n                kty=self.kty,\n                kid=self.get(\"kid\"),\n                alg=self.get(\"alg\"),\n                use=self.get(\"use\"),\n                key_ops=key_ops,\n                **params,\n            )\n        )\n\n    def as_jwks(self) -&gt; JwkSet:\n\"\"\"Return a JwkSet with this key as single element.\n\n        Returns:\n            a JwsSet with this single key\n\n        \"\"\"\n        from .jwks import JwkSet\n\n        return JwkSet(keys=(self,))\n\n    @classmethod\n    def from_cryptography_key(cls, cryptography_key: Any, **kwargs: Any) -&gt; Jwk:\n\"\"\"Initialize a Jwk from a key from the `cryptography` library.\n\n        The input key can be any private or public key supported by cryptography.\n\n        Args:\n          cryptography_key: a `cryptography` key instance\n          **kwargs: additional members to include in the Jwk (e.g. kid, use)\n\n        Returns:\n            the matching `Jwk` instance\n\n        Raises:\n            TypeError: if the key type is not supported\n\n        \"\"\"\n        for cryptography_class, jwk_class in cls.cryptography_key_types.items():\n            if isinstance(cryptography_key, cryptography_class):\n                return jwk_class.from_cryptography_key(cryptography_key, **kwargs)\n\n        raise TypeError(\n            f\"Unsupported Jwk class for this Key Type: {type(cryptography_key).__name__}\"\n        )\n\n    def _to_cryptography_key(self) -&gt; Any:\n\"\"\"Return a key from the `cryptography` library that matches this Jwk.\n\n        This is implemented by subclasses.\n\n        Returns:\n            a `cryptography`key instance initialized from the current key\n\n        \"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def from_pem(\n        cls,\n        der: bytes | str,\n        password: bytes | str | None = None,\n        **kwargs: Any,\n    ) -&gt; Jwk:\n\"\"\"Load a `Jwk` from a PEM encoded private or public key.\n\n        Args:\n          der: the PEM encoded data to load\n          password: the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8.\n          **kwargs: additional members to include in the `Jwk` (e.g. `kid`, `use`)\n\n        Returns:\n            a `Jwk` instance from the loaded key\n\n        \"\"\"\n        der = der.encode() if isinstance(der, str) else der\n        password = password.encode(\"UTF-8\") if isinstance(password, str) else password\n\n        try:\n            cryptography_key = serialization.load_pem_private_key(der, password)\n        except Exception as private_exc:\n            try:\n                cryptography_key = serialization.load_pem_public_key(der)\n\n            except Exception:\n                raise ValueError(\n                    \"The provided data is not a private or a public PEM encoded key.\"\n                ) from private_exc\n            if password is not None:\n                raise ValueError(\n                    \"A public key was loaded from PEM, while a password was provided for decryption.\"\n                    \"Only private keys are encrypted using a password.\"\n                )\n\n        return cls.from_cryptography_key(cryptography_key, **kwargs)\n\n    def to_pem(self, password: bytes | str | None = None) -&gt; str:\n\"\"\"Serialize this key to PEM format.\n\n        For private keys, you can provide a password for encryption. This password should be `bytes`. A `str` is also\n        accepted, and will be encoded to `bytes` using UTF-8 before it is used as encryption key.\n\n        Args:\n          password: password to use to encrypt the PEM.\n\n        Returns:\n            the PEM serialized key\n\n        \"\"\"\n        password = password.encode(\"UTF-8\") if isinstance(password, str) else password\n\n        if self.is_private:\n            encryption: serialization.KeySerializationEncryption\n            if password:\n                encryption = serialization.BestAvailableEncryption(password)\n            else:\n                encryption = serialization.NoEncryption()\n            return self.cryptography_key.private_bytes(  # type: ignore[no-any-return]\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                encryption,\n            ).decode()\n        else:\n            if password:\n                raise ValueError(\"Public keys cannot be encrypted when serialized.\")\n            return self.cryptography_key.public_bytes(  # type: ignore[no-any-return]\n                serialization.Encoding.PEM,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            ).decode()\n\n    @classmethod\n    def from_der(\n        cls,\n        der: bytes,\n        password: bytes | str | None = None,\n        **kwargs: Any,\n    ) -&gt; Jwk:\n\"\"\"Load a `Jwk` from DER.\"\"\"\n        password = password.encode(\"UTF-8\") if isinstance(password, str) else password\n\n        try:\n            cryptography_key = serialization.load_der_private_key(der, password)\n        except Exception as private_exc:\n            try:\n                cryptography_key = serialization.load_der_public_key(der)\n            except Exception:\n                raise ValueError(\n                    \"The provided data is not a private or a public DER encoded key.\"\n                ) from private_exc\n            if password is not None:\n                raise ValueError(\n                    \"A public key was loaded from DER, while a password was provided for decryption.\"\n                    \"Only private keys are encrypted using a password.\"\n                )\n\n        return cls.from_cryptography_key(cryptography_key, **kwargs)\n\n    def to_der(self, password: bytes | str | None = None) -&gt; BinaPy:\n\"\"\"Serialize this key to DER.\n\n        For private keys, you can provide a password for encryption. This password should be bytes. A `str` is also\n        accepted, and will be encoded to `bytes` using UTF-8 before it is used as encryption key.\n\n        Args:\n          password: password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded to bytes with UTF-8.\n\n        Returns:\n            the DER serialized key\n\n        \"\"\"\n        password = password.encode(\"UTF-8\") if isinstance(password, str) else password\n\n        if self.is_private:\n            encryption: serialization.KeySerializationEncryption\n            if password:\n                encryption = serialization.BestAvailableEncryption(password)\n            else:\n                encryption = serialization.NoEncryption()\n            return BinaPy(\n                self.cryptography_key.private_bytes(\n                    serialization.Encoding.DER,\n                    serialization.PrivateFormat.PKCS8,\n                    encryption,\n                )\n            )\n        else:\n            if password:\n                raise ValueError(\"Public keys cannot be encrypted when serialized.\")\n            return BinaPy(\n                self.cryptography_key.public_bytes(\n                    serialization.Encoding.DER,\n                    serialization.PublicFormat.SubjectPublicKeyInfo,\n                )\n            )\n\n    @classmethod\n    def generate(\n        cls, *, alg: str | None = None, kty: str | None = None, **kwargs: Any\n    ) -&gt; Jwk:\n\"\"\"Generate a Private Key and return it as a `Jwk` instance.\n\n        This method is implemented by subclasses for specific Key Types and returns an instance of that subclass.\n\n        Args:\n            alg: intended algorithm to use with the generated key\n            kty: key type identifier\n            **kwargs: specific parameters depending on the type of key, or additional members to include in the `Jwk`\n\n        Returns:\n            a `Jwk` instance with a generated key\n\n        \"\"\"\n        if alg:\n            key = cls.generate_for_alg(alg=alg, **kwargs)\n            if kty is not None and key.kty != kty:\n                raise ValueError(\n                    f\"Incompatible `{alg=}` and `{kty=}` parameters. \"\n                    f\"`{alg=}` points to `kty='{key.kty}'`.\"\n                )\n            return key\n        if kty:\n            return cls.generate_for_kty(kty=kty, **kwargs)\n        raise ValueError(\n            \"You must provide a hint for jwskate to know what kind of key it must generate. \"\n            \"You can either provide an 'alg' identifier as keyword parameter, and/or a 'kty'.\"\n        )\n\n    def copy(self) -&gt; Jwk:\n\"\"\"Create a copy of this key.\n\n        Returns:\n            a copy of this key, with the same value\n\n        \"\"\"\n        return Jwk(super().copy())\n\n    def with_kid_thumbprint(self, force: bool = False) -&gt; Jwk:\n\"\"\"Includes the JWK thumbprint as \"kid\".\n\n        If key already has a \"kid\":\n        - if `force` is `True`, this erases the previous \"kid\".\n        - if `force` is `False` (default), do nothing.\n\n        Args:\n            force: whether to overwrite a previously existing kid\n\n        Returns:\n            a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`).\n\n        \"\"\"\n        if self.get(\"kid\") is not None and not force:\n            return self\n        jwk = self.copy()\n        jwk[\"kid\"] = self.thumbprint()\n        return jwk\n\n    def with_usage_parameters(\n        self,\n        alg: str | None = None,\n        with_alg: bool = True,\n        with_use: bool = True,\n        with_key_ops: bool = True,\n    ) -&gt; Jwk:\n\"\"\"Copy this Jwk and add the `use` and `key_ops` parameters.\n\n        The returned jwk `alg` parameter will be the one passed as parameter to this method, or as dfault the one declared as `alg` parameter in this Jwk.\n        The `use` (Public Key Use) param is deduced based on this `alg` value.\n        The `key_ops` (Key Operations) param is deduced based on the key `use` and if the key is public, private,\n        or symmetric.\n\n        Args:\n            alg: the alg to use, if not present in this Jwk\n            with_alg: whether to include an `alg` parameter\n            with_use: whether to include a `use` parameter\n            with_key_ops: whether to include a `key_ops` parameter\n\n        Returns:\n            a Jwk with the same key, with `alg`, `use` and `key_ops` parameters.\n\n        \"\"\"\n        alg = alg or self.alg\n\n        if not alg:\n            raise ExpectedAlgRequired(\n                \"An algorithm is required to set the usage parameters\"\n            )\n\n        self._get_alg_class(alg)  # raises an exception if alg is not supported\n\n        jwk = self.copy()\n        if with_alg:\n            jwk[\"alg\"] = alg\n        if with_use:\n            jwk[\"use\"] = jwk.use\n        if with_key_ops:\n            jwk[\"key_ops\"] = jwk.key_ops\n\n        return jwk\n\n    def minimize(self) -&gt; Jwk:\n\"\"\"Strip out any optional or non-standard parameter from that key.\n\n        This will remove `alg`, `use`, `key_ops`, optional parameters from RSA keys, and other\n        unknown parameters.\n\n        \"\"\"\n        jwk = self.copy()\n        for key in self.keys():\n            if key == \"kty\" or key in self.PARAMS and self.PARAMS[key].is_required:\n                continue\n            del jwk[key]\n\n        return jwk\n\n    def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Compare JWK keys, ignoring optional/informational fields.\"\"\"\n        other = to_jwk(other)\n        return super(Jwk, self.minimize()).__eq__(other.minimize())\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.subclasses","title":"subclasses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subclasses: dict[str, type[Jwk]] = {}\n</code></pre> <p>A dict of 'kty' values to <code>Jwk</code> subclasses implementing each specific Key Type.</p>"},{"location":"api/#jwskate.jwk.base.Jwk.cryptography_key_types","title":"cryptography_key_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cryptography_key_types: dict[Any, type[Jwk]] = {}\n</code></pre> <p>A dict of cryptography classes to equivalent <code>Jwk</code> subclasses.</p>"},{"location":"api/#jwskate.jwk.base.Jwk.is_private","title":"is_private  <code>property</code>","text":"<pre><code>is_private: bool\n</code></pre> <p>Return <code>True</code> if the key is private, <code>False</code> otherwise.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the key is private, <code>False</code> otherwise</p>"},{"location":"api/#jwskate.jwk.base.Jwk.is_symmetric","title":"is_symmetric  <code>property</code>","text":"<pre><code>is_symmetric: bool\n</code></pre> <p>Return <code>True</code> if the key is symmetric, <code>False</code> otherwise.</p>"},{"location":"api/#jwskate.jwk.base.Jwk.kty","title":"kty  <code>property</code>","text":"<pre><code>kty: str\n</code></pre> <p>Return the Key Type.</p> <p>Returns:</p> Type Description <code>str</code> <p>the key type</p>"},{"location":"api/#jwskate.jwk.base.Jwk.alg","title":"alg  <code>property</code>","text":"<pre><code>alg: str | None\n</code></pre> <p>Return the configured key alg, if any.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>the key alg</p>"},{"location":"api/#jwskate.jwk.base.Jwk.kid","title":"kid  <code>property</code>","text":"<pre><code>kid: str | None\n</code></pre> <p>Return the JWK key ID (kid), if present.</p>"},{"location":"api/#jwskate.jwk.base.Jwk.use","title":"use  <code>property</code>","text":"<pre><code>use: str | None\n</code></pre> <p>Return the key use.</p> <p>If no <code>alg</code> parameter is present, this returns the <code>use</code> parameter from this JWK. If an <code>alg</code> parameter is present, the use is deduced from this alg. To check for the presence of the <code>use</code> parameter, use <code>jwk.get('use')</code>.</p>"},{"location":"api/#jwskate.jwk.base.Jwk.key_ops","title":"key_ops  <code>property</code>","text":"<pre><code>key_ops: tuple[str, ...]\n</code></pre> <p>Return the key operations.</p> <p>If no <code>alg</code> parameter is present, this returns the <code>key_ops</code> parameter from this JWK. If an <code>alg</code> parameter is present, the key operations are deduced from this alg. To check for the presence of the <code>key_ops</code> parameter, use <code>jwk.get('key_ops')</code>.</p>"},{"location":"api/#jwskate.jwk.base.Jwk.generate_for_alg","title":"generate_for_alg  <code>classmethod</code>","text":"<pre><code>generate_for_alg(alg: str, **kwargs: Any) -&gt; Jwk\n</code></pre> <p>Generate a key for usage with a specific <code>alg</code> and return the resulting <code>Jwk</code>.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str</code> <p>a signature or key management algorithm identifier</p> required <code>**kwargs</code> <code>Any</code> <p>specific parameters, depending on the key type, or additional members to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>the generated <code>Jwk</code></p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>@classmethod\ndef generate_for_alg(cls, alg: str, **kwargs: Any) -&gt; Jwk:\n\"\"\"Generate a key for usage with a specific `alg` and return the resulting `Jwk`.\n\n    Args:\n        alg: a signature or key management algorithm identifier\n        **kwargs: specific parameters, depending on the key type, or additional members to include in the `Jwk`\n\n    Returns:\n        the generated `Jwk`\n\n    \"\"\"\n    for kty, jwk_class in cls.subclasses.items():\n        try:\n            jwk_class._get_alg_class(alg)\n            return jwk_class.generate(alg=alg, **kwargs)\n        except UnsupportedAlg:\n            continue\n\n    raise UnsupportedAlg(alg)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.generate_for_kty","title":"generate_for_kty  <code>classmethod</code>","text":"<pre><code>generate_for_kty(kty: str, **kwargs: Any) -&gt; Jwk\n</code></pre> <p>Generate a key with a specific type and return the resulting <code>Jwk</code>.</p> <p>Parameters:</p> Name Type Description Default <code>kty</code> <code>str</code> <p>key type to generate</p> required <code>**kwargs</code> <code>Any</code> <p>specific parameters depending on the key type, or additional members to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>the resulting <code>Jwk</code></p> <p>Raises:</p> Type Description <code>UnsupportedKeyType</code> <p>if the specified key type (<code>kty</code>) is not supported</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>@classmethod\ndef generate_for_kty(cls, kty: str, **kwargs: Any) -&gt; Jwk:\n\"\"\"Generate a key with a specific type and return the resulting `Jwk`.\n\n    Args:\n      kty: key type to generate\n      **kwargs: specific parameters depending on the key type, or additional members to include in the `Jwk`\n\n    Returns:\n        the resulting `Jwk`\n\n    Raises:\n        UnsupportedKeyType: if the specified key type (`kty`) is not supported\n\n    \"\"\"\n    jwk_class = cls.subclasses.get(kty)\n    if jwk_class is None:\n        raise UnsupportedKeyType(\"Unsupported Key Type:\", kty)\n    return jwk_class.generate(**kwargs)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__() -&gt; None\n</code></pre> <p>Automatically add subclasses to the registry.</p> <p>This allows <code>__new__</code> to pick the appropriate subclass when creating a Jwk.</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n\"\"\"Automatically add subclasses to the registry.\n\n    This allows `__new__` to pick the appropriate subclass when creating a Jwk.\n\n    \"\"\"\n    Jwk.subclasses[cls.KTY] = cls\n    for klass in cls.CRYPTOGRAPHY_PRIVATE_KEY_CLASSES:\n        Jwk.cryptography_key_types[klass] = cls\n    for klass in cls.CRYPTOGRAPHY_PUBLIC_KEY_CLASSES:\n        Jwk.cryptography_key_types[klass] = cls\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.__new__","title":"__new__","text":"<pre><code>__new__(\n    key: Jwk | dict[str, Any] | Any, **kwargs: Any\n) -&gt; Jwk\n</code></pre> <p>Overridden <code>__new__</code> to make the Jwk constructor smarter.</p> The Jwk constructor will accept <ul> <li>a <code>dict</code> with the parsed Jwk content</li> <li>another Jwk, which will be used as-is instead of creating a copy</li> <li>an instance from a <code>cryptography</code> public or private key class</li> </ul> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>a dict containing JWK parameters, or another Jwk instance, or a <code>cryptography</code> key</p> required <code>**kwargs</code> <code>Any</code> <p>additional members to include in the Jwk</p> <code>{}</code> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def __new__(cls, key: Jwk | dict[str, Any] | Any, **kwargs: Any) -&gt; Jwk:\n\"\"\"Overridden `__new__` to make the Jwk constructor smarter.\n\n    The Jwk constructor will accept:\n\n        - a `dict` with the parsed Jwk content\n        - another Jwk, which will be used as-is instead of creating a copy\n        - an instance from a `cryptography` public or private key class\n\n    Args:\n        key: a dict containing JWK parameters, or another Jwk instance, or a `cryptography` key\n        **kwargs: additional members to include in the Jwk\n\n    \"\"\"\n    if cls == Jwk:\n        if isinstance(key, Jwk):\n            return cls.from_cryptography_key(key.cryptography_key, **kwargs)\n        if isinstance(key, dict):\n            kty: str | None = key.get(\"kty\")\n            if kty is None:\n                raise InvalidJwk(\"A Json Web Key must have a Key Type (kty)\")\n\n            subclass = Jwk.subclasses.get(kty)\n            if subclass is None:\n                raise InvalidJwk(\"Unsupported Key Type\", kty)\n            return super().__new__(subclass)  # type: ignore[type-var]\n        elif isinstance(key, str):\n            return cls.from_json(key)\n        else:\n            return cls.from_cryptography_key(key, **kwargs)\n    return super().__new__(cls, key, **kwargs)  # type: ignore[type-var]\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk._get_alg_class","title":"_get_alg_class  <code>classmethod</code>","text":"<pre><code>_get_alg_class(alg: str) -&gt; type[BaseAlg]\n</code></pre> <p>Given an alg identifier, return the matching JWA wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str</code> <p>an alg identifier</p> required <p>Returns:</p> Type Description <code>type[BaseAlg]</code> <p>the matching JWA wrapper</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>@classmethod\ndef _get_alg_class(cls, alg: str) -&gt; type[BaseAlg]:\n\"\"\"Given an alg identifier, return the matching JWA wrapper.\n\n    Args:\n        alg: an alg identifier\n\n    Returns:\n        the matching JWA wrapper\n\n    \"\"\"\n    alg_class: type[BaseAlg] | None\n\n    alg_class = cls.SIGNATURE_ALGORITHMS.get(alg)\n    if alg_class is not None:\n        return alg_class\n\n    alg_class = cls.KEY_MANAGEMENT_ALGORITHMS.get(alg)\n    if alg_class is not None:\n        return alg_class\n\n    alg_class = cls.ENCRYPTION_ALGORITHMS.get(alg)\n    if alg_class is not None:\n        return alg_class\n\n    raise UnsupportedAlg(alg)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(param: str) -&gt; Any\n</code></pre> <p>Allow access to key parameters as attributes.</p> <p>This is a convenience to allow <code>jwk.param</code> instead of <code>jwk['param']</code>.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str</code> <p>the parameter name to access</p> required Return <p>the param value</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the param is not found</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def __getattr__(self, param: str) -&gt; Any:\n\"\"\"Allow access to key parameters as attributes.\n\n    This is a convenience to allow `jwk.param` instead of `jwk['param']`.\n\n    Args:\n        param: the parameter name to access\n\n    Return:\n        the param value\n\n    Raises:\n        AttributeError: if the param is not found\n\n    \"\"\"\n    value = self.get(param)\n    if value is None:\n        raise AttributeError(param)\n    return value\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: str, value: Any) -&gt; None\n</code></pre> <p>Override base method to avoid modifying cryptographic key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>name of the attribute to set</p> required <code>value</code> <code>Any</code> <p>value to set</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>when trying to modify cryptographic attributes</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n\"\"\"Override base method to avoid modifying cryptographic key attributes.\n\n    Args:\n        key: name of the attribute to set\n        value: value to set\n\n    Raises:\n        RuntimeError: when trying to modify cryptographic attributes\n\n    \"\"\"\n    if key in self.PARAMS:\n        raise RuntimeError(\"JWK key attributes cannot be modified.\")\n    super().__setitem__(key, value)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.thumbprint","title":"thumbprint","text":"<pre><code>thumbprint(hashalg: str = 'sha-256') -&gt; str\n</code></pre> <p>Return the key thumbprint as specified by RFC 7638.</p> <p>Parameters:</p> Name Type Description Default <code>hashalg</code> <code>str</code> <p>A hash function (defaults to SHA256)</p> <code>'sha-256'</code> <p>Returns:</p> Type Description <code>str</code> <p>the calculated thumbprint</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def thumbprint(self, hashalg: str = \"sha-256\") -&gt; str:\n\"\"\"Return the key thumbprint as specified by RFC 7638.\n\n    Args:\n      hashalg: A hash function (defaults to SHA256)\n\n    Returns:\n        the calculated thumbprint\n\n    \"\"\"\n    alg = self.IANA_HASH_FUNCTION_NAMES.get(hashalg)\n    if not alg:\n        raise ValueError(f\"Unsupported hash alg {hashalg}\")\n\n    t = {\"kty\": self.get(\"kty\")}\n    for name, param in self.PARAMS.items():\n        if param.is_required and not param.is_private:\n            t[name] = self.get(name)\n\n    return (\n        BinaPy.serialize_to(\"json\", t, separators=(\",\", \":\"), sort_keys=True)\n        .to(alg)\n        .to(\"b64u\")\n        .ascii()\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.thumbprint_uri","title":"thumbprint_uri","text":"<pre><code>thumbprint_uri(hashalg: str = 'sha-256') -&gt; str\n</code></pre> <p>Return the JWK thumbprint URI for this key.</p> <p>Parameters:</p> Name Type Description Default <code>hashalg</code> <code>str</code> <p>the IANA registered name for the hash alg to use</p> <code>'sha-256'</code> <p>Returns:</p> Type Description <code>str</code> <p>the JWK thumbprint uri for this Jwk</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def thumbprint_uri(self, hashalg: str = \"sha-256\") -&gt; str:\n\"\"\"Return the JWK thumbprint URI for this key.\n\n    Args:\n        hashalg: the IANA registered name for the hash alg to use\n\n    Returns:\n         the JWK thumbprint uri for this Jwk\n\n    \"\"\"\n    return (\n        f\"urn:ietf:params:oauth:jwk-thumbprint:{hashalg}:{self.thumbprint(hashalg)}\"\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.check","title":"check","text":"<pre><code>check(\n    *,\n    is_private: bool | None = None,\n    is_symmetric: bool | None = None,\n    kty: str | None = None\n) -&gt; Jwk\n</code></pre> <p>Check this key for type, privateness and/or symmetricness.</p> <p>This raises a <code>ValueError</code> if the key is not as expected.</p> <p>Parameters:</p> Name Type Description Default <code>is_private</code> <code>bool | None</code> <p>if <code>True</code>, check if the key is private, if <code>False</code>, check if it is public, if <code>None</code>, do nothing</p> <code>None</code> <code>is_symmetric</code> <code>bool | None</code> <p>if <code>True</code>, check if the key is symmetric, if <code>False</code>, check if it is asymmetric, if <code>None</code>, do nothing</p> <code>None</code> <code>kty</code> <code>str | None</code> <p>the expected key type, if any</p> <code>None</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>this key, if all checks passed</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if any check fails</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def check(\n    self,\n    *,\n    is_private: bool | None = None,\n    is_symmetric: bool | None = None,\n    kty: str | None = None,\n) -&gt; Jwk:\n\"\"\"Check this key for type, privateness and/or symmetricness.\n\n    This raises a `ValueError` if the key is not as expected.\n\n    Args:\n        is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing\n        is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing\n        kty: the expected key type, if any\n\n    Returns:\n        this key, if all checks passed\n\n    Raises:\n        ValueError: if any check fails\n\n    \"\"\"\n    if is_private is not None:\n        if is_private is True and self.is_private is False:\n            raise ValueError(\"This key is public while a private key is expected.\")\n        elif is_private is False and self.is_private is True:\n            raise ValueError(\"This key is private while a public key is expected.\")\n\n    if is_symmetric is not None:\n        if is_symmetric is True and self.is_symmetric is False:\n            raise ValueError(\n                \"This key is asymmetric while a symmetric key is expected.\"\n            )\n        if is_symmetric is False and self.is_symmetric is True:\n            raise ValueError(\n                \"This key is symmetric while an asymmetric key is expected.\"\n            )\n\n    if kty is not None:\n        if self.kty != kty:\n            raise ValueError(\n                f\"This key has kty={self.kty} while a kty={kty} is expected.\"\n            )\n\n    return self\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk._validate","title":"_validate","text":"<pre><code>_validate() -&gt; None\n</code></pre> <p>Validate the content of this JWK.</p> <p>It checks that all required parameters are present and well-formed. If the key is private, it sets the <code>is_private</code> flag to <code>True</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if the key type doesn't match the subclass</p> <code>InvalidJwk</code> <p>if the JWK misses required members or has invalid members</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def _validate(self) -&gt; None:\n\"\"\"Validate the content of this JWK.\n\n    It checks that all required parameters are present and well-formed. If the key is private, it sets the `is_private` flag to `True`.\n\n    Raises:\n        TypeError: if the key type doesn't match the subclass\n        InvalidJwk: if the JWK misses required members or has invalid members\n\n    \"\"\"\n    if self.get(\"kty\") != self.KTY:\n        raise TypeError(\n            f\"This key 'kty' {self.get('kty')} doesn't match this Jwk subclass intended 'kty' {self.KTY}!\"\n        )\n\n    jwk_is_private = False\n    for name, param in self.PARAMS.items():\n        value = self.get(name)\n\n        if param.is_private and value is not None:\n            jwk_is_private = True\n\n        if not param.is_private and param.is_required and value is None:\n            raise InvalidJwk(\n                f\"Missing required public param {param.description} ({name})\"\n            )\n\n        if value is None:\n            pass\n        elif param.kind == \"b64u\":\n            if not isinstance(value, str):\n                raise InvalidJwk(\n                    f\"Parameter {param.description} ({name}) must be a string with a Base64URL-encoded value\"\n                )\n            if not BinaPy(value).check(\"b64u\"):\n                raise InvalidJwk(\n                    f\"Parameter {param.description} ({name}) must be a Base64URL-encoded value\"\n                )\n        elif param.kind == \"unsupported\":\n            if value is not None:  # pragma: no cover\n                raise InvalidJwk(f\"Unsupported JWK param '{name}'\")\n        elif param.kind == \"name\":\n            pass\n        else:\n            assert (\n                False\n            ), f\"Unsupported param '{name}' type '{param.kind}'\"  # pragma: no cover\n\n    # if at least one of the supplied parameter was private, then all required private parameters must be provided\n    if jwk_is_private:\n        for name, param in self.PARAMS.items():\n            value = self.get(name)\n            if param.is_private and param.is_required and value is None:\n                raise InvalidJwk(\n                    f\"Missing required private param {param.description} ({name})\"\n                )\n\n    # if key is used for signing, it must be private\n    for op in self.get(\"key_ops\", []):\n        if op in (\"sign\", \"unwrapKey\") and not self.is_private:\n            raise InvalidJwk(f\"Key Operation is '{op}' but the key is public\")\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.signature_class","title":"signature_class","text":"<pre><code>signature_class(\n    alg: str | None = None,\n) -&gt; type[BaseSignatureAlg]\n</code></pre> <p>Return the appropriate signature algorithm class to use with this key.</p> <p>The returned class is a <code>BaseSignatureAlg</code> subclass.</p> <p>If this key doesn't have an <code>alg</code> parameter, you must supply one as parameter to this method.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str | None</code> <p>the algorithm identifier, if not already present in this Jwk</p> <code>None</code> <p>Returns:</p> Type Description <code>type[BaseSignatureAlg]</code> <p>the appropriate <code>BaseSignatureAlg</code> subclass</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def signature_class(self, alg: str | None = None) -&gt; type[BaseSignatureAlg]:\n\"\"\"Return the appropriate signature algorithm class to use with this key.\n\n    The returned class is a `BaseSignatureAlg` subclass.\n\n    If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n    Args:\n        alg: the algorithm identifier, if not already present in this Jwk\n\n    Returns:\n        the appropriate `BaseSignatureAlg` subclass\n\n    \"\"\"\n    return select_alg_class(self.SIGNATURE_ALGORITHMS, jwk_alg=self.alg, alg=alg)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.encryption_class","title":"encryption_class","text":"<pre><code>encryption_class(\n    alg: str | None = None,\n) -&gt; type[BaseAESEncryptionAlg]\n</code></pre> <p>Return the appropriate encryption algorithm class to use with this key.</p> <p>The returned class is a subclass of <code>BaseAESEncryptionAlg</code>.</p> <p>If this key doesn't have an <code>alg</code> parameter, you must supply one as parameter to this method.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str | None</code> <p>the algorithm identifier, if not already present in this Jwk</p> <code>None</code> <p>Returns:</p> Type Description <code>type[BaseAESEncryptionAlg]</code> <p>the appropriate <code>BaseAESEncryptionAlg</code> subclass</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def encryption_class(self, alg: str | None = None) -&gt; type[BaseAESEncryptionAlg]:\n\"\"\"Return the appropriate encryption algorithm class to use with this key.\n\n    The returned class is a subclass of `BaseAESEncryptionAlg`.\n\n    If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n    Args:\n        alg: the algorithm identifier, if not already present in this Jwk\n\n    Returns:\n        the appropriate `BaseAESEncryptionAlg` subclass\n\n    \"\"\"\n    return select_alg_class(self.ENCRYPTION_ALGORITHMS, jwk_alg=self.alg, alg=alg)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.key_management_class","title":"key_management_class","text":"<pre><code>key_management_class(\n    alg: str | None = None,\n) -&gt; type[BaseKeyManagementAlg]\n</code></pre> <p>Return the appropriate key management algorithm class to use with this key.</p> <p>If this key doesn't have an <code>alg</code> parameter, you must supply one as parameter to this method.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str | None</code> <p>the algorithm identifier, if not already present in this Jwk</p> <code>None</code> <p>Returns:</p> Type Description <code>type[BaseKeyManagementAlg]</code> <p>the appropriate <code>BaseKeyManagementAlg</code> subclass</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def key_management_class(\n    self, alg: str | None = None\n) -&gt; type[BaseKeyManagementAlg]:\n\"\"\"Return the appropriate key management algorithm class to use with this key.\n\n    If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n    Args:\n        alg: the algorithm identifier, if not already present in this Jwk\n\n    Returns:\n        the appropriate `BaseKeyManagementAlg` subclass\n\n    \"\"\"\n    return select_alg_class(\n        self.KEY_MANAGEMENT_ALGORITHMS, jwk_alg=self.alg, alg=alg\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.signature_wrapper","title":"signature_wrapper","text":"<pre><code>signature_wrapper(\n    alg: str | None = None,\n) -&gt; BaseSignatureAlg\n</code></pre> <p>Initialize a  key management wrapper with this key.</p> <p>This returns an instance of a <code>BaseSignatureAlg</code> subclass.</p> <p>If this key doesn't have an <code>alg</code> parameter, you must supply one as parameter to this method.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str | None</code> <p>the algorithm identifier, if not already present in this Jwk</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseSignatureAlg</code> <p>a <code>BaseSignatureAlg</code> instance initialized with the current key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def signature_wrapper(self, alg: str | None = None) -&gt; BaseSignatureAlg:\n\"\"\"Initialize a  key management wrapper with this key.\n\n    This returns an instance of a `BaseSignatureAlg` subclass.\n\n    If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n    Args:\n        alg: the algorithm identifier, if not already present in this Jwk\n\n    Returns:\n        a `BaseSignatureAlg` instance initialized with the current key\n\n    \"\"\"\n    alg_class = self.signature_class(alg)\n    if issubclass(alg_class, BaseSymmetricAlg):\n        return alg_class(self.key)\n    elif issubclass(alg_class, BaseAsymmetricAlg):\n        return alg_class(self.cryptography_key)\n    raise UnsupportedAlg(alg)  # pragma: no cover\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.encryption_wrapper","title":"encryption_wrapper","text":"<pre><code>encryption_wrapper(\n    alg: str | None = None,\n) -&gt; BaseAESEncryptionAlg\n</code></pre> <p>Initialize an encryption wrapper with this key.</p> <p>This returns an instance of a <code>BaseAESEncryptionAlg</code> subclass.</p> <p>If this key doesn't have an <code>alg</code> parameter, you must supply one as parameter to this method.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str | None</code> <p>the algorithm identifier, if not already present in this Jwk</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseAESEncryptionAlg</code> <p>a <code>BaseAESEncryptionAlg</code> instance initialized with the current key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def encryption_wrapper(self, alg: str | None = None) -&gt; BaseAESEncryptionAlg:\n\"\"\"Initialize an encryption wrapper with this key.\n\n    This returns an instance of a `BaseAESEncryptionAlg` subclass.\n\n    If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n    Args:\n        alg: the algorithm identifier, if not already present in this Jwk\n\n    Returns:\n        a `BaseAESEncryptionAlg` instance initialized with the current key\n\n    \"\"\"\n    alg_class = self.encryption_class(alg)\n    if issubclass(alg_class, BaseSymmetricAlg):\n        return alg_class(self.key)\n    elif issubclass(alg_class, BaseAsymmetricAlg):  # pragma: no cover\n        return alg_class(self.cryptography_key)  # pragma: no cover\n    raise UnsupportedAlg(alg)  # pragma: no cover\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.key_management_wrapper","title":"key_management_wrapper","text":"<pre><code>key_management_wrapper(\n    alg: str | None = None,\n) -&gt; BaseKeyManagementAlg\n</code></pre> <p>Initialize a key management wrapper with this key.</p> <p>This returns an instance of a <code>BaseKeyManagementAlg</code> subclass.</p> <p>If this key doesn't have an <code>alg</code> parameter, you must supply one as parameter to this method.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str | None</code> <p>the algorithm identifier, if not already present in this Jwk</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseKeyManagementAlg</code> <p>a <code>BaseKeyManagementAlg</code> instance initialized with the current key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def key_management_wrapper(self, alg: str | None = None) -&gt; BaseKeyManagementAlg:\n\"\"\"Initialize a key management wrapper with this key.\n\n    This returns an instance of a `BaseKeyManagementAlg` subclass.\n\n    If this key doesn't have an `alg` parameter, you must supply one as parameter to this method.\n\n    Args:\n        alg: the algorithm identifier, if not already present in this Jwk\n\n    Returns:\n        a `BaseKeyManagementAlg` instance initialized with the current key\n\n    \"\"\"\n    alg_class = self.key_management_class(alg)\n    if issubclass(alg_class, BaseSymmetricAlg):\n        return alg_class(self.key)\n    elif issubclass(alg_class, BaseAsymmetricAlg):\n        return alg_class(self.cryptography_key)\n    raise UnsupportedAlg(alg)  # pragma: no cover\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.supported_signing_algorithms","title":"supported_signing_algorithms","text":"<pre><code>supported_signing_algorithms() -&gt; list[str]\n</code></pre> <p>Return the list of Signature algorithms that can be used with this key.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of supported algs</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def supported_signing_algorithms(self) -&gt; list[str]:\n\"\"\"Return the list of Signature algorithms that can be used with this key.\n\n    Returns:\n      a list of supported algs\n\n    \"\"\"\n    return list(self.SIGNATURE_ALGORITHMS)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.supported_key_management_algorithms","title":"supported_key_management_algorithms","text":"<pre><code>supported_key_management_algorithms() -&gt; list[str]\n</code></pre> <p>Return the list of Key Management algorithms that can be used with this key.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of supported algs</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def supported_key_management_algorithms(self) -&gt; list[str]:\n\"\"\"Return the list of Key Management algorithms that can be used with this key.\n\n    Returns:\n        a list of supported algs\n\n    \"\"\"\n    return list(self.KEY_MANAGEMENT_ALGORITHMS)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.supported_encryption_algorithms","title":"supported_encryption_algorithms","text":"<pre><code>supported_encryption_algorithms() -&gt; list[str]\n</code></pre> <p>Return the list of Encryption algorithms that can be used with this key.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of supported algs</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def supported_encryption_algorithms(self) -&gt; list[str]:\n\"\"\"Return the list of Encryption algorithms that can be used with this key.\n\n    Returns:\n        a list of supported algs\n\n    \"\"\"\n    return list(self.ENCRYPTION_ALGORITHMS)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.sign","title":"sign","text":"<pre><code>sign(\n    data: bytes | SupportsBytes, alg: str | None = None\n) -&gt; BinaPy\n</code></pre> <p>Sign a data using this Jwk, and return the generated signature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | SupportsBytes</code> <p>the data to sign</p> required <code>alg</code> <code>str | None</code> <p>the alg to use (if this key doesn't have an <code>alg</code> parameter)</p> <code>None</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the generated signature</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def sign(self, data: bytes | SupportsBytes, alg: str | None = None) -&gt; BinaPy:\n\"\"\"Sign a data using this Jwk, and return the generated signature.\n\n    Args:\n      data: the data to sign\n      alg: the alg to use (if this key doesn't have an `alg` parameter)\n\n    Returns:\n      the generated signature\n\n    \"\"\"\n    wrapper = self.signature_wrapper(alg)\n    signature = wrapper.sign(data)\n    return BinaPy(signature)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.verify","title":"verify","text":"<pre><code>verify(\n    data: bytes | SupportsBytes,\n    signature: bytes | SupportsBytes,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None\n) -&gt; bool\n</code></pre> <p>Verify a signature using this <code>Jwk</code>, and return <code>True</code> if valid.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | SupportsBytes</code> <p>the data to verify</p> required <code>signature</code> <code>bytes | SupportsBytes</code> <p>the signature to verify</p> required <code>alg</code> <code>str | None</code> <p>the allowed signature alg, if there is only one</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>the allowed signature algs, if there are several</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the signature matches, <code>False</code> otherwise</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def verify(\n    self,\n    data: bytes | SupportsBytes,\n    signature: bytes | SupportsBytes,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Verify a signature using this `Jwk`, and return `True` if valid.\n\n    Args:\n      data: the data to verify\n      signature: the signature to verify\n      alg: the allowed signature alg, if there is only one\n      algs: the allowed signature algs, if there are several\n\n    Returns:\n      `True` if the signature matches, `False` otherwise\n\n    \"\"\"\n    if not self.is_symmetric and self.is_private:\n        warnings.warn(\n            \"You are trying to validate a signature with a private key. \"\n            \"Signatures should always be verified with a public key.\"\n        )\n        public_jwk = self.public_jwk()\n    else:\n        public_jwk = self\n    if algs is None and alg:\n        algs = [alg]\n    for alg in algs or (None,):\n        wrapper = public_jwk.signature_wrapper(alg)\n        if wrapper.verify(data, signature):\n            return True\n\n    return False\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.encrypt","title":"encrypt","text":"<pre><code>encrypt(\n    plaintext: bytes | SupportsBytes,\n    *,\n    aad: bytes | None = None,\n    alg: str | None = None,\n    iv: bytes | None = None\n) -&gt; tuple[BinaPy, BinaPy, BinaPy]\n</code></pre> <p>Encrypt a plaintext with Authenticated Encryption using this key.</p> <p>Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data (<code>aad</code>). This returns a tuple with 3 raw data, in order: - the encrypted Data - the Initialization Vector that was used to encrypt data - the generated Authentication Tag</p> <p>Parameters:</p> Name Type Description Default <code>plaintext</code> <code>bytes | SupportsBytes</code> <p>the data to encrypt.</p> required <code>aad</code> <code>bytes | None</code> <p>the Additional Authenticated Data (AAD) to include in the authentication tag</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the alg to use to encrypt the data</p> <code>None</code> <code>iv</code> <code>bytes | None</code> <p>the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[BinaPy, BinaPy, BinaPy]</code> <p>a tuple (ciphertext, iv, authentication_tag), as raw data</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def encrypt(\n    self,\n    plaintext: bytes | SupportsBytes,\n    *,\n    aad: bytes | None = None,\n    alg: str | None = None,\n    iv: bytes | None = None,\n) -&gt; tuple[BinaPy, BinaPy, BinaPy]:\n\"\"\"Encrypt a plaintext with Authenticated Encryption using this key.\n\n    Authenticated Encryption with Associated Data (AEAD) is supported, by passing Additional Authenticated Data (`aad`).\n    This returns a tuple with 3 raw data, in order:\n    - the encrypted Data\n    - the Initialization Vector that was used to encrypt data\n    - the generated Authentication Tag\n\n    Args:\n      plaintext: the data to encrypt.\n      aad: the Additional Authenticated Data (AAD) to include in the authentication tag\n      alg: the alg to use to encrypt the data\n      iv: the Initialization Vector to use. If not provided, an IV is generated. If provided, the returned IV will be the same.\n\n    Returns:\n      a tuple (ciphertext, iv, authentication_tag), as raw data\n\n    \"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.decrypt","title":"decrypt","text":"<pre><code>decrypt(\n    ciphertext: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes,\n    tag: bytes | SupportsBytes,\n    aad: bytes | SupportsBytes | None = None,\n    alg: str | None = None\n) -&gt; BinaPy\n</code></pre> <p>Decrypt an encrypted data using this Jwk, and return the encrypted result.</p> <p>This is implemented by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>ciphertext</code> <code>bytes | SupportsBytes</code> <p>the data to decrypt</p> required <code>iv</code> <code>bytes | SupportsBytes</code> <p>the Initialization Vector (IV) that was used for encryption</p> required <code>tag</code> <code>bytes | SupportsBytes</code> <p>the Authentication Tag that will be verified while decrypting data</p> required <code>aad</code> <code>bytes | SupportsBytes | None</code> <p>the Additional Authentication Data (AAD) to verify the Tag against</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the alg to use for decryption</p> <code>None</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the clear-text data</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def decrypt(\n    self,\n    ciphertext: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes,\n    tag: bytes | SupportsBytes,\n    aad: bytes | SupportsBytes | None = None,\n    alg: str | None = None,\n) -&gt; BinaPy:\n\"\"\"Decrypt an encrypted data using this Jwk, and return the encrypted result.\n\n    This is implemented by subclasses.\n\n    Args:\n      ciphertext: the data to decrypt\n      iv: the Initialization Vector (IV) that was used for encryption\n      tag: the Authentication Tag that will be verified while decrypting data\n      aad: the Additional Authentication Data (AAD) to verify the Tag against\n      alg: the alg to use for decryption\n\n    Returns:\n      the clear-text data\n\n    \"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.sender_key","title":"sender_key","text":"<pre><code>sender_key(\n    enc: str,\n    *,\n    alg: str | None = None,\n    cek: bytes | None = None,\n    epk: Jwk | None = None,\n    **headers: Any\n) -&gt; tuple[Jwk, BinaPy, Mapping[str, Any]]\n</code></pre> <p>Produce a Content Encryption Key, to use for encryption.</p> <p>This method is meant to be used by encrypted token senders. Recipients should use the matching method <code>Jwk.recipient_key()</code>.</p> <p>Returns a tuple with 3 items:</p> <ul> <li>the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone!</li> <li>the encrypted CEK, as bytes. You must send this to your recipient. This may be <code>None</code> for Key Management algs which derive a CEK instead of generating one.</li> <li>extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well.</li> </ul> <p>For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead of letting <code>jwskate</code> generate a safe, unique random value for you. Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself, instead of letting <code>jwskate</code> generate an appropriate value for you. Only do this if you know what you are doing!</p> <p>Parameters:</p> Name Type Description Default <code>enc</code> <code>str</code> <p>the encryption algorithm to use with the CEK</p> required <code>alg</code> <code>str | None</code> <p>the Key Management algorithm to use to produce the CEK</p> <code>None</code> <code>cek</code> <code>bytes | None</code> <p>CEK to use (leave <code>None</code> to have an adequate random value generated automatically)</p> <code>None</code> <code>epk</code> <code>Jwk | None</code> <p>EPK to use (leave <code>None</code> to have an adequate ephemeral key generated automatically)</p> <code>None</code> <code>**headers</code> <code>Any</code> <p>additional headers to include for the CEK derivation</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Jwk, BinaPy, Mapping[str, Any]]</code> <p>a tuple (cek, wrapped_cek, additional_headers_map)</p> <p>Raises:</p> Type Description <code>UnsupportedAlg</code> <p>if the requested alg identifier is not supported</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def sender_key(\n    self,\n    enc: str,\n    *,\n    alg: str | None = None,\n    cek: bytes | None = None,\n    epk: Jwk | None = None,\n    **headers: Any,\n) -&gt; tuple[Jwk, BinaPy, Mapping[str, Any]]:\n\"\"\"Produce a Content Encryption Key, to use for encryption.\n\n    This method is meant to be used by encrypted token senders. Recipients should use the matching method `Jwk.recipient_key()`.\n\n    Returns a tuple with 3 items:\n\n    - the clear text CEK, as a SymmetricJwk instance. Use this key to encrypt your message, but do not communicate this key to anyone!\n    - the encrypted CEK, as bytes. You must send this to your recipient. This may be `None` for Key Management algs which derive a CEK instead of generating one.\n    - extra headers depending on the Key Management algorithm, as a dict of name to values: you must send those to your recipient as well.\n\n    For algorithms that rely on a randomly generated CEK, such as RSAES or AES, you can provide that CEK instead\n    of letting `jwskate` generate a safe, unique random value for you.\n    Likewise, for algorithms that rely on an ephemeral key, you can provide an EPK that you generated yourself,\n    instead of letting `jwskate` generate an appropriate value for you.\n    Only do this if you know what you are doing!\n\n    Args:\n      enc: the encryption algorithm to use with the CEK\n      alg: the Key Management algorithm to use to produce the CEK\n      cek: CEK to use (leave `None` to have an adequate random value generated automatically)\n      epk: EPK to use (leave `None` to have an adequate ephemeral key generated automatically)\n      **headers: additional headers to include for the CEK derivation\n\n    Returns:\n      a tuple (cek, wrapped_cek, additional_headers_map)\n\n    Raises:\n        UnsupportedAlg: if the requested alg identifier is not supported\n\n    \"\"\"\n    from jwskate import SymmetricJwk\n\n    if not self.is_symmetric and self.is_private:\n        warnings.warn(\n            \"You are using a private key for sender key wrapping. Key wrapping should always be done using the recipient public key.\"\n        )\n        key_alg_wrapper = self.public_jwk().key_management_wrapper(alg)\n    else:\n        key_alg_wrapper = self.key_management_wrapper(alg)\n\n    enc_alg_class = select_alg_class(SymmetricJwk.ENCRYPTION_ALGORITHMS, alg=enc)\n\n    cek_headers: dict[str, Any] = {}\n\n    if isinstance(key_alg_wrapper, BaseRsaKeyWrap):\n        if cek:\n            enc_alg_class.check_key(cek)\n        else:\n            cek = enc_alg_class.generate_key()\n        assert cek\n        wrapped_cek = key_alg_wrapper.wrap_key(cek)\n\n    elif isinstance(key_alg_wrapper, EcdhEs):\n        epk = epk or Jwk.from_cryptography_key(\n            key_alg_wrapper.generate_ephemeral_key()\n        )\n        cek_headers = {\"epk\": epk.public_jwk()}\n        if isinstance(key_alg_wrapper, BaseEcdhEs_AesKw):\n            if cek:\n                enc_alg_class.check_key(cek)\n            else:\n                cek = enc_alg_class.generate_key()\n            assert cek\n            wrapped_cek = key_alg_wrapper.wrap_key_with_epk(\n                cek, epk.cryptography_key, alg=key_alg_wrapper.name, **headers\n            )\n        else:\n            cek = key_alg_wrapper.sender_key(\n                epk.cryptography_key,\n                alg=enc_alg_class.name,\n                key_size=enc_alg_class.key_size,\n                **headers,\n            )\n            wrapped_cek = BinaPy(b\"\")\n\n    elif isinstance(key_alg_wrapper, BaseAesKeyWrap):\n        if cek:\n            enc_alg_class.check_key(cek)\n        else:\n            cek = enc_alg_class.generate_key()\n        assert cek\n        wrapped_cek = key_alg_wrapper.wrap_key(cek)\n\n    elif isinstance(key_alg_wrapper, BaseAesGcmKeyWrap):\n        if cek:\n            enc_alg_class.check_key(cek)\n        else:\n            cek = enc_alg_class.generate_key()\n        assert cek\n        iv = key_alg_wrapper.generate_iv()\n        wrapped_cek, tag = key_alg_wrapper.wrap_key(cek, iv=iv)\n        cek_headers = {\n            \"iv\": iv.to(\"b64u\").ascii(),\n            \"tag\": tag.to(\"b64u\").ascii(),\n        }\n\n    elif isinstance(key_alg_wrapper, DirectKeyUse):\n        cek = key_alg_wrapper.direct_key(enc_alg_class)\n        wrapped_cek = BinaPy(b\"\")\n    else:\n        raise UnsupportedAlg(\n            f\"Unsupported Key Management Alg {key_alg_wrapper}\"\n        )  # pragma: no cover\n\n    return SymmetricJwk.from_bytes(cek), wrapped_cek, cek_headers\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.recipient_key","title":"recipient_key","text":"<pre><code>recipient_key(\n    wrapped_cek: bytes | SupportsBytes,\n    enc: str,\n    *,\n    alg: str | None = None,\n    **headers: Any\n) -&gt; Jwk\n</code></pre> <p>Produce a Content Encryption Key, to use for decryption.</p> <p>This method is meant to be used by encrypted token recipient. Senders should use the matching method <code>Jwk.sender_key()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped_cek</code> <code>bytes | SupportsBytes</code> <p>the wrapped CEK</p> required <code>enc</code> <code>str</code> <p>the encryption algorithm to use with the CEK</p> required <code>alg</code> <code>str | None</code> <p>the Key Management algorithm to use to unwrap the CEK</p> <code>None</code> <code>**headers</code> <code>Any</code> <p>additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>the clear-text CEK, as a SymmetricJwk instance</p> <p>Raises:</p> Type Description <code>UnsupportedAlg</code> <p>if the requested alg identifier is not supported</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def recipient_key(\n    self,\n    wrapped_cek: bytes | SupportsBytes,\n    enc: str,\n    *,\n    alg: str | None = None,\n    **headers: Any,\n) -&gt; Jwk:\n\"\"\"Produce a Content Encryption Key, to use for decryption.\n\n    This method is meant to be used by encrypted token recipient. Senders should use the matching method `Jwk.sender_key()`.\n\n    Args:\n      wrapped_cek: the wrapped CEK\n      enc: the encryption algorithm to use with the CEK\n      alg: the Key Management algorithm to use to unwrap the CEK\n      **headers: additional headers used to decrypt the CEK (e.g. \"epk\" for ECDH algs, \"iv\", \"tag\" for AES-GCM algs)\n\n    Returns:\n      the clear-text CEK, as a SymmetricJwk instance\n\n    Raises:\n        UnsupportedAlg: if the requested alg identifier is not supported\n\n    \"\"\"\n    from jwskate import SymmetricJwk\n\n    if not self.is_symmetric and not self.is_private:\n        raise ValueError(\n            \"You are using a public key for recipient key unwrapping. Key unwrapping must always be done using the recipient private key.\"\n        )\n\n    key_alg_wrapper = self.key_management_wrapper(alg)\n    enc_alg_class = select_alg_class(SymmetricJwk.ENCRYPTION_ALGORITHMS, alg=enc)\n\n    if isinstance(key_alg_wrapper, BaseRsaKeyWrap):\n        cek = key_alg_wrapper.unwrap_key(wrapped_cek)\n\n    elif isinstance(key_alg_wrapper, EcdhEs):\n        epk = headers.get(\"epk\")\n        if epk is None:\n            raise ValueError(\"No EPK in the headers!\")\n        epk_jwk = Jwk(epk)\n        if epk_jwk.is_private:\n            raise ValueError(\"The EPK present in the header is private.\")\n        epk = epk_jwk.cryptography_key\n        if isinstance(key_alg_wrapper, BaseEcdhEs_AesKw):\n            cek = key_alg_wrapper.unwrap_key_with_epk(\n                wrapped_cek, epk, alg=key_alg_wrapper.name\n            )\n        else:\n            cek = key_alg_wrapper.recipient_key(\n                epk,\n                alg=enc_alg_class.name,\n                key_size=enc_alg_class.key_size,\n                **headers,\n            )\n\n    elif isinstance(key_alg_wrapper, BaseAesKeyWrap):\n        cek = key_alg_wrapper.unwrap_key(wrapped_cek)\n\n    elif isinstance(key_alg_wrapper, BaseAesGcmKeyWrap):\n        iv = headers.get(\"iv\")\n        if iv is None:\n            raise ValueError(\"No 'iv' in headers!\")\n        iv = BinaPy(iv).decode_from(\"b64u\")\n        tag = headers.get(\"tag\")\n        if tag is None:\n            raise ValueError(\"No 'tag' in headers!\")\n        tag = BinaPy(tag).decode_from(\"b64u\")\n        cek = key_alg_wrapper.unwrap_key(wrapped_cek, tag=tag, iv=iv)\n\n    elif isinstance(key_alg_wrapper, DirectKeyUse):\n        cek = key_alg_wrapper.direct_key(enc_alg_class)\n\n    else:\n        raise UnsupportedAlg(\n            f\"Unsupported Key Management Alg {key_alg_wrapper}\"\n        )  # pragma: no cover\n\n    return SymmetricJwk.from_bytes(cek)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.public_jwk","title":"public_jwk","text":"<pre><code>public_jwk() -&gt; Jwk\n</code></pre> <p>Return the public Jwk associated with this key.</p> <p>Returns:</p> Type Description <code>Jwk</code> <p>a Jwk with the public key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def public_jwk(self) -&gt; Jwk:\n\"\"\"Return the public Jwk associated with this key.\n\n    Returns:\n      a Jwk with the public key\n\n    \"\"\"\n    if not self.is_private:\n        return self\n\n    params = {\n        name: self.get(name)\n        for name, param in self.PARAMS.items()\n        if not param.is_private\n    }\n\n    if \"key_ops\" in self:\n        key_ops = list(self.key_ops)\n        if \"sign\" in key_ops:\n            key_ops.remove(\"sign\")\n            key_ops.append(\"verify\")\n        if \"unwrapKey\" in key_ops:\n            key_ops.remove(\"unwrapKey\")\n            key_ops.append(\"wrapKey\")\n    else:\n        key_ops = None\n\n    return Jwk(\n        dict(\n            kty=self.kty,\n            kid=self.get(\"kid\"),\n            alg=self.get(\"alg\"),\n            use=self.get(\"use\"),\n            key_ops=key_ops,\n            **params,\n        )\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.as_jwks","title":"as_jwks","text":"<pre><code>as_jwks() -&gt; JwkSet\n</code></pre> <p>Return a JwkSet with this key as single element.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>a JwsSet with this single key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def as_jwks(self) -&gt; JwkSet:\n\"\"\"Return a JwkSet with this key as single element.\n\n    Returns:\n        a JwsSet with this single key\n\n    \"\"\"\n    from .jwks import JwkSet\n\n    return JwkSet(keys=(self,))\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.from_cryptography_key","title":"from_cryptography_key  <code>classmethod</code>","text":"<pre><code>from_cryptography_key(\n    cryptography_key: Any, **kwargs: Any\n) -&gt; Jwk\n</code></pre> <p>Initialize a Jwk from a key from the <code>cryptography</code> library.</p> <p>The input key can be any private or public key supported by cryptography.</p> <p>Parameters:</p> Name Type Description Default <code>cryptography_key</code> <code>Any</code> <p>a <code>cryptography</code> key instance</p> required <code>**kwargs</code> <code>Any</code> <p>additional members to include in the Jwk (e.g. kid, use)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>the matching <code>Jwk</code> instance</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if the key type is not supported</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>@classmethod\ndef from_cryptography_key(cls, cryptography_key: Any, **kwargs: Any) -&gt; Jwk:\n\"\"\"Initialize a Jwk from a key from the `cryptography` library.\n\n    The input key can be any private or public key supported by cryptography.\n\n    Args:\n      cryptography_key: a `cryptography` key instance\n      **kwargs: additional members to include in the Jwk (e.g. kid, use)\n\n    Returns:\n        the matching `Jwk` instance\n\n    Raises:\n        TypeError: if the key type is not supported\n\n    \"\"\"\n    for cryptography_class, jwk_class in cls.cryptography_key_types.items():\n        if isinstance(cryptography_key, cryptography_class):\n            return jwk_class.from_cryptography_key(cryptography_key, **kwargs)\n\n    raise TypeError(\n        f\"Unsupported Jwk class for this Key Type: {type(cryptography_key).__name__}\"\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk._to_cryptography_key","title":"_to_cryptography_key","text":"<pre><code>_to_cryptography_key() -&gt; Any\n</code></pre> <p>Return a key from the <code>cryptography</code> library that matches this Jwk.</p> <p>This is implemented by subclasses.</p> <p>Returns:</p> Type Description <code>Any</code> <p>a <code>cryptography</code>key instance initialized from the current key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def _to_cryptography_key(self) -&gt; Any:\n\"\"\"Return a key from the `cryptography` library that matches this Jwk.\n\n    This is implemented by subclasses.\n\n    Returns:\n        a `cryptography`key instance initialized from the current key\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.from_pem","title":"from_pem  <code>classmethod</code>","text":"<pre><code>from_pem(\n    der: bytes | str,\n    password: bytes | str | None = None,\n    **kwargs: Any\n) -&gt; Jwk\n</code></pre> <p>Load a <code>Jwk</code> from a PEM encoded private or public key.</p> <p>Parameters:</p> Name Type Description Default <code>der</code> <code>bytes | str</code> <p>the PEM encoded data to load</p> required <code>password</code> <code>bytes | str | None</code> <p>the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional members to include in the <code>Jwk</code> (e.g. <code>kid</code>, <code>use</code>)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>a <code>Jwk</code> instance from the loaded key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>@classmethod\ndef from_pem(\n    cls,\n    der: bytes | str,\n    password: bytes | str | None = None,\n    **kwargs: Any,\n) -&gt; Jwk:\n\"\"\"Load a `Jwk` from a PEM encoded private or public key.\n\n    Args:\n      der: the PEM encoded data to load\n      password: the password to decrypt the PEM, if required. Should be bytes. If it is a string, it will be encoded with UTF-8.\n      **kwargs: additional members to include in the `Jwk` (e.g. `kid`, `use`)\n\n    Returns:\n        a `Jwk` instance from the loaded key\n\n    \"\"\"\n    der = der.encode() if isinstance(der, str) else der\n    password = password.encode(\"UTF-8\") if isinstance(password, str) else password\n\n    try:\n        cryptography_key = serialization.load_pem_private_key(der, password)\n    except Exception as private_exc:\n        try:\n            cryptography_key = serialization.load_pem_public_key(der)\n\n        except Exception:\n            raise ValueError(\n                \"The provided data is not a private or a public PEM encoded key.\"\n            ) from private_exc\n        if password is not None:\n            raise ValueError(\n                \"A public key was loaded from PEM, while a password was provided for decryption.\"\n                \"Only private keys are encrypted using a password.\"\n            )\n\n    return cls.from_cryptography_key(cryptography_key, **kwargs)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.to_pem","title":"to_pem","text":"<pre><code>to_pem(password: bytes | str | None = None) -&gt; str\n</code></pre> <p>Serialize this key to PEM format.</p> <p>For private keys, you can provide a password for encryption. This password should be <code>bytes</code>. A <code>str</code> is also accepted, and will be encoded to <code>bytes</code> using UTF-8 before it is used as encryption key.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>bytes | str | None</code> <p>password to use to encrypt the PEM.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the PEM serialized key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def to_pem(self, password: bytes | str | None = None) -&gt; str:\n\"\"\"Serialize this key to PEM format.\n\n    For private keys, you can provide a password for encryption. This password should be `bytes`. A `str` is also\n    accepted, and will be encoded to `bytes` using UTF-8 before it is used as encryption key.\n\n    Args:\n      password: password to use to encrypt the PEM.\n\n    Returns:\n        the PEM serialized key\n\n    \"\"\"\n    password = password.encode(\"UTF-8\") if isinstance(password, str) else password\n\n    if self.is_private:\n        encryption: serialization.KeySerializationEncryption\n        if password:\n            encryption = serialization.BestAvailableEncryption(password)\n        else:\n            encryption = serialization.NoEncryption()\n        return self.cryptography_key.private_bytes(  # type: ignore[no-any-return]\n            serialization.Encoding.PEM,\n            serialization.PrivateFormat.PKCS8,\n            encryption,\n        ).decode()\n    else:\n        if password:\n            raise ValueError(\"Public keys cannot be encrypted when serialized.\")\n        return self.cryptography_key.public_bytes(  # type: ignore[no-any-return]\n            serialization.Encoding.PEM,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        ).decode()\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.from_der","title":"from_der  <code>classmethod</code>","text":"<pre><code>from_der(\n    der: bytes,\n    password: bytes | str | None = None,\n    **kwargs: Any\n) -&gt; Jwk\n</code></pre> <p>Load a <code>Jwk</code> from DER.</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>@classmethod\ndef from_der(\n    cls,\n    der: bytes,\n    password: bytes | str | None = None,\n    **kwargs: Any,\n) -&gt; Jwk:\n\"\"\"Load a `Jwk` from DER.\"\"\"\n    password = password.encode(\"UTF-8\") if isinstance(password, str) else password\n\n    try:\n        cryptography_key = serialization.load_der_private_key(der, password)\n    except Exception as private_exc:\n        try:\n            cryptography_key = serialization.load_der_public_key(der)\n        except Exception:\n            raise ValueError(\n                \"The provided data is not a private or a public DER encoded key.\"\n            ) from private_exc\n        if password is not None:\n            raise ValueError(\n                \"A public key was loaded from DER, while a password was provided for decryption.\"\n                \"Only private keys are encrypted using a password.\"\n            )\n\n    return cls.from_cryptography_key(cryptography_key, **kwargs)\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.to_der","title":"to_der","text":"<pre><code>to_der(password: bytes | str | None = None) -&gt; BinaPy\n</code></pre> <p>Serialize this key to DER.</p> <p>For private keys, you can provide a password for encryption. This password should be bytes. A <code>str</code> is also accepted, and will be encoded to <code>bytes</code> using UTF-8 before it is used as encryption key.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>bytes | str | None</code> <p>password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded to bytes with UTF-8.</p> <code>None</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the DER serialized key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def to_der(self, password: bytes | str | None = None) -&gt; BinaPy:\n\"\"\"Serialize this key to DER.\n\n    For private keys, you can provide a password for encryption. This password should be bytes. A `str` is also\n    accepted, and will be encoded to `bytes` using UTF-8 before it is used as encryption key.\n\n    Args:\n      password: password to use to encrypt the PEM. Should be bytes. If it is a string, it will be encoded to bytes with UTF-8.\n\n    Returns:\n        the DER serialized key\n\n    \"\"\"\n    password = password.encode(\"UTF-8\") if isinstance(password, str) else password\n\n    if self.is_private:\n        encryption: serialization.KeySerializationEncryption\n        if password:\n            encryption = serialization.BestAvailableEncryption(password)\n        else:\n            encryption = serialization.NoEncryption()\n        return BinaPy(\n            self.cryptography_key.private_bytes(\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                encryption,\n            )\n        )\n    else:\n        if password:\n            raise ValueError(\"Public keys cannot be encrypted when serialized.\")\n        return BinaPy(\n            self.cryptography_key.public_bytes(\n                serialization.Encoding.DER,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n        )\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.generate","title":"generate  <code>classmethod</code>","text":"<pre><code>generate(\n    *,\n    alg: str | None = None,\n    kty: str | None = None,\n    **kwargs: Any\n) -&gt; Jwk\n</code></pre> <p>Generate a Private Key and return it as a <code>Jwk</code> instance.</p> <p>This method is implemented by subclasses for specific Key Types and returns an instance of that subclass.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str | None</code> <p>intended algorithm to use with the generated key</p> <code>None</code> <code>kty</code> <code>str | None</code> <p>key type identifier</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>specific parameters depending on the type of key, or additional members to include in the <code>Jwk</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>a <code>Jwk</code> instance with a generated key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>@classmethod\ndef generate(\n    cls, *, alg: str | None = None, kty: str | None = None, **kwargs: Any\n) -&gt; Jwk:\n\"\"\"Generate a Private Key and return it as a `Jwk` instance.\n\n    This method is implemented by subclasses for specific Key Types and returns an instance of that subclass.\n\n    Args:\n        alg: intended algorithm to use with the generated key\n        kty: key type identifier\n        **kwargs: specific parameters depending on the type of key, or additional members to include in the `Jwk`\n\n    Returns:\n        a `Jwk` instance with a generated key\n\n    \"\"\"\n    if alg:\n        key = cls.generate_for_alg(alg=alg, **kwargs)\n        if kty is not None and key.kty != kty:\n            raise ValueError(\n                f\"Incompatible `{alg=}` and `{kty=}` parameters. \"\n                f\"`{alg=}` points to `kty='{key.kty}'`.\"\n            )\n        return key\n    if kty:\n        return cls.generate_for_kty(kty=kty, **kwargs)\n    raise ValueError(\n        \"You must provide a hint for jwskate to know what kind of key it must generate. \"\n        \"You can either provide an 'alg' identifier as keyword parameter, and/or a 'kty'.\"\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.copy","title":"copy","text":"<pre><code>copy() -&gt; Jwk\n</code></pre> <p>Create a copy of this key.</p> <p>Returns:</p> Type Description <code>Jwk</code> <p>a copy of this key, with the same value</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def copy(self) -&gt; Jwk:\n\"\"\"Create a copy of this key.\n\n    Returns:\n        a copy of this key, with the same value\n\n    \"\"\"\n    return Jwk(super().copy())\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.with_kid_thumbprint","title":"with_kid_thumbprint","text":"<pre><code>with_kid_thumbprint(force: bool = False) -&gt; Jwk\n</code></pre> <p>Includes the JWK thumbprint as \"kid\".</p> <p>If key already has a \"kid\": - if <code>force</code> is <code>True</code>, this erases the previous \"kid\". - if <code>force</code> is <code>False</code> (default), do nothing.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>whether to overwrite a previously existing kid</p> <code>False</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>a copy of this key with a \"kid\" (either the previous one or the existing one, depending on <code>force</code>).</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def with_kid_thumbprint(self, force: bool = False) -&gt; Jwk:\n\"\"\"Includes the JWK thumbprint as \"kid\".\n\n    If key already has a \"kid\":\n    - if `force` is `True`, this erases the previous \"kid\".\n    - if `force` is `False` (default), do nothing.\n\n    Args:\n        force: whether to overwrite a previously existing kid\n\n    Returns:\n        a copy of this key with a \"kid\" (either the previous one or the existing one, depending on `force`).\n\n    \"\"\"\n    if self.get(\"kid\") is not None and not force:\n        return self\n    jwk = self.copy()\n    jwk[\"kid\"] = self.thumbprint()\n    return jwk\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.with_usage_parameters","title":"with_usage_parameters","text":"<pre><code>with_usage_parameters(\n    alg: str | None = None,\n    with_alg: bool = True,\n    with_use: bool = True,\n    with_key_ops: bool = True,\n) -&gt; Jwk\n</code></pre> <p>Copy this Jwk and add the <code>use</code> and <code>key_ops</code> parameters.</p> <p>The returned jwk <code>alg</code> parameter will be the one passed as parameter to this method, or as dfault the one declared as <code>alg</code> parameter in this Jwk. The <code>use</code> (Public Key Use) param is deduced based on this <code>alg</code> value. The <code>key_ops</code> (Key Operations) param is deduced based on the key <code>use</code> and if the key is public, private, or symmetric.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str | None</code> <p>the alg to use, if not present in this Jwk</p> <code>None</code> <code>with_alg</code> <code>bool</code> <p>whether to include an <code>alg</code> parameter</p> <code>True</code> <code>with_use</code> <code>bool</code> <p>whether to include a <code>use</code> parameter</p> <code>True</code> <code>with_key_ops</code> <code>bool</code> <p>whether to include a <code>key_ops</code> parameter</p> <code>True</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>a Jwk with the same key, with <code>alg</code>, <code>use</code> and <code>key_ops</code> parameters.</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def with_usage_parameters(\n    self,\n    alg: str | None = None,\n    with_alg: bool = True,\n    with_use: bool = True,\n    with_key_ops: bool = True,\n) -&gt; Jwk:\n\"\"\"Copy this Jwk and add the `use` and `key_ops` parameters.\n\n    The returned jwk `alg` parameter will be the one passed as parameter to this method, or as dfault the one declared as `alg` parameter in this Jwk.\n    The `use` (Public Key Use) param is deduced based on this `alg` value.\n    The `key_ops` (Key Operations) param is deduced based on the key `use` and if the key is public, private,\n    or symmetric.\n\n    Args:\n        alg: the alg to use, if not present in this Jwk\n        with_alg: whether to include an `alg` parameter\n        with_use: whether to include a `use` parameter\n        with_key_ops: whether to include a `key_ops` parameter\n\n    Returns:\n        a Jwk with the same key, with `alg`, `use` and `key_ops` parameters.\n\n    \"\"\"\n    alg = alg or self.alg\n\n    if not alg:\n        raise ExpectedAlgRequired(\n            \"An algorithm is required to set the usage parameters\"\n        )\n\n    self._get_alg_class(alg)  # raises an exception if alg is not supported\n\n    jwk = self.copy()\n    if with_alg:\n        jwk[\"alg\"] = alg\n    if with_use:\n        jwk[\"use\"] = jwk.use\n    if with_key_ops:\n        jwk[\"key_ops\"] = jwk.key_ops\n\n    return jwk\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.minimize","title":"minimize","text":"<pre><code>minimize() -&gt; Jwk\n</code></pre> <p>Strip out any optional or non-standard parameter from that key.</p> <p>This will remove <code>alg</code>, <code>use</code>, <code>key_ops</code>, optional parameters from RSA keys, and other unknown parameters.</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def minimize(self) -&gt; Jwk:\n\"\"\"Strip out any optional or non-standard parameter from that key.\n\n    This will remove `alg`, `use`, `key_ops`, optional parameters from RSA keys, and other\n    unknown parameters.\n\n    \"\"\"\n    jwk = self.copy()\n    for key in self.keys():\n        if key == \"kty\" or key in self.PARAMS and self.PARAMS[key].is_required:\n            continue\n        del jwk[key]\n\n    return jwk\n</code></pre>"},{"location":"api/#jwskate.jwk.base.Jwk.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare JWK keys, ignoring optional/informational fields.</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Compare JWK keys, ignoring optional/informational fields.\"\"\"\n    other = to_jwk(other)\n    return super(Jwk, self.minimize()).__eq__(other.minimize())\n</code></pre>"},{"location":"api/#jwskate.jwk.select_alg_class","title":"select_alg_class","text":"<pre><code>select_alg_class(\n    supported_algs: Mapping[str, T],\n    *,\n    jwk_alg: str | None = None,\n    alg: str | None = None,\n    strict: bool = False\n) -&gt; T\n</code></pre> <p>Choose the appropriate alg class to use for cryptographic operations.</p> <p>Given: - a mapping of supported algs names to wrapper classes - a preferred alg name (usually the one mentioned in a JWK) - and/or a user-specified alg this returns the wrapper class to use.</p> <p>This checks the coherency between the user specified <code>alg</code> and the <code>jwk_alg</code>, and will emit a warning if the user specified alg is different from the <code>jwk_alg</code>.</p> <p>Parameters:</p> Name Type Description Default <code>supported_algs</code> <code>Mapping[str, T]</code> <p>a mapping of supported alg names to alg wrapper</p> required <code>jwk_alg</code> <code>str | None</code> <p>the alg from the JWK, if any</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>a user specified alg</p> <code>None</code> <code>strict</code> <code>bool</code> <p>if <code>True</code> and alg does not match <code>jwk_alg</code>, raise a <code>MismatchingAlg</code> exception. If <code>False</code>, warn instead.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>the alg to use</p> <p>Raises:</p> Type Description <code>UnsupportedAlg</code> <p>if the requested <code>alg</code> is not supported</p> <code>ValueError</code> <p>if <code>supported_algs</code> is empty</p> <code>MismatchingAlg</code> <p>if <code>alg</code> does not match <code>jwk_alg</code></p> Source code in <code>jwskate/jwk/alg.py</code> <pre><code>def select_alg_class(\n    supported_algs: Mapping[str, T],\n    *,\n    jwk_alg: str | None = None,\n    alg: str | None = None,\n    strict: bool = False,\n) -&gt; T:\n\"\"\"Choose the appropriate alg class to use for cryptographic operations.\n\n    Given:\n    - a mapping of supported algs names to wrapper classes\n    - a preferred alg name (usually the one mentioned in a JWK)\n    - and/or a user-specified alg\n    this returns the wrapper class to use.\n\n    This checks the coherency between the user specified `alg` and the `jwk_alg`, and will emit a warning\n    if the user specified alg is different from the `jwk_alg`.\n\n    Args:\n      supported_algs: a mapping of supported alg names to alg wrapper\n      jwk_alg: the alg from the JWK, if any\n      alg: a user specified alg\n      strict: if `True` and alg does not match `jwk_alg`, raise a `MismatchingAlg` exception. If `False`, warn instead.\n\n    Returns:\n      the alg to use\n\n    Raises:\n        UnsupportedAlg: if the requested `alg` is not supported\n        ValueError: if `supported_algs` is empty\n        MismatchingAlg: if `alg` does not match `jwk_alg`\n\n    \"\"\"\n    if not supported_algs:\n        raise ValueError(\"No possible algorithms to choose from!\")\n\n    choosen_alg: str\n    if jwk_alg is not None:\n        if alg is not None:\n            if jwk_alg != alg:\n                if strict:\n                    raise MismatchingAlg(jwk_alg, alg)\n                else:\n                    warnings.warn(\n                        \"This key has an 'alg' parameter, you should use that alg for each operation.\"\n                    )\n            choosen_alg = alg\n        else:\n            choosen_alg = jwk_alg\n    elif alg is not None:\n        choosen_alg = alg\n    else:\n        raise ExpectedAlgRequired(\n            \"This key doesn't have an 'alg' parameter specifying which algorithm to use with that key, \"\n            \"so you need to provide the expected signing alg(s) for each operation.\"\n        )\n\n    try:\n        return supported_algs[choosen_alg]\n    except KeyError:\n        raise UnsupportedAlg(\n            f\"Alg {choosen_alg} is not supported. Supported algs: {list(supported_algs)}.\"\n        )\n</code></pre>"},{"location":"api/#jwskate.jwk.select_alg_classes","title":"select_alg_classes","text":"<pre><code>select_alg_classes(\n    supported_algs: Mapping[str, T],\n    *,\n    jwk_alg: str | None = None,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n    strict: bool = False\n) -&gt; list[T]\n</code></pre> <p>Select several appropriate algs classes to use on cryptographic operations.</p> <p>This method is typically used to get the list of valid algorithms when checking a signature, when several algorithms are allowed.</p> <p>Given: - a mapping of supported algorithms name to wrapper classes - an alg parameter from a JWK - and/or a user-specified alg - and/or a user specified list of usable algs this returns a list of supported alg wrapper classes that matches what the user specified, or, as default, the alg parameter from the JWK.</p> <p>This checks the coherency between the user specified <code>alg</code> and the <code>jwk_alg</code>, and will emit a warning if the user specified alg is different from the <code>jwk_alg</code>.</p> <p>Parameters:</p> Name Type Description Default <code>supported_algs</code> <code>Mapping[str, T]</code> <p>a mapping of alg names to alg wrappers</p> required <code>jwk_alg</code> <code>str | None</code> <p>the alg from the JWK, if any</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>a user specified alg to use, if any</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>a user specified list of algs to use, if several are allowed</p> <code>None</code> <code>strict</code> <code>bool</code> <p>if <code>True</code> and alg does not match <code>jwk_alg</code>, raise a <code>MismatchingAlg</code> exception. If <code>False</code>, warn instead.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[T]</code> <p>a list of possible algs to check</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if both 'alg' and 'algs' parameters are used</p> <code>UnsupportedAlg</code> <p>if none of the requested alg are supported</p> Source code in <code>jwskate/jwk/alg.py</code> <pre><code>def select_alg_classes(\n    supported_algs: Mapping[str, T],\n    *,\n    jwk_alg: str | None = None,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n    strict: bool = False,\n) -&gt; list[T]:\n\"\"\"Select several appropriate algs classes to use on cryptographic operations.\n\n    This method is typically used to get the list of valid algorithms when checking a signature, when several algorithms are allowed.\n\n    Given:\n    - a mapping of supported algorithms name to wrapper classes\n    - an alg parameter from a JWK\n    - and/or a user-specified alg\n    - and/or a user specified list of usable algs\n    this returns a list of supported alg wrapper classes that matches what the user specified, or, as default, the alg parameter from the JWK.\n\n    This checks the coherency between the user specified `alg` and the `jwk_alg`, and will emit a warning\n    if the user specified alg is different from the `jwk_alg`.\n\n    Args:\n      supported_algs: a mapping of alg names to alg wrappers\n      jwk_alg: the alg from the JWK, if any\n      alg: a user specified alg to use, if any\n      algs: a user specified list of algs to use, if several are allowed\n      strict: if `True` and alg does not match `jwk_alg`, raise a `MismatchingAlg` exception. If `False`, warn instead.\n\n    Returns:\n      a list of possible algs to check\n\n    Raises:\n        ValueError: if both 'alg' and 'algs' parameters are used\n        UnsupportedAlg: if none of the requested alg are supported\n\n    \"\"\"\n    if alg and algs:\n        raise ValueError(\"Please use either parameter 'alg' or 'algs', not both.\")\n\n    if not supported_algs:\n        raise ValueError(\"No possible algorithms to choose from!\")\n\n    if jwk_alg is not None:\n        if (alg and alg != jwk_alg) or (algs and jwk_alg not in algs):\n            if strict:\n                raise MismatchingAlg(jwk_alg, alg, algs)\n            else:\n                requested_alg = f\"{alg=}\" if alg else f\"{algs=}\"\n                warnings.warn(\n                    f\"This key has an 'alg' parameter with value {jwk_alg}, so you should use it with that alg only.\"\n                    f\"You requested {requested_alg}.\"\n                )\n\n    possible_algs: list[str] = []\n    if alg:\n        possible_algs = [alg]\n    elif algs:\n        possible_algs = list(algs)\n    elif jwk_alg:\n        possible_algs = [jwk_alg]\n\n    if possible_algs:\n        possible_supported_algs = [\n            supported_algs[alg] for alg in possible_algs if alg in supported_algs\n        ]\n        if possible_supported_algs:\n            return possible_supported_algs\n        else:\n            raise UnsupportedAlg(\n                f\"None of the user-specified alg(s) are supported. {possible_algs}\"\n            )\n\n    raise ExpectedAlgRequired(\n        \"This key doesn't have an 'alg' parameter specifying which algorithm to use with that key, \"\n        \"so you need to provide the expected signing alg(s) for each operation.\"\n    )\n</code></pre>"},{"location":"api/#jwskate.jwk.to_jwk","title":"to_jwk","text":"<pre><code>to_jwk(\n    key: Any,\n    *,\n    kty: str | None = None,\n    is_private: bool | None = None,\n    is_symmetric: bool | None = None\n) -&gt; Jwk\n</code></pre> <p>Convert any supported kind of key to a <code>Jwk</code>.</p> <p>This optionally check if that key is private or symmetric.</p> <p>The key can be any type supported by Jwk: - a <code>cryptography</code> key instance - a bytes, to initialize a symmetric key - a JWK, as a dict or as a JSON formatted string - an existing Jwk instance If the supplied param is already a Jwk, it is left untouched.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>the key material</p> required <code>kty</code> <code>str | None</code> <p>the expected key type</p> <code>None</code> <code>is_private</code> <code>bool | None</code> <p>if <code>True</code>, check if the key is private, if <code>False</code>, check if it is public, if <code>None</code>, do nothing</p> <code>None</code> <code>is_symmetric</code> <code>bool | None</code> <p>if <code>True</code>, check if the key is symmetric, if <code>False</code>, check if it is asymmetric, if <code>None</code>, do nothing</p> <code>None</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>a Jwk key</p> Source code in <code>jwskate/jwk/base.py</code> <pre><code>def to_jwk(\n    key: Any,\n    *,\n    kty: str | None = None,\n    is_private: bool | None = None,\n    is_symmetric: bool | None = None,\n) -&gt; Jwk:\n\"\"\"Convert any supported kind of key to a `Jwk`.\n\n    This optionally check if that key is private or symmetric.\n\n    The key can be any type supported by Jwk:\n    - a `cryptography` key instance\n    - a bytes, to initialize a symmetric key\n    - a JWK, as a dict or as a JSON formatted string\n    - an existing Jwk instance\n    If the supplied param is already a Jwk, it is left untouched.\n\n    Args:\n        key: the key material\n        kty: the expected key type\n        is_private: if `True`, check if the key is private, if `False`, check if it is public, if `None`, do nothing\n        is_symmetric: if `True`, check if the key is symmetric, if `False`, check if it is asymmetric, if `None`, do nothing\n\n    Returns:\n        a Jwk key\n\n    \"\"\"\n    jwk = key if isinstance(key, Jwk) else Jwk(key)\n    return jwk.check(kty=kty, is_private=is_private, is_symmetric=is_symmetric)\n</code></pre>"},{"location":"api/#jwskate.jwt","title":"jwskate.jwt","text":"<p>This module contains all Json Web Key (Jwk) related classes and utilities.</p>"},{"location":"api/#jwskate.jwt.JwtVerifier","title":"JwtVerifier","text":"<p>A helper class to validate JWTs tokens in a real application.</p> <p>Parameters:</p> Name Type Description Default <code>jwkset</code> <code>JwkSet | Jwk | dict[str, Any]</code> <p>a <code>JwkSet</code> or <code>Jwk</code> which will verify the token signatures</p> required <code>issuer</code> <code>str | None</code> <p>expected issuer value</p> required <code>audience</code> <code>str | None</code> <p>expected audience value</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>expected signature alg, if there is only one</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>expected signature algs, if there are several</p> <code>None</code> <code>leeway</code> <code>int</code> <p>number of seconds to allow when verifying token validity period</p> <code>10</code> <code>verifiers</code> <code>Iterable[Callable[[SignedJwt], None]] | None</code> <p>additional verifiers to implement custom checks on the tokens</p> <code>None</code> Usage <pre><code>from jwskate import JwtVerifier\n\n# initialize a JwtVerifier based on its expected issuer, audience, JwkSet and allowed signature algs\njwks = requests.get(\"https://myissuer.local/jwks\").json()\nverifier = JwtVerifier(\n    issuer=\"https://myissuer.local\", jwkset=jwks, audience=\"myapp\", alg=\"ES256\"\n)\n\n# then verify tokens\ntry:\n    verifier.verify(\n        \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL215aXNzdWVyLmxvY2FsIiwiYXVkIjoibXlhcHAiLCJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNjcyNzU5NjM0LCJleHAiOjE2NzI3NTk2OTR9.Uu5DtCnf9cwYtem8tQ4trHVgXyZBoa8fhFcGL87O2D4\"\n    )\n    print(\"token is verified!\")\nexcept ValueError:\n    print(\"token failed verification :(\")\n</code></pre> Source code in <code>jwskate/jwt/verifier.py</code> <pre><code>class JwtVerifier:\n\"\"\"A helper class to validate JWTs tokens in a real application.\n\n    Args:\n        jwkset: a `JwkSet` or `Jwk` which will verify the token signatures\n        issuer: expected issuer value\n        audience: expected audience value\n        alg: expected signature alg, if there is only one\n        algs: expected signature algs, if there are several\n        leeway: number of seconds to allow when verifying token validity period\n        verifiers: additional verifiers to implement custom checks on the tokens\n\n    Usage:\n        ```python\n        from jwskate import JwtVerifier\n\n        # initialize a JwtVerifier based on its expected issuer, audience, JwkSet and allowed signature algs\n        jwks = requests.get(\"https://myissuer.local/jwks\").json()\n        verifier = JwtVerifier(\n            issuer=\"https://myissuer.local\", jwkset=jwks, audience=\"myapp\", alg=\"ES256\"\n        )\n\n        # then verify tokens\n        try:\n            verifier.verify(\n                \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL215aXNzdWVyLmxvY2FsIiwiYXVkIjoibXlhcHAiLCJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNjcyNzU5NjM0LCJleHAiOjE2NzI3NTk2OTR9.Uu5DtCnf9cwYtem8tQ4trHVgXyZBoa8fhFcGL87O2D4\"\n            )\n            print(\"token is verified!\")\n        except ValueError:\n            print(\"token failed verification :(\")\n        ```\n\n    \"\"\"\n\n    def __init__(\n        self,\n        jwkset: JwkSet | Jwk | dict[str, Any],\n        *,\n        issuer: str | None,\n        audience: str | None = None,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n        leeway: int = 10,\n        verifiers: Iterable[Callable[[SignedJwt], None]] | None = None,\n    ) -&gt; None:\n        if isinstance(jwkset, Jwk):\n            jwkset = jwkset.as_jwks()\n        elif isinstance(jwkset, dict):\n            if \"keys\" in jwkset:\n                jwkset = JwkSet(jwkset)\n            else:\n                jwkset = Jwk(jwkset).as_jwks()\n\n        if not isinstance(jwkset, JwkSet) or jwkset.is_private:\n            raise ValueError(\n                \"Please provide either a `JwkSet` or a single `Jwk` for signature verification. \"\n                \"Signature verification keys must be public.\"\n            )\n\n        self.issuer = issuer\n        self.jwkset = jwkset\n        self.audience = audience\n        self.alg = alg\n        self.algs = algs\n        self.leeway = leeway\n        self.verifiers = list(verifiers) if verifiers else []\n\n    def verify(self, jwt: SignedJwt | str) -&gt; None:\n\"\"\"Verify a given JWT token.\n\n        This checks the token signature, issuer, audience and expiration date, plus any custom verification,\n        as configured at init time.\n\n        Args:\n            jwt: the JWT token to verify\n\n        \"\"\"\n        if not isinstance(jwt, SignedJwt):\n            jwt = SignedJwt(jwt)\n\n        if self.issuer and jwt.issuer != self.issuer:\n            raise InvalidClaim(\"Mismatching issuer\", self.issuer, jwt.issuer)\n\n        if self.audience and self.audience not in jwt.audiences:\n            raise InvalidClaim(\"Mismatching audience\", self.audience, jwt.audiences)\n\n        if \"kid\" in jwt.headers:\n            jwk = self.jwkset.get_jwk_by_kid(jwt.kid)\n            if not jwt.verify_signature(jwk, alg=self.alg, algs=self.algs):\n                raise InvalidSignature()\n        else:\n            for jwk in self.jwkset.verification_keys():\n                if jwt.verify_signature(jwk, alg=self.alg, algs=self.algs):\n                    break\n            else:\n                raise InvalidSignature()\n\n        if jwt.is_expired(self.leeway):\n            raise ExpiredJwt(f\"Jwt token expired at {jwt.expires_at}\")\n\n        for verifier in self.verifiers:\n            verifier(jwt)\n\n    def custom_verifier(self, verifier: Callable[[SignedJwt], None]) -&gt; None:\n\"\"\"A decorator to add custom verification steps to this verifier.\n\n        Usage:\n            ```python\n            from jwskate import Jwk, JwtVerifier\n\n            verification_key = Jwk(\n                {\"kty\": \"oct\", \"k\": \"eW91ci0yNTYtYml0LXNlY3JldA\", \"alg\": \"HS256\"}\n            )\n            verifier = JwtVerifier(verification_key.as_jwks(), issuer=\"https://foo.bar\")\n\n\n            @verifier.custom_verifier\n            def must_contain_claim_foo(jwt):\n                if \"foo\" not in jwt:\n                    raise ValueError(\"No foo!\")\n\n\n            verifier.verify(\n                \"eyJhbGciOiJIUzI1NiIsImtpZCI6ImlfdXRLRXhBS05jXy1hd3FEUkFVYmFoTWd5RGFLREdfTTc1S01Cd2xBdkEifQ.eyJpc3MiOiJodHRwczovL2Zvby5iYXIiLCJmb28iOiJZRVMiLCJpYXQiOjE1MTYyMzkwMjJ9.hk2vnymjcww8K-OcOkNCPUiJK-8Rj--RKJqsHSKe4jM\"\n            )\n            ```\n\n        \"\"\"\n        self.verifiers.append(verifier)\n</code></pre>"},{"location":"api/#jwskate.jwt.verifier.JwtVerifier.verify","title":"verify","text":"<pre><code>verify(jwt: SignedJwt | str) -&gt; None\n</code></pre> <p>Verify a given JWT token.</p> <p>This checks the token signature, issuer, audience and expiration date, plus any custom verification, as configured at init time.</p> <p>Parameters:</p> Name Type Description Default <code>jwt</code> <code>SignedJwt | str</code> <p>the JWT token to verify</p> required Source code in <code>jwskate/jwt/verifier.py</code> <pre><code>def verify(self, jwt: SignedJwt | str) -&gt; None:\n\"\"\"Verify a given JWT token.\n\n    This checks the token signature, issuer, audience and expiration date, plus any custom verification,\n    as configured at init time.\n\n    Args:\n        jwt: the JWT token to verify\n\n    \"\"\"\n    if not isinstance(jwt, SignedJwt):\n        jwt = SignedJwt(jwt)\n\n    if self.issuer and jwt.issuer != self.issuer:\n        raise InvalidClaim(\"Mismatching issuer\", self.issuer, jwt.issuer)\n\n    if self.audience and self.audience not in jwt.audiences:\n        raise InvalidClaim(\"Mismatching audience\", self.audience, jwt.audiences)\n\n    if \"kid\" in jwt.headers:\n        jwk = self.jwkset.get_jwk_by_kid(jwt.kid)\n        if not jwt.verify_signature(jwk, alg=self.alg, algs=self.algs):\n            raise InvalidSignature()\n    else:\n        for jwk in self.jwkset.verification_keys():\n            if jwt.verify_signature(jwk, alg=self.alg, algs=self.algs):\n                break\n        else:\n            raise InvalidSignature()\n\n    if jwt.is_expired(self.leeway):\n        raise ExpiredJwt(f\"Jwt token expired at {jwt.expires_at}\")\n\n    for verifier in self.verifiers:\n        verifier(jwt)\n</code></pre>"},{"location":"api/#jwskate.jwt.verifier.JwtVerifier.custom_verifier","title":"custom_verifier","text":"<pre><code>custom_verifier(\n    verifier: Callable[[SignedJwt], None]\n) -&gt; None\n</code></pre> <p>A decorator to add custom verification steps to this verifier.</p> Usage <pre><code>from jwskate import Jwk, JwtVerifier\n\nverification_key = Jwk(\n    {\"kty\": \"oct\", \"k\": \"eW91ci0yNTYtYml0LXNlY3JldA\", \"alg\": \"HS256\"}\n)\nverifier = JwtVerifier(verification_key.as_jwks(), issuer=\"https://foo.bar\")\n\n\n@verifier.custom_verifier\ndef must_contain_claim_foo(jwt):\n    if \"foo\" not in jwt:\n        raise ValueError(\"No foo!\")\n\n\nverifier.verify(\n    \"eyJhbGciOiJIUzI1NiIsImtpZCI6ImlfdXRLRXhBS05jXy1hd3FEUkFVYmFoTWd5RGFLREdfTTc1S01Cd2xBdkEifQ.eyJpc3MiOiJodHRwczovL2Zvby5iYXIiLCJmb28iOiJZRVMiLCJpYXQiOjE1MTYyMzkwMjJ9.hk2vnymjcww8K-OcOkNCPUiJK-8Rj--RKJqsHSKe4jM\"\n)\n</code></pre> Source code in <code>jwskate/jwt/verifier.py</code> <pre><code>def custom_verifier(self, verifier: Callable[[SignedJwt], None]) -&gt; None:\n\"\"\"A decorator to add custom verification steps to this verifier.\n\n    Usage:\n        ```python\n        from jwskate import Jwk, JwtVerifier\n\n        verification_key = Jwk(\n            {\"kty\": \"oct\", \"k\": \"eW91ci0yNTYtYml0LXNlY3JldA\", \"alg\": \"HS256\"}\n        )\n        verifier = JwtVerifier(verification_key.as_jwks(), issuer=\"https://foo.bar\")\n\n\n        @verifier.custom_verifier\n        def must_contain_claim_foo(jwt):\n            if \"foo\" not in jwt:\n                raise ValueError(\"No foo!\")\n\n\n        verifier.verify(\n            \"eyJhbGciOiJIUzI1NiIsImtpZCI6ImlfdXRLRXhBS05jXy1hd3FEUkFVYmFoTWd5RGFLREdfTTc1S01Cd2xBdkEifQ.eyJpc3MiOiJodHRwczovL2Zvby5iYXIiLCJmb28iOiJZRVMiLCJpYXQiOjE1MTYyMzkwMjJ9.hk2vnymjcww8K-OcOkNCPUiJK-8Rj--RKJqsHSKe4jM\"\n        )\n        ```\n\n    \"\"\"\n    self.verifiers.append(verifier)\n</code></pre>"},{"location":"api/#jwskate.jwt.ExpiredJwt","title":"ExpiredJwt","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when trying to validate an expired JWT token.</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>class ExpiredJwt(ValueError):\n\"\"\"Raised when trying to validate an expired JWT token.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwt.InvalidJwt","title":"InvalidJwt","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when an invalid Jwt is parsed.</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>class InvalidJwt(ValueError):\n\"\"\"Raised when an invalid Jwt is parsed.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwt.InvalidSignature","title":"InvalidSignature","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when trying to validate a JWT with an invalid signature.</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>class InvalidSignature(ValueError):\n\"\"\"Raised when trying to validate a JWT with an invalid signature.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwt.Jwt","title":"Jwt","text":"<p>             Bases: <code>BaseCompactToken</code></p> <p>Represents a Json Web Token.</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>class Jwt(BaseCompactToken):\n\"\"\"Represents a Json Web Token.\"\"\"\n\n    def __new__(cls, value: bytes | str, max_size: int = 16 * 1024) -&gt; SignedJwt | JweCompact | Jwt:  # type: ignore[misc]\n\"\"\"Allow parsing both Signed and Encrypted JWTs.\n\n        This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT.\n\n        Args:\n            value: the token value\n            max_size: maximum allowed size for the token\n\n        \"\"\"\n        if not isinstance(value, bytes):\n            value = value.encode(\"ascii\")\n\n        if cls == Jwt:\n            if value.count(b\".\") == 2:\n                from .signed import SignedJwt\n\n                return super().__new__(SignedJwt)\n            elif value.count(b\".\") == 4:\n                from ..jwe import JweCompact\n\n                return JweCompact(value, max_size)\n\n        return super().__new__(cls)\n\n    @classmethod\n    def sign(\n        cls,\n        claims: dict[str, Any],\n        key: Jwk | dict[str, Any] | Any,\n        alg: str | None = None,\n        typ: str | None = \"JWT\",\n        extra_headers: dict[str, Any] | None = None,\n    ) -&gt; SignedJwt:\n\"\"\"Sign a JSON payload with a private key and return the resulting `SignedJwt`.\n\n        This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none),\n        use `.unprotected()` instead.\n\n        Args:\n          claims: the payload to sign\n          key: the key to use for signing\n          alg: the alg to use for signing\n          typ: typ (token type) header to include. If `None`, do not include this header.\n          extra_headers: additional headers to include in the Jwt\n\n        Returns:\n          the resulting token\n\n        \"\"\"\n        key = to_jwk(key)\n\n        alg = alg or key.get(\"alg\")\n\n        if alg is None:\n            raise ValueError(\"a signing alg is required\")\n\n        extra_headers = extra_headers or {}\n        headers = dict(alg=alg, **extra_headers)\n        if typ:\n            headers[\"typ\"] = typ\n        if key.kid:\n            headers[\"kid\"] = key.kid\n\n        return cls.sign_arbitrary(claims=claims, headers=headers, key=key, alg=alg)\n\n    @classmethod\n    def sign_arbitrary(\n        self,\n        claims: dict[str, Any],\n        headers: dict[str, Any],\n        key: Jwk | dict[str, Any] | Any,\n        alg: str | None = None,\n    ) -&gt; SignedJwt:\n\"\"\"Sign provided headers and claims with a private key and return the resulting `SignedJwt`.\n\n        This does not check the consistency between headers, key, alg and kid.\n        DO NOT USE THIS METHOD UNLESS YOU KNOW WHAT YOU ARE DOING!!!\n        Use `Jwt.sign()` to make sure you are signing tokens properly.\n\n        Args:\n             claims: the payload to sign\n             headers: the headers to sign\n             key: the key to use for signing\n             alg: the alg to use for signing\n\n        \"\"\"\n        from .signed import SignedJwt\n\n        key = to_jwk(key)\n\n        alg = alg or key.get(\"alg\")\n\n        if alg is None:\n            raise ValueError(\"a signing alg is required\")\n\n        headers_part = BinaPy.serialize_to(\"json\", headers).to(\"b64u\")\n        claims_part = BinaPy.serialize_to(\"json\", claims).to(\"b64u\")\n        signed_value = b\".\".join((headers_part, claims_part))\n        signature = key.sign(signed_value, alg=alg).to(\"b64u\")\n        return SignedJwt(b\".\".join((signed_value, signature)))\n\n    @classmethod\n    def unprotected(\n        cls,\n        claims: dict[str, Any],\n        typ: str | None = \"JWT\",\n        extra_headers: dict[str, Any] | None = None,\n    ) -&gt; SignedJwt:\n\"\"\"Generate a JWT that is not signed and not encrypted (with alg=none).\n\n        Args:\n          claims: the claims to set in the token.\n          typ: typ (token type) header to include. If `None`, do not include this header.\n          extra_headers: additional headers to insert in the token.\n\n        Returns:\n            the resulting token\n\n        \"\"\"\n        from .signed import SignedJwt\n\n        headers = dict(extra_headers or {}, alg=\"none\")\n        if typ:\n            headers[\"typ\"] = typ\n\n        headers_part = BinaPy.serialize_to(\"json\", headers).to(\"b64u\")\n        claims_part = BinaPy.serialize_to(\"json\", claims).to(\"b64u\")\n        signed_value = b\".\".join((headers_part, claims_part))\n        signature = b\"\"\n        return SignedJwt(b\".\".join((signed_value, signature)))\n\n    @classmethod\n    def sign_and_encrypt(\n        cls,\n        claims: dict[str, Any],\n        sign_key: Jwk | dict[str, Any] | Any,\n        enc_key: Jwk | dict[str, Any] | Any,\n        enc: str,\n        *,\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        sign_extra_headers: dict[str, Any] | None = None,\n        enc_extra_headers: dict[str, Any] | None = None,\n    ) -&gt; JweCompact:\n\"\"\"Sign a JWT, then encrypt it as JWE payload.\n\n        This is a convenience method to do both the signing and encryption, in appropriate order.\n\n        Args:\n          claims: the payload to encrypt\n          sign_key: the Jwk to use for signature\n          sign_alg: the alg to use for signature\n          sign_extra_headers: additional headers for the inner signed JWT\n          enc_key: the Jwk to use for encryption\n          enc_alg: the alg to use for CEK encryption\n          enc: the alg to use for payload encryption\n          enc_extra_headers: additional headers for the outer encrypted JWE\n\n        Returns:\n          the resulting JWE token, with the signed JWT as payload\n\n        \"\"\"\n        enc_extra_headers = enc_extra_headers or {}\n        enc_extra_headers.setdefault(\"cty\", \"JWT\")\n\n        inner_jwt = cls.sign(\n            claims, key=sign_key, alg=sign_alg, extra_headers=sign_extra_headers\n        )\n        jwe = JweCompact.encrypt(\n            inner_jwt, enc_key, enc=enc, alg=enc_alg, extra_headers=enc_extra_headers\n        )\n        return jwe\n\n    @classmethod\n    def decrypt_nested_jwt(\n        cls, jwe: str | JweCompact, key: Jwk | dict[str, Any] | Any\n    ) -&gt; Jwt:\n\"\"\"Decrypt a JWE that contains a nested JWT.\n\n        It will return a [Jwt] instance for the inner JWT.\n\n        Args:\n            jwe: the JWE containing a nested Token\n            key: the decryption key\n\n        Returns:\n            the inner JWT\n\n        Raises:\n            InvalidJwt: if the inner JWT is not valid\n\n        \"\"\"\n        if not isinstance(jwe, JweCompact):\n            jwe = JweCompact(jwe)\n        cleartext = jwe.decrypt(key)\n        return Jwt(cleartext)\n\n    @classmethod\n    def decrypt_and_verify(\n        cls,\n        jwt: str | JweCompact,\n        enc_key: Jwk | dict[str, Any] | Any,\n        sig_key: Jwk | dict[str, Any] | None | Any,\n        sig_alg: str | None = None,\n        sig_algs: Iterable[str] | None = None,\n    ) -&gt; SignedJwt:\n\"\"\"Decrypt then verify the signature of a JWT nested in a JWE.\n\n        This can only be used with signed then encrypted Jwt, such as those produce by `Jwt.sign_and_encrypt()`.\n\n        Args:\n            jwt: the JWE containing a nested signed JWT\n            enc_key: the decryption key\n            sig_key: the signature verification key\n            sig_alg: the signature verification alg, if only 1 is allowed\n            sig_algs: the signature verifications algs, if several are allowed\n\n        Returns:\n            the nested signed JWT, in clear-text, signature already verified\n\n        Raises:\n            InvalidJwt: if the JWT is not valid\n            InvalidSignature: if the nested JWT signature is not valid\n\n        \"\"\"\n        from .signed import InvalidSignature, SignedJwt\n\n        nested_jwt = cls.decrypt_nested_jwt(jwt, enc_key)\n        if not isinstance(nested_jwt, SignedJwt):\n            raise ValueError(\"Nested JWT is not signed\", nested_jwt)\n\n        if sig_key:\n            if nested_jwt.verify_signature(sig_key, sig_alg, sig_algs):\n                return nested_jwt\n\n        raise InvalidSignature()\n\n    @classmethod\n    def timestamp(cls, delta_seconds: int = 0) -&gt; int:\n\"\"\"Return an integer timestamp that is suitable for use in Jwt tokens.\n\n        Timestamps are used in particular for `iat`, `exp` and `nbf` claims.\n\n        A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds.\n\n        By default, the current timestamp is returned. You can include `delta_seconds` to have a timestamp\n        a number of seconds in the future (if positive) or in the past (if negative).\n\n        Args:\n            delta_seconds: number of seconds in the future or in the past compared to current time\n\n        Returns:\n            An integer timestamp\n\n        \"\"\"\n        return int(datetime.now(timezone.utc).timestamp()) + delta_seconds\n\n    @classmethod\n    def timestamp_to_datetime(cls, timestamp: int) -&gt; datetime:\n\"\"\"Convert a JWT timestamp to a `datetime`.\n\n        Returned datetime is always in the UTC timezone.\n\n        Args:\n            timestamp: a timestamp from a JWT token\n\n        Returns:\n            the corresponding `datetime` in UTC timezone\n\n        \"\"\"\n        return datetime.fromtimestamp(timestamp, tz=timezone.utc)\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.__new__","title":"__new__","text":"<pre><code>__new__(\n    value: bytes | str, max_size: int = 16 * 1024\n) -&gt; SignedJwt | JweCompact | Jwt\n</code></pre> <p>Allow parsing both Signed and Encrypted JWTs.</p> <p>This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes | str</code> <p>the token value</p> required <code>max_size</code> <code>int</code> <p>maximum allowed size for the token</p> <code>16 * 1024</code> Source code in <code>jwskate/jwt/base.py</code> <pre><code>def __new__(cls, value: bytes | str, max_size: int = 16 * 1024) -&gt; SignedJwt | JweCompact | Jwt:  # type: ignore[misc]\n\"\"\"Allow parsing both Signed and Encrypted JWTs.\n\n    This returns the appropriate subclass or instance depending on the number of dots (.) in the serialized JWT.\n\n    Args:\n        value: the token value\n        max_size: maximum allowed size for the token\n\n    \"\"\"\n    if not isinstance(value, bytes):\n        value = value.encode(\"ascii\")\n\n    if cls == Jwt:\n        if value.count(b\".\") == 2:\n            from .signed import SignedJwt\n\n            return super().__new__(SignedJwt)\n        elif value.count(b\".\") == 4:\n            from ..jwe import JweCompact\n\n            return JweCompact(value, max_size)\n\n    return super().__new__(cls)\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.sign","title":"sign  <code>classmethod</code>","text":"<pre><code>sign(\n    claims: dict[str, Any],\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    typ: str | None = \"JWT\",\n    extra_headers: dict[str, Any] | None = None,\n) -&gt; SignedJwt\n</code></pre> <p>Sign a JSON payload with a private key and return the resulting <code>SignedJwt</code>.</p> <p>This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none), use <code>.unprotected()</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>dict[str, Any]</code> <p>the payload to sign</p> required <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the key to use for signing</p> required <code>alg</code> <code>str | None</code> <p>the alg to use for signing</p> <code>None</code> <code>typ</code> <code>str | None</code> <p>typ (token type) header to include. If <code>None</code>, do not include this header.</p> <code>'JWT'</code> <code>extra_headers</code> <code>dict[str, Any] | None</code> <p>additional headers to include in the Jwt</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>the resulting token</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>@classmethod\ndef sign(\n    cls,\n    claims: dict[str, Any],\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    typ: str | None = \"JWT\",\n    extra_headers: dict[str, Any] | None = None,\n) -&gt; SignedJwt:\n\"\"\"Sign a JSON payload with a private key and return the resulting `SignedJwt`.\n\n    This method cannot generate a token without a signature. If you want to use an unsigned token (with alg=none),\n    use `.unprotected()` instead.\n\n    Args:\n      claims: the payload to sign\n      key: the key to use for signing\n      alg: the alg to use for signing\n      typ: typ (token type) header to include. If `None`, do not include this header.\n      extra_headers: additional headers to include in the Jwt\n\n    Returns:\n      the resulting token\n\n    \"\"\"\n    key = to_jwk(key)\n\n    alg = alg or key.get(\"alg\")\n\n    if alg is None:\n        raise ValueError(\"a signing alg is required\")\n\n    extra_headers = extra_headers or {}\n    headers = dict(alg=alg, **extra_headers)\n    if typ:\n        headers[\"typ\"] = typ\n    if key.kid:\n        headers[\"kid\"] = key.kid\n\n    return cls.sign_arbitrary(claims=claims, headers=headers, key=key, alg=alg)\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.sign_arbitrary","title":"sign_arbitrary  <code>classmethod</code>","text":"<pre><code>sign_arbitrary(\n    claims: dict[str, Any],\n    headers: dict[str, Any],\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n) -&gt; SignedJwt\n</code></pre> <p>Sign provided headers and claims with a private key and return the resulting <code>SignedJwt</code>.</p> <p>This does not check the consistency between headers, key, alg and kid. DO NOT USE THIS METHOD UNLESS YOU KNOW WHAT YOU ARE DOING!!! Use <code>Jwt.sign()</code> to make sure you are signing tokens properly.</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>dict[str, Any]</code> <p>the payload to sign</p> required <code>headers</code> <code>dict[str, Any]</code> <p>the headers to sign</p> required <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the key to use for signing</p> required <code>alg</code> <code>str | None</code> <p>the alg to use for signing</p> <code>None</code> Source code in <code>jwskate/jwt/base.py</code> <pre><code>@classmethod\ndef sign_arbitrary(\n    self,\n    claims: dict[str, Any],\n    headers: dict[str, Any],\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n) -&gt; SignedJwt:\n\"\"\"Sign provided headers and claims with a private key and return the resulting `SignedJwt`.\n\n    This does not check the consistency between headers, key, alg and kid.\n    DO NOT USE THIS METHOD UNLESS YOU KNOW WHAT YOU ARE DOING!!!\n    Use `Jwt.sign()` to make sure you are signing tokens properly.\n\n    Args:\n         claims: the payload to sign\n         headers: the headers to sign\n         key: the key to use for signing\n         alg: the alg to use for signing\n\n    \"\"\"\n    from .signed import SignedJwt\n\n    key = to_jwk(key)\n\n    alg = alg or key.get(\"alg\")\n\n    if alg is None:\n        raise ValueError(\"a signing alg is required\")\n\n    headers_part = BinaPy.serialize_to(\"json\", headers).to(\"b64u\")\n    claims_part = BinaPy.serialize_to(\"json\", claims).to(\"b64u\")\n    signed_value = b\".\".join((headers_part, claims_part))\n    signature = key.sign(signed_value, alg=alg).to(\"b64u\")\n    return SignedJwt(b\".\".join((signed_value, signature)))\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.unprotected","title":"unprotected  <code>classmethod</code>","text":"<pre><code>unprotected(\n    claims: dict[str, Any],\n    typ: str | None = \"JWT\",\n    extra_headers: dict[str, Any] | None = None,\n) -&gt; SignedJwt\n</code></pre> <p>Generate a JWT that is not signed and not encrypted (with alg=none).</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>dict[str, Any]</code> <p>the claims to set in the token.</p> required <code>typ</code> <code>str | None</code> <p>typ (token type) header to include. If <code>None</code>, do not include this header.</p> <code>'JWT'</code> <code>extra_headers</code> <code>dict[str, Any] | None</code> <p>additional headers to insert in the token.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>the resulting token</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>@classmethod\ndef unprotected(\n    cls,\n    claims: dict[str, Any],\n    typ: str | None = \"JWT\",\n    extra_headers: dict[str, Any] | None = None,\n) -&gt; SignedJwt:\n\"\"\"Generate a JWT that is not signed and not encrypted (with alg=none).\n\n    Args:\n      claims: the claims to set in the token.\n      typ: typ (token type) header to include. If `None`, do not include this header.\n      extra_headers: additional headers to insert in the token.\n\n    Returns:\n        the resulting token\n\n    \"\"\"\n    from .signed import SignedJwt\n\n    headers = dict(extra_headers or {}, alg=\"none\")\n    if typ:\n        headers[\"typ\"] = typ\n\n    headers_part = BinaPy.serialize_to(\"json\", headers).to(\"b64u\")\n    claims_part = BinaPy.serialize_to(\"json\", claims).to(\"b64u\")\n    signed_value = b\".\".join((headers_part, claims_part))\n    signature = b\"\"\n    return SignedJwt(b\".\".join((signed_value, signature)))\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.sign_and_encrypt","title":"sign_and_encrypt  <code>classmethod</code>","text":"<pre><code>sign_and_encrypt(\n    claims: dict[str, Any],\n    sign_key: Jwk | dict[str, Any] | Any,\n    enc_key: Jwk | dict[str, Any] | Any,\n    enc: str,\n    *,\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    sign_extra_headers: dict[str, Any] | None = None,\n    enc_extra_headers: dict[str, Any] | None = None\n) -&gt; JweCompact\n</code></pre> <p>Sign a JWT, then encrypt it as JWE payload.</p> <p>This is a convenience method to do both the signing and encryption, in appropriate order.</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>dict[str, Any]</code> <p>the payload to encrypt</p> required <code>sign_key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the Jwk to use for signature</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use for signature</p> <code>None</code> <code>sign_extra_headers</code> <code>dict[str, Any] | None</code> <p>additional headers for the inner signed JWT</p> <code>None</code> <code>enc_key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the Jwk to use for encryption</p> required <code>enc_alg</code> <code>str | None</code> <p>the alg to use for CEK encryption</p> <code>None</code> <code>enc</code> <code>str</code> <p>the alg to use for payload encryption</p> required <code>enc_extra_headers</code> <code>dict[str, Any] | None</code> <p>additional headers for the outer encrypted JWE</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the resulting JWE token, with the signed JWT as payload</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>@classmethod\ndef sign_and_encrypt(\n    cls,\n    claims: dict[str, Any],\n    sign_key: Jwk | dict[str, Any] | Any,\n    enc_key: Jwk | dict[str, Any] | Any,\n    enc: str,\n    *,\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    sign_extra_headers: dict[str, Any] | None = None,\n    enc_extra_headers: dict[str, Any] | None = None,\n) -&gt; JweCompact:\n\"\"\"Sign a JWT, then encrypt it as JWE payload.\n\n    This is a convenience method to do both the signing and encryption, in appropriate order.\n\n    Args:\n      claims: the payload to encrypt\n      sign_key: the Jwk to use for signature\n      sign_alg: the alg to use for signature\n      sign_extra_headers: additional headers for the inner signed JWT\n      enc_key: the Jwk to use for encryption\n      enc_alg: the alg to use for CEK encryption\n      enc: the alg to use for payload encryption\n      enc_extra_headers: additional headers for the outer encrypted JWE\n\n    Returns:\n      the resulting JWE token, with the signed JWT as payload\n\n    \"\"\"\n    enc_extra_headers = enc_extra_headers or {}\n    enc_extra_headers.setdefault(\"cty\", \"JWT\")\n\n    inner_jwt = cls.sign(\n        claims, key=sign_key, alg=sign_alg, extra_headers=sign_extra_headers\n    )\n    jwe = JweCompact.encrypt(\n        inner_jwt, enc_key, enc=enc, alg=enc_alg, extra_headers=enc_extra_headers\n    )\n    return jwe\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.decrypt_nested_jwt","title":"decrypt_nested_jwt  <code>classmethod</code>","text":"<pre><code>decrypt_nested_jwt(\n    jwe: str | JweCompact, key: Jwk | dict[str, Any] | Any\n) -&gt; Jwt\n</code></pre> <p>Decrypt a JWE that contains a nested JWT.</p> <p>It will return a [Jwt] instance for the inner JWT.</p> <p>Parameters:</p> Name Type Description Default <code>jwe</code> <code>str | JweCompact</code> <p>the JWE containing a nested Token</p> required <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the decryption key</p> required <p>Returns:</p> Type Description <code>Jwt</code> <p>the inner JWT</p> <p>Raises:</p> Type Description <code>InvalidJwt</code> <p>if the inner JWT is not valid</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>@classmethod\ndef decrypt_nested_jwt(\n    cls, jwe: str | JweCompact, key: Jwk | dict[str, Any] | Any\n) -&gt; Jwt:\n\"\"\"Decrypt a JWE that contains a nested JWT.\n\n    It will return a [Jwt] instance for the inner JWT.\n\n    Args:\n        jwe: the JWE containing a nested Token\n        key: the decryption key\n\n    Returns:\n        the inner JWT\n\n    Raises:\n        InvalidJwt: if the inner JWT is not valid\n\n    \"\"\"\n    if not isinstance(jwe, JweCompact):\n        jwe = JweCompact(jwe)\n    cleartext = jwe.decrypt(key)\n    return Jwt(cleartext)\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.decrypt_and_verify","title":"decrypt_and_verify  <code>classmethod</code>","text":"<pre><code>decrypt_and_verify(\n    jwt: str | JweCompact,\n    enc_key: Jwk | dict[str, Any] | Any,\n    sig_key: Jwk | dict[str, Any] | None | Any,\n    sig_alg: str | None = None,\n    sig_algs: Iterable[str] | None = None,\n) -&gt; SignedJwt\n</code></pre> <p>Decrypt then verify the signature of a JWT nested in a JWE.</p> <p>This can only be used with signed then encrypted Jwt, such as those produce by <code>Jwt.sign_and_encrypt()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>jwt</code> <code>str | JweCompact</code> <p>the JWE containing a nested signed JWT</p> required <code>enc_key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the decryption key</p> required <code>sig_key</code> <code>Jwk | dict[str, Any] | None | Any</code> <p>the signature verification key</p> required <code>sig_alg</code> <code>str | None</code> <p>the signature verification alg, if only 1 is allowed</p> <code>None</code> <code>sig_algs</code> <code>Iterable[str] | None</code> <p>the signature verifications algs, if several are allowed</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>the nested signed JWT, in clear-text, signature already verified</p> <p>Raises:</p> Type Description <code>InvalidJwt</code> <p>if the JWT is not valid</p> <code>InvalidSignature</code> <p>if the nested JWT signature is not valid</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>@classmethod\ndef decrypt_and_verify(\n    cls,\n    jwt: str | JweCompact,\n    enc_key: Jwk | dict[str, Any] | Any,\n    sig_key: Jwk | dict[str, Any] | None | Any,\n    sig_alg: str | None = None,\n    sig_algs: Iterable[str] | None = None,\n) -&gt; SignedJwt:\n\"\"\"Decrypt then verify the signature of a JWT nested in a JWE.\n\n    This can only be used with signed then encrypted Jwt, such as those produce by `Jwt.sign_and_encrypt()`.\n\n    Args:\n        jwt: the JWE containing a nested signed JWT\n        enc_key: the decryption key\n        sig_key: the signature verification key\n        sig_alg: the signature verification alg, if only 1 is allowed\n        sig_algs: the signature verifications algs, if several are allowed\n\n    Returns:\n        the nested signed JWT, in clear-text, signature already verified\n\n    Raises:\n        InvalidJwt: if the JWT is not valid\n        InvalidSignature: if the nested JWT signature is not valid\n\n    \"\"\"\n    from .signed import InvalidSignature, SignedJwt\n\n    nested_jwt = cls.decrypt_nested_jwt(jwt, enc_key)\n    if not isinstance(nested_jwt, SignedJwt):\n        raise ValueError(\"Nested JWT is not signed\", nested_jwt)\n\n    if sig_key:\n        if nested_jwt.verify_signature(sig_key, sig_alg, sig_algs):\n            return nested_jwt\n\n    raise InvalidSignature()\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.timestamp","title":"timestamp  <code>classmethod</code>","text":"<pre><code>timestamp(delta_seconds: int = 0) -&gt; int\n</code></pre> <p>Return an integer timestamp that is suitable for use in Jwt tokens.</p> <p>Timestamps are used in particular for <code>iat</code>, <code>exp</code> and <code>nbf</code> claims.</p> <p>A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds.</p> <p>By default, the current timestamp is returned. You can include <code>delta_seconds</code> to have a timestamp a number of seconds in the future (if positive) or in the past (if negative).</p> <p>Parameters:</p> Name Type Description Default <code>delta_seconds</code> <code>int</code> <p>number of seconds in the future or in the past compared to current time</p> <code>0</code> <p>Returns:</p> Type Description <code>int</code> <p>An integer timestamp</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>@classmethod\ndef timestamp(cls, delta_seconds: int = 0) -&gt; int:\n\"\"\"Return an integer timestamp that is suitable for use in Jwt tokens.\n\n    Timestamps are used in particular for `iat`, `exp` and `nbf` claims.\n\n    A timestamp is a number of seconds since January 1st, 1970 00:00:00 UTC, ignoring leap seconds.\n\n    By default, the current timestamp is returned. You can include `delta_seconds` to have a timestamp\n    a number of seconds in the future (if positive) or in the past (if negative).\n\n    Args:\n        delta_seconds: number of seconds in the future or in the past compared to current time\n\n    Returns:\n        An integer timestamp\n\n    \"\"\"\n    return int(datetime.now(timezone.utc).timestamp()) + delta_seconds\n</code></pre>"},{"location":"api/#jwskate.jwt.base.Jwt.timestamp_to_datetime","title":"timestamp_to_datetime  <code>classmethod</code>","text":"<pre><code>timestamp_to_datetime(timestamp: int) -&gt; datetime\n</code></pre> <p>Convert a JWT timestamp to a <code>datetime</code>.</p> <p>Returned datetime is always in the UTC timezone.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>a timestamp from a JWT token</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>the corresponding <code>datetime</code> in UTC timezone</p> Source code in <code>jwskate/jwt/base.py</code> <pre><code>@classmethod\ndef timestamp_to_datetime(cls, timestamp: int) -&gt; datetime:\n\"\"\"Convert a JWT timestamp to a `datetime`.\n\n    Returned datetime is always in the UTC timezone.\n\n    Args:\n        timestamp: a timestamp from a JWT token\n\n    Returns:\n        the corresponding `datetime` in UTC timezone\n\n    \"\"\"\n    return datetime.fromtimestamp(timestamp, tz=timezone.utc)\n</code></pre>"},{"location":"api/#jwskate.jwt.InvalidClaim","title":"InvalidClaim","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when trying to validate a JWT with unexpected claims.</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>class InvalidClaim(ValueError):\n\"\"\"Raised when trying to validate a JWT with unexpected claims.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwt.SignedJwt","title":"SignedJwt","text":"<p>             Bases: <code>Jwt</code></p> <p>Represent a Signed Json Web Token (JWT), as defined in RFC7519.</p> <p>A signed JWT contains a JSON object as payload, which represents claims.</p> <p>To sign a JWT, use Jwt.sign.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes | str</code> <p>the token value.</p> required Source code in <code>jwskate/jwt/signed.py</code> <pre><code>class SignedJwt(Jwt):\n\"\"\"Represent a Signed Json Web Token (JWT), as defined in RFC7519.\n\n    A signed JWT contains a JSON object as payload, which represents claims.\n\n    To sign a JWT, use [Jwt.sign][jwskate.jwt.Jwt.sign].\n\n    Args:\n        value: the token value.\n\n    \"\"\"\n\n    def __init__(self, value: bytes | str) -&gt; None:\n        super().__init__(value)\n\n        if self.value.count(b\".\") != 2:\n            raise InvalidJwt(\n                \"A JWT must contain a header, a payload and a signature, separated by dots\",\n                value,\n            )\n\n        header, payload, signature = self.value.split(b\".\")\n        try:\n            self.headers = BinaPy(header).decode_from(\"b64u\").parse_from(\"json\")\n        except ValueError:\n            raise InvalidJwt(\n                \"Invalid JWT header: it must be a Base64URL-encoded JSON object\"\n            )\n\n        try:\n            self.claims = BinaPy(payload).decode_from(\"b64u\").parse_from(\"json\")\n        except ValueError:\n            raise InvalidJwt(\n                \"Invalid JWT payload: it must be a Base64URL-encoded JSON object\"\n            )\n\n        try:\n            self.signature = BinaPy(signature).decode_from(\"b64u\")\n        except ValueError:\n            raise InvalidJwt(\n                \"Invalid JWT signature: it must be a Base64URL-encoded binary data (bytes)\"\n            )\n\n    @cached_property\n    def signed_part(self) -&gt; bytes:\n\"\"\"Return the actual signed data from this token.\n\n        The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot.\n\n        Returns:\n          the signed part as bytes\n\n        \"\"\"\n        return b\".\".join(self.value.split(b\".\", 2)[:2])\n\n    def verify_signature(\n        self,\n        key: Jwk | dict[str, Any] | Any,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; bool:\n\"\"\"Verify this JWT signature using a given key and algorithm(s).\n\n        Args:\n          key: the private Jwk to use to verify the signature\n          alg: the alg to use to verify the signature, if only 1 is allowed\n          algs: the allowed signature algs, if there are several\n\n        Returns:\n            `True` if the token signature is verified, `False` otherwise\n\n        \"\"\"\n        key = to_jwk(key)\n\n        return key.verify(\n            data=self.signed_part, signature=self.signature, alg=alg, algs=algs\n        )\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n\"\"\"Check if this token is expired, based on its `exp` claim.\n\n        Args:\n            leeway: additional number of seconds for leeway.\n\n        Returns:\n            `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim.\n\n        \"\"\"\n        exp = self.expires_at\n        if exp is None:\n            return None\n        return exp &lt; (datetime.now(timezone.utc) + timedelta(seconds=leeway))\n\n    @cached_property\n    def expires_at(self) -&gt; datetime | None:\n\"\"\"Get the *Expires At* (`exp`) date from this token.\n\n        Returns:\n          a `datetime` initialized from the `exp` claim, or `None` if there is no `exp` claim\n\n        Raises:\n            AttributeError: if the `exp` claim cannot be parsed to a date\n\n        \"\"\"\n        exp = self.get_claim(\"exp\")\n        if not exp:\n            return None\n        try:\n            exp_dt = Jwt.timestamp_to_datetime(exp)\n            return exp_dt\n        except (TypeError, OSError):\n            raise AttributeError(\"invalid `exp `claim\", exp)\n\n    @cached_property\n    def issued_at(self) -&gt; datetime | None:\n\"\"\"Get the *Issued At* (`iat`) date from this token.\n\n        Returns:\n          a `datetime` initialized from the `iat` claim, or `None` if there is no `iat` claim\n\n        Raises:\n            AttributeError: if the `iss` claim cannot be parsed to a date\n\n        \"\"\"\n        iat = self.get_claim(\"iat\")\n        if not iat:\n            return None\n        try:\n            iat_dt = Jwt.timestamp_to_datetime(iat)\n            return iat_dt\n        except (TypeError, OSError):\n            raise AttributeError(\"invalid `iat `claim\", iat)\n\n    @cached_property\n    def not_before(self) -&gt; datetime | None:\n\"\"\"Get the *Not Before* (nbf) date from this token.\n\n        Returns:\n          a `datetime` initialized from the `nbf` claim, or `None` if there is no `nbf` claim\n\n        Raises:\n            AttributeError: if the `nbf` claim cannot be parsed to a date\n\n        \"\"\"\n        nbf = self.get_claim(\"nbf\")\n        if not nbf:\n            return None\n        try:\n            nbf_dt = Jwt.timestamp_to_datetime(nbf)\n            return nbf_dt\n        except (TypeError, OSError):\n            raise AttributeError(\"invalid `nbf `claim\", nbf)\n\n    @cached_property\n    def issuer(self) -&gt; str | None:\n\"\"\"Get the *Issuer* (`iss`) claim from this token.\n\n        Returns:\n          the issuer, as `str`, or `None` if there is no `\u00ecss` claim\n\n        Raises:\n            AttributeError: if the `\u00ecss` claim value is not a string\n\n        \"\"\"\n        iss = self.get_claim(\"iss\")\n        if iss is None or isinstance(iss, str):\n            return iss\n        raise AttributeError(\"iss has an unexpected type\", type(iss))\n\n    @cached_property\n    def audiences(self) -&gt; list[str]:\n\"\"\"Get the *Audience(s)* (`aud`) claim from this token.\n\n        If this token has a single audience, this will return a `list` anyway.\n\n        Returns:\n            the list of audiences from this token, from the `aud` claim.\n\n        Raises:\n            AttributeError: if the audience is an unexpected type\n\n        \"\"\"\n        aud = self.get_claim(\"aud\")\n        if aud is None:\n            return []\n        if isinstance(aud, str):\n            return [aud]\n        if isinstance(aud, list):\n            return aud\n        raise AttributeError(\"aud has an unexpected type\", type(aud))\n\n    @cached_property\n    def subject(self) -&gt; str | None:\n\"\"\"Get the *Subject* (`sub`) from this token.\n\n        Returns:\n          the subject, as `str`, or `None` if there is no `sub` claim\n\n        Raises:\n            AttributeError: if the `sub` value is not a string\n\n        \"\"\"\n        sub = self.get_claim(\"sub\")\n        if sub is None or isinstance(sub, str):\n            return sub\n        raise AttributeError(\"sub has an unexpected type\", type(sub))\n\n    @cached_property\n    def jwt_token_id(self) -&gt; str | None:\n\"\"\"Get the *JWT Token ID* (`jti`) from this token.\n\n        Returns:\n          the token identifier, as `str`, or `None` if there is no `jti` claim\n\n        Raises:\n          AttributeError: if the `jti` value is not a string\n\n        \"\"\"\n        jti = self.get_claim(\"jti\")\n        if jti is None or isinstance(jti, str):\n            return jti\n        raise AttributeError(\"jti has an unexpected type\", type(jti))\n\n    def get_claim(self, key: str, default: Any = None) -&gt; Any:\n\"\"\"Get a claim by name from this Jwt.\n\n        Args:\n          key: the claim name.\n          default: a default value if the claim is not found\n\n        Returns:\n          the claim value if found, or `default` if not found\n\n        \"\"\"\n        return self.claims.get(key, default)\n\n    def __getitem__(self, item: str) -&gt; Any:\n\"\"\"Allow access to claim by name with subscription.\n\n        Args:\n          item: the claim name\n\n        Returns:\n         the claim value\n\n        \"\"\"\n        value = self.get_claim(item)\n        if value is None:\n            raise KeyError(item)\n        return value\n\n    def __getattr__(self, item: str) -&gt; Any:\n\"\"\"Allow claim access as attributes.\n\n        Args:\n            item: the claim name\n\n        Returns:\n            the claim value\n\n        \"\"\"\n        value = self.get_claim(item)\n        if value is None:\n            raise AttributeError(item)\n        return value\n\n    def __str__(self) -&gt; str:\n\"\"\"Return the Jwt serialized value, as `str`.\n\n        Returns:\n            the serialized token value.\n\n        \"\"\"\n        return self.value.decode()\n\n    def __bytes__(self) -&gt; bytes:\n\"\"\"Return the Jwt serialized value, as `bytes`.\n\n        Returns:\n            the serialized token value.\n\n        \"\"\"\n        return self.value\n\n    def validate(\n        self,\n        key: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n        issuer: str | None = None,\n        audience: None | str = None,\n        check_exp: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"Validate a `SignedJwt` signature and expected claims.\n\n        This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date.\n        This can also check custom claims using extra `kwargs`, whose values can be:\n\n        - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\"\n        - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid\n\n        Args:\n          key: the signing key to use to verify the signature.\n          alg: the signature alg to use to verify the signature.\n          algs: allowed signature algs, if several\n          issuer: the expected issuer for this token.\n          audience: the expected audience for this token.\n          check_exp: \u00ecf `True` (default), check that the token is not expired.\n          **kwargs: additional claims to check\n\n        Returns:\n          Raises exceptions if any validation check fails.\n\n        Raises:\n          InvalidSignature: if the signature is not valid\n          InvalidClaim: if a claim doesn't validate\n          ExpiredJwt: if the expiration date is passed\n\n        \"\"\"\n        if not self.verify_signature(key, alg, algs):\n            raise InvalidSignature(\"Signature is not valid.\")\n\n        if issuer is not None:\n            if self.issuer != issuer:\n                raise InvalidClaim(\"iss\", \"Unexpected issuer\", self.issuer)\n\n        if audience is not None:\n            if self.audiences is None or audience not in self.audiences:\n                raise InvalidClaim(\"aud\", \"Unexpected audience\", self.audiences)\n\n        if check_exp:\n            expired = self.is_expired()\n            if expired is True:\n                raise ExpiredJwt(f\"This token expired at {self.expires_at}\")\n            elif expired is None:\n                raise InvalidClaim(\"exp\", \"This token misses a 'exp' claim.\")\n\n        for key, value in kwargs.items():\n            claim = self.get_claim(key)\n            if callable(value):\n                if not value(claim):\n                    raise InvalidClaim(\n                        key,\n                        f\"value of claim {key} doesn't validate with the provided validator\",\n                        claim,\n                    )\n            elif claim != value:\n                raise InvalidClaim(key, f\"unexpected value for claim {key}\", claim)\n</code></pre>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.signed_part","title":"signed_part  <code>cached</code> <code>property</code>","text":"<pre><code>signed_part: bytes\n</code></pre> <p>Return the actual signed data from this token.</p> <p>The signed part is composed of the header and payload, encoded in Base64-Url, joined by a dot.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>the signed part as bytes</p>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.expires_at","title":"expires_at  <code>cached</code> <code>property</code>","text":"<pre><code>expires_at: datetime | None\n</code></pre> <p>Get the Expires At (<code>exp</code>) date from this token.</p> <p>Returns:</p> Type Description <code>datetime | None</code> <p>a <code>datetime</code> initialized from the <code>exp</code> claim, or <code>None</code> if there is no <code>exp</code> claim</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the <code>exp</code> claim cannot be parsed to a date</p>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.issued_at","title":"issued_at  <code>cached</code> <code>property</code>","text":"<pre><code>issued_at: datetime | None\n</code></pre> <p>Get the Issued At (<code>iat</code>) date from this token.</p> <p>Returns:</p> Type Description <code>datetime | None</code> <p>a <code>datetime</code> initialized from the <code>iat</code> claim, or <code>None</code> if there is no <code>iat</code> claim</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the <code>iss</code> claim cannot be parsed to a date</p>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.not_before","title":"not_before  <code>cached</code> <code>property</code>","text":"<pre><code>not_before: datetime | None\n</code></pre> <p>Get the Not Before (nbf) date from this token.</p> <p>Returns:</p> Type Description <code>datetime | None</code> <p>a <code>datetime</code> initialized from the <code>nbf</code> claim, or <code>None</code> if there is no <code>nbf</code> claim</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the <code>nbf</code> claim cannot be parsed to a date</p>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.issuer","title":"issuer  <code>cached</code> <code>property</code>","text":"<pre><code>issuer: str | None\n</code></pre> <p>Get the Issuer (<code>iss</code>) claim from this token.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>the issuer, as <code>str</code>, or <code>None</code> if there is no <code>\u00ecss</code> claim</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the <code>\u00ecss</code> claim value is not a string</p>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.audiences","title":"audiences  <code>cached</code> <code>property</code>","text":"<pre><code>audiences: list[str]\n</code></pre> <p>Get the Audience(s) (<code>aud</code>) claim from this token.</p> <p>If this token has a single audience, this will return a <code>list</code> anyway.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>the list of audiences from this token, from the <code>aud</code> claim.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the audience is an unexpected type</p>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.subject","title":"subject  <code>cached</code> <code>property</code>","text":"<pre><code>subject: str | None\n</code></pre> <p>Get the Subject (<code>sub</code>) from this token.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>the subject, as <code>str</code>, or <code>None</code> if there is no <code>sub</code> claim</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the <code>sub</code> value is not a string</p>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.jwt_token_id","title":"jwt_token_id  <code>cached</code> <code>property</code>","text":"<pre><code>jwt_token_id: str | None\n</code></pre> <p>Get the JWT Token ID (<code>jti</code>) from this token.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>the token identifier, as <code>str</code>, or <code>None</code> if there is no <code>jti</code> claim</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the <code>jti</code> value is not a string</p>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.verify_signature","title":"verify_signature","text":"<pre><code>verify_signature(\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; bool\n</code></pre> <p>Verify this JWT signature using a given key and algorithm(s).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the private Jwk to use to verify the signature</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to verify the signature, if only 1 is allowed</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>the allowed signature algs, if there are several</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the token signature is verified, <code>False</code> otherwise</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>def verify_signature(\n    self,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Verify this JWT signature using a given key and algorithm(s).\n\n    Args:\n      key: the private Jwk to use to verify the signature\n      alg: the alg to use to verify the signature, if only 1 is allowed\n      algs: the allowed signature algs, if there are several\n\n    Returns:\n        `True` if the token signature is verified, `False` otherwise\n\n    \"\"\"\n    key = to_jwk(key)\n\n    return key.verify(\n        data=self.signed_part, signature=self.signature, alg=alg, algs=algs\n    )\n</code></pre>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.is_expired","title":"is_expired","text":"<pre><code>is_expired(leeway: int = 0) -&gt; bool | None\n</code></pre> <p>Check if this token is expired, based on its <code>exp</code> claim.</p> <p>Parameters:</p> Name Type Description Default <code>leeway</code> <code>int</code> <p>additional number of seconds for leeway.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the token is expired, <code>False</code> if it's not, <code>None</code> if there is no <code>exp</code> claim.</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n\"\"\"Check if this token is expired, based on its `exp` claim.\n\n    Args:\n        leeway: additional number of seconds for leeway.\n\n    Returns:\n        `True` if the token is expired, `False` if it's not, `None` if there is no `exp` claim.\n\n    \"\"\"\n    exp = self.expires_at\n    if exp is None:\n        return None\n    return exp &lt; (datetime.now(timezone.utc) + timedelta(seconds=leeway))\n</code></pre>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.get_claim","title":"get_claim","text":"<pre><code>get_claim(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get a claim by name from this Jwt.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the claim name.</p> required <code>default</code> <code>Any</code> <p>a default value if the claim is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>the claim value if found, or <code>default</code> if not found</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>def get_claim(self, key: str, default: Any = None) -&gt; Any:\n\"\"\"Get a claim by name from this Jwt.\n\n    Args:\n      key: the claim name.\n      default: a default value if the claim is not found\n\n    Returns:\n      the claim value if found, or `default` if not found\n\n    \"\"\"\n    return self.claims.get(key, default)\n</code></pre>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: str) -&gt; Any\n</code></pre> <p>Allow access to claim by name with subscription.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>the claim name</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the claim value</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>def __getitem__(self, item: str) -&gt; Any:\n\"\"\"Allow access to claim by name with subscription.\n\n    Args:\n      item: the claim name\n\n    Returns:\n     the claim value\n\n    \"\"\"\n    value = self.get_claim(item)\n    if value is None:\n        raise KeyError(item)\n    return value\n</code></pre>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> <p>Allow claim access as attributes.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>the claim name</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the claim value</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n\"\"\"Allow claim access as attributes.\n\n    Args:\n        item: the claim name\n\n    Returns:\n        the claim value\n\n    \"\"\"\n    value = self.get_claim(item)\n    if value is None:\n        raise AttributeError(item)\n    return value\n</code></pre>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the Jwt serialized value, as <code>str</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>the serialized token value.</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return the Jwt serialized value, as `str`.\n\n    Returns:\n        the serialized token value.\n\n    \"\"\"\n    return self.value.decode()\n</code></pre>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.__bytes__","title":"__bytes__","text":"<pre><code>__bytes__() -&gt; bytes\n</code></pre> <p>Return the Jwt serialized value, as <code>bytes</code>.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>the serialized token value.</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n\"\"\"Return the Jwt serialized value, as `bytes`.\n\n    Returns:\n        the serialized token value.\n\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/#jwskate.jwt.signed.SignedJwt.validate","title":"validate","text":"<pre><code>validate(\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n    issuer: str | None = None,\n    audience: None | str = None,\n    check_exp: bool = True,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Validate a <code>SignedJwt</code> signature and expected claims.</p> <p>This verifies the signature using the provided <code>jwk</code> and <code>alg</code>, then checks the token issuer, audience and expiration date. This can also check custom claims using extra <code>kwargs</code>, whose values can be:</p> <ul> <li>a static value (<code>str</code>, <code>int</code>, etc.): the value from the token will be compared \"as-is\"</li> <li>a callable, taking the claim value as parameter: if that callable returns <code>True</code>, the claim is considered as valid</li> </ul> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the signing key to use to verify the signature.</p> required <code>alg</code> <code>str | None</code> <p>the signature alg to use to verify the signature.</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>allowed signature algs, if several</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>the expected issuer for this token.</p> <code>None</code> <code>audience</code> <code>None | str</code> <p>the expected audience for this token.</p> <code>None</code> <code>check_exp</code> <code>bool</code> <p>\u00ecf <code>True</code> (default), check that the token is not expired.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>additional claims to check</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises exceptions if any validation check fails.</p> <p>Raises:</p> Type Description <code>InvalidSignature</code> <p>if the signature is not valid</p> <code>InvalidClaim</code> <p>if a claim doesn't validate</p> <code>ExpiredJwt</code> <p>if the expiration date is passed</p> Source code in <code>jwskate/jwt/signed.py</code> <pre><code>def validate(\n    self,\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n    issuer: str | None = None,\n    audience: None | str = None,\n    check_exp: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Validate a `SignedJwt` signature and expected claims.\n\n    This verifies the signature using the provided `jwk` and `alg`, then checks the token issuer, audience and expiration date.\n    This can also check custom claims using extra `kwargs`, whose values can be:\n\n    - a static value (`str`, `int`, etc.): the value from the token will be compared \"as-is\"\n    - a callable, taking the claim value as parameter: if that callable returns `True`, the claim is considered as valid\n\n    Args:\n      key: the signing key to use to verify the signature.\n      alg: the signature alg to use to verify the signature.\n      algs: allowed signature algs, if several\n      issuer: the expected issuer for this token.\n      audience: the expected audience for this token.\n      check_exp: \u00ecf `True` (default), check that the token is not expired.\n      **kwargs: additional claims to check\n\n    Returns:\n      Raises exceptions if any validation check fails.\n\n    Raises:\n      InvalidSignature: if the signature is not valid\n      InvalidClaim: if a claim doesn't validate\n      ExpiredJwt: if the expiration date is passed\n\n    \"\"\"\n    if not self.verify_signature(key, alg, algs):\n        raise InvalidSignature(\"Signature is not valid.\")\n\n    if issuer is not None:\n        if self.issuer != issuer:\n            raise InvalidClaim(\"iss\", \"Unexpected issuer\", self.issuer)\n\n    if audience is not None:\n        if self.audiences is None or audience not in self.audiences:\n            raise InvalidClaim(\"aud\", \"Unexpected audience\", self.audiences)\n\n    if check_exp:\n        expired = self.is_expired()\n        if expired is True:\n            raise ExpiredJwt(f\"This token expired at {self.expires_at}\")\n        elif expired is None:\n            raise InvalidClaim(\"exp\", \"This token misses a 'exp' claim.\")\n\n    for key, value in kwargs.items():\n        claim = self.get_claim(key)\n        if callable(value):\n            if not value(claim):\n                raise InvalidClaim(\n                    key,\n                    f\"value of claim {key} doesn't validate with the provided validator\",\n                    claim,\n                )\n        elif claim != value:\n            raise InvalidClaim(key, f\"unexpected value for claim {key}\", claim)\n</code></pre>"},{"location":"api/#jwskate.jwt.JwtSigner","title":"JwtSigner","text":"<p>A helper class to easily sign JWTs with standardised claims.</p> The standardised claims include <ul> <li><code>\u00ecat</code>: issued at date</li> <li><code>exp</code>: expiration date</li> <li><code>nbf</code>: not before date:</li> <li><code>iss</code>: issuer identifier</li> <li><code>sub</code>: subject identifier</li> <li><code>aud</code>: audience identifier</li> <li><code>jti</code>: JWT token ID</li> </ul> <p>The issuer, signing keys, signing alg and default lifetime are defined at initialization time, so you only have to define the subject, audience and custom claims when calling <code>JwtSigner.sign()</code>. This can be used as an alternative to <code>Jwt.sign()</code> when a single issuer issues multiple tokens.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>the issuer string to use as <code>\u00ecss</code> claim for signed tokens.</p> required <code>jwk</code> <code>Jwk</code> <p>the private Jwk to use to sign tokens.</p> required <code>alg</code> <code>str | None</code> <p>the signing alg to use to sign tokens.</p> <code>None</code> <code>default_lifetime</code> <code>int</code> <p>the default lifetime, in seconds, to use for claim <code>exp</code>. This can be overridden when calling <code>.sign()</code></p> <code>60</code> <code>default_leeway</code> <code>int | None</code> <p>the default leeway, in seconds, to use for claim <code>nbf</code>. If None, no <code>nbf</code> claim is included. This can be overridden when calling <code>.sign()</code></p> <code>None</code> Source code in <code>jwskate/jwt/signer.py</code> <pre><code>class JwtSigner:\n\"\"\"A helper class to easily sign JWTs with standardised claims.\n\n    The standardised claims include:\n\n       - `\u00ecat`: issued at date\n       - `exp`: expiration date\n       - `nbf`: not before date:\n       - `iss`: issuer identifier\n       - `sub`: subject identifier\n       - `aud`: audience identifier\n       - `jti`: JWT token ID\n\n    The issuer, signing keys, signing alg and default lifetime are\n    defined at initialization time, so you only have to define the\n    subject, audience and custom claims when calling `JwtSigner.sign()`.\n    This can be used as an alternative to `Jwt.sign()` when a single\n    issuer issues multiple tokens.\n\n    Args:\n        issuer: the issuer string to use as `\u00ecss` claim for signed tokens.\n        jwk: the private Jwk to use to sign tokens.\n        alg: the signing alg to use to sign tokens.\n        default_lifetime: the default lifetime, in seconds, to use for claim `exp`. This can be overridden\n            when calling `.sign()`\n        default_leeway: the default leeway, in seconds, to use for claim `nbf`. If None, no `nbf` claim is\n            included. This can be overridden when calling `.sign()`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        issuer: str,\n        jwk: Jwk,\n        alg: str | None = None,\n        default_lifetime: int = 60,\n        default_leeway: int | None = None,\n    ):\n        self.issuer = issuer\n        self.jwk = jwk\n        self.alg = jwk.alg or alg\n        self.default_lifetime = default_lifetime\n        self.default_leeway = default_leeway\n\n    def sign(\n        self,\n        subject: str | None = None,\n        audience: str | Iterable[str] | None = None,\n        extra_claims: dict[str, Any] | None = None,\n        extra_headers: dict[str, Any] | None = None,\n        lifetime: int | None = None,\n        leeway: int | None = None,\n    ) -&gt; SignedJwt:\n\"\"\"Sign a Jwt.\n\n        Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect\n        the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf`\n        includes `leeway` seconds in the past.\n\n        Args:\n          subject: the subject to include in claim `sub`. (Default value = None)\n          audience: the audience identifier(s) to include in claim `aud`.\n          extra_claims: additional claims to include in the signed token. (Default value = None)\n          extra_headers: additional headers to include in the header part. (Default value = None)\n          lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time.\n          leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time.\n\n        Returns:\n          the resulting signed token.\n\n        \"\"\"\n        now = Jwt.timestamp()\n        lifetime = lifetime or self.default_lifetime\n        exp = now + lifetime\n        leeway = leeway or self.default_leeway\n        nbf = (now - leeway) if leeway is not None else None\n        jti = self.generate_jti()\n        extra_claims = extra_claims or {}\n        claims = {\n            key: value\n            for key, value in dict(\n                extra_claims,\n                iss=self.issuer,\n                aud=audience,\n                sub=subject,\n                iat=now,\n                exp=exp,\n                nbf=nbf,\n                jti=jti,\n            ).items()\n            if value is not None\n        }\n        return Jwt.sign(claims, key=self.jwk, alg=self.alg, extra_headers=extra_headers)\n\n    def generate_jti(self) -&gt; str:\n\"\"\"Generate Jwt Token ID (jti) values.\n\n        Default uses UUID4. Can be overridden in subclasses.\n\n        Returns:\n            A unique value suitable for use as JWT Token ID (jti) claim.\n\n        \"\"\"\n        return str(uuid.uuid4())\n\n    @classmethod\n    def with_random_key(\n        cls,\n        issuer: str,\n        alg: str,\n        default_lifetime: int = 60,\n        default_leeway: int | None = None,\n        kid: str | None = None,\n    ) -&gt; JwtSigner:\n\"\"\"Initialize a JwtSigner with a randomly generated key.\n\n        Args:\n            issuer: the issuer identifier\n            alg: the signing alg to use\n            default_lifetime: lifetime for generated tokens expiration date (`exp` claim)\n            default_leeway: leeway for generated tokens not before date (`nbf` claim)\n            kid: key id to use for the generated key\n\n        Returns:\n            a JwtSigner initialized with a random key\n\n        \"\"\"\n        jwk = Jwk.generate_for_alg(alg, kid=kid).with_kid_thumbprint()\n        return cls(issuer, jwk, alg, default_lifetime, default_leeway)\n\n    def verifier(\n        self,\n        audience: str,\n        verifiers: Iterable[Callable[[SignedJwt], None]] | None = None,\n        **kwargs: Any,\n    ) -&gt; JwtVerifier:\n\"\"\"Return the matching JwtVerifier, initialized with the public key.\"\"\"\n        return JwtVerifier(\n            issuer=self.issuer,\n            jwkset=self.jwk.public_jwk().as_jwks(),\n            alg=self.alg,\n            audience=audience,\n            verifiers=verifiers,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#jwskate.jwt.signer.JwtSigner.sign","title":"sign","text":"<pre><code>sign(\n    subject: str | None = None,\n    audience: str | Iterable[str] | None = None,\n    extra_claims: dict[str, Any] | None = None,\n    extra_headers: dict[str, Any] | None = None,\n    lifetime: int | None = None,\n    leeway: int | None = None,\n) -&gt; SignedJwt\n</code></pre> <p>Sign a Jwt.</p> <p>Claim 'issuer' will have the value defined at initialization time. Claim <code>iat</code>, <code>nbf</code> and <code>exp</code> will reflect the current time when the token is signed. <code>exp</code> includes <code>lifetime</code> seconds in the future, and <code>nbf</code> includes <code>leeway</code> seconds in the past.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str | None</code> <p>the subject to include in claim <code>sub</code>. (Default value = None)</p> <code>None</code> <code>audience</code> <code>str | Iterable[str] | None</code> <p>the audience identifier(s) to include in claim <code>aud</code>.</p> <code>None</code> <code>extra_claims</code> <code>dict[str, Any] | None</code> <p>additional claims to include in the signed token. (Default value = None)</p> <code>None</code> <code>extra_headers</code> <code>dict[str, Any] | None</code> <p>additional headers to include in the header part. (Default value = None)</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>lifetime, in seconds, to use for the <code>exp</code> claim. If None, use the default_lifetime defined at initialization time.</p> <code>None</code> <code>leeway</code> <code>int | None</code> <p>leeway, in seconds, to use for the <code>nbf</code> claim. If None, use the default_leeway defined at initialization time.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>the resulting signed token.</p> Source code in <code>jwskate/jwt/signer.py</code> <pre><code>def sign(\n    self,\n    subject: str | None = None,\n    audience: str | Iterable[str] | None = None,\n    extra_claims: dict[str, Any] | None = None,\n    extra_headers: dict[str, Any] | None = None,\n    lifetime: int | None = None,\n    leeway: int | None = None,\n) -&gt; SignedJwt:\n\"\"\"Sign a Jwt.\n\n    Claim 'issuer' will have the value defined at initialization time. Claim `iat`, `nbf` and `exp` will reflect\n    the current time when the token is signed. `exp` includes `lifetime` seconds in the future, and `nbf`\n    includes `leeway` seconds in the past.\n\n    Args:\n      subject: the subject to include in claim `sub`. (Default value = None)\n      audience: the audience identifier(s) to include in claim `aud`.\n      extra_claims: additional claims to include in the signed token. (Default value = None)\n      extra_headers: additional headers to include in the header part. (Default value = None)\n      lifetime: lifetime, in seconds, to use for the `exp` claim. If None, use the default_lifetime defined at initialization time.\n      leeway: leeway, in seconds, to use for the `nbf` claim. If None, use the default_leeway defined at initialization time.\n\n    Returns:\n      the resulting signed token.\n\n    \"\"\"\n    now = Jwt.timestamp()\n    lifetime = lifetime or self.default_lifetime\n    exp = now + lifetime\n    leeway = leeway or self.default_leeway\n    nbf = (now - leeway) if leeway is not None else None\n    jti = self.generate_jti()\n    extra_claims = extra_claims or {}\n    claims = {\n        key: value\n        for key, value in dict(\n            extra_claims,\n            iss=self.issuer,\n            aud=audience,\n            sub=subject,\n            iat=now,\n            exp=exp,\n            nbf=nbf,\n            jti=jti,\n        ).items()\n        if value is not None\n    }\n    return Jwt.sign(claims, key=self.jwk, alg=self.alg, extra_headers=extra_headers)\n</code></pre>"},{"location":"api/#jwskate.jwt.signer.JwtSigner.generate_jti","title":"generate_jti","text":"<pre><code>generate_jti() -&gt; str\n</code></pre> <p>Generate Jwt Token ID (jti) values.</p> <p>Default uses UUID4. Can be overridden in subclasses.</p> <p>Returns:</p> Type Description <code>str</code> <p>A unique value suitable for use as JWT Token ID (jti) claim.</p> Source code in <code>jwskate/jwt/signer.py</code> <pre><code>def generate_jti(self) -&gt; str:\n\"\"\"Generate Jwt Token ID (jti) values.\n\n    Default uses UUID4. Can be overridden in subclasses.\n\n    Returns:\n        A unique value suitable for use as JWT Token ID (jti) claim.\n\n    \"\"\"\n    return str(uuid.uuid4())\n</code></pre>"},{"location":"api/#jwskate.jwt.signer.JwtSigner.with_random_key","title":"with_random_key  <code>classmethod</code>","text":"<pre><code>with_random_key(\n    issuer: str,\n    alg: str,\n    default_lifetime: int = 60,\n    default_leeway: int | None = None,\n    kid: str | None = None,\n) -&gt; JwtSigner\n</code></pre> <p>Initialize a JwtSigner with a randomly generated key.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>the issuer identifier</p> required <code>alg</code> <code>str</code> <p>the signing alg to use</p> required <code>default_lifetime</code> <code>int</code> <p>lifetime for generated tokens expiration date (<code>exp</code> claim)</p> <code>60</code> <code>default_leeway</code> <code>int | None</code> <p>leeway for generated tokens not before date (<code>nbf</code> claim)</p> <code>None</code> <code>kid</code> <code>str | None</code> <p>key id to use for the generated key</p> <code>None</code> <p>Returns:</p> Type Description <code>JwtSigner</code> <p>a JwtSigner initialized with a random key</p> Source code in <code>jwskate/jwt/signer.py</code> <pre><code>@classmethod\ndef with_random_key(\n    cls,\n    issuer: str,\n    alg: str,\n    default_lifetime: int = 60,\n    default_leeway: int | None = None,\n    kid: str | None = None,\n) -&gt; JwtSigner:\n\"\"\"Initialize a JwtSigner with a randomly generated key.\n\n    Args:\n        issuer: the issuer identifier\n        alg: the signing alg to use\n        default_lifetime: lifetime for generated tokens expiration date (`exp` claim)\n        default_leeway: leeway for generated tokens not before date (`nbf` claim)\n        kid: key id to use for the generated key\n\n    Returns:\n        a JwtSigner initialized with a random key\n\n    \"\"\"\n    jwk = Jwk.generate_for_alg(alg, kid=kid).with_kid_thumbprint()\n    return cls(issuer, jwk, alg, default_lifetime, default_leeway)\n</code></pre>"},{"location":"api/#jwskate.jwt.signer.JwtSigner.verifier","title":"verifier","text":"<pre><code>verifier(\n    audience: str,\n    verifiers: Iterable[Callable[[SignedJwt], None]]\n    | None = None,\n    **kwargs: Any\n) -&gt; JwtVerifier\n</code></pre> <p>Return the matching JwtVerifier, initialized with the public key.</p> Source code in <code>jwskate/jwt/signer.py</code> <pre><code>def verifier(\n    self,\n    audience: str,\n    verifiers: Iterable[Callable[[SignedJwt], None]] | None = None,\n    **kwargs: Any,\n) -&gt; JwtVerifier:\n\"\"\"Return the matching JwtVerifier, initialized with the public key.\"\"\"\n    return JwtVerifier(\n        issuer=self.issuer,\n        jwkset=self.jwk.public_jwk().as_jwks(),\n        alg=self.alg,\n        audience=audience,\n        verifiers=verifiers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#jwskate.jws","title":"jwskate.jws","text":"<p>This module implements JWS token handling.</p>"},{"location":"api/#jwskate.jws.JwsSignature","title":"JwsSignature","text":"<p>             Bases: <code>BaseJsonDict</code></p> <p>Represents a JWS Signature.</p> <p>A JWS Signature has</p> <ul> <li>a protected header (as a JSON object)</li> <li>a signature value (as raw data)</li> <li>an unprotected header (as arbitrary JSON data)</li> <li>optional extra JSON attributes</li> </ul> Source code in <code>jwskate/jws/signature.py</code> <pre><code>class JwsSignature(BaseJsonDict):\n\"\"\"Represents a JWS Signature.\n\n    A JWS Signature has\n\n     - a protected header (as a JSON object)\n     - a signature value (as raw data)\n     - an unprotected header (as arbitrary JSON data)\n     - optional extra JSON attributes\n\n    \"\"\"\n\n    @classmethod\n    def from_parts(\n        cls: type[S],\n        protected: Mapping[str, Any],\n        signature: bytes,\n        header: Any | None,\n        **kwargs: Any,\n    ) -&gt; S:\n\"\"\"Initialize a JwsSignature based on the provided parts.\n\n        Args:\n          protected: the protected headers, as a key: value mapping\n          signature: the raw signature value\n          header: the unprotected header, if any\n          **kwargs: extra attributes, if any\n\n        Returns:\n            A `JwsSignature` based on the provided parts.\n\n        \"\"\"\n        content = dict(\n            kwargs,\n            protected=BinaPy.serialize_to(\"json\", protected).to(\"b64u\").ascii(),\n            signature=BinaPy(signature).to(\"b64u\").ascii(),\n        )\n        if header is not None:\n            content[\"header\"] = header\n        return cls(content)\n\n    @cached_property\n    def protected(self) -&gt; dict[str, Any]:\n\"\"\"The protected header.\n\n        Returns:\n            the protected headers, as a `dict`.\n\n        Raises:\n            AttributeError: if this signature doesn't have protected headers.\n\n        \"\"\"\n        protected = self.get(\"protected\")\n        if protected is None:\n            raise AttributeError(\"This Jws JSON does not contain a 'protected' member\")\n        return BinaPy(protected).decode_from(\"b64u\").parse_from(\"json\")  # type: ignore[no-any-return]\n\n    @property\n    def header(self) -&gt; Any:\n\"\"\"The unprotected header, unaltered.\n\n        Returns:\n            The unprotected header\n\n        \"\"\"\n        return self.get(\"header\")\n\n    @cached_property\n    def signature(self) -&gt; bytes:\n\"\"\"The raw signature.\n\n        Returns:\n            The raw signed data, unencoded\n\n        Raises:\n            AttributeError: if no 'signature' member is present\n\n        \"\"\"\n        signature = self.get(\"signature\")\n        if signature is None:\n            raise AttributeError(\"This Jws JSON does not contain a 'signature' member\")\n        return BinaPy(signature).decode_from(\"b64u\")\n\n    @classmethod\n    def sign(\n        cls: type[S],\n        payload: bytes,\n        key: Jwk | dict[str, Any] | Any,\n        alg: str | None = None,\n        extra_protected_headers: Mapping[str, Any] | None = None,\n        header: Any | None = None,\n        **kwargs: Any,\n    ) -&gt; S:\n\"\"\"Sign a payload and return the generated JWS signature.\n\n        Args:\n          payload: the raw data to sign\n          key: the signature key to use\n          alg: the signature algorithm to use\n          extra_protected_headers: additional protected headers to include, if any\n          header: the unprotected header, if any.\n          **kwargs: additional members to include in this signature\n\n        Returns:\n            The generated signature.\n\n        \"\"\"\n        key = to_jwk(key)\n\n        headers = dict(extra_protected_headers or {}, alg=alg)\n        kid = key.get(\"kid\")\n        if kid:\n            headers[\"kid\"] = kid\n\n        signed_part = JwsSignature.assemble_signed_part(headers, payload)\n        signature = key.sign(signed_part, alg=alg)\n        return cls.from_parts(\n            protected=headers, signature=signature, header=header, **kwargs\n        )\n\n    @classmethod\n    def assemble_signed_part(\n        cls, headers: dict[str, Any], payload: bytes | str\n    ) -&gt; bytes:\n\"\"\"Assemble the protected header and payload to sign, as specified in.\n\n        [RFC7515\n        $5.1](https://datatracker.ietf.org/doc/html/rfc7515#section-5.1).\n\n        Args:\n          headers: the protected headers\n          payload: the raw payload to sign\n\n        Returns:\n            the raw data to sign\n\n        \"\"\"\n        return b\".\".join(\n            (\n                BinaPy.serialize_to(\"json\", headers).to(\"b64u\"),\n                BinaPy(payload).to(\"b64u\"),\n            )\n        )\n\n    def verify(\n        self,\n        payload: bytes,\n        key: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; bool:\n\"\"\"Verify this signature against the given payload using the provided key.\n\n        Args:\n          payload: the raw payload\n          key: the validation key to use\n          alg: the signature alg t if only 1 is allowed\n          algs: the allowed signature algs, if there are several\n\n        Returns:\n            `True` if the signature is verifier, `False` otherwise\n\n        \"\"\"\n        key = to_jwk(key)\n        signed_part = self.assemble_signed_part(self.protected, payload)\n        return key.verify(signed_part, self.signature, alg=alg, algs=algs)\n</code></pre>"},{"location":"api/#jwskate.jws.signature.JwsSignature.protected","title":"protected  <code>cached</code> <code>property</code>","text":"<pre><code>protected: dict[str, Any]\n</code></pre> <p>The protected header.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>the protected headers, as a <code>dict</code>.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if this signature doesn't have protected headers.</p>"},{"location":"api/#jwskate.jws.signature.JwsSignature.header","title":"header  <code>property</code>","text":"<pre><code>header: Any\n</code></pre> <p>The unprotected header, unaltered.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The unprotected header</p>"},{"location":"api/#jwskate.jws.signature.JwsSignature.signature","title":"signature  <code>cached</code> <code>property</code>","text":"<pre><code>signature: bytes\n</code></pre> <p>The raw signature.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The raw signed data, unencoded</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if no 'signature' member is present</p>"},{"location":"api/#jwskate.jws.signature.JwsSignature.from_parts","title":"from_parts  <code>classmethod</code>","text":"<pre><code>from_parts(\n    protected: Mapping[str, Any],\n    signature: bytes,\n    header: Any | None,\n    **kwargs: Any\n) -&gt; S\n</code></pre> <p>Initialize a JwsSignature based on the provided parts.</p> <p>Parameters:</p> Name Type Description Default <code>protected</code> <code>Mapping[str, Any]</code> <p>the protected headers, as a key: value mapping</p> required <code>signature</code> <code>bytes</code> <p>the raw signature value</p> required <code>header</code> <code>Any | None</code> <p>the unprotected header, if any</p> required <code>**kwargs</code> <code>Any</code> <p>extra attributes, if any</p> <code>{}</code> <p>Returns:</p> Type Description <code>S</code> <p>A <code>JwsSignature</code> based on the provided parts.</p> Source code in <code>jwskate/jws/signature.py</code> <pre><code>@classmethod\ndef from_parts(\n    cls: type[S],\n    protected: Mapping[str, Any],\n    signature: bytes,\n    header: Any | None,\n    **kwargs: Any,\n) -&gt; S:\n\"\"\"Initialize a JwsSignature based on the provided parts.\n\n    Args:\n      protected: the protected headers, as a key: value mapping\n      signature: the raw signature value\n      header: the unprotected header, if any\n      **kwargs: extra attributes, if any\n\n    Returns:\n        A `JwsSignature` based on the provided parts.\n\n    \"\"\"\n    content = dict(\n        kwargs,\n        protected=BinaPy.serialize_to(\"json\", protected).to(\"b64u\").ascii(),\n        signature=BinaPy(signature).to(\"b64u\").ascii(),\n    )\n    if header is not None:\n        content[\"header\"] = header\n    return cls(content)\n</code></pre>"},{"location":"api/#jwskate.jws.signature.JwsSignature.sign","title":"sign  <code>classmethod</code>","text":"<pre><code>sign(\n    payload: bytes,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    extra_protected_headers: Mapping[str, Any]\n    | None = None,\n    header: Any | None = None,\n    **kwargs: Any\n) -&gt; S\n</code></pre> <p>Sign a payload and return the generated JWS signature.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>the raw data to sign</p> required <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the signature key to use</p> required <code>alg</code> <code>str | None</code> <p>the signature algorithm to use</p> <code>None</code> <code>extra_protected_headers</code> <code>Mapping[str, Any] | None</code> <p>additional protected headers to include, if any</p> <code>None</code> <code>header</code> <code>Any | None</code> <p>the unprotected header, if any.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional members to include in this signature</p> <code>{}</code> <p>Returns:</p> Type Description <code>S</code> <p>The generated signature.</p> Source code in <code>jwskate/jws/signature.py</code> <pre><code>@classmethod\ndef sign(\n    cls: type[S],\n    payload: bytes,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    extra_protected_headers: Mapping[str, Any] | None = None,\n    header: Any | None = None,\n    **kwargs: Any,\n) -&gt; S:\n\"\"\"Sign a payload and return the generated JWS signature.\n\n    Args:\n      payload: the raw data to sign\n      key: the signature key to use\n      alg: the signature algorithm to use\n      extra_protected_headers: additional protected headers to include, if any\n      header: the unprotected header, if any.\n      **kwargs: additional members to include in this signature\n\n    Returns:\n        The generated signature.\n\n    \"\"\"\n    key = to_jwk(key)\n\n    headers = dict(extra_protected_headers or {}, alg=alg)\n    kid = key.get(\"kid\")\n    if kid:\n        headers[\"kid\"] = kid\n\n    signed_part = JwsSignature.assemble_signed_part(headers, payload)\n    signature = key.sign(signed_part, alg=alg)\n    return cls.from_parts(\n        protected=headers, signature=signature, header=header, **kwargs\n    )\n</code></pre>"},{"location":"api/#jwskate.jws.signature.JwsSignature.assemble_signed_part","title":"assemble_signed_part  <code>classmethod</code>","text":"<pre><code>assemble_signed_part(\n    headers: dict[str, Any], payload: bytes | str\n) -&gt; bytes\n</code></pre> <p>Assemble the protected header and payload to sign, as specified in.</p> <p>RFC7515 $5.1.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>dict[str, Any]</code> <p>the protected headers</p> required <code>payload</code> <code>bytes | str</code> <p>the raw payload to sign</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>the raw data to sign</p> Source code in <code>jwskate/jws/signature.py</code> <pre><code>@classmethod\ndef assemble_signed_part(\n    cls, headers: dict[str, Any], payload: bytes | str\n) -&gt; bytes:\n\"\"\"Assemble the protected header and payload to sign, as specified in.\n\n    [RFC7515\n    $5.1](https://datatracker.ietf.org/doc/html/rfc7515#section-5.1).\n\n    Args:\n      headers: the protected headers\n      payload: the raw payload to sign\n\n    Returns:\n        the raw data to sign\n\n    \"\"\"\n    return b\".\".join(\n        (\n            BinaPy.serialize_to(\"json\", headers).to(\"b64u\"),\n            BinaPy(payload).to(\"b64u\"),\n        )\n    )\n</code></pre>"},{"location":"api/#jwskate.jws.signature.JwsSignature.verify","title":"verify","text":"<pre><code>verify(\n    payload: bytes,\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None\n) -&gt; bool\n</code></pre> <p>Verify this signature against the given payload using the provided key.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>the raw payload</p> required <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the validation key to use</p> required <code>alg</code> <code>str | None</code> <p>the signature alg t if only 1 is allowed</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>the allowed signature algs, if there are several</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the signature is verifier, <code>False</code> otherwise</p> Source code in <code>jwskate/jws/signature.py</code> <pre><code>def verify(\n    self,\n    payload: bytes,\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Verify this signature against the given payload using the provided key.\n\n    Args:\n      payload: the raw payload\n      key: the validation key to use\n      alg: the signature alg t if only 1 is allowed\n      algs: the allowed signature algs, if there are several\n\n    Returns:\n        `True` if the signature is verifier, `False` otherwise\n\n    \"\"\"\n    key = to_jwk(key)\n    signed_part = self.assemble_signed_part(self.protected, payload)\n    return key.verify(signed_part, self.signature, alg=alg, algs=algs)\n</code></pre>"},{"location":"api/#jwskate.jws.JwsJsonFlat","title":"JwsJsonFlat","text":"<p>             Bases: <code>JwsSignature</code></p> <p>Represent a JWS with a single signature in JSON flat format.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>class JwsJsonFlat(JwsSignature):\n\"\"\"Represent a JWS with a single signature in JSON flat format.\"\"\"\n\n    @cached_property\n    def payload(self) -&gt; bytes:\n\"\"\"The JWS payload, decoded.\n\n        Returns:\n            The raw JWS payload.\n\n        \"\"\"\n        payload = self.get(\"payload\")\n        if payload is None:\n            raise AttributeError(\"This Jws JSON does not contain a 'payload' member\")\n        return BinaPy(payload).decode_from(\"b64u\")\n\n    @cached_property\n    def jws_signature(self) -&gt; JwsSignature:\n\"\"\"The JWS signature.\n\n        Returns:\n            The JWS signature.\n\n        \"\"\"\n        content = {\n            \"protected\": self[\"protected\"],\n            \"signature\": self[\"signature\"],\n        }\n        header = self.get(\"header\")\n        if header:\n            content[\"header\"] = self.header\n        return JwsSignature(content)\n\n    @classmethod\n    def sign(\n        cls,\n        payload: bytes,\n        key: Jwk | dict[str, Any] | Any,\n        alg: str | None = None,\n        extra_protected_headers: Mapping[str, Any] | None = None,\n        header: Any | None = None,\n        **kwargs: Any,\n    ) -&gt; JwsJsonFlat:\n\"\"\"Signs a payload into a JWS in JSON flat format.\n\n        Args:\n            payload: the data to sign.\n            key: the key to use\n            alg: the signature alg to use\n            extra_protected_headers: additional protected headers to include\n            header: the unprotected header to include\n            **kwargs: extra attributes to include in the JWS\n\n        Returns:\n            The JWS with the payload, signature, header and extra claims.\n\n        \"\"\"\n        signature = super().sign(\n            payload, key, alg, extra_protected_headers, header, **kwargs\n        )\n        signature[\"payload\"] = BinaPy(payload).to(\"b64u\").ascii()\n        return cls(signature)\n\n    def generalize(self) -&gt; JwsJsonGeneral:\n\"\"\"Create a JWS in JSON general format from this JWS in JSON flat.\n\n        Returns:\n            A JwsJsonGeneral with the same payload and signature.\n\n        \"\"\"\n        content = self.copy()\n        protected = content.pop(\"protected\")\n        header = content.pop(\"header\", None)\n        signature = content.pop(\"signature\")\n        jws_signature = {\"protected\": protected, \"signature\": signature}\n        if header is not None:\n            jws_signature[\"header\"] = header\n        content[\"signatures\"] = [jws_signature]\n        return JwsJsonGeneral(content)\n\n    def signed_part(self) -&gt; bytes:\n\"\"\"Return the signed part from this JWS, as bytes.\n\n        This is a concatenation of the protected header and the payload, separated by a dot (`.`).\n\n        Returns:\n            The signed data part.\n\n        \"\"\"\n        return JwsSignature.assemble_signed_part(self.protected, self.payload)\n\n    def compact(self) -&gt; JwsCompact:\n\"\"\"Create a JWS in compact format from this JWS JSON.\n\n        Returns:\n            A `JwsCompact` with the same payload and signature.\n\n        \"\"\"\n        return JwsCompact.from_parts(self.signed_part(), self.signature)\n\n    def verify_signature(\n        self,\n        key: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; bool:\n\"\"\"Verify this JWS signature with a given key.\n\n        Args:\n            key: the key to use to validate this signature.\n            alg: the signature alg, if only 1 is allowed.\n            algs: the allowed signature algs, if there are several.\n\n        Returns:\n            `True` if the signature is verified, `False` otherwise.\n\n        \"\"\"\n        return self.jws_signature.verify(self.payload, key, alg=alg, algs=algs)\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.payload","title":"payload  <code>cached</code> <code>property</code>","text":"<pre><code>payload: bytes\n</code></pre> <p>The JWS payload, decoded.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The raw JWS payload.</p>"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.jws_signature","title":"jws_signature  <code>cached</code> <code>property</code>","text":"<pre><code>jws_signature: JwsSignature\n</code></pre> <p>The JWS signature.</p> <p>Returns:</p> Type Description <code>JwsSignature</code> <p>The JWS signature.</p>"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.sign","title":"sign  <code>classmethod</code>","text":"<pre><code>sign(\n    payload: bytes,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    extra_protected_headers: Mapping[str, Any]\n    | None = None,\n    header: Any | None = None,\n    **kwargs: Any\n) -&gt; JwsJsonFlat\n</code></pre> <p>Signs a payload into a JWS in JSON flat format.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>the data to sign.</p> required <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the key to use</p> required <code>alg</code> <code>str | None</code> <p>the signature alg to use</p> <code>None</code> <code>extra_protected_headers</code> <code>Mapping[str, Any] | None</code> <p>additional protected headers to include</p> <code>None</code> <code>header</code> <code>Any | None</code> <p>the unprotected header to include</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>extra attributes to include in the JWS</p> <code>{}</code> <p>Returns:</p> Type Description <code>JwsJsonFlat</code> <p>The JWS with the payload, signature, header and extra claims.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>@classmethod\ndef sign(\n    cls,\n    payload: bytes,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    extra_protected_headers: Mapping[str, Any] | None = None,\n    header: Any | None = None,\n    **kwargs: Any,\n) -&gt; JwsJsonFlat:\n\"\"\"Signs a payload into a JWS in JSON flat format.\n\n    Args:\n        payload: the data to sign.\n        key: the key to use\n        alg: the signature alg to use\n        extra_protected_headers: additional protected headers to include\n        header: the unprotected header to include\n        **kwargs: extra attributes to include in the JWS\n\n    Returns:\n        The JWS with the payload, signature, header and extra claims.\n\n    \"\"\"\n    signature = super().sign(\n        payload, key, alg, extra_protected_headers, header, **kwargs\n    )\n    signature[\"payload\"] = BinaPy(payload).to(\"b64u\").ascii()\n    return cls(signature)\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.generalize","title":"generalize","text":"<pre><code>generalize() -&gt; JwsJsonGeneral\n</code></pre> <p>Create a JWS in JSON general format from this JWS in JSON flat.</p> <p>Returns:</p> Type Description <code>JwsJsonGeneral</code> <p>A JwsJsonGeneral with the same payload and signature.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def generalize(self) -&gt; JwsJsonGeneral:\n\"\"\"Create a JWS in JSON general format from this JWS in JSON flat.\n\n    Returns:\n        A JwsJsonGeneral with the same payload and signature.\n\n    \"\"\"\n    content = self.copy()\n    protected = content.pop(\"protected\")\n    header = content.pop(\"header\", None)\n    signature = content.pop(\"signature\")\n    jws_signature = {\"protected\": protected, \"signature\": signature}\n    if header is not None:\n        jws_signature[\"header\"] = header\n    content[\"signatures\"] = [jws_signature]\n    return JwsJsonGeneral(content)\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.signed_part","title":"signed_part","text":"<pre><code>signed_part() -&gt; bytes\n</code></pre> <p>Return the signed part from this JWS, as bytes.</p> <p>This is a concatenation of the protected header and the payload, separated by a dot (<code>.</code>).</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The signed data part.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def signed_part(self) -&gt; bytes:\n\"\"\"Return the signed part from this JWS, as bytes.\n\n    This is a concatenation of the protected header and the payload, separated by a dot (`.`).\n\n    Returns:\n        The signed data part.\n\n    \"\"\"\n    return JwsSignature.assemble_signed_part(self.protected, self.payload)\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.compact","title":"compact","text":"<pre><code>compact() -&gt; JwsCompact\n</code></pre> <p>Create a JWS in compact format from this JWS JSON.</p> <p>Returns:</p> Type Description <code>JwsCompact</code> <p>A <code>JwsCompact</code> with the same payload and signature.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def compact(self) -&gt; JwsCompact:\n\"\"\"Create a JWS in compact format from this JWS JSON.\n\n    Returns:\n        A `JwsCompact` with the same payload and signature.\n\n    \"\"\"\n    return JwsCompact.from_parts(self.signed_part(), self.signature)\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonFlat.verify_signature","title":"verify_signature","text":"<pre><code>verify_signature(\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None\n) -&gt; bool\n</code></pre> <p>Verify this JWS signature with a given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the key to use to validate this signature.</p> required <code>alg</code> <code>str | None</code> <p>the signature alg, if only 1 is allowed.</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>the allowed signature algs, if there are several.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the signature is verified, <code>False</code> otherwise.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def verify_signature(\n    self,\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Verify this JWS signature with a given key.\n\n    Args:\n        key: the key to use to validate this signature.\n        alg: the signature alg, if only 1 is allowed.\n        algs: the allowed signature algs, if there are several.\n\n    Returns:\n        `True` if the signature is verified, `False` otherwise.\n\n    \"\"\"\n    return self.jws_signature.verify(self.payload, key, alg=alg, algs=algs)\n</code></pre>"},{"location":"api/#jwskate.jws.InvalidJws","title":"InvalidJws","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when an invalid Jws is parsed.</p> Source code in <code>jwskate/jws/compact.py</code> <pre><code>class InvalidJws(ValueError):\n\"\"\"Raised when an invalid Jws is parsed.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jws.JwsCompact","title":"JwsCompact","text":"<p>             Bases: <code>BaseCompactToken</code></p> <p>Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes | str</code> <p>the JWS token value</p> required Source code in <code>jwskate/jws/compact.py</code> <pre><code>class JwsCompact(BaseCompactToken):\n\"\"\"Represents a Json Web Signature (JWS), using compact serialization, as defined in RFC7515.\n\n    Args:\n        value: the JWS token value\n\n    \"\"\"\n\n    def __init__(self, value: bytes | str, max_size: int = 16 * 1024):\n        super().__init__(value, max_size)\n\n        if self.value.count(b\".\") != 2:\n            raise InvalidJws(\n                \"A JWS must contain a header, a payload and a signature, separated by dots\"\n            )\n\n        header, payload, signature = BinaPy(self.value).split(b\".\")\n\n        try:\n            self.headers = BinaPy(header).decode_from(\"b64u\").parse_from(\"json\")\n        except ValueError:\n            raise InvalidJws(\n                \"Invalid JWS header: it must be a Base64URL-encoded JSON object\"\n            )\n\n        try:\n            self.payload = BinaPy(payload).decode_from(\"b64u\")\n        except ValueError:\n            raise InvalidJws(\n                \"Invalid JWS payload: it must be a Base64URL-encoded binary data (bytes)\"\n            )\n\n        try:\n            self.signature = BinaPy(signature).decode_from(\"b64u\")\n        except ValueError:\n            raise InvalidJws(\n                \"Invalid JWS signature: it must be a Base64URL-encoded binary data (bytes)\"\n            )\n\n    @classmethod\n    def sign(\n        cls,\n        payload: bytes | SupportsBytes,\n        key: Jwk | dict[str, Any] | Any,\n        alg: str | None = None,\n        extra_headers: dict[str, Any] | None = None,\n    ) -&gt; JwsCompact:\n\"\"\"Sign a payload and returns the resulting JwsCompact.\n\n        Args:\n          payload: the payload to sign\n          key: the jwk to use to sign this payload\n          alg: the alg to use\n          extra_headers: additional headers to add to the Jws Headers\n\n        Returns:\n          the resulting token\n\n        \"\"\"\n        key = to_jwk(key)\n\n        if not isinstance(payload, bytes):\n            payload = bytes(payload)\n\n        headers = dict(extra_headers or {}, alg=alg)\n        kid = key.get(\"kid\")\n        if kid:\n            headers[\"kid\"] = kid\n\n        signed_part = JwsSignature.assemble_signed_part(headers, payload)\n        signature = key.sign(signed_part, alg=alg)\n        return cls.from_parts(signed_part, signature)\n\n    @classmethod\n    def from_parts(\n        cls,\n        signed_part: bytes | SupportsBytes | str,\n        signature: bytes | SupportsBytes,\n    ) -&gt; JwsCompact:\n\"\"\"Construct a JWS token based on its signed part and signature values.\n\n        Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot.\n\n        Args:\n          signed_part: the signed part\n          signature: the signature value\n\n        Returns:\n            the resulting token\n\n        \"\"\"\n        if isinstance(signed_part, str):\n            signed_part = signed_part.encode(\"ascii\")\n        if not isinstance(signed_part, bytes):\n            signed_part = bytes(signed_part)\n\n        if not isinstance(signature, bytes):\n            signature = bytes(signature)\n\n        return cls(b\".\".join((signed_part, BinaPy(signature).to(\"b64u\"))))\n\n    @cached_property\n    def signed_part(self) -&gt; bytes:\n\"\"\"Returns the signed part (header + payload) from this JwsCompact.\n\n        Returns:\n            the signed part\n\n        \"\"\"\n        return b\".\".join(self.value.split(b\".\", 2)[:2])\n\n    def verify_signature(\n        self,\n        key: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; bool:\n\"\"\"Verify the signature from this JwsCompact using a Jwk.\n\n        Args:\n          key: the Jwk to use to validate this signature\n          alg: the alg to use, if there is only 1 allowed\n          algs: the allowed algs, if here are several\n\n        Returns:\n         `True` if the signature matches, `False` otherwise\n\n        \"\"\"\n        key = to_jwk(key)\n        return key.verify(self.signed_part, self.signature, alg=alg, algs=algs)\n\n    def flat_json(self, unprotected_header: Any = None) -&gt; JwsJsonFlat:\n\"\"\"Create a JWS in JSON flat format based on this Compact JWS.\n\n        Args:\n          unprotected_header: optional unprotected header to include in the JWS JSON\n\n        Returns:\n            the resulting token\n\n        \"\"\"\n        from .json import JwsJsonFlat\n\n        protected, payload, signature = self.value.split(b\".\")\n\n        content = {\n            \"payload\": payload.decode(),\n            \"protected\": protected.decode(),\n            \"signature\": signature.decode(),\n        }\n        if unprotected_header is not None:\n            content[\"header\"] = unprotected_header\n        return JwsJsonFlat(content)\n\n    def general_json(self, unprotected_header: Any = None) -&gt; JwsJsonGeneral:\n\"\"\"Create a JWS in JSON General format based on this JWS Compact.\n\n        The resulting token will have a single signature which is the one from this token.\n\n        Args:\n            unprotected_header: optional unprotected header to include in the JWS JSON\n\n        Returns:\n            the resulting token\n\n        \"\"\"\n        jws = self.flat_json(unprotected_header)\n        return jws.generalize()\n\n    def jws_signature(self, unprotected_header: Any = None) -&gt; JwsSignature:\n\"\"\"Return a JwsSignature based on this JWS Compact token.\"\"\"\n        return JwsSignature.from_parts(\n            protected=self.headers, signature=self.signature, header=unprotected_header\n        )\n</code></pre>"},{"location":"api/#jwskate.jws.compact.JwsCompact.signed_part","title":"signed_part  <code>cached</code> <code>property</code>","text":"<pre><code>signed_part: bytes\n</code></pre> <p>Returns the signed part (header + payload) from this JwsCompact.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>the signed part</p>"},{"location":"api/#jwskate.jws.compact.JwsCompact.sign","title":"sign  <code>classmethod</code>","text":"<pre><code>sign(\n    payload: bytes | SupportsBytes,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    extra_headers: dict[str, Any] | None = None,\n) -&gt; JwsCompact\n</code></pre> <p>Sign a payload and returns the resulting JwsCompact.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes | SupportsBytes</code> <p>the payload to sign</p> required <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the jwk to use to sign this payload</p> required <code>alg</code> <code>str | None</code> <p>the alg to use</p> <code>None</code> <code>extra_headers</code> <code>dict[str, Any] | None</code> <p>additional headers to add to the Jws Headers</p> <code>None</code> <p>Returns:</p> Type Description <code>JwsCompact</code> <p>the resulting token</p> Source code in <code>jwskate/jws/compact.py</code> <pre><code>@classmethod\ndef sign(\n    cls,\n    payload: bytes | SupportsBytes,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    extra_headers: dict[str, Any] | None = None,\n) -&gt; JwsCompact:\n\"\"\"Sign a payload and returns the resulting JwsCompact.\n\n    Args:\n      payload: the payload to sign\n      key: the jwk to use to sign this payload\n      alg: the alg to use\n      extra_headers: additional headers to add to the Jws Headers\n\n    Returns:\n      the resulting token\n\n    \"\"\"\n    key = to_jwk(key)\n\n    if not isinstance(payload, bytes):\n        payload = bytes(payload)\n\n    headers = dict(extra_headers or {}, alg=alg)\n    kid = key.get(\"kid\")\n    if kid:\n        headers[\"kid\"] = kid\n\n    signed_part = JwsSignature.assemble_signed_part(headers, payload)\n    signature = key.sign(signed_part, alg=alg)\n    return cls.from_parts(signed_part, signature)\n</code></pre>"},{"location":"api/#jwskate.jws.compact.JwsCompact.from_parts","title":"from_parts  <code>classmethod</code>","text":"<pre><code>from_parts(\n    signed_part: bytes | SupportsBytes | str,\n    signature: bytes | SupportsBytes,\n) -&gt; JwsCompact\n</code></pre> <p>Construct a JWS token based on its signed part and signature values.</p> <p>Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot.</p> <p>Parameters:</p> Name Type Description Default <code>signed_part</code> <code>bytes | SupportsBytes | str</code> <p>the signed part</p> required <code>signature</code> <code>bytes | SupportsBytes</code> <p>the signature value</p> required <p>Returns:</p> Type Description <code>JwsCompact</code> <p>the resulting token</p> Source code in <code>jwskate/jws/compact.py</code> <pre><code>@classmethod\ndef from_parts(\n    cls,\n    signed_part: bytes | SupportsBytes | str,\n    signature: bytes | SupportsBytes,\n) -&gt; JwsCompact:\n\"\"\"Construct a JWS token based on its signed part and signature values.\n\n    Signed part is the concatenation of the header and payload, both encoded in Base64-Url, and joined by a dot.\n\n    Args:\n      signed_part: the signed part\n      signature: the signature value\n\n    Returns:\n        the resulting token\n\n    \"\"\"\n    if isinstance(signed_part, str):\n        signed_part = signed_part.encode(\"ascii\")\n    if not isinstance(signed_part, bytes):\n        signed_part = bytes(signed_part)\n\n    if not isinstance(signature, bytes):\n        signature = bytes(signature)\n\n    return cls(b\".\".join((signed_part, BinaPy(signature).to(\"b64u\"))))\n</code></pre>"},{"location":"api/#jwskate.jws.compact.JwsCompact.verify_signature","title":"verify_signature","text":"<pre><code>verify_signature(\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None\n) -&gt; bool\n</code></pre> <p>Verify the signature from this JwsCompact using a Jwk.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the Jwk to use to validate this signature</p> required <code>alg</code> <code>str | None</code> <p>the alg to use, if there is only 1 allowed</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>the allowed algs, if here are several</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the signature matches, <code>False</code> otherwise</p> Source code in <code>jwskate/jws/compact.py</code> <pre><code>def verify_signature(\n    self,\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Verify the signature from this JwsCompact using a Jwk.\n\n    Args:\n      key: the Jwk to use to validate this signature\n      alg: the alg to use, if there is only 1 allowed\n      algs: the allowed algs, if here are several\n\n    Returns:\n     `True` if the signature matches, `False` otherwise\n\n    \"\"\"\n    key = to_jwk(key)\n    return key.verify(self.signed_part, self.signature, alg=alg, algs=algs)\n</code></pre>"},{"location":"api/#jwskate.jws.compact.JwsCompact.flat_json","title":"flat_json","text":"<pre><code>flat_json(unprotected_header: Any = None) -&gt; JwsJsonFlat\n</code></pre> <p>Create a JWS in JSON flat format based on this Compact JWS.</p> <p>Parameters:</p> Name Type Description Default <code>unprotected_header</code> <code>Any</code> <p>optional unprotected header to include in the JWS JSON</p> <code>None</code> <p>Returns:</p> Type Description <code>JwsJsonFlat</code> <p>the resulting token</p> Source code in <code>jwskate/jws/compact.py</code> <pre><code>def flat_json(self, unprotected_header: Any = None) -&gt; JwsJsonFlat:\n\"\"\"Create a JWS in JSON flat format based on this Compact JWS.\n\n    Args:\n      unprotected_header: optional unprotected header to include in the JWS JSON\n\n    Returns:\n        the resulting token\n\n    \"\"\"\n    from .json import JwsJsonFlat\n\n    protected, payload, signature = self.value.split(b\".\")\n\n    content = {\n        \"payload\": payload.decode(),\n        \"protected\": protected.decode(),\n        \"signature\": signature.decode(),\n    }\n    if unprotected_header is not None:\n        content[\"header\"] = unprotected_header\n    return JwsJsonFlat(content)\n</code></pre>"},{"location":"api/#jwskate.jws.compact.JwsCompact.general_json","title":"general_json","text":"<pre><code>general_json(\n    unprotected_header: Any = None,\n) -&gt; JwsJsonGeneral\n</code></pre> <p>Create a JWS in JSON General format based on this JWS Compact.</p> <p>The resulting token will have a single signature which is the one from this token.</p> <p>Parameters:</p> Name Type Description Default <code>unprotected_header</code> <code>Any</code> <p>optional unprotected header to include in the JWS JSON</p> <code>None</code> <p>Returns:</p> Type Description <code>JwsJsonGeneral</code> <p>the resulting token</p> Source code in <code>jwskate/jws/compact.py</code> <pre><code>def general_json(self, unprotected_header: Any = None) -&gt; JwsJsonGeneral:\n\"\"\"Create a JWS in JSON General format based on this JWS Compact.\n\n    The resulting token will have a single signature which is the one from this token.\n\n    Args:\n        unprotected_header: optional unprotected header to include in the JWS JSON\n\n    Returns:\n        the resulting token\n\n    \"\"\"\n    jws = self.flat_json(unprotected_header)\n    return jws.generalize()\n</code></pre>"},{"location":"api/#jwskate.jws.compact.JwsCompact.jws_signature","title":"jws_signature","text":"<pre><code>jws_signature(\n    unprotected_header: Any = None,\n) -&gt; JwsSignature\n</code></pre> <p>Return a JwsSignature based on this JWS Compact token.</p> Source code in <code>jwskate/jws/compact.py</code> <pre><code>def jws_signature(self, unprotected_header: Any = None) -&gt; JwsSignature:\n\"\"\"Return a JwsSignature based on this JWS Compact token.\"\"\"\n    return JwsSignature.from_parts(\n        protected=self.headers, signature=self.signature, header=unprotected_header\n    )\n</code></pre>"},{"location":"api/#jwskate.jws.JwsJsonGeneral","title":"JwsJsonGeneral","text":"<p>             Bases: <code>BaseJsonDict</code></p> <p>Represents a JWS in JSON general format (possibly with multiple signatures).</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>class JwsJsonGeneral(BaseJsonDict):\n\"\"\"Represents a JWS in JSON general format (possibly with multiple signatures).\"\"\"\n\n    @cached_property\n    def payload(self) -&gt; bytes:\n\"\"\"The raw signed data.\n\n        Returns:\n            The signed data.\n\n        \"\"\"\n        payload = self.get(\"payload\")\n        if payload is None:\n            raise AttributeError(\"This Jws JSON does not contain a 'payload' member\")\n        return BinaPy(payload).decode_from(\"b64u\")\n\n    @classmethod\n    def sign(\n        cls,\n        payload: bytes,\n        *signature_parameters: (\n            tuple[\n                Jwk | Mapping[str, Any],\n                str,\n                Mapping[str, Any] | None,\n                Mapping[str, Any] | None,\n            ]\n            | tuple[\n                Jwk | Mapping[str, Any],\n                str,\n                Mapping[str, Any] | None,\n            ]\n            | tuple[\n                Jwk | Mapping[str, Any],\n                str,\n            ]\n            | Jwk\n            | Mapping[str, Any]\n        ),\n    ) -&gt; JwsJsonGeneral:\n\"\"\"Sign a payload with several keys and return the resulting JWS in JSON general format.\n\n        Args:\n            payload: the data to sign\n            *signature_parameters: each of those parameter can be:\n                - a `(jwk, alg, extra_protected_headers, header)` tuple\n                - a `(jwk, alg, extra_protected_headers)` tuple,\n                - a `(jwk, alg)` tuple,\n                - a `jwk`\n                with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature.\n\n        Returns:\n            A JwsJsonGeneral with the generated signatures.\n\n        \"\"\"\n        jws = cls({\"payload\": BinaPy(payload).to(\"b64u\").ascii()})\n        for parameters in signature_parameters:\n            jws.add_signature(*parameters)\n        return jws\n\n    @cached_property\n    def signatures(self) -&gt; list[JwsSignature]:\n\"\"\"The list of `JwsSignature` from this JWS.\n\n        Returns:\n            The list of signatures from this JWS.\n\n        \"\"\"\n        signatures = self.get(\"signatures\")\n        if signatures is None:\n            raise AttributeError(\"This Jws JSON does not contain a 'signatures' member\")\n        return [JwsSignature(sig) for sig in signatures]\n\n    def add_signature(\n        self,\n        key: Jwk | dict[str, Any] | Any,\n        alg: str | None = None,\n        extra_protected_headers: Mapping[str, Any] | None = None,\n        header: Mapping[str, Any] | None = None,\n    ) -&gt; JwsJsonGeneral:\n\"\"\"Add a new signature in this JWS.\n\n        Args:\n            key: the private key to use\n            alg: the signature algorithm\n            extra_protected_headers: additional headers to include, as a {key: value} mapping\n            header: the raw unprotected header to include in the signature\n\n        Returns:\n            the same JWS with the new signature included.\n\n        \"\"\"\n        self.setdefault(\"signatures\", [])\n        self[\"signatures\"].append(\n            JwsSignature.sign(self.payload, key, alg, extra_protected_headers, header)\n        )\n        return self\n\n    def signed_part(\n        self,\n        signature_chooser: Callable[\n            [list[JwsSignature]], JwsSignature\n        ] = lambda sigs: sigs[0],\n    ) -&gt; bytes:\n\"\"\"Return the signed part from a given signature.\n\n        The signed part is a concatenation of the protected header from a specific signature, then the payload,\n        separated by a dot (`.`).\n        You can select the specific signature with the `signature_chooser` parameter.\n        By default, the first signature is selected.\n\n        Args:\n            signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.\n\n        Returns:\n            The raw signed part from the chosen signature.\n\n        \"\"\"\n        signature = signature_chooser(self.signatures)\n        return JwsSignature.assemble_signed_part(signature.protected, self.payload)\n\n    def compact(\n        self,\n        signature_chooser: Callable[\n            [list[JwsSignature]], JwsSignature\n        ] = lambda sigs: sigs[0],\n    ) -&gt; JwsCompact:\n\"\"\"Create a compact JWS from a specific signature from this JWS.\n\n        Args:\n            signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.\n\n        Returns:\n            A JwsCompact with the payload and the chosen signature from this JWS.\n\n        \"\"\"\n        signature = signature_chooser(self.signatures)\n        return JwsCompact.from_parts(\n            JwsSignature.assemble_signed_part(signature.protected, self.payload),\n            signature.signature,\n        )\n\n    def flatten(\n        self,\n        signature_chooser: Callable[\n            [list[JwsSignature]], JwsSignature\n        ] = lambda sigs: sigs[0],\n    ) -&gt; JwsJsonFlat:\n\"\"\"Create a JWS in JSON flat format from a specific signature from this JWS.\n\n        Args:\n            signature_chooser:  a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.\n\n        Returns:\n            A JwsJsonFlat with the payload and the chosen signature from this JWS.\n\n        \"\"\"\n        signature = signature_chooser(self.signatures)\n        return JwsJsonFlat.from_parts(\n            payload=self[\"payload\"],\n            protected=signature.protected,\n            header=signature.header,\n            signature=signature.signature,\n        )\n\n    def verify_signature(\n        self,\n        key: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; bool:\n\"\"\"Verify the signatures from this JWS.\n\n        It will try to validate each signature with the given key, and returns `True` if at least one signature verifies.\n        Args:\n            key: the public key to use\n            alg: the signature algorithm to use, if only 1 is allowed.\n            algs: the allowed signature algorithms, if there are several.\n\n        Returns:\n            `True` if any of the signature verifies with the given key, `False` otherwise.\n\n        \"\"\"\n        for signature in self.signatures:\n            if signature.verify(self.payload, key, alg=alg, algs=algs):\n                return True\n        return False\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.payload","title":"payload  <code>cached</code> <code>property</code>","text":"<pre><code>payload: bytes\n</code></pre> <p>The raw signed data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The signed data.</p>"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.signatures","title":"signatures  <code>cached</code> <code>property</code>","text":"<pre><code>signatures: list[JwsSignature]\n</code></pre> <p>The list of <code>JwsSignature</code> from this JWS.</p> <p>Returns:</p> Type Description <code>list[JwsSignature]</code> <p>The list of signatures from this JWS.</p>"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.sign","title":"sign  <code>classmethod</code>","text":"<pre><code>sign(\n    payload: bytes,\n    *signature_parameters: tuple[\n        Jwk | Mapping[str, Any],\n        str,\n        Mapping[str, Any] | None,\n        Mapping[str, Any] | None,\n    ]\n    | tuple[\n        Jwk | Mapping[str, Any],\n        str,\n        Mapping[str, Any] | None,\n    ]\n    | tuple[Jwk | Mapping[str, Any], str]\n    | Jwk\n    | Mapping[str, Any]\n) -&gt; JwsJsonGeneral\n</code></pre> <p>Sign a payload with several keys and return the resulting JWS in JSON general format.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>the data to sign</p> required <code>*signature_parameters</code> <code>tuple[Jwk | Mapping[str, Any], str, Mapping[str, Any] | None, Mapping[str, Any] | None] | tuple[Jwk | Mapping[str, Any], str, Mapping[str, Any] | None] | tuple[Jwk | Mapping[str, Any], str] | Jwk | Mapping[str, Any]</code> <p>each of those parameter can be: - a <code>(jwk, alg, extra_protected_headers, header)</code> tuple - a <code>(jwk, alg, extra_protected_headers)</code> tuple, - a <code>(jwk, alg)</code> tuple, - a <code>jwk</code> with <code>jwk</code> being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature.</p> <code>()</code> <p>Returns:</p> Type Description <code>JwsJsonGeneral</code> <p>A JwsJsonGeneral with the generated signatures.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>@classmethod\ndef sign(\n    cls,\n    payload: bytes,\n    *signature_parameters: (\n        tuple[\n            Jwk | Mapping[str, Any],\n            str,\n            Mapping[str, Any] | None,\n            Mapping[str, Any] | None,\n        ]\n        | tuple[\n            Jwk | Mapping[str, Any],\n            str,\n            Mapping[str, Any] | None,\n        ]\n        | tuple[\n            Jwk | Mapping[str, Any],\n            str,\n        ]\n        | Jwk\n        | Mapping[str, Any]\n    ),\n) -&gt; JwsJsonGeneral:\n\"\"\"Sign a payload with several keys and return the resulting JWS in JSON general format.\n\n    Args:\n        payload: the data to sign\n        *signature_parameters: each of those parameter can be:\n            - a `(jwk, alg, extra_protected_headers, header)` tuple\n            - a `(jwk, alg, extra_protected_headers)` tuple,\n            - a `(jwk, alg)` tuple,\n            - a `jwk`\n            with `jwk` being a Jwk key, alg being the signature algorithm to use, extra_protected_headers a mapping of extra protected headers and values to include, and header the raw unprotected header to include in the signature.\n\n    Returns:\n        A JwsJsonGeneral with the generated signatures.\n\n    \"\"\"\n    jws = cls({\"payload\": BinaPy(payload).to(\"b64u\").ascii()})\n    for parameters in signature_parameters:\n        jws.add_signature(*parameters)\n    return jws\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.add_signature","title":"add_signature","text":"<pre><code>add_signature(\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    extra_protected_headers: Mapping[str, Any]\n    | None = None,\n    header: Mapping[str, Any] | None = None,\n) -&gt; JwsJsonGeneral\n</code></pre> <p>Add a new signature in this JWS.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the private key to use</p> required <code>alg</code> <code>str | None</code> <p>the signature algorithm</p> <code>None</code> <code>extra_protected_headers</code> <code>Mapping[str, Any] | None</code> <p>additional headers to include, as a {key: value} mapping</p> <code>None</code> <code>header</code> <code>Mapping[str, Any] | None</code> <p>the raw unprotected header to include in the signature</p> <code>None</code> <p>Returns:</p> Type Description <code>JwsJsonGeneral</code> <p>the same JWS with the new signature included.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def add_signature(\n    self,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    extra_protected_headers: Mapping[str, Any] | None = None,\n    header: Mapping[str, Any] | None = None,\n) -&gt; JwsJsonGeneral:\n\"\"\"Add a new signature in this JWS.\n\n    Args:\n        key: the private key to use\n        alg: the signature algorithm\n        extra_protected_headers: additional headers to include, as a {key: value} mapping\n        header: the raw unprotected header to include in the signature\n\n    Returns:\n        the same JWS with the new signature included.\n\n    \"\"\"\n    self.setdefault(\"signatures\", [])\n    self[\"signatures\"].append(\n        JwsSignature.sign(self.payload, key, alg, extra_protected_headers, header)\n    )\n    return self\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.signed_part","title":"signed_part","text":"<pre><code>signed_part(\n    signature_chooser: Callable[\n        [list[JwsSignature]], JwsSignature\n    ] = lambda sigs: sigs[0]\n) -&gt; bytes\n</code></pre> <p>Return the signed part from a given signature.</p> <p>The signed part is a concatenation of the protected header from a specific signature, then the payload, separated by a dot (<code>.</code>). You can select the specific signature with the <code>signature_chooser</code> parameter. By default, the first signature is selected.</p> <p>Parameters:</p> Name Type Description Default <code>signature_chooser</code> <code>Callable[[list[JwsSignature]], JwsSignature]</code> <p>a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.</p> <code>lambda sigs: sigs[0]</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The raw signed part from the chosen signature.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def signed_part(\n    self,\n    signature_chooser: Callable[\n        [list[JwsSignature]], JwsSignature\n    ] = lambda sigs: sigs[0],\n) -&gt; bytes:\n\"\"\"Return the signed part from a given signature.\n\n    The signed part is a concatenation of the protected header from a specific signature, then the payload,\n    separated by a dot (`.`).\n    You can select the specific signature with the `signature_chooser` parameter.\n    By default, the first signature is selected.\n\n    Args:\n        signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.\n\n    Returns:\n        The raw signed part from the chosen signature.\n\n    \"\"\"\n    signature = signature_chooser(self.signatures)\n    return JwsSignature.assemble_signed_part(signature.protected, self.payload)\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.compact","title":"compact","text":"<pre><code>compact(\n    signature_chooser: Callable[\n        [list[JwsSignature]], JwsSignature\n    ] = lambda sigs: sigs[0]\n) -&gt; JwsCompact\n</code></pre> <p>Create a compact JWS from a specific signature from this JWS.</p> <p>Parameters:</p> Name Type Description Default <code>signature_chooser</code> <code>Callable[[list[JwsSignature]], JwsSignature]</code> <p>a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.</p> <code>lambda sigs: sigs[0]</code> <p>Returns:</p> Type Description <code>JwsCompact</code> <p>A JwsCompact with the payload and the chosen signature from this JWS.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def compact(\n    self,\n    signature_chooser: Callable[\n        [list[JwsSignature]], JwsSignature\n    ] = lambda sigs: sigs[0],\n) -&gt; JwsCompact:\n\"\"\"Create a compact JWS from a specific signature from this JWS.\n\n    Args:\n        signature_chooser: a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.\n\n    Returns:\n        A JwsCompact with the payload and the chosen signature from this JWS.\n\n    \"\"\"\n    signature = signature_chooser(self.signatures)\n    return JwsCompact.from_parts(\n        JwsSignature.assemble_signed_part(signature.protected, self.payload),\n        signature.signature,\n    )\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.flatten","title":"flatten","text":"<pre><code>flatten(\n    signature_chooser: Callable[\n        [list[JwsSignature]], JwsSignature\n    ] = lambda sigs: sigs[0]\n) -&gt; JwsJsonFlat\n</code></pre> <p>Create a JWS in JSON flat format from a specific signature from this JWS.</p> <p>Parameters:</p> Name Type Description Default <code>signature_chooser</code> <code>Callable[[list[JwsSignature]], JwsSignature]</code> <p>a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.</p> <code>lambda sigs: sigs[0]</code> <p>Returns:</p> Type Description <code>JwsJsonFlat</code> <p>A JwsJsonFlat with the payload and the chosen signature from this JWS.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def flatten(\n    self,\n    signature_chooser: Callable[\n        [list[JwsSignature]], JwsSignature\n    ] = lambda sigs: sigs[0],\n) -&gt; JwsJsonFlat:\n\"\"\"Create a JWS in JSON flat format from a specific signature from this JWS.\n\n    Args:\n        signature_chooser:  a callable that takes the list of signatures from this JWS as parameter and returns the choosen signature.\n\n    Returns:\n        A JwsJsonFlat with the payload and the chosen signature from this JWS.\n\n    \"\"\"\n    signature = signature_chooser(self.signatures)\n    return JwsJsonFlat.from_parts(\n        payload=self[\"payload\"],\n        protected=signature.protected,\n        header=signature.header,\n        signature=signature.signature,\n    )\n</code></pre>"},{"location":"api/#jwskate.jws.json.JwsJsonGeneral.verify_signature","title":"verify_signature","text":"<pre><code>verify_signature(\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None\n) -&gt; bool\n</code></pre> <p>Verify the signatures from this JWS.</p> <p>It will try to validate each signature with the given key, and returns <code>True</code> if at least one signature verifies.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the public key to use</p> required <code>alg</code> <code>str | None</code> <p>the signature algorithm to use, if only 1 is allowed.</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>the allowed signature algorithms, if there are several.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if any of the signature verifies with the given key, <code>False</code> otherwise.</p> Source code in <code>jwskate/jws/json.py</code> <pre><code>def verify_signature(\n    self,\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Verify the signatures from this JWS.\n\n    It will try to validate each signature with the given key, and returns `True` if at least one signature verifies.\n    Args:\n        key: the public key to use\n        alg: the signature algorithm to use, if only 1 is allowed.\n        algs: the allowed signature algorithms, if there are several.\n\n    Returns:\n        `True` if any of the signature verifies with the given key, `False` otherwise.\n\n    \"\"\"\n    for signature in self.signatures:\n        if signature.verify(self.payload, key, alg=alg, algs=algs):\n            return True\n    return False\n</code></pre>"},{"location":"api/#jwskate.jwe","title":"jwskate.jwe","text":"<p>This module implements Json Web Encryption as described in [RFC7516].</p> <p>[RFC7516] : https: //www.rfc-editor.org/rfc/rfc7516</p>"},{"location":"api/#jwskate.jwe.InvalidJwe","title":"InvalidJwe","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when an invalid JWE token is parsed.</p> Source code in <code>jwskate/jwe/compact.py</code> <pre><code>class InvalidJwe(ValueError):\n\"\"\"Raised when an invalid JWE token is parsed.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwe.JweCompact","title":"JweCompact","text":"<p>             Bases: <code>BaseCompactToken</code></p> <p>Represents a Json Web Encryption object, in compact representation, as defined in RFC7516.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes | str</code> <p>the compact representation for this Jwe</p> required Source code in <code>jwskate/jwe/compact.py</code> <pre><code>class JweCompact(BaseCompactToken):\n\"\"\"Represents a Json Web Encryption object, in compact representation, as defined in RFC7516.\n\n    Args:\n        value: the compact representation for this Jwe\n\n    \"\"\"\n\n    def __init__(self, value: bytes | str, max_size: int = 16 * 1024):\n        super().__init__(value, max_size)\n\n        if self.value.count(b\".\") != 4:\n            raise InvalidJwe(\n                \"Invalid JWE: a JWE must contain a header, an encrypted key, an IV, a ciphertext and an authentication tag, separated by dots.\"\n            )\n\n        header, cek, iv, ciphertext, auth_tag = self.value.split(b\".\")\n        try:\n            headers = BinaPy(header).decode_from(\"b64u\").parse_from(\"json\")\n        except ValueError:\n            raise InvalidJwe(\n                \"Invalid JWE header: it must be a Base64URL-encoded JSON object.\"\n            )\n        enc = headers.get(\"enc\")\n        if enc is None or not isinstance(enc, str):\n            raise InvalidJwe(\n                \"Invalid JWE header: this JWE doesn't have a valid 'enc' header.\"\n            )\n        self.headers = headers\n        self.additional_authenticated_data = header\n\n        try:\n            self.wrapped_cek = BinaPy(cek).decode_from(\"b64u\")\n        except ValueError:\n            raise InvalidJwe(\n                \"Invalid JWE CEK: it must be a Base64URL-encoded binary data.\"\n            )\n\n        try:\n            self.initialization_vector = BinaPy(iv).decode_from(\"b64u\")\n        except ValueError:\n            raise InvalidJwe(\n                \"Invalid JWE IV: it must be a Base64URL-encoded binary data.\"\n            )\n\n        try:\n            self.ciphertext = BinaPy(ciphertext).decode_from(\"b64u\")\n        except ValueError:\n            raise InvalidJwe(\n                \"Invalid JWE ciphertext: it must be a Base64URL-encoded binary data.\"\n            )\n\n        try:\n            self.authentication_tag = BinaPy(auth_tag).decode_from(\"b64u\")\n        except ValueError:\n            raise InvalidJwe(\n                \"Invalid JWE authentication tag: it must be a Base64URL-encoded binary data.\"\n            )\n\n    @classmethod\n    def from_parts(\n        cls,\n        *,\n        headers: Mapping[str, Any],\n        cek: bytes,\n        iv: bytes,\n        ciphertext: bytes,\n        tag: bytes,\n    ) -&gt; JweCompact:\n\"\"\"Initialize a `JweCompact` from its different parts (header, cek, iv, ciphertext, tag).\n\n        Args:\n          headers: the headers (as a mapping of name: value)\n          cek: the raw CEK\n          iv: the raw IV\n          ciphertext: the raw ciphertext\n          tag: the authentication tag\n\n        Returns:\n            the initialized `JweCompact` instance\n\n        \"\"\"\n        return cls(\n            b\".\".join(\n                (\n                    BinaPy.serialize_to(\"json\", headers).to(\"b64u\"),\n                    BinaPy(cek).to(\"b64u\"),\n                    BinaPy(iv).to(\"b64u\"),\n                    BinaPy(ciphertext).to(\"b64u\"),\n                    BinaPy(tag).to(\"b64u\"),\n                )\n            )\n        )\n\n    @cached_property\n    def enc(self) -&gt; str:\n\"\"\"Return the `enc` from the JWE header.\n\n        The `enc` header contains the identifier of the CEK encryption algorithm.\n\n        Returns:\n            the enc value\n\n        Raises:\n            AttributeError: if there is no enc header or it is not a string\n\n        \"\"\"\n        return self.get_header(\"enc\")  # type: ignore[no-any-return]\n        # header has been checked at init time\n\n    @classmethod\n    def encrypt(\n        cls,\n        plaintext: bytes | SupportsBytes,\n        key: Jwk | dict[str, Any] | Any,\n        *,\n        enc: str,\n        alg: str | None = None,\n        extra_headers: dict[str, Any] | None = None,\n        cek: bytes | None = None,\n        iv: bytes | None = None,\n        epk: Jwk | None = None,\n    ) -&gt; JweCompact:\n\"\"\"Encrypt an arbitrary plaintext into a `JweCompact`.\n\n        Args:\n          plaintext: the raw plaintext to encrypt\n          key: the public or symmetric key to use for encryption\n          enc: the encryption algorithm to use\n          alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk\n          extra_headers: additional headers to include in the generated token\n          cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`.\n          iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`.\n          epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`.\n\n        Returns:\n            the generated JweCompact instance\n\n        \"\"\"\n        extra_headers = extra_headers or {}\n        key = to_jwk(key)\n        alg = select_alg_class(\n            key.KEY_MANAGEMENT_ALGORITHMS, jwk_alg=key.alg, alg=alg\n        ).name\n\n        cek_jwk, wrapped_cek, cek_headers = key.sender_key(\n            enc=enc, alg=alg, cek=cek, epk=epk, **extra_headers\n        )\n\n        headers = dict(extra_headers, **cek_headers, alg=alg, enc=enc)\n        if key.kid is not None:\n            headers[\"kid\"] = key.kid\n\n        aad = BinaPy.serialize_to(\"json\", headers).to(\"b64u\")\n\n        ciphertext, iv, tag = cek_jwk.encrypt(plaintext, aad=aad, iv=iv, alg=enc)\n\n        return cls.from_parts(\n            headers=headers, cek=wrapped_cek, iv=iv, ciphertext=ciphertext, tag=tag\n        )\n\n    PBES2_ALGORITHMS: Mapping[str, type[BasePbes2]] = {\n        alg.name: alg\n        for alg in [Pbes2_HS256_A128KW, Pbes2_HS384_A192KW, Pbes2_HS512_A256KW]\n    }\n\n    def unwrap_cek(\n        self,\n        key_or_password: Jwk | dict[str, Any] | bytes | str,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; Jwk:\n\"\"\"Unwrap the CEK from this `Jwe` using the provided key or password.\n\n        Args:\n          key_or_password: the decryption JWK or password\n          alg: allowed key management algorithm, if there is only 1\n          algs: allowed key managements algorithms, if there are several\n\n        Returns:\n            the unwrapped CEK, as a SymmetricJwk\n\n        \"\"\"\n        if isinstance(key_or_password, (bytes, str)):\n            password = key_or_password\n            return self.unwrap_cek_with_password(password)\n\n        jwk = to_jwk(key_or_password)\n        select_alg_classes(\n            jwk.KEY_MANAGEMENT_ALGORITHMS,\n            jwk_alg=self.alg,\n            alg=alg,\n            algs=algs,\n            strict=True,\n        )\n        cek = jwk.recipient_key(self.wrapped_cek, **self.headers)\n        return cek\n\n    def decrypt(\n        self,\n        key: Jwk | dict[str, Any] | Any,\n        alg: str | None = None,\n        algs: Iterable[str] | None = None,\n    ) -&gt; BinaPy:\n\"\"\"Decrypts this `Jwe` payload using a `Jwk`.\n\n        Args:\n          key: the decryption key\n          alg: allowed key management algorithm, if there is only 1\n          algs: allowed keys management algorithms, if there are several\n\n        Returns:\n          the decrypted payload\n\n        \"\"\"\n        cek_jwk = self.unwrap_cek(key, alg=alg, algs=algs)\n\n        plaintext = cek_jwk.decrypt(\n            ciphertext=self.ciphertext,\n            iv=self.initialization_vector,\n            tag=self.authentication_tag,\n            aad=self.additional_authenticated_data,\n            alg=self.enc,\n        )\n        return plaintext\n\n    @classmethod\n    def encrypt_with_password(\n        cls,\n        plaintext: SupportsBytes | bytes,\n        password: SupportsBytes | bytes | str,\n        *,\n        alg: str,\n        enc: str,\n        salt: bytes | None = None,\n        count: int = 2000,\n        cek: bytes | None = None,\n        iv: bytes | None = None,\n    ) -&gt; JweCompact:\n\"\"\"Encrypt a payload with a password and return the resulting JweCompact.\n\n        This performs symmetric encryption using PBES2.\n\n        Args:\n          plaintext: the data to encrypt\n          password: the password to use\n          alg: the Key Management alg to use\n          enc: the Payload Encryption alg to use\n          salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value\n          count: the number of PBES2 iterations (recommended minimum 1000)\n          cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value\n          iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value\n\n        Returns:\n            the resulting JweCompact\n\n        Raises:\n            UnsupportedAlg: if the key management alg is not supported\n            ValueError: if the `count` parameter is not a positive integer\n\n        \"\"\"\n        keyalg = cls.PBES2_ALGORITHMS.get(alg)\n        if keyalg is None:\n            raise UnsupportedAlg(\n                f\"Unsupported password-based encryption algorithm '{alg}'. \"\n                f\"Value must be one of {list(cls.PBES2_ALGORITHMS.keys())}.\"\n            )\n\n        if cek is None:\n            cek_jwk = SymmetricJwk.generate_for_alg(enc)\n            cek = cek_jwk.key\n        else:\n            cek_jwk = SymmetricJwk.from_bytes(cek)\n\n        wrapper = keyalg(password)\n        if salt is None:\n            salt = wrapper.generate_salt()\n\n        if count &lt; 1:\n            raise ValueError(\n                \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\"\n            )\n        if count &lt; 1000:\n            warnings.warn(\"PBES2 iteration count should be &gt; 1000.\")\n\n        wrapped_cek = wrapper.wrap_key(cek, salt=salt, count=count)\n\n        headers = dict(alg=alg, enc=enc, p2s=BinaPy(salt).to(\"b64u\").ascii(), p2c=count)\n        aad = BinaPy.serialize_to(\"json\", headers).to(\"b64u\")\n        ciphertext, iv, tag = cek_jwk.encrypt(\n            plaintext=plaintext, aad=aad, alg=enc, iv=iv\n        )\n\n        return cls.from_parts(\n            headers=headers, cek=wrapped_cek, iv=iv, ciphertext=ciphertext, tag=tag\n        )\n\n    def unwrap_cek_with_password(self, password: bytes | str) -&gt; Jwk:\n\"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens.\n\n        Args:\n          password: the decryption password\n\n        Returns:\n            the CEK, as a SymmetricJwk instance\n\n        Raises:\n            UnsupportedAlg: if the token key management algorithm is not supported\n            AttributeError: if the token misses the PBES2-related headers\n\n        \"\"\"\n        keyalg = self.PBES2_ALGORITHMS.get(self.alg)\n        if keyalg is None:\n            raise UnsupportedAlg(\n                f\"Unsupported password-based encryption algorithm '{self.alg}'. \"\n                f\"Value must be one of {list(self.PBES2_ALGORITHMS.keys())}.\"\n            )\n        p2s = self.headers.get(\"p2s\")\n        if p2s is None:\n            raise InvalidJwe(\"Invalid JWE: a required 'p2s' header is missing.\")\n        salt = BinaPy(p2s).decode_from(\"b64u\")\n        p2c = self.headers.get(\"p2c\")\n        if p2c is None:\n            raise InvalidJwe(\"Invalid JWE: a required 'p2c' header is missing.\")\n        if not isinstance(p2c, int) or p2c &lt; 1:\n            raise InvalidJwe(\n                \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\"\n            )\n        wrapper = keyalg(password)\n        cek = wrapper.unwrap_key(self.wrapped_cek, salt=salt, count=p2c)\n        return SymmetricJwk.from_bytes(cek)\n\n    def decrypt_with_password(self, password: bytes | str) -&gt; bytes:\n\"\"\"Decrypt this JWE with a password.\n\n        This only works for tokens encrypted with a password.\n\n        Args:\n          password: the password to use\n\n        Returns:\n            the unencrypted payload\n\n        \"\"\"\n        cek_jwk = self.unwrap_cek_with_password(password)\n        plaintext = cek_jwk.decrypt(\n            ciphertext=self.ciphertext,\n            iv=self.initialization_vector,\n            tag=self.authentication_tag,\n            aad=self.additional_authenticated_data,\n            alg=self.enc,\n        )\n        return plaintext\n</code></pre>"},{"location":"api/#jwskate.jwe.compact.JweCompact.enc","title":"enc  <code>cached</code> <code>property</code>","text":"<pre><code>enc: str\n</code></pre> <p>Return the <code>enc</code> from the JWE header.</p> <p>The <code>enc</code> header contains the identifier of the CEK encryption algorithm.</p> <p>Returns:</p> Type Description <code>str</code> <p>the enc value</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if there is no enc header or it is not a string</p>"},{"location":"api/#jwskate.jwe.compact.JweCompact.from_parts","title":"from_parts  <code>classmethod</code>","text":"<pre><code>from_parts(\n    *,\n    headers: Mapping[str, Any],\n    cek: bytes,\n    iv: bytes,\n    ciphertext: bytes,\n    tag: bytes\n) -&gt; JweCompact\n</code></pre> <p>Initialize a <code>JweCompact</code> from its different parts (header, cek, iv, ciphertext, tag).</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Mapping[str, Any]</code> <p>the headers (as a mapping of name: value)</p> required <code>cek</code> <code>bytes</code> <p>the raw CEK</p> required <code>iv</code> <code>bytes</code> <p>the raw IV</p> required <code>ciphertext</code> <code>bytes</code> <p>the raw ciphertext</p> required <code>tag</code> <code>bytes</code> <p>the authentication tag</p> required <p>Returns:</p> Type Description <code>JweCompact</code> <p>the initialized <code>JweCompact</code> instance</p> Source code in <code>jwskate/jwe/compact.py</code> <pre><code>@classmethod\ndef from_parts(\n    cls,\n    *,\n    headers: Mapping[str, Any],\n    cek: bytes,\n    iv: bytes,\n    ciphertext: bytes,\n    tag: bytes,\n) -&gt; JweCompact:\n\"\"\"Initialize a `JweCompact` from its different parts (header, cek, iv, ciphertext, tag).\n\n    Args:\n      headers: the headers (as a mapping of name: value)\n      cek: the raw CEK\n      iv: the raw IV\n      ciphertext: the raw ciphertext\n      tag: the authentication tag\n\n    Returns:\n        the initialized `JweCompact` instance\n\n    \"\"\"\n    return cls(\n        b\".\".join(\n            (\n                BinaPy.serialize_to(\"json\", headers).to(\"b64u\"),\n                BinaPy(cek).to(\"b64u\"),\n                BinaPy(iv).to(\"b64u\"),\n                BinaPy(ciphertext).to(\"b64u\"),\n                BinaPy(tag).to(\"b64u\"),\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#jwskate.jwe.compact.JweCompact.encrypt","title":"encrypt  <code>classmethod</code>","text":"<pre><code>encrypt(\n    plaintext: bytes | SupportsBytes,\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    enc: str,\n    alg: str | None = None,\n    extra_headers: dict[str, Any] | None = None,\n    cek: bytes | None = None,\n    iv: bytes | None = None,\n    epk: Jwk | None = None\n) -&gt; JweCompact\n</code></pre> <p>Encrypt an arbitrary plaintext into a <code>JweCompact</code>.</p> <p>Parameters:</p> Name Type Description Default <code>plaintext</code> <code>bytes | SupportsBytes</code> <p>the raw plaintext to encrypt</p> required <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the public or symmetric key to use for encryption</p> required <code>enc</code> <code>str</code> <p>the encryption algorithm to use</p> required <code>alg</code> <code>str | None</code> <p>the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk</p> <code>None</code> <code>extra_headers</code> <code>dict[str, Any] | None</code> <p>additional headers to include in the generated token</p> <code>None</code> <code>cek</code> <code>bytes | None</code> <p>the CEK to force use, for algorithms relying on a random CEK. Leave <code>None</code> to have a safe value generated by <code>jwskate</code>.</p> <code>None</code> <code>iv</code> <code>bytes | None</code> <p>the IV to force use. Leave <code>None</code> to have a safe value generated by <code>jwskate</code>.</p> <code>None</code> <code>epk</code> <code>Jwk | None</code> <p>the EPK to force use. Leave <code>None</code> to have a safe value generated by <code>jwskate</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the generated JweCompact instance</p> Source code in <code>jwskate/jwe/compact.py</code> <pre><code>@classmethod\ndef encrypt(\n    cls,\n    plaintext: bytes | SupportsBytes,\n    key: Jwk | dict[str, Any] | Any,\n    *,\n    enc: str,\n    alg: str | None = None,\n    extra_headers: dict[str, Any] | None = None,\n    cek: bytes | None = None,\n    iv: bytes | None = None,\n    epk: Jwk | None = None,\n) -&gt; JweCompact:\n\"\"\"Encrypt an arbitrary plaintext into a `JweCompact`.\n\n    Args:\n      plaintext: the raw plaintext to encrypt\n      key: the public or symmetric key to use for encryption\n      enc: the encryption algorithm to use\n      alg: the Key Management algorithm to use, if there is no 'alg' header defined in the Jwk\n      extra_headers: additional headers to include in the generated token\n      cek: the CEK to force use, for algorithms relying on a random CEK. Leave `None` to have a safe value generated by `jwskate`.\n      iv: the IV to force use. Leave `None` to have a safe value generated by `jwskate`.\n      epk: the EPK to force use. Leave `None` to have a safe value generated by `jwskate`.\n\n    Returns:\n        the generated JweCompact instance\n\n    \"\"\"\n    extra_headers = extra_headers or {}\n    key = to_jwk(key)\n    alg = select_alg_class(\n        key.KEY_MANAGEMENT_ALGORITHMS, jwk_alg=key.alg, alg=alg\n    ).name\n\n    cek_jwk, wrapped_cek, cek_headers = key.sender_key(\n        enc=enc, alg=alg, cek=cek, epk=epk, **extra_headers\n    )\n\n    headers = dict(extra_headers, **cek_headers, alg=alg, enc=enc)\n    if key.kid is not None:\n        headers[\"kid\"] = key.kid\n\n    aad = BinaPy.serialize_to(\"json\", headers).to(\"b64u\")\n\n    ciphertext, iv, tag = cek_jwk.encrypt(plaintext, aad=aad, iv=iv, alg=enc)\n\n    return cls.from_parts(\n        headers=headers, cek=wrapped_cek, iv=iv, ciphertext=ciphertext, tag=tag\n    )\n</code></pre>"},{"location":"api/#jwskate.jwe.compact.JweCompact.unwrap_cek","title":"unwrap_cek","text":"<pre><code>unwrap_cek(\n    key_or_password: Jwk | dict[str, Any] | bytes | str,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; Jwk\n</code></pre> <p>Unwrap the CEK from this <code>Jwe</code> using the provided key or password.</p> <p>Parameters:</p> Name Type Description Default <code>key_or_password</code> <code>Jwk | dict[str, Any] | bytes | str</code> <p>the decryption JWK or password</p> required <code>alg</code> <code>str | None</code> <p>allowed key management algorithm, if there is only 1</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>allowed key managements algorithms, if there are several</p> <code>None</code> <p>Returns:</p> Type Description <code>Jwk</code> <p>the unwrapped CEK, as a SymmetricJwk</p> Source code in <code>jwskate/jwe/compact.py</code> <pre><code>def unwrap_cek(\n    self,\n    key_or_password: Jwk | dict[str, Any] | bytes | str,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; Jwk:\n\"\"\"Unwrap the CEK from this `Jwe` using the provided key or password.\n\n    Args:\n      key_or_password: the decryption JWK or password\n      alg: allowed key management algorithm, if there is only 1\n      algs: allowed key managements algorithms, if there are several\n\n    Returns:\n        the unwrapped CEK, as a SymmetricJwk\n\n    \"\"\"\n    if isinstance(key_or_password, (bytes, str)):\n        password = key_or_password\n        return self.unwrap_cek_with_password(password)\n\n    jwk = to_jwk(key_or_password)\n    select_alg_classes(\n        jwk.KEY_MANAGEMENT_ALGORITHMS,\n        jwk_alg=self.alg,\n        alg=alg,\n        algs=algs,\n        strict=True,\n    )\n    cek = jwk.recipient_key(self.wrapped_cek, **self.headers)\n    return cek\n</code></pre>"},{"location":"api/#jwskate.jwe.compact.JweCompact.decrypt","title":"decrypt","text":"<pre><code>decrypt(\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; BinaPy\n</code></pre> <p>Decrypts this <code>Jwe</code> payload using a <code>Jwk</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk | dict[str, Any] | Any</code> <p>the decryption key</p> required <code>alg</code> <code>str | None</code> <p>allowed key management algorithm, if there is only 1</p> <code>None</code> <code>algs</code> <code>Iterable[str] | None</code> <p>allowed keys management algorithms, if there are several</p> <code>None</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the decrypted payload</p> Source code in <code>jwskate/jwe/compact.py</code> <pre><code>def decrypt(\n    self,\n    key: Jwk | dict[str, Any] | Any,\n    alg: str | None = None,\n    algs: Iterable[str] | None = None,\n) -&gt; BinaPy:\n\"\"\"Decrypts this `Jwe` payload using a `Jwk`.\n\n    Args:\n      key: the decryption key\n      alg: allowed key management algorithm, if there is only 1\n      algs: allowed keys management algorithms, if there are several\n\n    Returns:\n      the decrypted payload\n\n    \"\"\"\n    cek_jwk = self.unwrap_cek(key, alg=alg, algs=algs)\n\n    plaintext = cek_jwk.decrypt(\n        ciphertext=self.ciphertext,\n        iv=self.initialization_vector,\n        tag=self.authentication_tag,\n        aad=self.additional_authenticated_data,\n        alg=self.enc,\n    )\n    return plaintext\n</code></pre>"},{"location":"api/#jwskate.jwe.compact.JweCompact.encrypt_with_password","title":"encrypt_with_password  <code>classmethod</code>","text":"<pre><code>encrypt_with_password(\n    plaintext: SupportsBytes | bytes,\n    password: SupportsBytes | bytes | str,\n    *,\n    alg: str,\n    enc: str,\n    salt: bytes | None = None,\n    count: int = 2000,\n    cek: bytes | None = None,\n    iv: bytes | None = None\n) -&gt; JweCompact\n</code></pre> <p>Encrypt a payload with a password and return the resulting JweCompact.</p> <p>This performs symmetric encryption using PBES2.</p> <p>Parameters:</p> Name Type Description Default <code>plaintext</code> <code>SupportsBytes | bytes</code> <p>the data to encrypt</p> required <code>password</code> <code>SupportsBytes | bytes | str</code> <p>the password to use</p> required <code>alg</code> <code>str</code> <p>the Key Management alg to use</p> required <code>enc</code> <code>str</code> <p>the Payload Encryption alg to use</p> required <code>salt</code> <code>bytes | None</code> <p>the salt to use. Leave <code>None</code> (default) to have <code>jwskate</code> generate a safe random value</p> <code>None</code> <code>count</code> <code>int</code> <p>the number of PBES2 iterations (recommended minimum 1000)</p> <code>2000</code> <code>cek</code> <code>bytes | None</code> <p>the CEK to force use. Leave <code>None</code> (default) to have <code>jwskate</code> generate a safe random value</p> <code>None</code> <code>iv</code> <code>bytes | None</code> <p>the IV to force use. Leave <code>None</code> (default) to have <code>jwskate</code> generate a safe random value</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the resulting JweCompact</p> <p>Raises:</p> Type Description <code>UnsupportedAlg</code> <p>if the key management alg is not supported</p> <code>ValueError</code> <p>if the <code>count</code> parameter is not a positive integer</p> Source code in <code>jwskate/jwe/compact.py</code> <pre><code>@classmethod\ndef encrypt_with_password(\n    cls,\n    plaintext: SupportsBytes | bytes,\n    password: SupportsBytes | bytes | str,\n    *,\n    alg: str,\n    enc: str,\n    salt: bytes | None = None,\n    count: int = 2000,\n    cek: bytes | None = None,\n    iv: bytes | None = None,\n) -&gt; JweCompact:\n\"\"\"Encrypt a payload with a password and return the resulting JweCompact.\n\n    This performs symmetric encryption using PBES2.\n\n    Args:\n      plaintext: the data to encrypt\n      password: the password to use\n      alg: the Key Management alg to use\n      enc: the Payload Encryption alg to use\n      salt: the salt to use. Leave `None` (default) to have `jwskate` generate a safe random value\n      count: the number of PBES2 iterations (recommended minimum 1000)\n      cek: the CEK to force use. Leave `None` (default) to have `jwskate` generate a safe random value\n      iv: the IV to force use. Leave `None` (default) to have `jwskate` generate a safe random value\n\n    Returns:\n        the resulting JweCompact\n\n    Raises:\n        UnsupportedAlg: if the key management alg is not supported\n        ValueError: if the `count` parameter is not a positive integer\n\n    \"\"\"\n    keyalg = cls.PBES2_ALGORITHMS.get(alg)\n    if keyalg is None:\n        raise UnsupportedAlg(\n            f\"Unsupported password-based encryption algorithm '{alg}'. \"\n            f\"Value must be one of {list(cls.PBES2_ALGORITHMS.keys())}.\"\n        )\n\n    if cek is None:\n        cek_jwk = SymmetricJwk.generate_for_alg(enc)\n        cek = cek_jwk.key\n    else:\n        cek_jwk = SymmetricJwk.from_bytes(cek)\n\n    wrapper = keyalg(password)\n    if salt is None:\n        salt = wrapper.generate_salt()\n\n    if count &lt; 1:\n        raise ValueError(\n            \"PBES2 iteration count must be a positive integer, with a minimum recommended value of 1000.\"\n        )\n    if count &lt; 1000:\n        warnings.warn(\"PBES2 iteration count should be &gt; 1000.\")\n\n    wrapped_cek = wrapper.wrap_key(cek, salt=salt, count=count)\n\n    headers = dict(alg=alg, enc=enc, p2s=BinaPy(salt).to(\"b64u\").ascii(), p2c=count)\n    aad = BinaPy.serialize_to(\"json\", headers).to(\"b64u\")\n    ciphertext, iv, tag = cek_jwk.encrypt(\n        plaintext=plaintext, aad=aad, alg=enc, iv=iv\n    )\n\n    return cls.from_parts(\n        headers=headers, cek=wrapped_cek, iv=iv, ciphertext=ciphertext, tag=tag\n    )\n</code></pre>"},{"location":"api/#jwskate.jwe.compact.JweCompact.unwrap_cek_with_password","title":"unwrap_cek_with_password","text":"<pre><code>unwrap_cek_with_password(password: bytes | str) -&gt; Jwk\n</code></pre> <p>Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>bytes | str</code> <p>the decryption password</p> required <p>Returns:</p> Type Description <code>Jwk</code> <p>the CEK, as a SymmetricJwk instance</p> <p>Raises:</p> Type Description <code>UnsupportedAlg</code> <p>if the token key management algorithm is not supported</p> <code>AttributeError</code> <p>if the token misses the PBES2-related headers</p> Source code in <code>jwskate/jwe/compact.py</code> <pre><code>def unwrap_cek_with_password(self, password: bytes | str) -&gt; Jwk:\n\"\"\"Unwrap a CEK using a password. Works only for password-encrypted JWE Tokens.\n\n    Args:\n      password: the decryption password\n\n    Returns:\n        the CEK, as a SymmetricJwk instance\n\n    Raises:\n        UnsupportedAlg: if the token key management algorithm is not supported\n        AttributeError: if the token misses the PBES2-related headers\n\n    \"\"\"\n    keyalg = self.PBES2_ALGORITHMS.get(self.alg)\n    if keyalg is None:\n        raise UnsupportedAlg(\n            f\"Unsupported password-based encryption algorithm '{self.alg}'. \"\n            f\"Value must be one of {list(self.PBES2_ALGORITHMS.keys())}.\"\n        )\n    p2s = self.headers.get(\"p2s\")\n    if p2s is None:\n        raise InvalidJwe(\"Invalid JWE: a required 'p2s' header is missing.\")\n    salt = BinaPy(p2s).decode_from(\"b64u\")\n    p2c = self.headers.get(\"p2c\")\n    if p2c is None:\n        raise InvalidJwe(\"Invalid JWE: a required 'p2c' header is missing.\")\n    if not isinstance(p2c, int) or p2c &lt; 1:\n        raise InvalidJwe(\n            \"Invalid JWE: invalid value for the 'p2c' header, must be a positive integer.\"\n        )\n    wrapper = keyalg(password)\n    cek = wrapper.unwrap_key(self.wrapped_cek, salt=salt, count=p2c)\n    return SymmetricJwk.from_bytes(cek)\n</code></pre>"},{"location":"api/#jwskate.jwe.compact.JweCompact.decrypt_with_password","title":"decrypt_with_password","text":"<pre><code>decrypt_with_password(password: bytes | str) -&gt; bytes\n</code></pre> <p>Decrypt this JWE with a password.</p> <p>This only works for tokens encrypted with a password.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>bytes | str</code> <p>the password to use</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>the unencrypted payload</p> Source code in <code>jwskate/jwe/compact.py</code> <pre><code>def decrypt_with_password(self, password: bytes | str) -&gt; bytes:\n\"\"\"Decrypt this JWE with a password.\n\n    This only works for tokens encrypted with a password.\n\n    Args:\n      password: the password to use\n\n    Returns:\n        the unencrypted payload\n\n    \"\"\"\n    cek_jwk = self.unwrap_cek_with_password(password)\n    plaintext = cek_jwk.decrypt(\n        ciphertext=self.ciphertext,\n        iv=self.initialization_vector,\n        tag=self.authentication_tag,\n        aad=self.additional_authenticated_data,\n        alg=self.enc,\n    )\n    return plaintext\n</code></pre>"},{"location":"api/#jwskate.jwa","title":"jwskate.jwa","text":"<p>This module implements the Json Web Algorithms as defined in RFC7518.</p> <p>Each algorithm is represented as a wrapper around a symmetric or asymmetric key, and exposes the cryptographic operations as methods. The cryptographic operations themselves are delegated to <code>cryptography</code>.</p>"},{"location":"api/#jwskate.jwa.P_256","title":"P_256  <code>module-attribute</code>","text":"<pre><code>P_256: EllipticCurve = EllipticCurve(\n    name=\"P-256\",\n    cryptography_curve=ec.SECP256R1(),\n    coordinate_size=32,\n)\n</code></pre> <p>P-256 curve.</p>"},{"location":"api/#jwskate.jwa.P_384","title":"P_384  <code>module-attribute</code>","text":"<pre><code>P_384: EllipticCurve = EllipticCurve(\n    name=\"P-384\",\n    cryptography_curve=ec.SECP384R1(),\n    coordinate_size=48,\n)\n</code></pre> <p>P-384 curve.</p>"},{"location":"api/#jwskate.jwa.Ed25519","title":"Ed25519  <code>module-attribute</code>","text":"<pre><code>Ed25519 = OKPCurve(\n    name=\"Ed25519\",\n    description=\"Ed25519 signature algorithm key pairs\",\n    cryptography_private_key_class=ed25519.Ed25519PrivateKey,\n    cryptography_public_key_class=ed25519.Ed25519PublicKey,\n    use=\"sig\",\n)\n</code></pre> <p>Ed25519 curve.</p>"},{"location":"api/#jwskate.jwa.P_521","title":"P_521  <code>module-attribute</code>","text":"<pre><code>P_521: EllipticCurve = EllipticCurve(\n    name=\"P-521\",\n    cryptography_curve=ec.SECP521R1(),\n    coordinate_size=66,\n)\n</code></pre> <p>P-521 curve.</p>"},{"location":"api/#jwskate.jwa.Ed448","title":"Ed448  <code>module-attribute</code>","text":"<pre><code>Ed448 = OKPCurve(\n    name=\"Ed448\",\n    description=\"Ed448 signature algorithm key pairs\",\n    cryptography_private_key_class=ed448.Ed448PrivateKey,\n    cryptography_public_key_class=ed448.Ed448PublicKey,\n    use=\"sig\",\n)\n</code></pre> <p>Ed448 curve.</p>"},{"location":"api/#jwskate.jwa.secp256k1","title":"secp256k1  <code>module-attribute</code>","text":"<pre><code>secp256k1: EllipticCurve = EllipticCurve(\n    name=\"secp256k1\",\n    cryptography_curve=ec.SECP256K1(),\n    coordinate_size=32,\n)\n</code></pre> <p>secp256k1 curve</p>"},{"location":"api/#jwskate.jwa.X25519","title":"X25519  <code>module-attribute</code>","text":"<pre><code>X25519 = OKPCurve(\n    name=\"X25519\",\n    description=\"X25519 function key pairs\",\n    cryptography_private_key_class=x25519.X25519PrivateKey,\n    cryptography_public_key_class=x25519.X25519PublicKey,\n    use=\"enc\",\n)\n</code></pre> <p>X25519 curve.</p>"},{"location":"api/#jwskate.jwa.X448","title":"X448  <code>module-attribute</code>","text":"<pre><code>X448 = OKPCurve(\n    name=\"X448\",\n    description=\"X448 function key pairs\",\n    cryptography_private_key_class=x448.X448PrivateKey,\n    cryptography_public_key_class=x448.X448PublicKey,\n    use=\"enc\",\n)\n</code></pre> <p>X448 curve.</p>"},{"location":"api/#jwskate.jwa.DirectKeyUse","title":"DirectKeyUse","text":"<p>             Bases: <code>BaseKeyManagementAlg</code>, <code>BaseSymmetricAlg</code></p> <p>Direct use of a shared symmetric key as the CEK.</p> Source code in <code>jwskate/jwa/key_mgmt/dir.py</code> <pre><code>class DirectKeyUse(BaseKeyManagementAlg, BaseSymmetricAlg):\n\"\"\"Direct use of a shared symmetric key as the CEK.\"\"\"\n\n    name = \"dir\"\n    description = __doc__\n\n    def direct_key(self, aesalg: type[BaseSymmetricAlg]) -&gt; BinaPy:\n\"\"\"Check that the current key is appropriate for a given alg and return that same key.\n\n        Args:\n          aesalg: the AES encryption alg to use\n\n        Returns:\n          the current configured key, as-is\n\n        \"\"\"\n        aesalg.check_key(self.key)\n        return BinaPy(self.key)\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.dir.DirectKeyUse.direct_key","title":"direct_key","text":"<pre><code>direct_key(aesalg: type[BaseSymmetricAlg]) -&gt; BinaPy\n</code></pre> <p>Check that the current key is appropriate for a given alg and return that same key.</p> <p>Parameters:</p> Name Type Description Default <code>aesalg</code> <code>type[BaseSymmetricAlg]</code> <p>the AES encryption alg to use</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the current configured key, as-is</p> Source code in <code>jwskate/jwa/key_mgmt/dir.py</code> <pre><code>def direct_key(self, aesalg: type[BaseSymmetricAlg]) -&gt; BinaPy:\n\"\"\"Check that the current key is appropriate for a given alg and return that same key.\n\n    Args:\n      aesalg: the AES encryption alg to use\n\n    Returns:\n      the current configured key, as-is\n\n    \"\"\"\n    aesalg.check_key(self.key)\n    return BinaPy(self.key)\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseAesGcmKeyWrap","title":"BaseAesGcmKeyWrap","text":"<p>             Bases: <code>BaseAESGCM</code>, <code>BaseKeyManagementAlg</code></p> <p>Base class for AES-GCM Key wrapping algorithms.</p> Source code in <code>jwskate/jwa/key_mgmt/aesgcmkw.py</code> <pre><code>class BaseAesGcmKeyWrap(BaseAESGCM, BaseKeyManagementAlg):\n\"\"\"Base class for AES-GCM Key wrapping algorithms.\"\"\"\n\n    use = \"enc\"\n\n    key_size: int\n\"\"\"Required key size, in bits.\"\"\"\n    tag_size: int = 16\n\"\"\"Authentication tag size, in bits.\"\"\"\n    iv_size: int = 96\n\"\"\"Initialisation Vector size, in bits.\"\"\"\n\n    def wrap_key(\n        self, plainkey: bytes | SupportsBytes, *, iv: bytes | SupportsBytes\n    ) -&gt; tuple[BinaPy, BinaPy]:\n\"\"\"Wrap a symmetric key, which is typically used as Content Encryption Key (CEK).\n\n        This method is used by the sender of the encrypted message.\n\n        This needs a random Initialisation Vector (`iv`) of the appropriate size,\n        which you can generate using the classmethod `generate_iv()`.\n\n        Args:\n          plainkey: the key to wrap\n          iv: the Initialisation Vector to use\n\n        Returns:\n          a tuple (wrapped_key, authentication_tag)\n\n        \"\"\"\n        return self.encrypt(plainkey, iv=iv)\n\n    def unwrap_key(\n        self,\n        cipherkey: bytes | SupportsBytes,\n        *,\n        tag: bytes | SupportsBytes,\n        iv: bytes | SupportsBytes,\n    ) -&gt; BinaPy:\n\"\"\"Unwrap a symmetric key.\n\n        This method is used by the recipient of an encrypted message.\n\n        This requires:\n        - the same IV that was provided during encryption\n        - the same Authentication Tag that was generated during encryption\n\n        Args:\n          cipherkey: the wrapped key\n          tag: the authentication tag\n          iv: the Initialisation Vector\n\n        Returns:\n          the unwrapped key.\n\n        \"\"\"\n        return self.decrypt(cipherkey, auth_tag=tag, iv=iv)\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.key_size","title":"key_size  <code>instance-attribute</code>","text":"<pre><code>key_size: int\n</code></pre> <p>Required key size, in bits.</p>"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.tag_size","title":"tag_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_size: int = 16\n</code></pre> <p>Authentication tag size, in bits.</p>"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.iv_size","title":"iv_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iv_size: int = 96\n</code></pre> <p>Initialisation Vector size, in bits.</p>"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.wrap_key","title":"wrap_key","text":"<pre><code>wrap_key(\n    plainkey: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes\n) -&gt; tuple[BinaPy, BinaPy]\n</code></pre> <p>Wrap a symmetric key, which is typically used as Content Encryption Key (CEK).</p> <p>This method is used by the sender of the encrypted message.</p> <p>This needs a random Initialisation Vector (<code>iv</code>) of the appropriate size, which you can generate using the classmethod <code>generate_iv()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>plainkey</code> <code>bytes | SupportsBytes</code> <p>the key to wrap</p> required <code>iv</code> <code>bytes | SupportsBytes</code> <p>the Initialisation Vector to use</p> required <p>Returns:</p> Type Description <code>tuple[BinaPy, BinaPy]</code> <p>a tuple (wrapped_key, authentication_tag)</p> Source code in <code>jwskate/jwa/key_mgmt/aesgcmkw.py</code> <pre><code>def wrap_key(\n    self, plainkey: bytes | SupportsBytes, *, iv: bytes | SupportsBytes\n) -&gt; tuple[BinaPy, BinaPy]:\n\"\"\"Wrap a symmetric key, which is typically used as Content Encryption Key (CEK).\n\n    This method is used by the sender of the encrypted message.\n\n    This needs a random Initialisation Vector (`iv`) of the appropriate size,\n    which you can generate using the classmethod `generate_iv()`.\n\n    Args:\n      plainkey: the key to wrap\n      iv: the Initialisation Vector to use\n\n    Returns:\n      a tuple (wrapped_key, authentication_tag)\n\n    \"\"\"\n    return self.encrypt(plainkey, iv=iv)\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.aesgcmkw.BaseAesGcmKeyWrap.unwrap_key","title":"unwrap_key","text":"<pre><code>unwrap_key(\n    cipherkey: bytes | SupportsBytes,\n    *,\n    tag: bytes | SupportsBytes,\n    iv: bytes | SupportsBytes\n) -&gt; BinaPy\n</code></pre> <p>Unwrap a symmetric key.</p> <p>This method is used by the recipient of an encrypted message.</p> <p>This requires: - the same IV that was provided during encryption - the same Authentication Tag that was generated during encryption</p> <p>Parameters:</p> Name Type Description Default <code>cipherkey</code> <code>bytes | SupportsBytes</code> <p>the wrapped key</p> required <code>tag</code> <code>bytes | SupportsBytes</code> <p>the authentication tag</p> required <code>iv</code> <code>bytes | SupportsBytes</code> <p>the Initialisation Vector</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the unwrapped key.</p> Source code in <code>jwskate/jwa/key_mgmt/aesgcmkw.py</code> <pre><code>def unwrap_key(\n    self,\n    cipherkey: bytes | SupportsBytes,\n    *,\n    tag: bytes | SupportsBytes,\n    iv: bytes | SupportsBytes,\n) -&gt; BinaPy:\n\"\"\"Unwrap a symmetric key.\n\n    This method is used by the recipient of an encrypted message.\n\n    This requires:\n    - the same IV that was provided during encryption\n    - the same Authentication Tag that was generated during encryption\n\n    Args:\n      cipherkey: the wrapped key\n      tag: the authentication tag\n      iv: the Initialisation Vector\n\n    Returns:\n      the unwrapped key.\n\n    \"\"\"\n    return self.decrypt(cipherkey, auth_tag=tag, iv=iv)\n</code></pre>"},{"location":"api/#jwskate.jwa.PrivateKeyRequired","title":"PrivateKeyRequired","text":"<p>             Bases: <code>AttributeError</code></p> <p>Raised when a public key is provided for an operation that requires a private key.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>class PrivateKeyRequired(AttributeError):\n\"\"\"Raised when a public key is provided for an operation that requires a private key.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwa.EllipticCurve","title":"EllipticCurve  <code>dataclass</code>","text":"<p>A descriptive class for Elliptic Curves.</p> <p>Elliptic Curves have a name, a <code>cryptography.ec.EllipticCurve</code>, and a coordinate size.</p> Source code in <code>jwskate/jwa/ec.py</code> <pre><code>@dataclass\nclass EllipticCurve:\n\"\"\"A descriptive class for Elliptic Curves.\n\n    Elliptic Curves have a name, a `cryptography.ec.EllipticCurve`, and a coordinate size.\n\n    \"\"\"\n\n    name: str\n\"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-\n    key-elliptic-curve).\n\n    This name will appear in `alg` or `enc` fields in JOSE headers.\n    \"\"\"\n\n    cryptography_curve: ec.EllipticCurve\n\"\"\"`cryptography` curve instance.\"\"\"\n\n    coordinate_size: int\n\"\"\"Coordinate size, in bytes.\"\"\"\n\n    instances: ClassVar[dict[str, EllipticCurve]] = {}\n\"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Automatically register subclasses in the instance registry.\"\"\"\n        self.instances[self.name] = self\n\n    def generate(self) -&gt; tuple[int, int, int]:\n\"\"\"Generate a new EC key on this curve.\n\n        Returns:\n             a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key)\n\n        \"\"\"\n        key = ec.generate_private_key(self.cryptography_curve)\n        pn = key.private_numbers()  # type: ignore[attr-defined]\n        x = pn.public_numbers.x\n        y = pn.public_numbers.y\n        d = pn.private_value\n        return x, y, d\n\n    @classmethod\n    def get_curve(\n        cls, key: ec.EllipticCurvePublicKey | ec.EllipticCurvePrivateKey\n    ) -&gt; EllipticCurve:\n\"\"\"Get the appropriate `EllipticCurve` instance for a given key.\n\n        The provided key must be an `EllipticCurvePublicKey` or `EllipticCurvePrivateKey`\n        from the `cryptography` module.\n\n        Args:\n          key: an Elliptic Curve private or public key from `cryptography`.\n\n        Returns:\n          the appropriate instance of EllipticCurve for the given key.\n\n        Raises:\n            NotImplementedError: if the curve is not supported\n\n        \"\"\"\n        for c in cls.instances.values():\n            if c.cryptography_curve.name == key.curve.name:\n                return c\n        raise NotImplementedError(f\"Unsupported Curve {key.curve.name}\")\n\n    @classmethod\n    def get_jwk_parameters(\n        cls, key: ec.EllipticCurvePrivateKey | ec.EllipticCurvePublicKey\n    ) -&gt; dict[str, Any]:\n\"\"\"Extract all private and public parameters from the given `cryptography` key.\n\n        Key must be an instance of `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`.\n\n        Args:\n          key: an Elliptic Curve public or private key from `cryptography`.\n\n        Returns:\n          a dict of JWK parameters matching that key\n\n        Raises:\n            TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey\n\n        \"\"\"\n        public_numbers: ec.EllipticCurvePublicNumbers\n        if isinstance(key, ec.EllipticCurvePrivateKey):\n            public_numbers = key.public_key().public_numbers()\n        elif isinstance(key, ec.EllipticCurvePublicKey):\n            public_numbers = key.public_numbers()\n        else:\n            raise TypeError(\n                \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\"\n            )\n\n        crv = cls.get_curve(key)\n        x = BinaPy.from_int(public_numbers.x, crv.coordinate_size).to(\"b64u\").ascii()\n        y = BinaPy.from_int(public_numbers.y, crv.coordinate_size).to(\"b64u\").ascii()\n        parameters = {\"kty\": KeyTypes.EC, \"crv\": crv.name, \"x\": x, \"y\": y}\n        if isinstance(key, ec.EllipticCurvePrivateKey):\n            pn = key.private_numbers()  # type: ignore[attr-defined]\n            d = (\n                BinaPy.from_int(pn.private_value, crv.coordinate_size)\n                .to(\"b64u\")\n                .ascii()\n            )\n            parameters[\"d\"] = d\n        return parameters\n</code></pre>"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Curve name as defined in IANA JOSE.</p> <p>This name will appear in <code>alg</code> or <code>enc</code> fields in JOSE headers.</p>"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.cryptography_curve","title":"cryptography_curve  <code>instance-attribute</code>","text":"<pre><code>cryptography_curve: ec.EllipticCurve\n</code></pre> <p><code>cryptography</code> curve instance.</p>"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.coordinate_size","title":"coordinate_size  <code>instance-attribute</code>","text":"<pre><code>coordinate_size: int\n</code></pre> <p>Coordinate size, in bytes.</p>"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.instances","title":"instances  <code>class-attribute</code>","text":"<pre><code>instances: dict[str, EllipticCurve] = {}\n</code></pre> <p>Registry of subclasses, in a {name: instance} mapping.</p>"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Automatically register subclasses in the instance registry.</p> Source code in <code>jwskate/jwa/ec.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Automatically register subclasses in the instance registry.\"\"\"\n    self.instances[self.name] = self\n</code></pre>"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.generate","title":"generate","text":"<pre><code>generate() -&gt; tuple[int, int, int]\n</code></pre> <p>Generate a new EC key on this curve.</p> <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>a tuple of 4 <code>int</code>s: <code>x</code> and <code>y</code> coordinates (public key) and <code>d</code> (private key)</p> Source code in <code>jwskate/jwa/ec.py</code> <pre><code>def generate(self) -&gt; tuple[int, int, int]:\n\"\"\"Generate a new EC key on this curve.\n\n    Returns:\n         a tuple of 4 `int`s: `x` and `y` coordinates (public key) and `d` (private key)\n\n    \"\"\"\n    key = ec.generate_private_key(self.cryptography_curve)\n    pn = key.private_numbers()  # type: ignore[attr-defined]\n    x = pn.public_numbers.x\n    y = pn.public_numbers.y\n    d = pn.private_value\n    return x, y, d\n</code></pre>"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_curve","title":"get_curve  <code>classmethod</code>","text":"<pre><code>get_curve(\n    key: ec.EllipticCurvePublicKey\n    | ec.EllipticCurvePrivateKey,\n) -&gt; EllipticCurve\n</code></pre> <p>Get the appropriate <code>EllipticCurve</code> instance for a given key.</p> <p>The provided key must be an <code>EllipticCurvePublicKey</code> or <code>EllipticCurvePrivateKey</code> from the <code>cryptography</code> module.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>ec.EllipticCurvePublicKey | ec.EllipticCurvePrivateKey</code> <p>an Elliptic Curve private or public key from <code>cryptography</code>.</p> required <p>Returns:</p> Type Description <code>EllipticCurve</code> <p>the appropriate instance of EllipticCurve for the given key.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the curve is not supported</p> Source code in <code>jwskate/jwa/ec.py</code> <pre><code>@classmethod\ndef get_curve(\n    cls, key: ec.EllipticCurvePublicKey | ec.EllipticCurvePrivateKey\n) -&gt; EllipticCurve:\n\"\"\"Get the appropriate `EllipticCurve` instance for a given key.\n\n    The provided key must be an `EllipticCurvePublicKey` or `EllipticCurvePrivateKey`\n    from the `cryptography` module.\n\n    Args:\n      key: an Elliptic Curve private or public key from `cryptography`.\n\n    Returns:\n      the appropriate instance of EllipticCurve for the given key.\n\n    Raises:\n        NotImplementedError: if the curve is not supported\n\n    \"\"\"\n    for c in cls.instances.values():\n        if c.cryptography_curve.name == key.curve.name:\n            return c\n    raise NotImplementedError(f\"Unsupported Curve {key.curve.name}\")\n</code></pre>"},{"location":"api/#jwskate.jwa.ec.EllipticCurve.get_jwk_parameters","title":"get_jwk_parameters  <code>classmethod</code>","text":"<pre><code>get_jwk_parameters(\n    key: ec.EllipticCurvePrivateKey\n    | ec.EllipticCurvePublicKey,\n) -&gt; dict[str, Any]\n</code></pre> <p>Extract all private and public parameters from the given <code>cryptography</code> key.</p> <p>Key must be an instance of <code>EllipticCurvePrivateKey</code> or <code>EllipticCurvePublicKey</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>ec.EllipticCurvePrivateKey | ec.EllipticCurvePublicKey</code> <p>an Elliptic Curve public or private key from <code>cryptography</code>.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>a dict of JWK parameters matching that key</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey</p> Source code in <code>jwskate/jwa/ec.py</code> <pre><code>@classmethod\ndef get_jwk_parameters(\n    cls, key: ec.EllipticCurvePrivateKey | ec.EllipticCurvePublicKey\n) -&gt; dict[str, Any]:\n\"\"\"Extract all private and public parameters from the given `cryptography` key.\n\n    Key must be an instance of `EllipticCurvePrivateKey` or `EllipticCurvePublicKey`.\n\n    Args:\n      key: an Elliptic Curve public or private key from `cryptography`.\n\n    Returns:\n      a dict of JWK parameters matching that key\n\n    Raises:\n        TypeError: if the provided key is not an EllipticCurvePrivateKey or EllipticCurvePublicKey\n\n    \"\"\"\n    public_numbers: ec.EllipticCurvePublicNumbers\n    if isinstance(key, ec.EllipticCurvePrivateKey):\n        public_numbers = key.public_key().public_numbers()\n    elif isinstance(key, ec.EllipticCurvePublicKey):\n        public_numbers = key.public_numbers()\n    else:\n        raise TypeError(\n            \"A EllipticCurvePrivateKey or a EllipticCurvePublicKey is required.\"\n        )\n\n    crv = cls.get_curve(key)\n    x = BinaPy.from_int(public_numbers.x, crv.coordinate_size).to(\"b64u\").ascii()\n    y = BinaPy.from_int(public_numbers.y, crv.coordinate_size).to(\"b64u\").ascii()\n    parameters = {\"kty\": KeyTypes.EC, \"crv\": crv.name, \"x\": x, \"y\": y}\n    if isinstance(key, ec.EllipticCurvePrivateKey):\n        pn = key.private_numbers()  # type: ignore[attr-defined]\n        d = (\n            BinaPy.from_int(pn.private_value, crv.coordinate_size)\n            .to(\"b64u\")\n            .ascii()\n        )\n        parameters[\"d\"] = d\n    return parameters\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseAesKeyWrap","title":"BaseAesKeyWrap","text":"<p>             Bases: <code>BaseKeyManagementAlg</code>, <code>BaseSymmetricAlg</code></p> <p>Base class for AES KW algorithms.</p> Source code in <code>jwskate/jwa/key_mgmt/aeskw.py</code> <pre><code>class BaseAesKeyWrap(BaseKeyManagementAlg, BaseSymmetricAlg):\n\"\"\"Base class for AES KW algorithms.\"\"\"\n\n    key_size: int\n\"\"\"Required AES key size in bits.\"\"\"\n\n    @classmethod\n    @override\n    def check_key(cls, key: bytes) -&gt; None:\n\"\"\"Check that a key is valid for usage with this algorithm.\n\n        To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits).\n\n        Args:\n          key: a key to check\n\n        Raises:\n            ValueError: if the key is not appropriate\n\n        \"\"\"\n        if not isinstance(key, bytes) or len(key) * 8 != cls.key_size:\n            raise ValueError(f\"Key must be {cls.key_size} bits.\")\n\n    @classmethod\n    @override\n    def with_random_key(cls) -&gt; Self:\n        return cls(BinaPy.random_bits(cls.key_size))\n\n    def wrap_key(self, plainkey: bytes) -&gt; BinaPy:\n\"\"\"Wrap a key.\n\n        Args:\n          plainkey: the key to wrap.\n\n        Returns:\n          BinaPy: the wrapped key.\n\n        \"\"\"\n        return BinaPy(keywrap.aes_key_wrap(self.key, plainkey))\n\n    def unwrap_key(self, cipherkey: bytes | SupportsBytes) -&gt; BinaPy:\n\"\"\"Unwrap a key.\n\n        Args:\n          cipherkey: the wrapped key.\n\n        Returns:\n          BinaPy: the unwrapped key.\n\n        \"\"\"\n        if not isinstance(cipherkey, bytes):\n            cipherkey = bytes(cipherkey)\n\n        return BinaPy(keywrap.aes_key_unwrap(self.key, cipherkey))\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.key_size","title":"key_size  <code>instance-attribute</code>","text":"<pre><code>key_size: int\n</code></pre> <p>Required AES key size in bits.</p>"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.check_key","title":"check_key  <code>classmethod</code>","text":"<pre><code>check_key(key: bytes) -&gt; None\n</code></pre> <p>Check that a key is valid for usage with this algorithm.</p> <p>To be valid, a key must be <code>bytes</code> and be of appropriate length (128, 192 or 256 bits).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>a key to check</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the key is not appropriate</p> Source code in <code>jwskate/jwa/key_mgmt/aeskw.py</code> <pre><code>@classmethod\n@override\ndef check_key(cls, key: bytes) -&gt; None:\n\"\"\"Check that a key is valid for usage with this algorithm.\n\n    To be valid, a key must be `bytes` and be of appropriate length (128, 192 or 256 bits).\n\n    Args:\n      key: a key to check\n\n    Raises:\n        ValueError: if the key is not appropriate\n\n    \"\"\"\n    if not isinstance(key, bytes) or len(key) * 8 != cls.key_size:\n        raise ValueError(f\"Key must be {cls.key_size} bits.\")\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.wrap_key","title":"wrap_key","text":"<pre><code>wrap_key(plainkey: bytes) -&gt; BinaPy\n</code></pre> <p>Wrap a key.</p> <p>Parameters:</p> Name Type Description Default <code>plainkey</code> <code>bytes</code> <p>the key to wrap.</p> required <p>Returns:</p> Name Type Description <code>BinaPy</code> <code>BinaPy</code> <p>the wrapped key.</p> Source code in <code>jwskate/jwa/key_mgmt/aeskw.py</code> <pre><code>def wrap_key(self, plainkey: bytes) -&gt; BinaPy:\n\"\"\"Wrap a key.\n\n    Args:\n      plainkey: the key to wrap.\n\n    Returns:\n      BinaPy: the wrapped key.\n\n    \"\"\"\n    return BinaPy(keywrap.aes_key_wrap(self.key, plainkey))\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.aeskw.BaseAesKeyWrap.unwrap_key","title":"unwrap_key","text":"<pre><code>unwrap_key(cipherkey: bytes | SupportsBytes) -&gt; BinaPy\n</code></pre> <p>Unwrap a key.</p> <p>Parameters:</p> Name Type Description Default <code>cipherkey</code> <code>bytes | SupportsBytes</code> <p>the wrapped key.</p> required <p>Returns:</p> Name Type Description <code>BinaPy</code> <code>BinaPy</code> <p>the unwrapped key.</p> Source code in <code>jwskate/jwa/key_mgmt/aeskw.py</code> <pre><code>def unwrap_key(self, cipherkey: bytes | SupportsBytes) -&gt; BinaPy:\n\"\"\"Unwrap a key.\n\n    Args:\n      cipherkey: the wrapped key.\n\n    Returns:\n      BinaPy: the unwrapped key.\n\n    \"\"\"\n    if not isinstance(cipherkey, bytes):\n        cipherkey = bytes(cipherkey)\n\n    return BinaPy(keywrap.aes_key_unwrap(self.key, cipherkey))\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseHMACSigAlg","title":"BaseHMACSigAlg","text":"<p>             Bases: <code>BaseSymmetricAlg</code>, <code>BaseSignatureAlg</code></p> <p>Base class for HMAC signature algorithms.</p> Source code in <code>jwskate/jwa/signature/hmac.py</code> <pre><code>class BaseHMACSigAlg(BaseSymmetricAlg, BaseSignatureAlg):\n\"\"\"Base class for HMAC signature algorithms.\"\"\"\n\n    mac: type[hmac.HMAC] = hmac.HMAC\n    min_key_size: int\n\n    @classmethod\n    @override\n    def with_random_key(cls) -&gt; Self:\n        return cls(BinaPy.random_bits(cls.min_key_size))\n\n    def sign(self, data: bytes | SupportsBytes) -&gt; BinaPy:  # noqa: D102\n        if not isinstance(data, bytes):\n            data = bytes(data)\n\n        if self.read_only:\n            raise NotImplementedError\n        m = self.mac(self.key, self.hashing_alg)\n        m.update(data)\n        signature = m.finalize()\n        return BinaPy(signature)\n\n    def verify(\n        self, data: bytes | SupportsBytes, signature: bytes | SupportsBytes\n    ) -&gt; bool:  # noqa: D102\n        if not isinstance(data, bytes):\n            data = bytes(data)\n\n        if not isinstance(signature, bytes):\n            signature = bytes(signature)\n\n        candidate_signature = self.sign(data)\n        return candidate_signature == signature\n</code></pre>"},{"location":"api/#jwskate.jwa.BasePbes2","title":"BasePbes2","text":"<p>             Bases: <code>BaseKeyManagementAlg</code></p> <p>Base class for PBES2 based algorithms.</p> <p>PBES2 derives a cryptographic key from a human-provided password.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>SupportsBytes | bytes | str</code> <p>the encryption/decryption password to use</p> required Source code in <code>jwskate/jwa/key_mgmt/pbes2.py</code> <pre><code>class BasePbes2(BaseKeyManagementAlg):\n\"\"\"Base class for PBES2 based algorithms.\n\n    PBES2 derives a cryptographic key from a human-provided password.\n\n    Args:\n        password: the encryption/decryption password to use\n\n    \"\"\"\n\n    kwalg: type[BaseAesKeyWrap]\n    hash_alg: hashes.HashAlgorithm\n\n    def __init__(self, password: SupportsBytes | bytes | str):\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n        if not isinstance(password, bytes):\n            password = bytes(password)\n        self.password = password\n\n    @classmethod\n    def generate_salt(cls, size: int = 12) -&gt; BinaPy:\n\"\"\"Generate a salt that is suitable for use for encryption.\n\n        Args:\n          size: size of the generated salt, in bytes\n\n        Returns:\n            the generated salt\n\n        Raises:\n            ValueError: if the salt is less than 8 bytes long\n\n        \"\"\"\n        if size &lt; 8:\n            raise ValueError(\"salts used for PBES2 must be at least 8 bytes long\")\n        return BinaPy.random(size)\n\n    def derive(self, *, salt: bytes, count: int) -&gt; BinaPy:\n\"\"\"Derive an encryption key.\n\n        Derivation is based on the configured password, a given salt and the number of\n        PBKDF iterations.\n\n        Args:\n          salt: the generated salt\n          count: number of PBKDF iterations\n\n        Returns:\n            the generated encryption/decryption key\n\n        \"\"\"\n        full_salt = self.name.encode() + b\"\\0\" + salt\n        pbkdf = pbkdf2.PBKDF2HMAC(\n            algorithm=self.hash_alg,\n            length=self.kwalg.key_size // 8,\n            salt=full_salt,\n            iterations=count,\n        )\n        return BinaPy(pbkdf.derive(self.password))\n\n    def wrap_key(self, plainkey: bytes, *, salt: bytes, count: int) -&gt; BinaPy:\n\"\"\"Wrap a key using this alg.\n\n        Args:\n          plainkey: the key to wrap\n          salt: the salt to use\n          count: the number of PBKDF iterations\n\n        Returns:\n            the wrapped key\n\n        \"\"\"\n        aes_key = self.derive(salt=salt, count=count)\n        return BinaPy(self.kwalg(aes_key).wrap_key(plainkey))\n\n    def unwrap_key(self, cipherkey: bytes, *, salt: bytes, count: int) -&gt; BinaPy:\n\"\"\"Unwrap a key using this alg.\n\n        Args:\n          cipherkey: the wrapped key\n          salt: the salt to use\n          count: the number of PBKDF iterations\n\n        Returns:\n            the unwrapped key\n\n        \"\"\"\n        aes_key = self.derive(salt=salt, count=count)\n        return BinaPy(self.kwalg(aes_key).unwrap_key(cipherkey))\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.generate_salt","title":"generate_salt  <code>classmethod</code>","text":"<pre><code>generate_salt(size: int = 12) -&gt; BinaPy\n</code></pre> <p>Generate a salt that is suitable for use for encryption.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>size of the generated salt, in bytes</p> <code>12</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the generated salt</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the salt is less than 8 bytes long</p> Source code in <code>jwskate/jwa/key_mgmt/pbes2.py</code> <pre><code>@classmethod\ndef generate_salt(cls, size: int = 12) -&gt; BinaPy:\n\"\"\"Generate a salt that is suitable for use for encryption.\n\n    Args:\n      size: size of the generated salt, in bytes\n\n    Returns:\n        the generated salt\n\n    Raises:\n        ValueError: if the salt is less than 8 bytes long\n\n    \"\"\"\n    if size &lt; 8:\n        raise ValueError(\"salts used for PBES2 must be at least 8 bytes long\")\n    return BinaPy.random(size)\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.derive","title":"derive","text":"<pre><code>derive(*, salt: bytes, count: int) -&gt; BinaPy\n</code></pre> <p>Derive an encryption key.</p> <p>Derivation is based on the configured password, a given salt and the number of PBKDF iterations.</p> <p>Parameters:</p> Name Type Description Default <code>salt</code> <code>bytes</code> <p>the generated salt</p> required <code>count</code> <code>int</code> <p>number of PBKDF iterations</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the generated encryption/decryption key</p> Source code in <code>jwskate/jwa/key_mgmt/pbes2.py</code> <pre><code>def derive(self, *, salt: bytes, count: int) -&gt; BinaPy:\n\"\"\"Derive an encryption key.\n\n    Derivation is based on the configured password, a given salt and the number of\n    PBKDF iterations.\n\n    Args:\n      salt: the generated salt\n      count: number of PBKDF iterations\n\n    Returns:\n        the generated encryption/decryption key\n\n    \"\"\"\n    full_salt = self.name.encode() + b\"\\0\" + salt\n    pbkdf = pbkdf2.PBKDF2HMAC(\n        algorithm=self.hash_alg,\n        length=self.kwalg.key_size // 8,\n        salt=full_salt,\n        iterations=count,\n    )\n    return BinaPy(pbkdf.derive(self.password))\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.wrap_key","title":"wrap_key","text":"<pre><code>wrap_key(\n    plainkey: bytes, *, salt: bytes, count: int\n) -&gt; BinaPy\n</code></pre> <p>Wrap a key using this alg.</p> <p>Parameters:</p> Name Type Description Default <code>plainkey</code> <code>bytes</code> <p>the key to wrap</p> required <code>salt</code> <code>bytes</code> <p>the salt to use</p> required <code>count</code> <code>int</code> <p>the number of PBKDF iterations</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the wrapped key</p> Source code in <code>jwskate/jwa/key_mgmt/pbes2.py</code> <pre><code>def wrap_key(self, plainkey: bytes, *, salt: bytes, count: int) -&gt; BinaPy:\n\"\"\"Wrap a key using this alg.\n\n    Args:\n      plainkey: the key to wrap\n      salt: the salt to use\n      count: the number of PBKDF iterations\n\n    Returns:\n        the wrapped key\n\n    \"\"\"\n    aes_key = self.derive(salt=salt, count=count)\n    return BinaPy(self.kwalg(aes_key).wrap_key(plainkey))\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.pbes2.BasePbes2.unwrap_key","title":"unwrap_key","text":"<pre><code>unwrap_key(\n    cipherkey: bytes, *, salt: bytes, count: int\n) -&gt; BinaPy\n</code></pre> <p>Unwrap a key using this alg.</p> <p>Parameters:</p> Name Type Description Default <code>cipherkey</code> <code>bytes</code> <p>the wrapped key</p> required <code>salt</code> <code>bytes</code> <p>the salt to use</p> required <code>count</code> <code>int</code> <p>the number of PBKDF iterations</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the unwrapped key</p> Source code in <code>jwskate/jwa/key_mgmt/pbes2.py</code> <pre><code>def unwrap_key(self, cipherkey: bytes, *, salt: bytes, count: int) -&gt; BinaPy:\n\"\"\"Unwrap a key using this alg.\n\n    Args:\n      cipherkey: the wrapped key\n      salt: the salt to use\n      count: the number of PBKDF iterations\n\n    Returns:\n        the unwrapped key\n\n    \"\"\"\n    aes_key = self.derive(salt=salt, count=count)\n    return BinaPy(self.kwalg(aes_key).unwrap_key(cipherkey))\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseRsaKeyWrap","title":"BaseRsaKeyWrap","text":"<p>             Bases: <code>BaseKeyManagementAlg</code>, <code>BaseAsymmetricAlg[rsa.RSAPrivateKey, rsa.RSAPublicKey]</code></p> <p>Base class for RSA Key Wrapping algorithms.</p> Source code in <code>jwskate/jwa/key_mgmt/rsa.py</code> <pre><code>class BaseRsaKeyWrap(\n    BaseKeyManagementAlg,\n    BaseAsymmetricAlg[rsa.RSAPrivateKey, rsa.RSAPublicKey],\n):\n\"\"\"Base class for RSA Key Wrapping algorithms.\"\"\"\n\n    padding: Any\n\n    name: str\n    description: str\n\n    private_key_class = rsa.RSAPrivateKey\n    public_key_class = rsa.RSAPublicKey\n\n    min_key_size: int = 2048\n\n    @classmethod\n    @override\n    def with_random_key(cls) -&gt; Self:\n        return cls(\n            rsa.generate_private_key(public_exponent=65537, key_size=cls.min_key_size)\n        )\n\n    def wrap_key(self, plainkey: bytes) -&gt; BinaPy:\n\"\"\"Wrap a symmetric key using this algorithm.\n\n        Args:\n          plainkey: the symmetric key to wrap\n\n        Returns:\n            the wrapped key\n\n        Raises:\n            PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key\n\n        \"\"\"\n        if self.read_only:\n            raise NotImplementedError(\n                \"Due to security reasons, this algorithm is only usable for decryption.\"\n            )\n        with self.public_key_required() as key:\n            return BinaPy(key.encrypt(plainkey, self.padding))\n\n    def unwrap_key(self, cipherkey: bytes | SupportsBytes) -&gt; BinaPy:\n\"\"\"Unwrap a symmetric key with this alg.\n\n        Args:\n          cipherkey: the wrapped key\n\n        Returns:\n            the unwrapped clear-text key\n        Raises:\n            PrivateKeyRequired: if this alg is initialized with a public key instead of a private key\n\n        \"\"\"\n        if not isinstance(cipherkey, bytes):\n            cipherkey = bytes(cipherkey)\n\n        with self.private_key_required() as key:\n            return BinaPy(key.decrypt(cipherkey, self.padding))\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.wrap_key","title":"wrap_key","text":"<pre><code>wrap_key(plainkey: bytes) -&gt; BinaPy\n</code></pre> <p>Wrap a symmetric key using this algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>plainkey</code> <code>bytes</code> <p>the symmetric key to wrap</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the wrapped key</p> <p>Raises:</p> Type Description <code>PublicKeyRequired</code> <p>if this algorithm is initialized with a private key instead of a public key</p> Source code in <code>jwskate/jwa/key_mgmt/rsa.py</code> <pre><code>def wrap_key(self, plainkey: bytes) -&gt; BinaPy:\n\"\"\"Wrap a symmetric key using this algorithm.\n\n    Args:\n      plainkey: the symmetric key to wrap\n\n    Returns:\n        the wrapped key\n\n    Raises:\n        PublicKeyRequired: if this algorithm is initialized with a private key instead of a public key\n\n    \"\"\"\n    if self.read_only:\n        raise NotImplementedError(\n            \"Due to security reasons, this algorithm is only usable for decryption.\"\n        )\n    with self.public_key_required() as key:\n        return BinaPy(key.encrypt(plainkey, self.padding))\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.rsa.BaseRsaKeyWrap.unwrap_key","title":"unwrap_key","text":"<pre><code>unwrap_key(cipherkey: bytes | SupportsBytes) -&gt; BinaPy\n</code></pre> <p>Unwrap a symmetric key with this alg.</p> <p>Parameters:</p> Name Type Description Default <code>cipherkey</code> <code>bytes | SupportsBytes</code> <p>the wrapped key</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the unwrapped clear-text key</p> <p>Raises:</p> Type Description <code>PrivateKeyRequired</code> <p>if this alg is initialized with a public key instead of a private key</p> Source code in <code>jwskate/jwa/key_mgmt/rsa.py</code> <pre><code>def unwrap_key(self, cipherkey: bytes | SupportsBytes) -&gt; BinaPy:\n\"\"\"Unwrap a symmetric key with this alg.\n\n    Args:\n      cipherkey: the wrapped key\n\n    Returns:\n        the unwrapped clear-text key\n    Raises:\n        PrivateKeyRequired: if this alg is initialized with a public key instead of a private key\n\n    \"\"\"\n    if not isinstance(cipherkey, bytes):\n        cipherkey = bytes(cipherkey)\n\n    with self.private_key_required() as key:\n        return BinaPy(key.decrypt(cipherkey, self.padding))\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseRSASigAlg","title":"BaseRSASigAlg","text":"<p>             Bases: <code>BaseAsymmetricAlg[asymmetric.rsa.RSAPrivateKey, asymmetric.rsa.RSAPublicKey]</code>, <code>BaseSignatureAlg</code></p> <p>Base class for RSA based signature algorithms.</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>class BaseRSASigAlg(\n    BaseAsymmetricAlg[asymmetric.rsa.RSAPrivateKey, asymmetric.rsa.RSAPublicKey],\n    BaseSignatureAlg,\n):\n\"\"\"Base class for RSA based signature algorithms.\"\"\"\n\n    padding_alg: padding.AsymmetricPadding = padding.PKCS1v15()\n    min_key_size: int = 2048\n\n    private_key_class = asymmetric.rsa.RSAPrivateKey\n    public_key_class = asymmetric.rsa.RSAPublicKey\n\n    @classmethod\n    @override\n    def with_random_key(cls) -&gt; Self:\n        return cls(\n            rsa.generate_private_key(public_exponent=65537, key_size=cls.min_key_size)\n        )\n\n    def sign(self, data: bytes | SupportsBytes) -&gt; BinaPy:\n\"\"\"Sign arbitrary data.\n\n        Args:\n          data: the data to sign\n\n        Returns:\n            the generated signature\n\n        Raises:\n            NotImplementedError: for algorithms that are considered insecure, only signature verification is available\n            PrivateKeyRequired: if the configured key is not private\n\n        \"\"\"\n        if self.read_only:\n            raise NotImplementedError\n\n        if not isinstance(data, bytes):\n            data = bytes(data)\n\n        with self.private_key_required() as key:\n            return BinaPy(key.sign(data, self.padding_alg, self.hashing_alg))\n\n    def verify(\n        self, data: bytes | SupportsBytes, signature: bytes | SupportsBytes\n    ) -&gt; bool:\n\"\"\"Verify a signature against some data.\n\n        Args:\n          data: the data to verify\n          signature: the signature\n\n        Returns:\n            `True` if the signature is valid, `False` otherwise\n\n        \"\"\"\n        if not isinstance(data, bytes):\n            data = bytes(data)\n\n        if not isinstance(signature, bytes):\n            signature = bytes(signature)\n\n        with self.public_key_required() as key:\n            try:\n                key.verify(\n                    signature,\n                    data,\n                    self.padding_alg,\n                    self.hashing_alg,\n                )\n                return True\n            except exceptions.InvalidSignature:\n                return False\n</code></pre>"},{"location":"api/#jwskate.jwa.signature.rsa.BaseRSASigAlg.sign","title":"sign","text":"<pre><code>sign(data: bytes | SupportsBytes) -&gt; BinaPy\n</code></pre> <p>Sign arbitrary data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | SupportsBytes</code> <p>the data to sign</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the generated signature</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>for algorithms that are considered insecure, only signature verification is available</p> <code>PrivateKeyRequired</code> <p>if the configured key is not private</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>def sign(self, data: bytes | SupportsBytes) -&gt; BinaPy:\n\"\"\"Sign arbitrary data.\n\n    Args:\n      data: the data to sign\n\n    Returns:\n        the generated signature\n\n    Raises:\n        NotImplementedError: for algorithms that are considered insecure, only signature verification is available\n        PrivateKeyRequired: if the configured key is not private\n\n    \"\"\"\n    if self.read_only:\n        raise NotImplementedError\n\n    if not isinstance(data, bytes):\n        data = bytes(data)\n\n    with self.private_key_required() as key:\n        return BinaPy(key.sign(data, self.padding_alg, self.hashing_alg))\n</code></pre>"},{"location":"api/#jwskate.jwa.signature.rsa.BaseRSASigAlg.verify","title":"verify","text":"<pre><code>verify(\n    data: bytes | SupportsBytes,\n    signature: bytes | SupportsBytes,\n) -&gt; bool\n</code></pre> <p>Verify a signature against some data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | SupportsBytes</code> <p>the data to verify</p> required <code>signature</code> <code>bytes | SupportsBytes</code> <p>the signature</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the signature is valid, <code>False</code> otherwise</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>def verify(\n    self, data: bytes | SupportsBytes, signature: bytes | SupportsBytes\n) -&gt; bool:\n\"\"\"Verify a signature against some data.\n\n    Args:\n      data: the data to verify\n      signature: the signature\n\n    Returns:\n        `True` if the signature is valid, `False` otherwise\n\n    \"\"\"\n    if not isinstance(data, bytes):\n        data = bytes(data)\n\n    if not isinstance(signature, bytes):\n        signature = bytes(signature)\n\n    with self.public_key_required() as key:\n        try:\n            key.verify(\n                signature,\n                data,\n                self.padding_alg,\n                self.hashing_alg,\n            )\n            return True\n        except exceptions.InvalidSignature:\n            return False\n</code></pre>"},{"location":"api/#jwskate.jwa.EdDsa","title":"EdDsa","text":"<p>             Bases: <code>BaseAsymmetricAlg[Union[ed25519.Ed25519PrivateKey, ed448.Ed448PrivateKey], Union[ed25519.Ed25519PublicKey, ed448.Ed448PublicKey]]</code>, <code>BaseSignatureAlg</code></p> <p>EdDSA signature algorithms.</p> Source code in <code>jwskate/jwa/signature/eddsa.py</code> <pre><code>class EdDsa(\n    BaseAsymmetricAlg[\n        Union[ed25519.Ed25519PrivateKey, ed448.Ed448PrivateKey],\n        Union[ed25519.Ed25519PublicKey, ed448.Ed448PublicKey],\n    ],\n    BaseSignatureAlg,\n):\n\"\"\"EdDSA signature algorithms.\"\"\"\n\n    private_key_class = (ed25519.Ed25519PrivateKey, ed448.Ed448PrivateKey)\n    public_key_class = (ed25519.Ed25519PublicKey, ed448.Ed448PublicKey)\n\n    name = \"EdDSA\"\n    description = __doc__\n\n    @classmethod\n    @override\n    def with_random_key(cls) -&gt; Self:\n        return cls(ed25519.Ed25519PrivateKey.generate())\n\n    def sign(self, data: bytes | SupportsBytes) -&gt; BinaPy:  # noqa: D102\n        if not isinstance(data, bytes):\n            data = bytes(data)\n\n        with self.private_key_required() as key:\n            return BinaPy(key.sign(data))\n\n    def verify(\n        self, data: bytes | SupportsBytes, signature: bytes | SupportsBytes\n    ) -&gt; bool:  # noqa: D102\n        if not isinstance(data, bytes):\n            data = bytes(data)\n        if not isinstance(signature, bytes):\n            signature = bytes(signature)\n\n        with self.public_key_required() as key:\n            try:\n                key.verify(signature, data)\n                return True\n            except exceptions.InvalidSignature:\n                return False\n</code></pre>"},{"location":"api/#jwskate.jwa.EcdhEs","title":"EcdhEs","text":"<p>             Bases: <code>BaseKeyManagementAlg</code>, <code>BaseAsymmetricAlg[Union[ec.EllipticCurvePrivateKey, x25519.X25519PrivateKey, x448.X448PrivateKey], Union[ec.EllipticCurvePublicKey, x25519.X25519PublicKey, x448.X448PublicKey]]</code></p> <p>Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>class EcdhEs(\n    BaseKeyManagementAlg,\n    BaseAsymmetricAlg[\n        Union[ec.EllipticCurvePrivateKey, x25519.X25519PrivateKey, x448.X448PrivateKey],\n        Union[ec.EllipticCurvePublicKey, x25519.X25519PublicKey, x448.X448PublicKey],\n    ],\n):\n\"\"\"Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.\"\"\"\n\n    name = \"ECDH-ES\"\n    description = __doc__\n    public_key_class = (\n        ec.EllipticCurvePublicKey,\n        x25519.X25519PublicKey,\n        x448.X448PublicKey,\n    )\n    private_key_class = (\n        ec.EllipticCurvePrivateKey,\n        x25519.X25519PrivateKey,\n        x448.X448PrivateKey,\n    )\n\n    @classmethod\n    @override\n    def with_random_key(cls) -&gt; Self:\n        return cls(x25519.X25519PrivateKey.generate())\n\n    @classmethod\n    def otherinfo(cls, alg: str, apu: bytes, apv: bytes, key_size: int) -&gt; BinaPy:\n\"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash.\n\n        Args:\n          alg: identifier for the encryption alg\n          apu: Agreement PartyUInfo\n          apv: Agreement PartyVInfo\n          key_size: length of the generated key\n\n        Returns:\n            the \"otherinfo\" value\n\n        \"\"\"\n        algorithm_id = BinaPy.from_int(len(alg), length=4) + BinaPy(alg)\n        partyuinfo = BinaPy.from_int(len(apu), length=4) + apu\n        partyvinfo = BinaPy.from_int(len(apv), length=4) + apv\n        supppubinfo = BinaPy.from_int(key_size or key_size, length=4)\n        otherinfo = b\"\".join((algorithm_id, partyuinfo, partyvinfo, supppubinfo))\n        return BinaPy(otherinfo)\n\n    @classmethod\n    def ecdh(\n        cls,\n        private_key: (\n            ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey\n        ),\n        public_key: (\n            ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey\n        ),\n    ) -&gt; BinaPy:\n\"\"\"Perform an Elliptic Curve Diffie-Hellman key exchange.\n\n        This derives a shared key between a sender and a receiver, based on a public and a private key from each side.\n        ECDH exchange produces the same key with either a sender private key and a recipient public key,\n        or the matching sender public key and recipient private key.\n\n        Args:\n          private_key: a private EC key\n          public_key: a public EC key\n\n        Returns:\n          a shared key\n\n        \"\"\"\n        if isinstance(private_key, ec.EllipticCurvePrivateKey) and isinstance(\n            public_key, ec.EllipticCurvePublicKey\n        ):\n            shared_key = private_key.exchange(ec.ECDH(), public_key)\n        elif isinstance(private_key, x25519.X25519PrivateKey) and isinstance(\n            public_key, x25519.X25519PublicKey\n        ):\n            shared_key = private_key.exchange(public_key)\n        elif isinstance(private_key, x448.X448PrivateKey) and isinstance(\n            public_key, x448.X448PublicKey\n        ):\n            shared_key = private_key.exchange(public_key)\n        else:\n            raise ValueError(\n                \"Invalid or unsupported private/public key combination for ECDH\",\n                type(private_key),\n                type(public_key),\n            )\n        return BinaPy(shared_key)\n\n    @classmethod\n    def derive(\n        cls,\n        *,\n        private_key: (\n            ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey\n        ),\n        public_key: (\n            ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey\n        ),\n        otherinfo: bytes,\n        key_size: int,\n    ) -&gt; BinaPy:\n\"\"\"Derive a key using ECDH and Concat KDF Hash.\n\n        Args:\n          private_key: the private key\n          public_key: the public key\n          otherinfo: the Concat KDF \"otherinfo\" parameter\n          key_size: the expected CEK key size\n\n        Returns:\n            the derived key\n\n        \"\"\"\n        shared_key = cls.ecdh(private_key, public_key)\n        ckdf = ConcatKDFHash(\n            algorithm=hashes.SHA256(), length=key_size // 8, otherinfo=otherinfo\n        )\n        return BinaPy(ckdf.derive(shared_key))\n\n    def generate_ephemeral_key(\n        self,\n    ) -&gt; ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey:\n\"\"\"Generate an ephemeral key that is suitable for use with this algorithm.\n\n        Returns:\n            a generated EllipticCurvePrivateKey, on the same curve as this algorithm key\n\n        \"\"\"\n        if isinstance(\n            self.key, (ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey)\n        ):\n            return ec.generate_private_key(self.key.curve)\n        elif isinstance(self.key, (x25519.X25519PrivateKey, x25519.X25519PublicKey)):\n            return x25519.X25519PrivateKey.generate()\n        elif isinstance(self.key, (x448.X448PublicKey, x448.X448PrivateKey)):\n            return x448.X448PrivateKey.generate()\n\n    def sender_key(\n        self,\n        ephemeral_private_key: (\n            ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey\n        ),\n        *,\n        alg: str,\n        key_size: int,\n        **headers: Any,\n    ) -&gt; BinaPy:\n\"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender.\n\n        Args:\n          ephemeral_private_key: the EPK to use for this key\n          alg: the content encryption algorithm identifier\n          key_size: the expected CEK size\n          **headers: additional headers to include for CEK derivation\n\n        Returns:\n            the CEK for encryption by the sender\n\n        \"\"\"\n        with self.public_key_required() as key:\n            apu = BinaPy(headers.get(\"apu\", b\"\")).decode_from(\"b64u\")\n            apv = BinaPy(headers.get(\"apv\", b\"\")).decode_from(\"b64u\")\n            otherinfo = self.otherinfo(alg, apu, apv, key_size)\n            cek = self.derive(\n                private_key=ephemeral_private_key,\n                public_key=key,\n                otherinfo=otherinfo,\n                key_size=key_size,\n            )\n            return cek\n\n    def recipient_key(\n        self,\n        ephemeral_public_key: (\n            ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey\n        ),\n        *,\n        alg: str,\n        key_size: int,\n        **headers: Any,\n    ) -&gt; BinaPy:\n\"\"\"Compute a shared key, for use by the recipient of an encrypted message.\n\n        Args:\n          ephemeral_public_key: the EPK, as received from sender\n          alg: the content encryption algorithm identifier\n          key_size: the CEK size\n          **headers: additional headers as received from sender\n\n        Returns:\n            the CEK for decryption by the recipient\n\n        \"\"\"\n        with self.private_key_required() as key:\n            apu = BinaPy(headers.get(\"apu\", b\"\")).decode_from(\"b64u\")\n            apv = BinaPy(headers.get(\"apv\", b\"\")).decode_from(\"b64u\")\n            otherinfo = self.otherinfo(alg, apu, apv, key_size)\n            cek = self.derive(\n                private_key=key,\n                public_key=ephemeral_public_key,\n                otherinfo=otherinfo,\n                key_size=key_size,\n            )\n            return cek\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.otherinfo","title":"otherinfo  <code>classmethod</code>","text":"<pre><code>otherinfo(\n    alg: str, apu: bytes, apv: bytes, key_size: int\n) -&gt; BinaPy\n</code></pre> <p>Build the \"otherinfo\" parameter for Concat KDF Hash.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str</code> <p>identifier for the encryption alg</p> required <code>apu</code> <code>bytes</code> <p>Agreement PartyUInfo</p> required <code>apv</code> <code>bytes</code> <p>Agreement PartyVInfo</p> required <code>key_size</code> <code>int</code> <p>length of the generated key</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the \"otherinfo\" value</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>@classmethod\ndef otherinfo(cls, alg: str, apu: bytes, apv: bytes, key_size: int) -&gt; BinaPy:\n\"\"\"Build the \"otherinfo\" parameter for Concat KDF Hash.\n\n    Args:\n      alg: identifier for the encryption alg\n      apu: Agreement PartyUInfo\n      apv: Agreement PartyVInfo\n      key_size: length of the generated key\n\n    Returns:\n        the \"otherinfo\" value\n\n    \"\"\"\n    algorithm_id = BinaPy.from_int(len(alg), length=4) + BinaPy(alg)\n    partyuinfo = BinaPy.from_int(len(apu), length=4) + apu\n    partyvinfo = BinaPy.from_int(len(apv), length=4) + apv\n    supppubinfo = BinaPy.from_int(key_size or key_size, length=4)\n    otherinfo = b\"\".join((algorithm_id, partyuinfo, partyvinfo, supppubinfo))\n    return BinaPy(otherinfo)\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.ecdh","title":"ecdh  <code>classmethod</code>","text":"<pre><code>ecdh(\n    private_key: ec.EllipticCurvePrivateKey\n    | x25519.X25519PrivateKey\n    | x448.X448PrivateKey,\n    public_key: ec.EllipticCurvePublicKey\n    | x25519.X25519PublicKey\n    | x448.X448PublicKey,\n) -&gt; BinaPy\n</code></pre> <p>Perform an Elliptic Curve Diffie-Hellman key exchange.</p> <p>This derives a shared key between a sender and a receiver, based on a public and a private key from each side. ECDH exchange produces the same key with either a sender private key and a recipient public key, or the matching sender public key and recipient private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey</code> <p>a private EC key</p> required <code>public_key</code> <code>ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey</code> <p>a public EC key</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>a shared key</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>@classmethod\ndef ecdh(\n    cls,\n    private_key: (\n        ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey\n    ),\n    public_key: (\n        ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey\n    ),\n) -&gt; BinaPy:\n\"\"\"Perform an Elliptic Curve Diffie-Hellman key exchange.\n\n    This derives a shared key between a sender and a receiver, based on a public and a private key from each side.\n    ECDH exchange produces the same key with either a sender private key and a recipient public key,\n    or the matching sender public key and recipient private key.\n\n    Args:\n      private_key: a private EC key\n      public_key: a public EC key\n\n    Returns:\n      a shared key\n\n    \"\"\"\n    if isinstance(private_key, ec.EllipticCurvePrivateKey) and isinstance(\n        public_key, ec.EllipticCurvePublicKey\n    ):\n        shared_key = private_key.exchange(ec.ECDH(), public_key)\n    elif isinstance(private_key, x25519.X25519PrivateKey) and isinstance(\n        public_key, x25519.X25519PublicKey\n    ):\n        shared_key = private_key.exchange(public_key)\n    elif isinstance(private_key, x448.X448PrivateKey) and isinstance(\n        public_key, x448.X448PublicKey\n    ):\n        shared_key = private_key.exchange(public_key)\n    else:\n        raise ValueError(\n            \"Invalid or unsupported private/public key combination for ECDH\",\n            type(private_key),\n            type(public_key),\n        )\n    return BinaPy(shared_key)\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.derive","title":"derive  <code>classmethod</code>","text":"<pre><code>derive(\n    *,\n    private_key: ec.EllipticCurvePrivateKey\n    | x25519.X25519PrivateKey\n    | x448.X448PrivateKey,\n    public_key: ec.EllipticCurvePublicKey\n    | x25519.X25519PublicKey\n    | x448.X448PublicKey,\n    otherinfo: bytes,\n    key_size: int\n) -&gt; BinaPy\n</code></pre> <p>Derive a key using ECDH and Concat KDF Hash.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey</code> <p>the private key</p> required <code>public_key</code> <code>ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey</code> <p>the public key</p> required <code>otherinfo</code> <code>bytes</code> <p>the Concat KDF \"otherinfo\" parameter</p> required <code>key_size</code> <code>int</code> <p>the expected CEK key size</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the derived key</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>@classmethod\ndef derive(\n    cls,\n    *,\n    private_key: (\n        ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey\n    ),\n    public_key: (\n        ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey\n    ),\n    otherinfo: bytes,\n    key_size: int,\n) -&gt; BinaPy:\n\"\"\"Derive a key using ECDH and Concat KDF Hash.\n\n    Args:\n      private_key: the private key\n      public_key: the public key\n      otherinfo: the Concat KDF \"otherinfo\" parameter\n      key_size: the expected CEK key size\n\n    Returns:\n        the derived key\n\n    \"\"\"\n    shared_key = cls.ecdh(private_key, public_key)\n    ckdf = ConcatKDFHash(\n        algorithm=hashes.SHA256(), length=key_size // 8, otherinfo=otherinfo\n    )\n    return BinaPy(ckdf.derive(shared_key))\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.generate_ephemeral_key","title":"generate_ephemeral_key","text":"<pre><code>generate_ephemeral_key() -&gt; (\n    ec.EllipticCurvePrivateKey\n    | x25519.X25519PrivateKey\n    | x448.X448PrivateKey\n)\n</code></pre> <p>Generate an ephemeral key that is suitable for use with this algorithm.</p> <p>Returns:</p> Type Description <code>ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey</code> <p>a generated EllipticCurvePrivateKey, on the same curve as this algorithm key</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>def generate_ephemeral_key(\n    self,\n) -&gt; ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey:\n\"\"\"Generate an ephemeral key that is suitable for use with this algorithm.\n\n    Returns:\n        a generated EllipticCurvePrivateKey, on the same curve as this algorithm key\n\n    \"\"\"\n    if isinstance(\n        self.key, (ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey)\n    ):\n        return ec.generate_private_key(self.key.curve)\n    elif isinstance(self.key, (x25519.X25519PrivateKey, x25519.X25519PublicKey)):\n        return x25519.X25519PrivateKey.generate()\n    elif isinstance(self.key, (x448.X448PublicKey, x448.X448PrivateKey)):\n        return x448.X448PrivateKey.generate()\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.sender_key","title":"sender_key","text":"<pre><code>sender_key(\n    ephemeral_private_key: ec.EllipticCurvePrivateKey\n    | x25519.X25519PrivateKey\n    | x448.X448PrivateKey,\n    *,\n    alg: str,\n    key_size: int,\n    **headers: Any\n) -&gt; BinaPy\n</code></pre> <p>Compute a CEK for encryption of a message. This method is meant for usage by a sender.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral_private_key</code> <code>ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey</code> <p>the EPK to use for this key</p> required <code>alg</code> <code>str</code> <p>the content encryption algorithm identifier</p> required <code>key_size</code> <code>int</code> <p>the expected CEK size</p> required <code>**headers</code> <code>Any</code> <p>additional headers to include for CEK derivation</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the CEK for encryption by the sender</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>def sender_key(\n    self,\n    ephemeral_private_key: (\n        ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey\n    ),\n    *,\n    alg: str,\n    key_size: int,\n    **headers: Any,\n) -&gt; BinaPy:\n\"\"\"Compute a CEK for encryption of a message. This method is meant for usage by a sender.\n\n    Args:\n      ephemeral_private_key: the EPK to use for this key\n      alg: the content encryption algorithm identifier\n      key_size: the expected CEK size\n      **headers: additional headers to include for CEK derivation\n\n    Returns:\n        the CEK for encryption by the sender\n\n    \"\"\"\n    with self.public_key_required() as key:\n        apu = BinaPy(headers.get(\"apu\", b\"\")).decode_from(\"b64u\")\n        apv = BinaPy(headers.get(\"apv\", b\"\")).decode_from(\"b64u\")\n        otherinfo = self.otherinfo(alg, apu, apv, key_size)\n        cek = self.derive(\n            private_key=ephemeral_private_key,\n            public_key=key,\n            otherinfo=otherinfo,\n            key_size=key_size,\n        )\n        return cek\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.EcdhEs.recipient_key","title":"recipient_key","text":"<pre><code>recipient_key(\n    ephemeral_public_key: ec.EllipticCurvePublicKey\n    | x25519.X25519PublicKey\n    | x448.X448PublicKey,\n    *,\n    alg: str,\n    key_size: int,\n    **headers: Any\n) -&gt; BinaPy\n</code></pre> <p>Compute a shared key, for use by the recipient of an encrypted message.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral_public_key</code> <code>ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey</code> <p>the EPK, as received from sender</p> required <code>alg</code> <code>str</code> <p>the content encryption algorithm identifier</p> required <code>key_size</code> <code>int</code> <p>the CEK size</p> required <code>**headers</code> <code>Any</code> <p>additional headers as received from sender</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the CEK for decryption by the recipient</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>def recipient_key(\n    self,\n    ephemeral_public_key: (\n        ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey\n    ),\n    *,\n    alg: str,\n    key_size: int,\n    **headers: Any,\n) -&gt; BinaPy:\n\"\"\"Compute a shared key, for use by the recipient of an encrypted message.\n\n    Args:\n      ephemeral_public_key: the EPK, as received from sender\n      alg: the content encryption algorithm identifier\n      key_size: the CEK size\n      **headers: additional headers as received from sender\n\n    Returns:\n        the CEK for decryption by the recipient\n\n    \"\"\"\n    with self.private_key_required() as key:\n        apu = BinaPy(headers.get(\"apu\", b\"\")).decode_from(\"b64u\")\n        apv = BinaPy(headers.get(\"apv\", b\"\")).decode_from(\"b64u\")\n        otherinfo = self.otherinfo(alg, apu, apv, key_size)\n        cek = self.derive(\n            private_key=key,\n            public_key=ephemeral_public_key,\n            otherinfo=otherinfo,\n            key_size=key_size,\n        )\n        return cek\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseECSignatureAlg","title":"BaseECSignatureAlg","text":"<p>             Bases: <code>BaseAsymmetricAlg[ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey]</code>, <code>BaseSignatureAlg</code></p> <p>Base class for Elliptic Curve signature algorithms.</p> Source code in <code>jwskate/jwa/signature/ec.py</code> <pre><code>class BaseECSignatureAlg(\n    BaseAsymmetricAlg[ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey],\n    BaseSignatureAlg,\n):\n\"\"\"Base class for Elliptic Curve signature algorithms.\"\"\"\n\n    curve: EllipticCurve\n    public_key_class = ec.EllipticCurvePublicKey\n    private_key_class = ec.EllipticCurvePrivateKey\n\n    @classmethod\n    def check_key(\n        cls, key: ec.EllipticCurvePrivateKey | ec.EllipticCurvePublicKey\n    ) -&gt; None:  # noqa: D102\n        if key.curve.name != cls.curve.cryptography_curve.name:\n            raise ValueError(\n                f\"This key is on curve {key.curve.name}. An EC key on curve {cls.curve.name} is expected.\"\n            )\n\n    @classmethod\n    @override\n    def with_random_key(cls) -&gt; Self:\n        return cls(ec.generate_private_key(cls.curve.cryptography_curve))\n\n    def sign(self, data: bytes | SupportsBytes) -&gt; BinaPy:  # noqa: D102\n        if not isinstance(data, bytes):\n            data = bytes(data)\n\n        with self.private_key_required() as key:\n            dss_sig = key.sign(data, ec.ECDSA(self.hashing_alg))\n            r, s = asymmetric.utils.decode_dss_signature(dss_sig)\n            return BinaPy.from_int(r, self.curve.coordinate_size) + BinaPy.from_int(\n                s, self.curve.coordinate_size\n            )\n\n    def verify(\n        self, data: bytes | SupportsBytes, signature: bytes | SupportsBytes\n    ) -&gt; bool:  # noqa: D102\n        if not isinstance(data, bytes):\n            data = bytes(data)\n\n        if not isinstance(signature, bytes):\n            signature = bytes(signature)\n\n        with self.public_key_required() as key:\n            if len(signature) != self.curve.coordinate_size * 2:\n                raise ValueError(\n                    f\"Invalid signature length {len(signature)} bytes, expected {self.curve.coordinate_size * 2} bytes\"\n                )\n\n            r_bytes, s_bytes = (\n                signature[: self.curve.coordinate_size],\n                signature[self.curve.coordinate_size :],\n            )\n            r = int.from_bytes(r_bytes, \"big\", signed=False)\n            s = int.from_bytes(s_bytes, \"big\", signed=False)\n            dss_signature = asymmetric.utils.encode_dss_signature(r, s)\n\n            try:\n                key.verify(\n                    dss_signature,\n                    data,\n                    ec.ECDSA(self.hashing_alg),\n                )\n                return True\n            except exceptions.InvalidSignature:\n                return False\n</code></pre>"},{"location":"api/#jwskate.jwa.PublicKeyRequired","title":"PublicKeyRequired","text":"<p>             Bases: <code>AttributeError</code></p> <p>Raised when a private key is provided for an operation that requires a public key.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>class PublicKeyRequired(AttributeError):\n\"\"\"Raised when a private key is provided for an operation that requires a public key.\"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseAlg","title":"BaseAlg","text":"<p>Base class for all algorithms.</p> <p>An algorithm has a <code>name</code> and a <code>description</code>, whose reference is found in IANA JOSE registry.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>class BaseAlg:\n\"\"\"Base class for all algorithms.\n\n    An algorithm has a `name` and a `description`, whose reference is found in [IANA JOSE registry][IANA].\n\n    [IANA]: https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms\n\n    \"\"\"\n\n    use: str\n\"\"\"Alg use ('sig' or 'enc')\"\"\"\n\n    name: str\n\"\"\"Technical name of the algorithm.\"\"\"\n    description: str\n\"\"\"Description of the algorithm (human readable)\"\"\"\n    read_only: bool = False\n\"\"\"For algs that are considered insecure, set to True to allow only signature verification or\n    decryption of existing data, but don't allow new signatures or encryption.\"\"\"\n\n    def __repr__(self) -&gt; str:\n\"\"\"Use the name of the alg as repr.\"\"\"\n        return self.name\n\n    @classmethod\n    def with_random_key(cls) -&gt; Self:\n\"\"\"Initialize an instance of this alg with a randomly-generated key.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAlg.use","title":"use  <code>instance-attribute</code>","text":"<pre><code>use: str\n</code></pre> <p>Alg use ('sig' or 'enc')</p>"},{"location":"api/#jwskate.jwa.base.BaseAlg.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Technical name of the algorithm.</p>"},{"location":"api/#jwskate.jwa.base.BaseAlg.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Description of the algorithm (human readable)</p>"},{"location":"api/#jwskate.jwa.base.BaseAlg.read_only","title":"read_only  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>read_only: bool = False\n</code></pre> <p>For algs that are considered insecure, set to True to allow only signature verification or decryption of existing data, but don't allow new signatures or encryption.</p>"},{"location":"api/#jwskate.jwa.base.BaseAlg.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Use the name of the alg as repr.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Use the name of the alg as repr.\"\"\"\n    return self.name\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAlg.with_random_key","title":"with_random_key  <code>classmethod</code>","text":"<pre><code>with_random_key() -&gt; Self\n</code></pre> <p>Initialize an instance of this alg with a randomly-generated key.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@classmethod\ndef with_random_key(cls) -&gt; Self:\n\"\"\"Initialize an instance of this alg with a randomly-generated key.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#jwskate.jwa.HS256","title":"HS256","text":"<p>             Bases: <code>BaseHMACSigAlg</code></p> <p>HMAC using SHA-256.</p> Source code in <code>jwskate/jwa/signature/hmac.py</code> <pre><code>class HS256(BaseHMACSigAlg):  # noqa: D415\n\"\"\"HMAC using SHA-256.\"\"\"\n\n    name = \"HS256\"\n    description = __doc__\n    hashing_alg = hashes.SHA256()\n    min_key_size = 256\n</code></pre>"},{"location":"api/#jwskate.jwa.OKPCurve","title":"OKPCurve  <code>dataclass</code>","text":"<p>Represent an Octet Key Pair (OKP) Curve.</p> Source code in <code>jwskate/jwa/okp.py</code> <pre><code>@dataclass\nclass OKPCurve:\n\"\"\"Represent an Octet Key Pair (OKP) Curve.\"\"\"\n\n    name: str\n\"\"\"Curve name as defined in [IANA JOSE](https://www.iana.org/assignments/jose/jose.xhtml#web-\n    key-elliptic-curve).\n\n    This name will appear in `crv` headers.\n    \"\"\"\n\n    description: str\n\"\"\"Curve description (human readable).\"\"\"\n\n    cryptography_private_key_class: type[Any]\n\"\"\"`cryptography` private key class.\"\"\"\n\n    cryptography_public_key_class: type[Any]\n\"\"\"`cryptography` public key class.\"\"\"\n\n    use: str\n\"\"\"Curve usage (`'sig'` or '`enc'`).\"\"\"\n\n    instances: ClassVar[dict[str, OKPCurve]] = {}\n\"\"\"Registry of subclasses, in a {name: instance} mapping.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Automatically registers subclasses in the instance registry.\"\"\"\n        self.instances[self.name] = self\n\n    def generate(self) -&gt; tuple[bytes, bytes]:\n\"\"\"Generate a new private key on this curve.\n\n        Returns:\n            a tuple of `x` (public  part), and `d` (private part), as bytes\n\n        \"\"\"\n        key = self.cryptography_private_key_class.generate()\n        x = key.public_key().public_bytes(\n            serialization.Encoding.Raw, serialization.PublicFormat.Raw\n        )\n        d = key.private_bytes(\n            serialization.Encoding.Raw,\n            serialization.PrivateFormat.Raw,\n            serialization.NoEncryption(),\n        )\n        return x, d\n\n    @classmethod\n    def get_curve(cls, key: PublicKeyProtocol | PrivateKeyProtocol) -&gt; OKPCurve:\n\"\"\"Return the appropriate `OKPCurve` instance for a given key.\n\n        This takes a `cryptography` private or public key as parameter. If the key type matches an OKP curve\n\n        Args:\n          key: `cryptography` private or public OKP key.\n\n        Returns:\n          OKPCurve: the appropriate `OKPCurve` for the given key\n\n        Raises:\n            NotImplementedError: if the required OKP curve is not supported\n\n        \"\"\"\n        for c in cls.instances.values():\n            if isinstance(\n                key, (c.cryptography_private_key_class, c.cryptography_public_key_class)\n            ):\n                return c\n        raise TypeError(\n            f\"\"\"\\\nUnsupported key type for OKP: {type(key)}. Supported key types are: \"\n{', '.join(\nname\nfor curve in cls.instances.values()\nfor name in (curve.cryptography_private_key_class.__name__, curve.cryptography_public_key_class.__name__)\n)}\"\"\"\n        )\n</code></pre>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Curve name as defined in IANA JOSE.</p> <p>This name will appear in <code>crv</code> headers.</p>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Curve description (human readable).</p>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_private_key_class","title":"cryptography_private_key_class  <code>instance-attribute</code>","text":"<pre><code>cryptography_private_key_class: type[Any]\n</code></pre> <p><code>cryptography</code> private key class.</p>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.cryptography_public_key_class","title":"cryptography_public_key_class  <code>instance-attribute</code>","text":"<pre><code>cryptography_public_key_class: type[Any]\n</code></pre> <p><code>cryptography</code> public key class.</p>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.use","title":"use  <code>instance-attribute</code>","text":"<pre><code>use: str\n</code></pre> <p>Curve usage (<code>'sig'</code> or '<code>enc'</code>).</p>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.instances","title":"instances  <code>class-attribute</code>","text":"<pre><code>instances: dict[str, OKPCurve] = {}\n</code></pre> <p>Registry of subclasses, in a {name: instance} mapping.</p>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Automatically registers subclasses in the instance registry.</p> Source code in <code>jwskate/jwa/okp.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Automatically registers subclasses in the instance registry.\"\"\"\n    self.instances[self.name] = self\n</code></pre>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.generate","title":"generate","text":"<pre><code>generate() -&gt; tuple[bytes, bytes]\n</code></pre> <p>Generate a new private key on this curve.</p> <p>Returns:</p> Type Description <code>tuple[bytes, bytes]</code> <p>a tuple of <code>x</code> (public  part), and <code>d</code> (private part), as bytes</p> Source code in <code>jwskate/jwa/okp.py</code> <pre><code>def generate(self) -&gt; tuple[bytes, bytes]:\n\"\"\"Generate a new private key on this curve.\n\n    Returns:\n        a tuple of `x` (public  part), and `d` (private part), as bytes\n\n    \"\"\"\n    key = self.cryptography_private_key_class.generate()\n    x = key.public_key().public_bytes(\n        serialization.Encoding.Raw, serialization.PublicFormat.Raw\n    )\n    d = key.private_bytes(\n        serialization.Encoding.Raw,\n        serialization.PrivateFormat.Raw,\n        serialization.NoEncryption(),\n    )\n    return x, d\n</code></pre>"},{"location":"api/#jwskate.jwa.okp.OKPCurve.get_curve","title":"get_curve  <code>classmethod</code>","text":"<pre><code>get_curve(\n    key: PublicKeyProtocol | PrivateKeyProtocol,\n) -&gt; OKPCurve\n</code></pre> <p>Return the appropriate <code>OKPCurve</code> instance for a given key.</p> <p>This takes a <code>cryptography</code> private or public key as parameter. If the key type matches an OKP curve</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>PublicKeyProtocol | PrivateKeyProtocol</code> <p><code>cryptography</code> private or public OKP key.</p> required <p>Returns:</p> Name Type Description <code>OKPCurve</code> <code>OKPCurve</code> <p>the appropriate <code>OKPCurve</code> for the given key</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the required OKP curve is not supported</p> Source code in <code>jwskate/jwa/okp.py</code> <pre><code>    @classmethod\n    def get_curve(cls, key: PublicKeyProtocol | PrivateKeyProtocol) -&gt; OKPCurve:\n\"\"\"Return the appropriate `OKPCurve` instance for a given key.\n\n        This takes a `cryptography` private or public key as parameter. If the key type matches an OKP curve\n\n        Args:\n          key: `cryptography` private or public OKP key.\n\n        Returns:\n          OKPCurve: the appropriate `OKPCurve` for the given key\n\n        Raises:\n            NotImplementedError: if the required OKP curve is not supported\n\n        \"\"\"\n        for c in cls.instances.values():\n            if isinstance(\n                key, (c.cryptography_private_key_class, c.cryptography_public_key_class)\n            ):\n                return c\n        raise TypeError(\n            f\"\"\"\\\nUnsupported key type for OKP: {type(key)}. Supported key types are: \"\n{', '.join(\nname\nfor curve in cls.instances.values()\nfor name in (curve.cryptography_private_key_class.__name__, curve.cryptography_public_key_class.__name__)\n)}\"\"\"\n        )\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseSymmetricAlg","title":"BaseSymmetricAlg","text":"<p>             Bases: <code>BaseAlg</code></p> <p>Base class for Symmetric algorithms (using a raw bytes key).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>the key to use for cryptographic operations</p> required Source code in <code>jwskate/jwa/base.py</code> <pre><code>class BaseSymmetricAlg(BaseAlg):\n\"\"\"Base class for Symmetric algorithms (using a raw bytes key).\n\n    Args:\n        key: the key to use for cryptographic operations\n\n    \"\"\"\n\n    def __init__(self, key: bytes):\n        self.check_key(key)\n        self.key = key\n\n    @classmethod\n    def check_key(cls, key: bytes) -&gt; None:\n\"\"\"Check that a given key is suitable for this alg class.\n\n        This raises an exception if the key is not suitable.\n        This method must be implemented by subclasses as required.\n\n        Args:\n          key: the key to check for this alg class\n\n        Returns:\n          Returns `None`. Raises an exception if the key is not suitable\n\n        \"\"\"\n        pass\n\n    @classmethod\n    def supports_key(cls, key: bytes) -&gt; bool:\n\"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise.\n\n        This is a convenience wrapper around `check_key(key)`.\n\n        Args:\n          key: the key to check for this alg class\n\n        Returns:\n          `True` if the key is suitable for this alg class, `False` otherwise\n\n        \"\"\"\n        try:\n            cls.check_key(key)\n            return True\n        except Exception:\n            return False\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.check_key","title":"check_key  <code>classmethod</code>","text":"<pre><code>check_key(key: bytes) -&gt; None\n</code></pre> <p>Check that a given key is suitable for this alg class.</p> <p>This raises an exception if the key is not suitable. This method must be implemented by subclasses as required.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>the key to check for this alg class</p> required <p>Returns:</p> Type Description <code>None</code> <p>Returns <code>None</code>. Raises an exception if the key is not suitable</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@classmethod\ndef check_key(cls, key: bytes) -&gt; None:\n\"\"\"Check that a given key is suitable for this alg class.\n\n    This raises an exception if the key is not suitable.\n    This method must be implemented by subclasses as required.\n\n    Args:\n      key: the key to check for this alg class\n\n    Returns:\n      Returns `None`. Raises an exception if the key is not suitable\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseSymmetricAlg.supports_key","title":"supports_key  <code>classmethod</code>","text":"<pre><code>supports_key(key: bytes) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the given key is suitable for this alg class, or <code>False</code> otherwise.</p> <p>This is a convenience wrapper around <code>check_key(key)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>the key to check for this alg class</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the key is suitable for this alg class, <code>False</code> otherwise</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@classmethod\ndef supports_key(cls, key: bytes) -&gt; bool:\n\"\"\"Return `True` if the given key is suitable for this alg class, or `False` otherwise.\n\n    This is a convenience wrapper around `check_key(key)`.\n\n    Args:\n      key: the key to check for this alg class\n\n    Returns:\n      `True` if the key is suitable for this alg class, `False` otherwise\n\n    \"\"\"\n    try:\n        cls.check_key(key)\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/#jwskate.jwa.HS384","title":"HS384","text":"<p>             Bases: <code>BaseHMACSigAlg</code></p> <p>HMAC using SHA-384.</p> Source code in <code>jwskate/jwa/signature/hmac.py</code> <pre><code>class HS384(BaseHMACSigAlg):  # noqa: D415\n\"\"\"HMAC using SHA-384.\"\"\"\n\n    name = \"HS384\"\n    description = __doc__\n    hashing_alg = hashes.SHA384()\n    min_key_size = 384\n</code></pre>"},{"location":"api/#jwskate.jwa.Ed25519Dsa","title":"Ed25519Dsa","text":"<p>             Bases: <code>BaseAsymmetricAlg[ed25519.Ed25519PrivateKey, ed25519.Ed25519PublicKey]</code>, <code>BaseSignatureAlg</code></p> <p>EdDSA signature algorithm with Ed25519 curve.</p> Source code in <code>jwskate/jwa/signature/eddsa.py</code> <pre><code>class Ed25519Dsa(\n    BaseAsymmetricAlg[\n        ed25519.Ed25519PrivateKey,\n        ed25519.Ed25519PublicKey,\n    ],\n    BaseSignatureAlg,\n):\n\"\"\"EdDSA signature algorithm with Ed25519 curve.\"\"\"\n\n    description = __doc__\n    hashing_alg = hashes.SHA256()\n\n    private_key_class = ed25519.Ed25519PrivateKey\n    public_key_class = ed25519.Ed25519PublicKey\n</code></pre>"},{"location":"api/#jwskate.jwa.HS512","title":"HS512","text":"<p>             Bases: <code>BaseHMACSigAlg</code></p> <p>HMAC using SHA-512.</p> Source code in <code>jwskate/jwa/signature/hmac.py</code> <pre><code>class HS512(BaseHMACSigAlg):  # noqa: D415\n\"\"\"HMAC using SHA-512.\"\"\"\n\n    name = \"HS512\"\n    description = __doc__\n    hashing_alg = hashes.SHA512()\n    min_key_size = 512\n</code></pre>"},{"location":"api/#jwskate.jwa.A128KW","title":"A128KW","text":"<p>             Bases: <code>BaseAesKeyWrap</code></p> <p>AES Key Wrap with default initial value using 128-bit key.</p> Source code in <code>jwskate/jwa/key_mgmt/aeskw.py</code> <pre><code>class A128KW(BaseAesKeyWrap):\n\"\"\"AES Key Wrap with default initial value using 128-bit key.\"\"\"\n\n    name = \"A128KW\"\n    description = __doc__\n    key_size = 128\n</code></pre>"},{"location":"api/#jwskate.jwa.A128GCMKW","title":"A128GCMKW","text":"<p>             Bases: <code>BaseAesGcmKeyWrap</code></p> <p>Key wrapping with AES GCM using 128-bit key.</p> Source code in <code>jwskate/jwa/key_mgmt/aesgcmkw.py</code> <pre><code>class A128GCMKW(BaseAesGcmKeyWrap):\n\"\"\"Key wrapping with AES GCM using 128-bit key.\"\"\"\n\n    name = \"A128GCMKW\"\n    description = __doc__\n    key_size = 128\n</code></pre>"},{"location":"api/#jwskate.jwa.Ed448Dsa","title":"Ed448Dsa","text":"<p>             Bases: <code>BaseAsymmetricAlg[ed448.Ed448PrivateKey, ed448.Ed448PublicKey]</code>, <code>BaseSignatureAlg</code></p> <p>EdDSA signature algorithm with Ed25519 curve.</p> Source code in <code>jwskate/jwa/signature/eddsa.py</code> <pre><code>class Ed448Dsa(\n    BaseAsymmetricAlg[\n        ed448.Ed448PrivateKey,\n        ed448.Ed448PublicKey,\n    ],\n    BaseSignatureAlg,\n):\n\"\"\"EdDSA signature algorithm with Ed25519 curve.\"\"\"\n\n    description = __doc__\n    hashing_alg = hashes.SHAKE256(114)\n\n    private_key_class = ed448.Ed448PrivateKey\n    public_key_class = ed448.Ed448PublicKey\n</code></pre>"},{"location":"api/#jwskate.jwa.RsaEsPcks1v1_5","title":"RsaEsPcks1v1_5","text":"<p>             Bases: <code>BaseRsaKeyWrap</code></p> <p>RSAES-PKCS1-v1_5.</p> Source code in <code>jwskate/jwa/key_mgmt/rsa.py</code> <pre><code>class RsaEsPcks1v1_5(BaseRsaKeyWrap):  # noqa: D415\n\"\"\"RSAES-PKCS1-v1_5.\"\"\"\n\n    name = \"RSA1_5\"\n    description = __doc__\n    read_only = True\n\n    padding = padding.PKCS1v15()\n</code></pre>"},{"location":"api/#jwskate.jwa.A192KW","title":"A192KW","text":"<p>             Bases: <code>BaseAesKeyWrap</code></p> <p>AES Key Wrap with default initial value using 192-bit key.</p> Source code in <code>jwskate/jwa/key_mgmt/aeskw.py</code> <pre><code>class A192KW(BaseAesKeyWrap):\n\"\"\"AES Key Wrap with default initial value using 192-bit key.\"\"\"\n\n    name = \"A192KW\"\n    description = __doc__\n    key_size = 192\n</code></pre>"},{"location":"api/#jwskate.jwa.A192GCMKW","title":"A192GCMKW","text":"<p>             Bases: <code>BaseAesGcmKeyWrap</code></p> <p>Key wrapping with AES GCM using 192-bit key.</p> Source code in <code>jwskate/jwa/key_mgmt/aesgcmkw.py</code> <pre><code>class A192GCMKW(BaseAesGcmKeyWrap):\n\"\"\"Key wrapping with AES GCM using 192-bit key.\"\"\"\n\n    name = \"A192GCMKW\"\n    description = __doc__\n    key_size = 192\n</code></pre>"},{"location":"api/#jwskate.jwa.A256KW","title":"A256KW","text":"<p>             Bases: <code>BaseAesKeyWrap</code></p> <p>AES Key Wrap with default initial value using 256-bit key.</p> Source code in <code>jwskate/jwa/key_mgmt/aeskw.py</code> <pre><code>class A256KW(BaseAesKeyWrap):\n\"\"\"AES Key Wrap with default initial value using 256-bit key.\"\"\"\n\n    name = \"A256KW\"\n    description = __doc__\n    key_size = 256\n</code></pre>"},{"location":"api/#jwskate.jwa.ES256","title":"ES256","text":"<p>             Bases: <code>BaseECSignatureAlg</code></p> <p>ECDSA using P-256 and SHA-256.</p> Source code in <code>jwskate/jwa/signature/ec.py</code> <pre><code>class ES256(BaseECSignatureAlg):\n\"\"\"ECDSA using P-256 and SHA-256.\"\"\"\n\n    name = \"ES256\"\n    description = __doc__\n    curve = P_256\n    hashing_alg = hashes.SHA256()\n</code></pre>"},{"location":"api/#jwskate.jwa.RsaEsOaep","title":"RsaEsOaep","text":"<p>             Bases: <code>BaseRsaKeyWrap</code></p> <p>RSAES OAEP using default parameters.</p> Source code in <code>jwskate/jwa/key_mgmt/rsa.py</code> <pre><code>class RsaEsOaep(BaseRsaKeyWrap):  # noqa: D415\n\"\"\"RSAES OAEP using default parameters.\"\"\"\n\n    name = \"RSA-OAEP\"\n    description = __doc__\n\n    padding = padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA1()),\n        algorithm=hashes.SHA1(),\n        label=None,\n    )\n</code></pre>"},{"location":"api/#jwskate.jwa.A256GCMKW","title":"A256GCMKW","text":"<p>             Bases: <code>BaseAesGcmKeyWrap</code></p> <p>Key wrapping with AES GCM using 256-bit key.</p> Source code in <code>jwskate/jwa/key_mgmt/aesgcmkw.py</code> <pre><code>class A256GCMKW(BaseAesGcmKeyWrap):\n\"\"\"Key wrapping with AES GCM using 256-bit key.\"\"\"\n\n    name = \"A256GCMKW\"\n    description = __doc__\n    key_size = 256\n</code></pre>"},{"location":"api/#jwskate.jwa.RS256","title":"RS256","text":"<p>             Bases: <code>BaseRSASigAlg</code></p> <p>RSASSA-PKCS1-v1_5 using SHA-256.</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>class RS256(BaseRSASigAlg):  # noqa: D415\n\"\"\"RSASSA-PKCS1-v1_5 using SHA-256.\"\"\"\n\n    name = \"RS256\"\n    description = __doc__\n    hashing_alg = hashes.SHA256()\n</code></pre>"},{"location":"api/#jwskate.jwa.ES384","title":"ES384","text":"<p>             Bases: <code>BaseECSignatureAlg</code></p> <p>ECDSA using P-384 and SHA-384.</p> Source code in <code>jwskate/jwa/signature/ec.py</code> <pre><code>class ES384(BaseECSignatureAlg):\n\"\"\"ECDSA using P-384 and SHA-384.\"\"\"\n\n    name = \"ES384\"\n    description = __doc__\n    curve = P_384\n    hashing_alg = hashes.SHA384()\n</code></pre>"},{"location":"api/#jwskate.jwa.A128GCM","title":"A128GCM","text":"<p>             Bases: <code>BaseAESGCM</code></p> <p>AES GCM using 128-bit key.</p> Source code in <code>jwskate/jwa/encryption/aesgcm.py</code> <pre><code>class A128GCM(BaseAESGCM):\n\"\"\"AES GCM using 128-bit key.\"\"\"\n\n    name = \"A128GCM\"\n    description = __doc__\n    key_size = 128\n</code></pre>"},{"location":"api/#jwskate.jwa.RS384","title":"RS384","text":"<p>             Bases: <code>BaseRSASigAlg</code></p> <p>RSASSA-PKCS1-v1_5 using SHA-384.</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>class RS384(BaseRSASigAlg):  # noqa: D415\n\"\"\"RSASSA-PKCS1-v1_5 using SHA-384.\"\"\"\n\n    name = \"RS384\"\n    description = __doc__\n    hashing_alg = hashes.SHA384()\n</code></pre>"},{"location":"api/#jwskate.jwa.RsaEsOaepSha256","title":"RsaEsOaepSha256","text":"<p>             Bases: <code>BaseRsaKeyWrap</code></p> <p>RSAES OAEP using SHA-256 and MGF1 with SHA-256.</p> Source code in <code>jwskate/jwa/key_mgmt/rsa.py</code> <pre><code>class RsaEsOaepSha256(BaseRsaKeyWrap):  # noqa: D415\n\"\"\"RSAES OAEP using SHA-256 and MGF1 with SHA-256.\"\"\"\n\n    name = \"RSA-OAEP-256\"\n    description = __doc__\n\n    padding = padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None,\n    )\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseAsymmetricAlg","title":"BaseAsymmetricAlg","text":"<p>             Bases: <code>Generic[Kpriv, Kpub]</code>, <code>BaseAlg</code></p> <p>Base class for asymmetric algorithms. Those can be initialised with a private or public key.</p> <p>The available cryptographic operations will depend on the alg and the provided key type.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Kpriv | Kpub</code> <p>the key to use.</p> required Source code in <code>jwskate/jwa/base.py</code> <pre><code>class BaseAsymmetricAlg(Generic[Kpriv, Kpub], BaseAlg):\n\"\"\"Base class for asymmetric algorithms. Those can be initialised with a private or public key.\n\n    The available cryptographic operations will depend on the alg and\n    the provided key type.\n\n    Args:\n        key: the key to use.\n\n    \"\"\"\n\n    private_key_class: type[Kpriv] | tuple[type[Kpriv], ...]\n    public_key_class: type[Kpub] | tuple[type[Kpub], ...]\n\n    def __init__(self, key: Kpriv | Kpub):\n        self.check_key(key)\n        self.key = key\n\n    @classmethod\n    def check_key(cls, key: Kpriv | Kpub) -&gt; None:\n\"\"\"Check that a given key is suitable for this alg class.\n\n        This must be implemented by subclasses as required.\n\n        Args:\n          key: the key to use.\n\n        Returns:\n          Returns None. Raises an exception if the key is not suitable.\n\n        Raises:\n            Exception: if the key is not suitable for use with this alg class\n\n        \"\"\"\n\n    @contextmanager\n    def private_key_required(self) -&gt; Iterator[Kpriv]:\n\"\"\"Check if this alg is initialised with a private key, as a context manager.\n\n        Yields:\n            the private key\n\n        Raises:\n            PrivateKeyRequired: if the configured key is not private\n\n        \"\"\"\n        if not isinstance(self.key, self.private_key_class):\n            raise PrivateKeyRequired()\n        yield self.key  # type: ignore[misc]\n\n    @contextmanager\n    def public_key_required(self) -&gt; Iterator[Kpub]:\n\"\"\"Check if this alg is initialised with a public key, as a context manager.\n\n        Yields:\n            The public key\n\n        Raises:\n            PublicKeyRequired: if the configured key is private\n\n        \"\"\"\n        if not isinstance(self.key, self.public_key_class):\n            raise PublicKeyRequired()\n        yield self.key  # type: ignore[misc]\n\n    def public_key(self) -&gt; Kpub:\n\"\"\"Return the public key matching the private key.\"\"\"\n        if hasattr(self.key, \"public_key\"):\n            return self.key.public_key()  # type: ignore[no-any-return]\n        raise NotImplementedError()\n\n    def public_alg(self) -&gt; Self:\n\"\"\"Return an alg instance initialised with the public key.\"\"\"\n        with self.private_key_required():\n            return self.__class__(self.public_key())\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.check_key","title":"check_key  <code>classmethod</code>","text":"<pre><code>check_key(key: Kpriv | Kpub) -&gt; None\n</code></pre> <p>Check that a given key is suitable for this alg class.</p> <p>This must be implemented by subclasses as required.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Kpriv | Kpub</code> <p>the key to use.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Returns None. Raises an exception if the key is not suitable.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the key is not suitable for use with this alg class</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@classmethod\ndef check_key(cls, key: Kpriv | Kpub) -&gt; None:\n\"\"\"Check that a given key is suitable for this alg class.\n\n    This must be implemented by subclasses as required.\n\n    Args:\n      key: the key to use.\n\n    Returns:\n      Returns None. Raises an exception if the key is not suitable.\n\n    Raises:\n        Exception: if the key is not suitable for use with this alg class\n\n    \"\"\"\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.private_key_required","title":"private_key_required","text":"<pre><code>private_key_required() -&gt; Iterator[Kpriv]\n</code></pre> <p>Check if this alg is initialised with a private key, as a context manager.</p> <p>Yields:</p> Type Description <code>Kpriv</code> <p>the private key</p> <p>Raises:</p> Type Description <code>PrivateKeyRequired</code> <p>if the configured key is not private</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@contextmanager\ndef private_key_required(self) -&gt; Iterator[Kpriv]:\n\"\"\"Check if this alg is initialised with a private key, as a context manager.\n\n    Yields:\n        the private key\n\n    Raises:\n        PrivateKeyRequired: if the configured key is not private\n\n    \"\"\"\n    if not isinstance(self.key, self.private_key_class):\n        raise PrivateKeyRequired()\n    yield self.key  # type: ignore[misc]\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.public_key_required","title":"public_key_required","text":"<pre><code>public_key_required() -&gt; Iterator[Kpub]\n</code></pre> <p>Check if this alg is initialised with a public key, as a context manager.</p> <p>Yields:</p> Type Description <code>Kpub</code> <p>The public key</p> <p>Raises:</p> Type Description <code>PublicKeyRequired</code> <p>if the configured key is private</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@contextmanager\ndef public_key_required(self) -&gt; Iterator[Kpub]:\n\"\"\"Check if this alg is initialised with a public key, as a context manager.\n\n    Yields:\n        The public key\n\n    Raises:\n        PublicKeyRequired: if the configured key is private\n\n    \"\"\"\n    if not isinstance(self.key, self.public_key_class):\n        raise PublicKeyRequired()\n    yield self.key  # type: ignore[misc]\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.public_key","title":"public_key","text":"<pre><code>public_key() -&gt; Kpub\n</code></pre> <p>Return the public key matching the private key.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>def public_key(self) -&gt; Kpub:\n\"\"\"Return the public key matching the private key.\"\"\"\n    if hasattr(self.key, \"public_key\"):\n        return self.key.public_key()  # type: ignore[no-any-return]\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAsymmetricAlg.public_alg","title":"public_alg","text":"<pre><code>public_alg() -&gt; Self\n</code></pre> <p>Return an alg instance initialised with the public key.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>def public_alg(self) -&gt; Self:\n\"\"\"Return an alg instance initialised with the public key.\"\"\"\n    with self.private_key_required():\n        return self.__class__(self.public_key())\n</code></pre>"},{"location":"api/#jwskate.jwa.ES512","title":"ES512","text":"<p>             Bases: <code>BaseECSignatureAlg</code></p> <p>ECDSA using P-521 and SHA-512.</p> Source code in <code>jwskate/jwa/signature/ec.py</code> <pre><code>class ES512(BaseECSignatureAlg):\n\"\"\"ECDSA using P-521 and SHA-512.\"\"\"\n\n    name = \"ES512\"\n    description = __doc__\n    curve = P_521\n    hashing_alg = hashes.SHA512()\n</code></pre>"},{"location":"api/#jwskate.jwa.A192GCM","title":"A192GCM","text":"<p>             Bases: <code>BaseAESGCM</code></p> <p>AES GCM using 192-bit key.</p> Source code in <code>jwskate/jwa/encryption/aesgcm.py</code> <pre><code>class A192GCM(BaseAESGCM):\n\"\"\"AES GCM using 192-bit key.\"\"\"\n\n    name = \"A192GCM\"\n    description = __doc__\n    key_size = 192\n</code></pre>"},{"location":"api/#jwskate.jwa.RS512","title":"RS512","text":"<p>             Bases: <code>BaseRSASigAlg</code></p> <p>RSASSA-PKCS1-v1_5 using SHA-256.</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>class RS512(BaseRSASigAlg):  # noqa: D415\n\"\"\"RSASSA-PKCS1-v1_5 using SHA-256.\"\"\"\n\n    name = \"RS512\"\n    description = __doc__\n    hashing_alg = hashes.SHA512()\n</code></pre>"},{"location":"api/#jwskate.jwa.Pbes2_HS256_A128KW","title":"Pbes2_HS256_A128KW","text":"<p>             Bases: <code>BasePbes2</code></p> <p>PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.</p> Source code in <code>jwskate/jwa/key_mgmt/pbes2.py</code> <pre><code>class Pbes2_HS256_A128KW(BasePbes2):\n\"\"\"PBES2 with HMAC SHA-256 and \"A128KW\" wrapping.\"\"\"\n\n    name = \"PBES2-HS256+A128KW\"\n    description = __doc__\n    kwalg = A128KW\n    hash_alg = hashes.SHA256()\n</code></pre>"},{"location":"api/#jwskate.jwa.RsaEsOaepSha384","title":"RsaEsOaepSha384","text":"<p>             Bases: <code>BaseRsaKeyWrap</code></p> <p>RSA-OAEP using SHA-384 and MGF1 with SHA-384.</p> Source code in <code>jwskate/jwa/key_mgmt/rsa.py</code> <pre><code>class RsaEsOaepSha384(BaseRsaKeyWrap):  # noqa: D415\n\"\"\"RSA-OAEP using SHA-384 and MGF1 with SHA-384.\"\"\"\n\n    name = \"RSA-OAEP-384\"\n    description = __doc__\n\n    padding = padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA384()),\n        algorithm=hashes.SHA384(),\n        label=None,\n    )\n</code></pre>"},{"location":"api/#jwskate.jwa.ES256K","title":"ES256K","text":"<p>             Bases: <code>BaseECSignatureAlg</code></p> <p>ECDSA using secp256k1 and SHA-256.</p> Source code in <code>jwskate/jwa/signature/ec.py</code> <pre><code>class ES256K(BaseECSignatureAlg):\n\"\"\"ECDSA using secp256k1 and SHA-256.\"\"\"\n\n    name = \"ES256k\"\n    description = __doc__\n    curve = secp256k1\n    hashing_alg = hashes.SHA256()\n</code></pre>"},{"location":"api/#jwskate.jwa.A256GCM","title":"A256GCM","text":"<p>             Bases: <code>BaseAESGCM</code></p> <p>AES GCM using 256-bit key.</p> Source code in <code>jwskate/jwa/encryption/aesgcm.py</code> <pre><code>class A256GCM(BaseAESGCM):\n\"\"\"AES GCM using 256-bit key.\"\"\"\n\n    name = \"A256GCM\"\n    description = __doc__\n    key_size = 256\n</code></pre>"},{"location":"api/#jwskate.jwa.PS256","title":"PS256","text":"<p>             Bases: <code>BaseRSASigAlg</code></p> <p>RSASSA-PSS using SHA-256 and MGF1 with SHA-256.</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>class PS256(BaseRSASigAlg):  # noqa: D415\n\"\"\"RSASSA-PSS using SHA-256 and MGF1 with SHA-256.\"\"\"\n\n    name = \"PS256\"\n    description = __doc__\n    hashing_alg = hashes.SHA256()\n    padding_alg = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=256 // 8)\n</code></pre>"},{"location":"api/#jwskate.jwa.Pbes2_HS384_A192KW","title":"Pbes2_HS384_A192KW","text":"<p>             Bases: <code>BasePbes2</code></p> <p>PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.</p> Source code in <code>jwskate/jwa/key_mgmt/pbes2.py</code> <pre><code>class Pbes2_HS384_A192KW(BasePbes2):\n\"\"\"PBES2 with HMAC SHA-384 and \"A192KW\" wrapping.\"\"\"\n\n    name = \"PBES2-HS384+A192KW\"\n    description = __doc__\n    kwalg = A192KW\n    hash_alg = hashes.SHA384()\n</code></pre>"},{"location":"api/#jwskate.jwa.PS384","title":"PS384","text":"<p>             Bases: <code>BaseRSASigAlg</code></p> <p>RSASSA-PSS using SHA-384 and MGF1 with SHA-384.</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>class PS384(BaseRSASigAlg):  # noqa: D415\n\"\"\"RSASSA-PSS using SHA-384 and MGF1 with SHA-384.\"\"\"\n\n    name = \"PS384\"\n    description = __doc__\n    hashing_alg = hashes.SHA384()\n    padding_alg = padding.PSS(mgf=padding.MGF1(hashes.SHA384()), salt_length=384 // 8)\n</code></pre>"},{"location":"api/#jwskate.jwa.Pbes2_HS512_A256KW","title":"Pbes2_HS512_A256KW","text":"<p>             Bases: <code>BasePbes2</code></p> <p>PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.</p> Source code in <code>jwskate/jwa/key_mgmt/pbes2.py</code> <pre><code>class Pbes2_HS512_A256KW(BasePbes2):\n\"\"\"PBES2 with HMAC SHA-512 and \"A256KW\" wrapping.\"\"\"\n\n    name = \"PBES2-HS512+A256KW\"\n    description = __doc__\n    kwalg = A256KW\n    hash_alg = hashes.SHA512()\n</code></pre>"},{"location":"api/#jwskate.jwa.RsaEsOaepSha512","title":"RsaEsOaepSha512","text":"<p>             Bases: <code>BaseRsaKeyWrap</code></p> <p>RSA-OAEP using SHA-512 and MGF1 with SHA-512.</p> Source code in <code>jwskate/jwa/key_mgmt/rsa.py</code> <pre><code>class RsaEsOaepSha512(BaseRsaKeyWrap):  # noqa: D415\n\"\"\"RSA-OAEP using SHA-512 and MGF1 with SHA-512.\"\"\"\n\n    name = \"RSA-OAEP-512\"\n    description = __doc__\n\n    padding = padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA512()),\n        algorithm=hashes.SHA512(),\n        label=None,\n    )\n</code></pre>"},{"location":"api/#jwskate.jwa.PS512","title":"PS512","text":"<p>             Bases: <code>BaseRSASigAlg</code></p> <p>RSASSA-PSS using SHA-512 and MGF1 with SHA-512.</p> Source code in <code>jwskate/jwa/signature/rsa.py</code> <pre><code>class PS512(BaseRSASigAlg):  # noqa: D415\n\"\"\"RSASSA-PSS using SHA-512 and MGF1 with SHA-512.\"\"\"\n\n    name = \"PS512\"\n    description = __doc__\n    hashing_alg = hashes.SHA512()\n    padding_alg = padding.PSS(mgf=padding.MGF1(hashes.SHA512()), salt_length=512 // 8)\n</code></pre>"},{"location":"api/#jwskate.jwa.A128CBC_HS256","title":"A128CBC_HS256","text":"<p>             Bases: <code>BaseAesCbcHmacSha2</code></p> <p>AES_128_CBC_HMAC_SHA_256.</p> Source code in <code>jwskate/jwa/encryption/aescbchmac.py</code> <pre><code>class A128CBC_HS256(BaseAesCbcHmacSha2):\n\"\"\"AES_128_CBC_HMAC_SHA_256.\"\"\"\n\n    name = \"A128CBC-HS256\"\n    description = __doc__\n    mac_key_size = 128\n    aes_key_size = 128\n    key_size = mac_key_size + aes_key_size\n    tag_size = 16\n    hash_alg = hashes.SHA256()\n</code></pre>"},{"location":"api/#jwskate.jwa.A192CBC_HS384","title":"A192CBC_HS384","text":"<p>             Bases: <code>BaseAesCbcHmacSha2</code></p> <p>AES_192_CBC_HMAC_SHA_384.</p> Source code in <code>jwskate/jwa/encryption/aescbchmac.py</code> <pre><code>class A192CBC_HS384(BaseAesCbcHmacSha2):\n\"\"\"AES_192_CBC_HMAC_SHA_384.\"\"\"\n\n    name = \"A192CBC-HS384\"\n    description = __doc__\n    mac_key_size = 192\n    aes_key_size = 192\n    key_size = mac_key_size + aes_key_size\n    tag_size = 24\n    hash_alg = hashes.SHA384()\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseSignatureAlg","title":"BaseSignatureAlg","text":"<p>             Bases: <code>BaseAlg</code></p> <p>Base class for signature algorithms.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>class BaseSignatureAlg(BaseAlg):\n\"\"\"Base class for signature algorithms.\"\"\"\n\n    use = \"sig\"\n    hashing_alg: hashes.HashAlgorithm\n\n    def sign(self, data: bytes | SupportsBytes) -&gt; BinaPy:\n\"\"\"Sign arbitrary data, return the signature.\n\n        Args:\n          data: raw data to sign\n\n        Returns:\n          the raw signature\n\n        \"\"\"\n        raise NotImplementedError\n\n    def verify(\n        self, data: bytes | SupportsBytes, signature: bytes | SupportsBytes\n    ) -&gt; bool:\n\"\"\"Verify a signature against some data.\n\n        Args:\n          data: the raw data to verify\n          signature: the raw signature\n\n        Returns:\n          `True` if the signature matches, `False` otherwise.\n\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.sign","title":"sign","text":"<pre><code>sign(data: bytes | SupportsBytes) -&gt; BinaPy\n</code></pre> <p>Sign arbitrary data, return the signature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | SupportsBytes</code> <p>raw data to sign</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>the raw signature</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>def sign(self, data: bytes | SupportsBytes) -&gt; BinaPy:\n\"\"\"Sign arbitrary data, return the signature.\n\n    Args:\n      data: raw data to sign\n\n    Returns:\n      the raw signature\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseSignatureAlg.verify","title":"verify","text":"<pre><code>verify(\n    data: bytes | SupportsBytes,\n    signature: bytes | SupportsBytes,\n) -&gt; bool\n</code></pre> <p>Verify a signature against some data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | SupportsBytes</code> <p>the raw data to verify</p> required <code>signature</code> <code>bytes | SupportsBytes</code> <p>the raw signature</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the signature matches, <code>False</code> otherwise.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>def verify(\n    self, data: bytes | SupportsBytes, signature: bytes | SupportsBytes\n) -&gt; bool:\n\"\"\"Verify a signature against some data.\n\n    Args:\n      data: the raw data to verify\n      signature: the raw signature\n\n    Returns:\n      `True` if the signature matches, `False` otherwise.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#jwskate.jwa.A256CBC_HS512","title":"A256CBC_HS512","text":"<p>             Bases: <code>BaseAesCbcHmacSha2</code></p> <p>AES_256_CBC_HMAC_SHA_512.</p> Source code in <code>jwskate/jwa/encryption/aescbchmac.py</code> <pre><code>class A256CBC_HS512(BaseAesCbcHmacSha2):\n\"\"\"AES_256_CBC_HMAC_SHA_512.\"\"\"\n\n    name = \"A256CBC-HS512\"\n    description = __doc__\n    mac_key_size = 256\n    aes_key_size = 256\n    key_size = mac_key_size + aes_key_size\n    tag_size = 32\n    hash_alg = hashes.SHA512()\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseAESEncryptionAlg","title":"BaseAESEncryptionAlg","text":"<p>             Bases: <code>BaseSymmetricAlg</code></p> <p>Base class for AES encryption algorithms.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>class BaseAESEncryptionAlg(BaseSymmetricAlg):\n\"\"\"Base class for AES encryption algorithms.\"\"\"\n\n    use = \"enc\"\n\n    key_size: int\n    tag_size: int\n    iv_size: int\n\n    @classmethod\n    def check_key(cls, key: bytes) -&gt; None:\n\"\"\"Check that a key is suitable for this algorithm.\n\n        Args:\n          key: the key to check\n\n        Raises:\n            ValueError: if the key is not suitable\n\n        \"\"\"\n        if len(key) * 8 != cls.key_size:\n            raise ValueError(\n                f\"This key size of {len(key) * 8} bits doesn't match the expected key size of {cls.key_size} bits\"\n            )\n\n    @classmethod\n    def generate_key(cls) -&gt; BinaPy:\n\"\"\"Generate a key of an appropriate size for this AES alg subclass.\n\n        Returns:\n            a random AES key\n\n        \"\"\"\n        return BinaPy.random_bits(cls.key_size)\n\n    @classmethod\n    def generate_iv(cls) -&gt; BinaPy:\n\"\"\"Generate an Initialisation Vector of the appropriate size.\n\n        Returns:\n            a random IV\n\n        \"\"\"\n        return BinaPy.random_bits(cls.iv_size)\n\n    def encrypt(\n        self,\n        plaintext: bytes | SupportsBytes,\n        *,\n        iv: bytes | SupportsBytes,\n        aad: bytes | SupportsBytes | None = None,\n    ) -&gt; tuple[BinaPy, BinaPy]:\n\"\"\"Encrypt arbitrary data, with optional Authenticated Encryption.\n\n        This needs as parameters:\n\n        - the raw data to encrypt (`plaintext`)\n        - a given random Initialisation Vector (`iv`) of the appropriate size\n        - optional Additional Authentication Data (`aad`)\n\n        And returns a tuple `(ciphered_data, authentication_tag)`.\n\n        Args:\n          plaintext: the data to encrypt\n          iv: the Initialisation Vector to use\n          aad: the Additional Authentication Data\n\n        Returns:\n          a tuple of ciphered data and authentication tag\n\n        \"\"\"\n        raise NotImplementedError\n\n    def decrypt(\n        self,\n        ciphertext: bytes | SupportsBytes,\n        *,\n        iv: bytes | SupportsBytes,\n        auth_tag: bytes | SupportsBytes,\n        aad: bytes | SupportsBytes | None = None,\n    ) -&gt; BinaPy:\n\"\"\"Decrypt and verify a ciphertext with Authenticated Encryption.\n\n        This needs:\n        - the raw encrypted Data (`ciphertext`) and Authentication Tag (`auth_tag`) that were produced by encryption,\n        - the same Initialisation Vector (`iv`) and optional Additional Authentication Data that were provided for encryption.\n        and returns the resulting clear text data.\n\n        Args:\n          ciphertext: the data to decrypt\n          iv: the Initialisation Vector to use. Must be the same one used during encryption\n          auth_tag: the authentication tag\n          aad: the Additional Authentication Data. Must be the same one used during encryption\n\n        Returns:\n          the deciphered data\n\n        \"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    @override\n    def with_random_key(cls) -&gt; Self:\n\"\"\"Initialize this alg with a random key.\n\n        Returns:\n            a subclass of `BaseAESEncryptionAlg` initialized with a randomly generated key\n\n        \"\"\"\n        return cls(cls.generate_key())\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.check_key","title":"check_key  <code>classmethod</code>","text":"<pre><code>check_key(key: bytes) -&gt; None\n</code></pre> <p>Check that a key is suitable for this algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>the key to check</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the key is not suitable</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@classmethod\ndef check_key(cls, key: bytes) -&gt; None:\n\"\"\"Check that a key is suitable for this algorithm.\n\n    Args:\n      key: the key to check\n\n    Raises:\n        ValueError: if the key is not suitable\n\n    \"\"\"\n    if len(key) * 8 != cls.key_size:\n        raise ValueError(\n            f\"This key size of {len(key) * 8} bits doesn't match the expected key size of {cls.key_size} bits\"\n        )\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_key","title":"generate_key  <code>classmethod</code>","text":"<pre><code>generate_key() -&gt; BinaPy\n</code></pre> <p>Generate a key of an appropriate size for this AES alg subclass.</p> <p>Returns:</p> Type Description <code>BinaPy</code> <p>a random AES key</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@classmethod\ndef generate_key(cls) -&gt; BinaPy:\n\"\"\"Generate a key of an appropriate size for this AES alg subclass.\n\n    Returns:\n        a random AES key\n\n    \"\"\"\n    return BinaPy.random_bits(cls.key_size)\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.generate_iv","title":"generate_iv  <code>classmethod</code>","text":"<pre><code>generate_iv() -&gt; BinaPy\n</code></pre> <p>Generate an Initialisation Vector of the appropriate size.</p> <p>Returns:</p> Type Description <code>BinaPy</code> <p>a random IV</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@classmethod\ndef generate_iv(cls) -&gt; BinaPy:\n\"\"\"Generate an Initialisation Vector of the appropriate size.\n\n    Returns:\n        a random IV\n\n    \"\"\"\n    return BinaPy.random_bits(cls.iv_size)\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.encrypt","title":"encrypt","text":"<pre><code>encrypt(\n    plaintext: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes,\n    aad: bytes | SupportsBytes | None = None\n) -&gt; tuple[BinaPy, BinaPy]\n</code></pre> <p>Encrypt arbitrary data, with optional Authenticated Encryption.</p> <p>This needs as parameters:</p> <ul> <li>the raw data to encrypt (<code>plaintext</code>)</li> <li>a given random Initialisation Vector (<code>iv</code>) of the appropriate size</li> <li>optional Additional Authentication Data (<code>aad</code>)</li> </ul> <p>And returns a tuple <code>(ciphered_data, authentication_tag)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>plaintext</code> <code>bytes | SupportsBytes</code> <p>the data to encrypt</p> required <code>iv</code> <code>bytes | SupportsBytes</code> <p>the Initialisation Vector to use</p> required <code>aad</code> <code>bytes | SupportsBytes | None</code> <p>the Additional Authentication Data</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[BinaPy, BinaPy]</code> <p>a tuple of ciphered data and authentication tag</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>def encrypt(\n    self,\n    plaintext: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes,\n    aad: bytes | SupportsBytes | None = None,\n) -&gt; tuple[BinaPy, BinaPy]:\n\"\"\"Encrypt arbitrary data, with optional Authenticated Encryption.\n\n    This needs as parameters:\n\n    - the raw data to encrypt (`plaintext`)\n    - a given random Initialisation Vector (`iv`) of the appropriate size\n    - optional Additional Authentication Data (`aad`)\n\n    And returns a tuple `(ciphered_data, authentication_tag)`.\n\n    Args:\n      plaintext: the data to encrypt\n      iv: the Initialisation Vector to use\n      aad: the Additional Authentication Data\n\n    Returns:\n      a tuple of ciphered data and authentication tag\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.decrypt","title":"decrypt","text":"<pre><code>decrypt(\n    ciphertext: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes,\n    auth_tag: bytes | SupportsBytes,\n    aad: bytes | SupportsBytes | None = None\n) -&gt; BinaPy\n</code></pre> <p>Decrypt and verify a ciphertext with Authenticated Encryption.</p> <p>This needs: - the raw encrypted Data (<code>ciphertext</code>) and Authentication Tag (<code>auth_tag</code>) that were produced by encryption, - the same Initialisation Vector (<code>iv</code>) and optional Additional Authentication Data that were provided for encryption. and returns the resulting clear text data.</p> <p>Parameters:</p> Name Type Description Default <code>ciphertext</code> <code>bytes | SupportsBytes</code> <p>the data to decrypt</p> required <code>iv</code> <code>bytes | SupportsBytes</code> <p>the Initialisation Vector to use. Must be the same one used during encryption</p> required <code>auth_tag</code> <code>bytes | SupportsBytes</code> <p>the authentication tag</p> required <code>aad</code> <code>bytes | SupportsBytes | None</code> <p>the Additional Authentication Data. Must be the same one used during encryption</p> <code>None</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the deciphered data</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>def decrypt(\n    self,\n    ciphertext: bytes | SupportsBytes,\n    *,\n    iv: bytes | SupportsBytes,\n    auth_tag: bytes | SupportsBytes,\n    aad: bytes | SupportsBytes | None = None,\n) -&gt; BinaPy:\n\"\"\"Decrypt and verify a ciphertext with Authenticated Encryption.\n\n    This needs:\n    - the raw encrypted Data (`ciphertext`) and Authentication Tag (`auth_tag`) that were produced by encryption,\n    - the same Initialisation Vector (`iv`) and optional Additional Authentication Data that were provided for encryption.\n    and returns the resulting clear text data.\n\n    Args:\n      ciphertext: the data to decrypt\n      iv: the Initialisation Vector to use. Must be the same one used during encryption\n      auth_tag: the authentication tag\n      aad: the Additional Authentication Data. Must be the same one used during encryption\n\n    Returns:\n      the deciphered data\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#jwskate.jwa.base.BaseAESEncryptionAlg.with_random_key","title":"with_random_key  <code>classmethod</code>","text":"<pre><code>with_random_key() -&gt; Self\n</code></pre> <p>Initialize this alg with a random key.</p> <p>Returns:</p> Type Description <code>Self</code> <p>a subclass of <code>BaseAESEncryptionAlg</code> initialized with a randomly generated key</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>@classmethod\n@override\ndef with_random_key(cls) -&gt; Self:\n\"\"\"Initialize this alg with a random key.\n\n    Returns:\n        a subclass of `BaseAESEncryptionAlg` initialized with a randomly generated key\n\n    \"\"\"\n    return cls(cls.generate_key())\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseEcdhEs_AesKw","title":"BaseEcdhEs_AesKw","text":"<p>             Bases: <code>EcdhEs</code></p> <p>Base class for ECDH-ES+AESKW algorithms.</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>class BaseEcdhEs_AesKw(EcdhEs):\n\"\"\"Base class for ECDH-ES+AESKW algorithms.\"\"\"\n\n    kwalg: type[BaseAesKeyWrap]\n\n    def wrap_key_with_epk(\n        self,\n        plainkey: bytes,\n        ephemeral_private_key: (\n            ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey\n        ),\n        **headers: Any,\n    ) -&gt; BinaPy:\n\"\"\"Wrap a key for content encryption.\n\n        Args:\n          plainkey: the key to wrap\n          ephemeral_private_key: the EPK to use\n          **headers: additional headers for CEK derivation\n\n        Returns:\n            the wrapped CEK\n\n        \"\"\"\n        aes_key = self.sender_key(\n            ephemeral_private_key, key_size=self.kwalg.key_size, **headers\n        )\n        return self.kwalg(aes_key).wrap_key(plainkey)\n\n    def unwrap_key_with_epk(\n        self,\n        cipherkey: bytes | SupportsBytes,\n        ephemeral_public_key: (\n            ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey\n        ),\n        **headers: Any,\n    ) -&gt; BinaPy:\n\"\"\"Unwrap a key for content decryption.\n\n        Args:\n          cipherkey: the wrapped key\n          ephemeral_public_key: the EPK\n          **headers: additional headers for CEK derivation\n\n        Returns:\n            the unwrapped key\n\n        \"\"\"\n        aes_key = self.recipient_key(\n            ephemeral_public_key, key_size=self.kwalg.key_size, **headers\n        )\n        return self.kwalg(aes_key).unwrap_key(cipherkey)\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.wrap_key_with_epk","title":"wrap_key_with_epk","text":"<pre><code>wrap_key_with_epk(\n    plainkey: bytes,\n    ephemeral_private_key: ec.EllipticCurvePrivateKey\n    | x25519.X25519PrivateKey\n    | x448.X448PrivateKey,\n    **headers: Any\n) -&gt; BinaPy\n</code></pre> <p>Wrap a key for content encryption.</p> <p>Parameters:</p> Name Type Description Default <code>plainkey</code> <code>bytes</code> <p>the key to wrap</p> required <code>ephemeral_private_key</code> <code>ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey</code> <p>the EPK to use</p> required <code>**headers</code> <code>Any</code> <p>additional headers for CEK derivation</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the wrapped CEK</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>def wrap_key_with_epk(\n    self,\n    plainkey: bytes,\n    ephemeral_private_key: (\n        ec.EllipticCurvePrivateKey | x25519.X25519PrivateKey | x448.X448PrivateKey\n    ),\n    **headers: Any,\n) -&gt; BinaPy:\n\"\"\"Wrap a key for content encryption.\n\n    Args:\n      plainkey: the key to wrap\n      ephemeral_private_key: the EPK to use\n      **headers: additional headers for CEK derivation\n\n    Returns:\n        the wrapped CEK\n\n    \"\"\"\n    aes_key = self.sender_key(\n        ephemeral_private_key, key_size=self.kwalg.key_size, **headers\n    )\n    return self.kwalg(aes_key).wrap_key(plainkey)\n</code></pre>"},{"location":"api/#jwskate.jwa.key_mgmt.ecdh.BaseEcdhEs_AesKw.unwrap_key_with_epk","title":"unwrap_key_with_epk","text":"<pre><code>unwrap_key_with_epk(\n    cipherkey: bytes | SupportsBytes,\n    ephemeral_public_key: ec.EllipticCurvePublicKey\n    | x25519.X25519PublicKey\n    | x448.X448PublicKey,\n    **headers: Any\n) -&gt; BinaPy\n</code></pre> <p>Unwrap a key for content decryption.</p> <p>Parameters:</p> Name Type Description Default <code>cipherkey</code> <code>bytes | SupportsBytes</code> <p>the wrapped key</p> required <code>ephemeral_public_key</code> <code>ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey</code> <p>the EPK</p> required <code>**headers</code> <code>Any</code> <p>additional headers for CEK derivation</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the unwrapped key</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>def unwrap_key_with_epk(\n    self,\n    cipherkey: bytes | SupportsBytes,\n    ephemeral_public_key: (\n        ec.EllipticCurvePublicKey | x25519.X25519PublicKey | x448.X448PublicKey\n    ),\n    **headers: Any,\n) -&gt; BinaPy:\n\"\"\"Unwrap a key for content decryption.\n\n    Args:\n      cipherkey: the wrapped key\n      ephemeral_public_key: the EPK\n      **headers: additional headers for CEK derivation\n\n    Returns:\n        the unwrapped key\n\n    \"\"\"\n    aes_key = self.recipient_key(\n        ephemeral_public_key, key_size=self.kwalg.key_size, **headers\n    )\n    return self.kwalg(aes_key).unwrap_key(cipherkey)\n</code></pre>"},{"location":"api/#jwskate.jwa.EcdhEs_A128KW","title":"EcdhEs_A128KW","text":"<p>             Bases: <code>BaseEcdhEs_AesKw</code></p> <p>ECDH-ES using Concat KDF and \"A128KW\" wrapping.</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>class EcdhEs_A128KW(BaseEcdhEs_AesKw):\n\"\"\"ECDH-ES using Concat KDF and \"A128KW\" wrapping.\"\"\"\n\n    name = \"ECDH-ES+A128KW\"\n    description = __doc__\n    kwalg = A128KW\n</code></pre>"},{"location":"api/#jwskate.jwa.EcdhEs_A192KW","title":"EcdhEs_A192KW","text":"<p>             Bases: <code>BaseEcdhEs_AesKw</code></p> <p>ECDH-ES using Concat KDF and \"A192KW\" wrapping.</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>class EcdhEs_A192KW(BaseEcdhEs_AesKw):\n\"\"\"ECDH-ES using Concat KDF and \"A192KW\" wrapping.\"\"\"\n\n    name = \"ECDH-ES+A192KW\"\n    description = __doc__\n    kwalg = A192KW\n</code></pre>"},{"location":"api/#jwskate.jwa.EcdhEs_A256KW","title":"EcdhEs_A256KW","text":"<p>             Bases: <code>BaseEcdhEs_AesKw</code></p> <p>ECDH-ES using Concat KDF and \"A256KW\" wrapping.</p> Source code in <code>jwskate/jwa/key_mgmt/ecdh.py</code> <pre><code>class EcdhEs_A256KW(BaseEcdhEs_AesKw):\n\"\"\"ECDH-ES using Concat KDF and \"A256KW\" wrapping.\"\"\"\n\n    name = \"ECDH-ES+A256KW\"\n    description = __doc__\n    kwalg = A256KW\n</code></pre>"},{"location":"api/#jwskate.jwa.BaseKeyManagementAlg","title":"BaseKeyManagementAlg","text":"<p>             Bases: <code>BaseAlg</code></p> <p>Base class for Key Management algorithms.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>class BaseKeyManagementAlg(BaseAlg):\n\"\"\"Base class for Key Management algorithms.\"\"\"\n\n    use = \"enc\"\n</code></pre>"},{"location":"api/#jwskate.jwa.MismatchingAuthTag","title":"MismatchingAuthTag","text":"<p>             Bases: <code>cryptography.exceptions.InvalidTag</code></p> <p>Raised during decryption, when the Authentication Tag doesn't match the expected value.</p> Source code in <code>jwskate/jwa/base.py</code> <pre><code>class MismatchingAuthTag(cryptography.exceptions.InvalidTag):\n\"\"\"Raised during decryption, when the Authentication Tag doesn't match the expected value.\"\"\"\n</code></pre>"},{"location":"authors/","title":"Authors","text":"<p>{% include-markdown \"../AUTHORS.md\" %}</p>"},{"location":"contributing/","title":"contributing","text":"<p>{% include-markdown \"../CONTRIBUTING.md\" %}</p>"},{"location":"history/","title":"History","text":"<p>{% include-markdown \"../HISTORY.md\" %}</p>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install <code>jwskate</code>, run this command in your terminal:</p> <pre><code>$ pip install jwskate\n</code></pre> <p>This is the preferred method to install <code>jwskate</code>, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for <code>jwskate</code> can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/guillp/jwskate\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/guillp/jwskate/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"recipes/","title":"examples","text":"<p>This is a collection of recipes related to <code>jwskate</code> usage.</p>"},{"location":"recipes/#jwk","title":"JWK","text":""},{"location":"recipes/#generate-privatepublic-key-pairs","title":"Generate private/public key pairs","text":"<pre><code>from jwskate import Jwk\n\nprivate_jwk = (\n    Jwk.generate(alg=\"ES256\")  # select the signature or encryption alg here\n    .with_kid_thumbprint()  # optionally, include a RFC7638 compliant thumbprint as kid\n    .with_usage_parameters()  # optionally, include 'use' and 'key_ops'\n)\n\nprint(private_jwk)\n# {\n#   \"kty\": \"EC\",\n#   \"crv\": \"P-256\",\n#   \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\",\n#   \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\",\n#   \"d\": \"Lce_08inNOEe6Q9xEGrR9T0CJNQa1o4EhGtDQYAI0N8\",\n#   \"alg\": \"ES256\",\n#   \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\",\n#   \"use\": \"sig\",\n#   \"key_ops\": [\n#     \"sign\"\n#   ]\n# }\n\npublic_jwk = private_jwk.public_jwk()\nprint(public_jwk.to_json(indent=2))\n# {\n#   \"kty\": \"EC\",\n#   \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\",\n#   \"alg\": \"ES256\",\n#   \"use\": \"sig\",\n#   \"key_ops\": [\n#     \"verify\"\n#   ],\n#   \"crv\": \"P-256\",\n#   \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\",\n#   \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\"\n# }\n\n# let's expose this public key as a JWKS:\nprint(public_jwk.as_jwks().to_json(indent=2))\n# {\n#   \"keys\": [\n#     {\n#       \"kty\": \"EC\",\n#       \"kid\": \"CzCOqostujy4iT3B55dkYYrSusaFvYjbCotGvo-e2gA\",\n#       \"alg\": \"ES256\",\n#       \"use\": \"sig\",\n#       \"key_ops\": [\n#         \"verify\"\n#       ],\n#       \"crv\": \"P-256\",\n#       \"x\": \"fYI3VbV5MYEu3TNGU4fgEr5re_Pq_PfexDYvDomK3SY\",\n#       \"y\": \"BEe3LhDVW_MsFFwPeRxW_cnGLakXdE6cvLfSXwLe6Gk\"\n#     }\n#   ]\n# }\n</code></pre>"},{"location":"recipes/#fetching-a-jwks-from-a-remote-endpoint","title":"Fetching a JWKS from a remote endpoint","text":"<pre><code>from jwskate import JwkSet\nimport requests\n\nraw_jwks = requests.get(\"https://www.googleapis.com/oauth2/v3/certs\").json()\njwkset = JwkSet(raw_jwks)\n\nprint(jwkset)\n# {\n#  \"keys\": [\n#      ...\n#  ]\n# }\n\n# compared to a raw dict, a JwkSet offers convenience methods like:\nif jwkset.is_private:  # returns True if the jwks contains at least one private key\n    raise ValueError(\n        \"JWKS contains private keys!\"\n    )  # an exposed JWKS should only contain public keys\n\nmy_jwk = jwkset.get_jwk_by_kid(\"my_key_id\")  # gets a key by key id (kid)\n# select keys that is suitable for signature verification\nverification_jwks = jwkset.verification_keys()\n# select keys that are suitable for encryption\nencryption_jwks = jwkset.encryption_keys()\n</code></pre>"},{"location":"recipes/#converting-between-pem-key-jwk-and-cryptography-keys","title":"Converting between PEM key, JWK and <code>cryptography</code> keys","text":"<pre><code>from jwskate import Jwk\n\n# generate a sample JWK, any asymmetric type will do:\nprivate_jwk = (\n    Jwk.generate(alg=\"ES256\")  # generates the key\n    .with_usage_parameters()  # adds use and key_ops\n    .with_kid_thumbprint()  # adds the key thumbprint as kid\n)\nprint(private_jwk.to_json(indent=2))\n# {'kty': 'EC',\n#  'crv': 'P-256',\n#  'x': '8xX1CEhDNNjEySUKLw88YeiVwEOW34BWm0hBkAxqlVU',\n#  'y': 'UfZ0JKT7MxdNMyqMKzKcAcYTcuqoXeplcJ3jNfnj3tM',\n#  'd': 'T45KDokOKyuhEA92ri5a951c5kjmQfGyh1SrEkonb4s',\n#  'alg': 'ES256',\n#  'use': 'sig',\n#  'key_ops': ['sign'],\n#  'kid': '_E8_LoT4QEwctEkGNbiP9dogVDz6Lq9i8G_fj9nnEo0'}\n\n# get the cryptography key that is wrapped in the Jwk:\ncryptography_private_key = private_jwk.cryptography_key\nprint(type(cryptography_private_key))\n# &lt;class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePrivateKey'&gt;\n\n# create the PEM for the private key (encrypted with a password)\nprivate_pem = private_jwk.to_pem(\"Th1s_P@ssW0rD_iS_5o_5tr0nG!\")\nprint(private_pem.decode())\n# -----BEGIN ENCRYPTED PRIVATE KEY-----\n# MIHsMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAhFd4nINf0/8QICCAAw\n# DAYIKoZIhvcNAgkFADAdBglghkgBZQMEASoEEJNdsyMjSx3d6RqBBTuI5LoEgZD4\n# qdPHcTZhKAuzQ9mkM1SlaZfiydWM2KFqPCYPLwoX+3kuCHPanMLlDxwOGN9XMRYl\n# hG3eO0Gu4eWdc/2QEcXIyBCbyKnSwhaHUSSfkhyK9eh8diHQw+blOIImIldLPxnp\n# +ABOhO6pCjQxM7I5op7RZuxLNWGLyAlfOOvawLfnM/wKLW6GXmlywu7PZ5qk9Bk=\n# -----END ENCRYPTED PRIVATE KEY-----\n\n# write this private PEM to a file:\nwith open(\"my_private_key.pem\", \"wb\") as foutput:\n    foutput.write(private_pem)\n\n# create the PEM for the public key (unencrypted)\npublic_jwk = private_jwk.public_jwk()\nprint(public_jwk)\n# {\n#   \"kty\": \"EC\",\n#   \"kid\": \"m-oFw9zA2YPFyqm265jbHnzXRa3SQ1ESdCE1AtAqO1U\",\n#   \"alg\": \"ES256\",\n#   \"use\": \"sig\",\n#   \"key_ops\": [\n#     \"verify\"\n#   ],\n#   \"crv\": \"P-256\",\n#   \"x\": \"VVbLOXwIgIFsYQSpnbLm5hr-ibfnIK0EeWYj2HXWvks\",\n#   \"y\": \"7f24WIqwHGr-jU9dH8GHpPEHMtAuXiwsedFnS6xayhk\"\n# }\n\n# get the cryptography public key\ncryptography_public_key = public_jwk.cryptography_key\nprint(type(cryptography_public_key))\n# &lt;class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePublicKey'&gt;\n\n# get the public PEM\npublic_pem = public_jwk.to_pem()\nprint(public_pem.decode())\n# -----BEGIN PUBLIC KEY-----\n# MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE8xX1CEhDNNjEySUKLw88YeiVwEOW\n# 34BWm0hBkAxqlVVR9nQkpPszF00zKowrMpwBxhNy6qhd6mVwneM1+ePe0w==\n# -----END PUBLIC KEY-----\n\n# write this public PEM to a file:\nwith open(\"my_public_key.pem\", \"wb\") as foutput:\n    foutput.write(public_pem)\n\n# read the private PEM from file and load it as a Jwk:\nwith open(\"my_private_key.pem\", \"rb\") as finput:\n    private_pem_from_file = finput.read()\nprivate_jwk_from_file = (\n    Jwk.from_pem(private_pem_from_file, password=\"Th1s_P@ssW0rD_iS_5o_5tr0nG!\")\n    .with_usage_parameters(alg=\"ES256\")  # adds back the alg, use and key_ops parameters\n    .with_kid_thumbprint()  # adds back the thumbprint as kid\n)\nassert private_jwk_from_file == private_jwk\n\n# read the public PEM from file and load it as a Jwk:\nwith open(\"my_public_key.pem\", \"rb\") as finput:\n    public_pem_from_file = finput.read()\npublic_jwk_from_file = (\n    Jwk.from_pem(public_pem_from_file)\n    .with_usage_parameters(alg=\"ES256\")  # adds back the alg, use and key_ops parameters\n    .with_kid_thumbprint()  # adds back the thumbprint as kid\n)\nassert public_jwk_from_file == public_jwk\n</code></pre>"},{"location":"recipes/#jwt","title":"JWT","text":""},{"location":"recipes/#parsing-a-jwt","title":"Parsing a JWT","text":"<pre><code>from jwskate import Jwt\nfrom datetime import datetime, timezone\n\n# you may recognize the default JWT value from https://jwt.io\njwt = Jwt(\n    \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n    \"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.\"\n    \"SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"\n)\n# access the parsed header, as a dict\nprint(jwt.headers)\n# {'alg': 'HS256', 'typ': 'JWT'}\n# access the parsed claims, as a dict\nprint(jwt.claims)\n# {'sub': '1234567890', 'name': 'John Doe', 'iat': 1516239022}\n# access the signature, as bytes\nprint(jwt.signature.hex())\n# 49f94ac7044948c78a285d904f87f0a4c7897f7e8f3a4eb2255fda750b2cc397\n\n# alg and typ from the headers are accessible as attributes\nassert jwt.alg == \"HS256\"\nassert jwt.typ == \"JWT\"\n\n# some registered claims are accessible, pre-parsed and validated according to RFC7519\nassert jwt.issuer is None\nassert jwt.subject == \"1234567890\"\nassert jwt.audiences == []\n# this would be a datetime if token had a valid 'exp' claim\nassert jwt.expires_at is None\n# this would be a datetime if token had a valid 'nbf' claim\nassert jwt.not_before is None\nassert jwt.issued_at == datetime(2018, 1, 18, 1, 30, 22, tzinfo=timezone.utc)\nassert jwt.jwt_token_id is None\n\n# checking the signature is as easy as\njwt.verify_signature(b\"your-256-bit-secret\", alg=\"HS256\")\n</code></pre>"},{"location":"usage/","title":"usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use <code>jwskate</code> in a project, you can import all exposed objects from the root module:</p> <pre><code>from jwskate import *\n</code></pre>"},{"location":"usage/#cheat-sheet","title":"Cheat Sheet","text":""},{"location":"usage/#generating-new-keys","title":"Generating new keys","text":"Usage Method For a specific algorithm <code>Jwk.generate(alg='ES256')</code> For a specific key type <code>Jwk.generate(kty='RSA')</code>"},{"location":"usage/#loading-keys","title":"Loading keys","text":"From Method A JWK in Python dict <code>jwk = Jwk({'kty': 'RSA', 'n': '...', ...})</code> A JWK in JSON formatted string <code>jwk = Jwk('{\"kty\": \"RSA\", \"n\": \"...\", ...}')</code> A<code>cryptography</code> key <code>jwk = Jwk(cryptography_key)</code> A public key in a PEM formatted string <code>jwk = Jwk.from_pem(</code><code>'''-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp0VYc2zc/6yNzQUSFprv</code><code>... 3QIDAQAB</code><code>-----END PUBLIC KEY----- '''</code><code>)</code> A private key in a PEM formatted string <code>jwk = Jwk.from_pem(</code><code>'''-----BEGIN PRIVATE KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp0VYc2zc/6yNzQUSFprv</code><code>... 3QIDAQAB</code><code>-----END PRIVATE KEY----- ''',</code> <code>password=b'password_if_any'</code> <code>)</code> A private key in a DER binary <code>jwk = Jwk.from_der(b'der_formatted_binary')</code>"},{"location":"usage/#saving-keys","title":"Saving keys","text":"<p>From an instance of a <code>Jwk</code> named <code>jwk</code>:</p> To Method Note A JWK in Python dict <code>jwk</code> # Jwk is a dict subclass you may also do<code>dict(jwk)</code> A JWK in JSON formatted string <code>jwk.to_json()</code> A cryptography key <code>jwk.cryptography_key</code> A PEM formatted string <code>jwk.to_pem(password=\"mypassword\")</code> password is optional A symmetric key, as bytes <code>jwk.key</code> only works with kty=oct A JWKS <code>jwk.as_jwks()</code> will contain<code>jwk</code> as single key"},{"location":"usage/#inspecting-keys","title":"Inspecting keys","text":"Usage Method Returns Check privateness <code>jwk.is_private()</code> <code>bool</code> Check symmetricness <code>jwk.is_symmetric()</code> <code>bool</code> Get Key Type <code>jwk.kty</code> key type, as<code>str</code> Get Alg (if present) <code>jwk.alg</code> intended algorithm identifier, as<code>str</code> Get Use <code>jwk.use</code> intended key use, if present, or deduced from<code>alg</code> Get Key Ops <code>jwk.key_ops</code> intended key operations, if present,or deduced from <code>use</code>, <code>kty</code>, privateness and symmetricness Get attributes <code>jwk['attribute']</code><code>jwk.attribute</code> attribute value Get thumbprint <code>jwk.thumbprint()</code><code>jwk.thumbprint_uri()</code> Computed thumbprint or thumbprint URI Get supported algorithms <code>jwk.supported_signing_algorithms()</code><code>jwk.supported_key_management_algorithms()</code><code>jwk.supported_encryption_algorithms()</code> List of supported algorithms identifiers, as<code>str</code>."},{"location":"usage/#jwk","title":"JWK","text":""},{"location":"usage/#loading-keys_1","title":"Loading keys","text":"<p>The <code>Jwk</code> class and its subclasses represent keys in JWK format. You can initialize a Jwk from:</p> <ul> <li>a dict representing the JWK content, already parsed from JSON:</li> </ul> <pre><code>from jwskate import Jwk\n\njwk = Jwk(\n    {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",\n        \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",\n        \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\",\n    }\n)\n</code></pre> <ul> <li>a string containing a JSON representation of the JWK:</li> </ul> <pre><code>from jwskate import Jwk\n\njwk = Jwk(\n    '{\"kty\": \"EC\", \"crv\": \"P-256\",'\n    'x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",'\n    'y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",'\n    'd\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}'\n)\n</code></pre> <ul> <li>a <code>cryptography</code> key:</li> </ul> <pre><code>from jwskate import Jwk\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\nkey = ec.generate_private_key(ec.SECP256R1)\njwk = Jwk(key)\n</code></pre> <ul> <li>a public or private key in PEM format, optionally protected by a password:</li> </ul> <pre><code>from jwskate import Jwk\n\npublic_jwk = Jwk.from_pem(\nb\"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsjtGIk8SxD+OEiBpP2/T\nJUAF0upwuKGMk6wH8Rwov88VvzJrVm2NCticTk5FUg+UG5r8JArrV4tJPRHQyvqK\nwF4NiksuvOjv3HyIf4oaOhZjT8hDne1Bfv+cFqZJ61Gk0MjANh/T5q9vxER/7TdU\nNHKpoRV+NVlKN5bEU/NQ5FQjVXicfswxh6Y6fl2PIFqT2CfjD+FkBPU1iT9qyJYH\nA38IRvwNtcitFgCeZwdGPoxiPPh1WHY8VxpUVBv/2JsUtrB/rAIbGqZoxAIWvijJ\nPe9o1TY3VlOzk9ASZ1AeatvOir+iDVJ5OpKmLnzc46QgGPUsjIyo6Sje9dxpGtoG\nQQIDAQAB\n-----END PUBLIC KEY-----\"\"\"\n)\n\nprivate_jwk = Jwk.from_pem(\nb\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEAywYF71cKSo3xyi7/0S7N1blFCmBX4eZz0gXf+zyBfomuqhwr\n....\ndaBAqhoDEr4SoKju8pagw6lqm65XeARyWkxqFqAZbb2K3bWY3x9qZT6oubLrCDGD\n-----END RSA PRIVATE KEY-----\"\"\",\n    \"P@ssw0rd\",\n)\n</code></pre>"},{"location":"usage/#getting-key-parameters","title":"Getting key parameters","text":"<p>Once you have a <code>Jwk</code> instance, you can access its parameters either by using subscription or attributes:</p> <pre><code>from jwskate import Jwk\n\njwk = Jwk(\n    {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",\n        \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",\n        \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\",\n    }\n)\nassert jwk.kty == \"EC\"\nassert jwk.crv == \"P-256\"\nassert jwk.x == \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\"\nassert jwk[\"x\"] == jwk.x\n</code></pre> <p>Those will return the exact (usually base64url-encoded) value, exactly as expressed in the JWK. You can also get the real, decoded parameters with some special attributes, which depend on the key type (thus on the <code>Jwk</code> subclass):</p> <pre><code>from jwskate import Jwk\n\njwk = Jwk(\n    {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",\n        \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",\n        \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\",\n    }\n)\nassert (\n    jwk.x_coordinate\n    == 41091394722340406951651919287101979028566994134304719828008599584440827098914\n)\nassert (\n    jwk.y_coordinate\n    == 5099336126642036233987555101153084413345413137896124327269101893088581300336\n)\nassert (\n    jwk.ecc_private_key\n    == 8342345011805978907621665437908035545366143771247820774310445528411160853919\n)\n</code></pre> <p>The available special attributes vary depending on the key type.</p>"},{"location":"usage/#generating-keys","title":"Generating keys","text":"<p><code>jwskate</code> can generate private keys from any of it supported key types. To generate a key, use <code>Jwk.generate()</code>. It just needs some hints to know what kind of key to generate, either an identifier for the algorithm that will be used with that key (<code>alg</code>), or a key type (<code>kty</code>). An <code>alg</code> is preferred, since it gives more hints to generate a key that is suitable for its purpose. Those hints include the Elliptic Curve to use, or the key size to generate. The specified <code>alg</code> will be part of the generated key, and will avoid having to specify the alg for every cryptographic operation you will perform with that key.</p> <pre><code>from jwskate import Jwk\n\n# specifying an alg:\nrsa_jwk_RS256 = Jwk.generate(alg=\"RS256\")\n# 'kty': 'RSA', 'n': '0o-yPaR-e7yr3l3pA7CFwGpHu3QSGhEK50w_qeK0UGD2hmqNCRxD5cAYJ1JKltgcsmSQ4b94_DPdJjRaNdyJbX15cF25tVtoPRW6g5_kgiIpTzrDFcVTY0CJ0DHztnkG9IitC-xBRJSgJd2SPyL9j1bSfdWPjvaq1Z8LhxjUauUNaQmIkVw_ji-eGksClF-3Nv9l3s3V7sCbHaVLL6pQ1KV2SXW327xACHp5wbwtEociBRQWNMGoNpQz0k1dhTsfQTz2xOwKn-iETTySZSNnP6cvOjwlz2t5KjZNns3CBYKWw9z0AqLJ_99_y14q3krxpauuOQ_uh3Y_qPNSaFoUfjp5NuvAlVuptW3dzgf86Svb8KF7mmx0oC328FY_VCusUuKuis-lgX_P-_f-wTXEiXQkHjaekNDd8YFyssDu6NKWH8IfKR53NCtShLslNvifkQxIUOP6gVrMCvTr4oOAYQsw2K3C92CNfmavYsLtej0A-j7La-NeHuYX9UoWQimSefChw0LZ4unVahMqb6nb7C3_FVv7nLJzupahpmERTKDqv09Kw060KvMKv-OSd8sK_Zzfv5emjZmNaZTVBCAu5OVZBOVRKmzEPT9K0g-63DdLOlNmS_4Ns6qCzrFdc9Fy6HiJB60xOpZ-EBU7Ft_rr5YmtTrAW_oguHiN-hku0Vk', 'e': 'AQAB', 'd': 'INc-t_SRsbTsothyK8bQJaxYlyPJtafA0_CFjCFgJEVAo223pPBz-pU_xH-bmJ6zuHM3pwNugvoyh5nqFAqF-L4gPxFZ51pkDgWh5ej-AqSssr8khvRpnB-zHvYbip33zWi1LMM4LtJ2OVGvVLTyvUo6YbFPHGoxR55FywK-vBQQ8mKv7-lmaZktsfDPFzCSlTu3uiIlOCwcRWnEKfazeBHSkC88ckOQl9dFFEgdnjfWFjAFgqGjHdgho68ODhCkQFBE4NPmmFLzXPnnOhUP2SgMlVWk7rlW2D7zU6Md8YQRBb15kCEEcSnSdyKvJvqjaUaMpuPAPVUzz_hw0EvJyYSLYQMtI5gLhVZzKeTV_dsfB7QPJR9Q03lktwZOLzLqoRucC9nTiT_g7gsBUMBi6LRD34Krd_YGp4A24tynzMlD8KATO1oU4QSdVvxPGticKGUntEJcUAkq00aMKv9zrb1WBUDIIccf6UKbjj2tj3r9hUASg1xHrlZmIhXK9xe3FeNP34dp_5ACLfl9JQzorzoNsaNgf0swD2ww_-wSsUbxfpow1RYtfS9aKpbJGADx-gyGReRU8YVie3SJ1yfur90EvIbq4eIVdMFklQGbbMnR291DZNJM0e_RNzOSMj574rNaq_7Tq5uMNaoFfAc2rKZDdL-Ze9e6YD7UO10WpB0', 'p': '5MC2kUwy3I4hyQwk4ikh201IZEw_onOktcQAT3QSl6R_zlUMb8j9lR1-_7R5xNeQsUaN3gXuEzlAbuTAS7EgF_WcvEsYyi_Eqn2B_o2QAUUJXEtNqyeC5Q2bGLXM5Yl0nqaMOpI5lsoAK4CfTe0L6B3AeriFhlTPI-LY8_PrtbeSf06NHuJ2_1XqZVE-tQiDlKu29zWntOJ8L-0f9ABA1q6ixSX4hCa3QyE3_4hGgxH8pskQ8GSfUJ05KBu_bjlTghCvqGfoBQAxJSZJtmK71RNZ9zznDiwhJA0tGr1iZuAlsv3k_HRPbSuxPO1-XNWmyL9-66d05h7evurmLWnX3w', 'q': '66RGuDf9nqDBb1PNQy7EDldwDYdIU-1TzjcEjfBktI0powazWPS9d8DsnxRuL0IdEmS4QyZoNx7UnUjr7si4yDuzYkwo6DRsjWMkTjnSbzwd-2d55kU68qmloWc5t1fTWGslEVbDGX05bak2JfCqW87sycxfAFHANTwnIfTEbrVFiNb8FnRBA5dRGp-dyH6nSMzV5-V0d-CjJnil_TNwx6cOVJQgT40gJl-15jwpiHBGmTKUghHwspxVrrwH6sGr-eMfF2AaJplXbJCu1G_q494XGLwJvV_q6uTSTC6aU-eKlOwRJYFgSmkbHAuxdLfAmYHzjgMvoLQjE4tdJwRdxw', 'dp': 'DKx8sPomyz94sbnhhUJAJPVYMG5lDCwaERQF7GEC8rHjftwJb1wUaKGUurgWEwjadGfzTjzH3vrKDhrQaKEspQcvouMKQZF59PQ1MpRHSTq49QsbB4ON5gDl-e2Ap6sA8hVKKaiWVjtk3QQoT1n10etsEaCNjU6_lz5nRMTb51p_XFxOx0pGy4jIDsr8jW0mVSNaZMHtQ8FUnhcmMQ-eiAZu8DtVVIUMnESH5Ll5JqPlepwjOx5oEUBUvVskNQgqD0e7Y7o2CajkECnZ5af8viZvUppmNsvNHkE4oYWioQ6EKDGW8UHEcMj97eE-oggYUIEDmCzT9jf5oVxEWnnFww', 'dq': 'YSmgm29C3Xitqgjk91G-N6eoJXvlv-15A-u9rgU0kRov0-_8Xa60vT9IkiOrd0MMl7v-GnoouKm2w5AA8LnFL5MmWV7L80tCg14g5zyCX6lrN3GoWuGq98op6I6Wxtmo5KlxZF_hHI588pG2KRi-NhLxohfqCEitN4YxIJg7suZ94Hm9Akk3UZLAN3kfZz-KHMORZAhB6PgwbbmLwAbI9xoUF53oYMTxP8FxUJj4CzE4ewzXHXbmR8-cqOsRXKQ1FFmpRUs0HTxXRwW1gRUQxpqZ7XIDlhmJ1Qc7C3yf1_7-Ln_UZiGdobELI5pStqzZ9rIVyjXYGqyMVg-9_kuXmw', 'qi': 'HpqAlt1xp_to2iVqIfXh-CulsUgLupespF1lKdpzqLkApD1JVjxXm3dItI6wGewMgABdpE6WoiTqE-gyuMlgws-1vO6RnNpeT43p3pJfzKWaaC3v4agk1_xR6BZag2-dHPNBYED0nidS9HCZH7VsxbhIZ71vio7MGJbRJieDcF0Xpn5bZ5XBhbXvgo7tIySsIZ8U7DGs3PnDkDujJY1_11YMtUPW_zJmE1OJvoE3mroBoRwF2pjASmk3_WMmAyko79LoUCPWn-HI4dtjMV5YuUJ7S1OHrR7QoAWHThSCmc_Br5XHvMllcDjcvppFGfTNRNaADZ-eeygyA-Gxe6Hahg', 'alg': 'RS256'}\nec_jwk_ES512 = Jwk.generate(alg=\"ES256\")\n# {'kty': 'EC', 'crv': 'P-256', 'x': 'vYXg2w4d7qzhFl2BOleEfXTiUGjar9XZdNzL6WtQapA', 'y': 'QGfFxR3rOCPM4PXM6GgwwcEYHm42S-SYYRCWvbMIyko', 'd': '1E3PnLV9zAGbV8axbNm3kVykE-xhJbueYkIVcLC4t_g', 'alg': 'ES256'}\noct_jwk_HS256 = Jwk.generate(alg=\"HS256\")\n# {'kty': 'oct', 'k': 'EM4Yf0JLy5a6MoF0PIVhE51R4i-sPGXfiBg7Gyd7YzA', 'alg': 'HS256'}\n\n# a few examples without specifying an alg, but passing a key type instead:\nrsa_jwk = Jwk.generate(kty=\"RSA\")\noct_jwk = Jwk.generate(kty=\"oct\")\n\n# you may combine both if needed:\nrsa_jwk = Jwk.generate(kty=\"RSA\", alg=\"RS256\")\n# a ValueError is raised if kty and alg are inconsistent:\nrsa_jwk = Jwk.generate(kty=\"EC\", alg=\"RS256\")\n# ValueError: Incompatible `alg='RS256'` and `kty='EC'` parameters. `alg='RS256'` points to `kty='RSA'`.\n</code></pre> <p>You can include additional parameters such as \"use\" or \"key_ops\", or custom parameters which will be included in the generated key:</p> <pre><code>from jwskate import Jwk\n\njwk = Jwk.generate(alg=\"ES256\", use=\"sig\", custom_param=\"custom_value\")\n\nassert jwk.use == \"sig\"\nassert jwk.custom_param == \"custom_value\"\n</code></pre> <p>For keys with a variable key size (such as RSA or oct), you may specify the key size:</p> <pre><code>from jwskate import Jwk\n\njwk = Jwk.generate(kty=\"oct\", key_size=512)\n</code></pre> <p><code>jwskate</code> will warn you if the key size you specify is insufficient for the alg you are trying to use, or will raise an exception if it is not the mandatory key size for the alg:</p> <pre><code>from jwskate import Jwk\n\nJwk.generate(alg=\"HS256\", key_size=40)\n# UserWarning: Symmetric keys to use with HS256 should be at least 256 bits in order to make the key at least as hard to brute-force as the signature. You requested a key size of 40 bits.\n\nJwk.generate(alg=\"A128KW\", key_size=40)\n# ValueError: Key for A128KW must be exactly 128 bits. You should remove the `key_size` parameter to generate a key of the appropriate length.\n</code></pre> <p>Note that keys generated by jwskate are always private. You can get the matching public key as described below.</p>"},{"location":"usage/#private-and-public-keys","title":"Private and Public Keys","text":"<p>You can check if a key is public or private with the <code>is_private</code> property:</p> <pre><code>from jwskate import Jwk\n\nprivate_jwk = Jwk(\n    {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",\n        \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",\n        \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\",\n    }\n)\nassert private_jwk.is_private\n</code></pre> <p>You can get the public key that match a given private key with the <code>public_jwk()</code> method. It returns a new <code>Jwk</code> instance that does not contain the private parameters:</p> <pre><code>from jwskate import Jwk\n\nprivate_jwk = Jwk(\n    {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",\n        \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",\n        \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\",\n    }\n)\npublic_jwk = private_jwk.public_jwk()\nassert \"d\" not in public_jwk  # \"d\" would contain the private key\nassert not public_jwk.is_private\n</code></pre> <p>Note that Symmetric keys are always considered private, so calling <code>.public_jwk()</code> will raise a <code>ValueError</code>. You can know if a key is symmetric with <code>.is_symmetric</code>:</p> <pre><code>from jwskate import Jwk\n\njwk = Jwk.generate(kty=\"oct\", key_size=128)\nassert jwk.is_symmetric\nassert jwk.is_private\n</code></pre>"},{"location":"usage/#dumping-keys","title":"Dumping keys","text":""},{"location":"usage/#to-json","title":"to JSON","text":"<p><code>Jwk</code> instances are dicts, so you can serialize it to JSON in the usual ways (with Python <code>json</code> module or any other means). You can also use the <code>to_json()</code> convenience method to serialize a <code>Jwk</code>:</p> <pre><code>from jwskate import Jwk\n\njwk = Jwk(\n    {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",\n        \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",\n        \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\",\n    }\n)\njwk.to_json()\n# '{\"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\", \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\", \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\"}'\n</code></pre>"},{"location":"usage/#to-cryptography-keys","title":"to <code>cryptography</code> keys","text":"<p>You can access the <code>cryptography_key</code> attribute to get a <code>cryptography</code> key instance that matches a <code>Jwk</code>:</p> <pre><code>from jwskate import Jwk\n\njwk = Jwk(\n    {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"WtjnvHG9b_IKBLn4QYTHz-AdoAiO_ork5LH1BL_5tyI\",\n        \"y\": \"C0YfOUDuCOvTCt7hAqO-f9z8_JdOnOPbfYmUk-RosHA\",\n        \"d\": \"EnGZlkoa4VUsnl72LcRRychNJ2FFknm_ph855tNuPZ8\",\n    }\n)\ncryptography_key = jwk.cryptography_key\nassert (\n    str(cryptography_key.__class__)\n    == \"&lt;class 'cryptography.hazmat.backends.openssl.ec._EllipticCurvePrivateKey'&gt;\"\n)\n</code></pre>"},{"location":"usage/#signing-and-verifying-data","title":"Signing and verifying data","text":"<p>You can sign arbitrary data, then validate the signature with a <code>Jwk</code> instance, using the <code>sign()</code> and <code>verify()</code> methods:</p> <pre><code>from jwskate import Jwk\n\ndata = b\"Signing is easy!\"\njwk = Jwk.generate_for_kty(\"EC\", crv=\"P-256\")\n\nsignature = jwk.sign(data, alg=\"ES256\")\nassert jwk.verify(data, signature, alg=\"ES256\")\nassert not jwk.verify(\n    data,\n    b\"this_is_a_wrong_signature_value_12345678012345678012345678012345\",\n    alg=\"ES256\",\n)\n</code></pre>"},{"location":"usage/#encrypting-and-decrypting-data","title":"Encrypting and Decrypting data","text":"<p>Encryption or decryption require a symmetric key, which translates to an instance of <code>SymmetricJwk</code>, with <code>kty='oct'</code>. You can encrypt and decrypt arbitrary data with a Jwk instance, using the <code>encrypt()</code> and <code>decrypt()</code> methods:</p> <pre><code>from jwskate import Jwk\n\ndata = b\"Encryption is easy!\"\nalg = \"A256GCM\"\njwk = Jwk.generate_for_kty(\"oct\", key_size=256, alg=alg)\n\nciphertext, iv, tag = jwk.encrypt(data)\n\nassert jwk.decrypt(ciphertext, iv=iv, tag=tag) == data\n</code></pre>"},{"location":"usage/#authenticated-encryption","title":"Authenticated encryption","text":"<p>You can include Additional Authenticated Data (<code>aad</code>) in the <code>encrypt()</code> and <code>decrypt()</code> operations:</p> <pre><code>from jwskate import Jwk\n\ndata = b\"Authenticated Encryption is easy!\"\nalg = \"A256GCM\"\naad = b\"This is my auth tag\"\njwk = Jwk.generate_for_kty(\"oct\", key_size=256, alg=alg)\n\nciphertext, iv, tag = jwk.encrypt(data, aad=aad)\n\nassert jwk.decrypt(ciphertext, iv=iv, tag=tag, aad=aad) == data\n</code></pre>"},{"location":"usage/#key-management","title":"Key Management","text":"<p>Encrypting/decrypting arbitrary data is never done using asymmetric keys. But it is possible to use Key Management algorithms with asymmetric keys to encrypt/decrypt or otherwise derive symmetric keys, which in turn can be used for encryption/decryption using symmetric encryption algorithms.</p> <p>Some of those Key Management algorithms rely on key wrapping, where a randomly-generated symmetric key (called a Content Encryption Key or CEK) is itself encrypted with an asymmetric algorithm. Other algorithms rely on Diffie-Hellman, where the CEK is derived from a pair of keys: one public and the other private. Sender will use a generated private key and the recipient public key, while the recipient will use its private key and the sender public key. On both sides, the resulting CEK will be the same. It is also possible to use a symmetric key to encrypt the CEK with a symmetric algorithm, which is mostly used when the recipient is the same as the sender.</p> <p><code>jwskate</code> provides methods that make Key Management very easy. If you are the message sender, you must obtain the recipient public key, as a <code>Jwk</code> instance. You can then use the <code>sender_key()</code> method on that instance to generate an appropriate CEK. It needs the target encryption algorithm as parameter, and optionally the key management algorithm, if it is not specified in the recipient public key. It will return a tuple <code>(plaintext_message, encrypted_cek, extra_headers)</code>, with <code>plaintext_message</code> being the generated CEK (as an instance of <code>SymmetricJwk</code>), <code>encrypted_cek</code> is the wrapped CEK value (which can be empty for Diffie-Hellman based algorithms), and <code>extra_headers</code> a dict of extra headers that are required for the key management algorithm (for example, <code>epk</code> for ECDH-ES based algorithms),</p> <p>You can use <code>cleartext_cek</code> to encrypt your message with a given Encryption algorithm. You must then send <code>encrypted_cek</code> and <code>extra_headers</code> to your recipient, along with the encrypted message, and both Key Management and Encryption algorithms identifiers.</p> <pre><code>from jwskate import Jwk\n\nplaintext_message = b\"Key Management and Encryption are easy!\"\nrcpt_private_jwk = Jwk.generate(alg=\"ECDH-ES\", crv=\"P-256\")\n# {'kty': 'EC',\n# 'crv': 'P-256',\n# 'alg': 'ECDH-ES',\n# 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE',\n# 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4',\n# 'd': 'Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E'}\n\nrcpt_public_jwk = rcpt_private_jwk.public_jwk()\n# {'kty': 'EC',\n# 'crv': 'P-256',\n# 'x': '10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE',\n# 'y': 'Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4'}\n\nenc_alg = \"A256GCM\"\nkm_alg = \"ECDH-ES\"\nplaintext_cek, encrypted_cek, extra_headers = rcpt_public_jwk.sender_key(enc_alg)\n# plaintext_cek: {'kty': 'oct', 'k': 'iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc'}\n# encrypted_cek: b''\n# extra_headers: {'epk': {'kty': 'EC',\n#  'crv': 'P-256',\n#  'x': '_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg',\n#  'y': 'nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs'}}\n\nencrypted_message, iv, tag = plaintext_cek.encrypt(plaintext_message, alg=enc_alg)\n# encrypted_message: b'\\xb5J\\x16\\x08\\x82Xp\\x0f,\\x0eu\\xe5\\xd6\\xa6y\\xe0J\\xae\\xcbu\\xf8B\\xbd'\n# iv: b'K\"H\\xf3@\\tt\\\\\\xc78\\xc2D'\n# tag: b'\\xc4\\xee\\xcf`\\xfa\\\\\\x8e\\x9dn\\xc4&gt;D\\xd8\\x1d\\x8c\\x1a'\n</code></pre> <p>On recipient side, in order to decrypt the message, you will need to obtain the same symmetric CEK that was used to encrypt the message. That is done with <code>recipient_key()</code> on the recipient private key. You need to provide it with the <code>encrypted_cek</code> received from the sender (possibly empty for Diffie-Hellman based algorithms), the Key Management algorithm that is used to wrap the CEK, the Encryption algorithm that is used to encrypt/decrypt the message, and the eventual extra headers depending on the Key Management algorithm.</p> <p>You can then use that CEK to decrypt the received message.</p> <pre><code>from jwskate import Jwk\n\n# reusing the variables from above\nenc_alg = \"A256GCM\"\nkm_alg = \"ECDH-ES\"\nplaintext_cek = {\"kty\": \"oct\", \"k\": \"iUa0WAadkir02DrdapFGzPI-9q9xqP-JaU4M69euMvc\"}\nencrypted_cek = b\"\"\nextra_headers = {\n    \"epk\": {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"_26Ak6hccBPzFe2t2CYwFMH8jkKm-UWajOrci9KIPfg\",\n        \"y\": \"nVXtV6YcU1IsT8qL9zAbvMrvXvhdEvMoeVfDeF-bsRs\",\n    }\n}\nrecipient_private_jwk = Jwk(\n    {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"10QvcmuPmErnHHnrnQ7kVV-Mm_jA4QUG5W9t81jAVyE\",\n        \"y\": \"Vk3Y4_qH09pm8rCLl_htf321fK62qbz6jxLlk0Y3Qe4\",\n        \"d\": \"Y4vvC9He6beJi3lKYdVgvvUS9zUWz_YnV0xKT90-Z5E\",\n    }\n)\n\nencrypted_message = b\"\\xb5J\\x16\\x08\\x82Xp\\x0f,\\x0eu\\xe5\\xd6\\xa6y\\xe0J\\xae\\xcbu\\xf8B\\xbd\"\niv = b'K\"H\\xf3@\\tt\\\\\\xc78\\xc2D'\ntag = b\"\\xc4\\xee\\xcf`\\xfa\\\\\\x8e\\x9dn\\xc4&gt;D\\xd8\\x1d\\x8c\\x1a\"\n\n# obtain the same CEK as the sender, based on our private key, and public data provided by sender\ncek = recipient_private_jwk.recipient_key(\n    encrypted_cek, enc=\"A256GCM\", alg=\"ECDH-ES\", **extra_headers\n)\n# and decrypt the message with that CEK (and the IV, Auth Tag and encryption alg identifier provided by sender)\nplaintext_message = cek.decrypt(encrypted_message, iv=iv, tag=tag, alg=enc_alg)\n\nassert plaintext_message == b\"Key Management and Encryption are easy!\"\n</code></pre>"},{"location":"usage/#jws","title":"JWS","text":"<p>The <code>JwsCompact</code> class represents a syntactically valid JWS token in compact representation.</p>"},{"location":"usage/#parsing-tokens","title":"Parsing tokens","text":"<p>To parse an existing Jws token and access its content (without validating the signature yet), you simply need to create an instance of <code>JwsCompact</code> with the serialized token as value:</p> <pre><code>from jwskate import JwsCompact\n\njws = JwsCompact(\n    \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\"\n    \"SGVsbG8gV29ybGQh.\"\n    \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\"\n    \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\"\n    \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\"\n    \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\"\n    \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\"\n)\n\njws.payload\n# b'Hello World!'\njws.headers\n# {'alg': 'RS256', 'kid': 'JWK-ABCD'}\njws.alg\n# 'RS256'\njws.kid\n# 'JWK-ABCD'\njws.signature\n# '\\xd5\\xeb\\x9cK\\xd6ZNp\\t\\xc9\\xf5M\\x87\\x12\\xc9\\xfe\\x98E7Z\\xde\\xc6m%\\xfar\\x17X\\x18\\xd4\"gR\\xdb\\xdc\\xf9\\xe4\\x1b\\xb1\\x1f\\xa3c\\x1a\\x99mIr\\xab\\x81\\x8cXC\\x1a\\x86\\n\\xc1\\x88\\xc6T\\x95\\xa0\\x81!)Wa\\x13U]\\xf4\\xd3\\xc9G,;#\\x8c\\xc1E\\xdc\\x15\\xbd\\xca\\x8cD\\xe0\\xcc\\xa8&lt;B\\x8a\\xa6\\xc3C\\xfe[#\\x98\\xc0\\xa8Q\\t\\x00P\\x97f\\x8d\\x93\\xe2,e\\xc6\\xcf\\xb6y{fHJz\\xbd~uN\\ri\\xbe\\'\\x0c\\xe7\\xf6+)\\xf4\\xbc&amp;}\\xe5\\xb7\\xdcV\\xe5\\x16\\x8d)B}\\xe0\\xa5K\\x96\\x8b\\xff\"w\\x05\\xb2\\x1d\\x9b\\x83\\x98\\xdd\\xa3T\\x84\\xa1Le\\x07b\\x08\\xd0\\x97e|+ \\x1e\\x88Iw\\x9f\\x1eZ1S\\xa1\\xe3m\\x1fW\\xa2\\\\g\\x998v\\xe50\\xbc\\xf9k\\x90!c\\xc8\\xd8\\xdc.6\\xe3\\xeb`\\x82&gt;\\x81+\\xa7\\xf0\\xa5\\xe7]tP\\xf7\\x9a\\xd1EL\\xdc:)?\\xb6\\x12\\x04\\xde:Q\\x00\\xd3\\xdaP\\xa9na\\xa2\\xc0\\xa3\\xd9\\xdb\\x80\\x95\\x1f\\x85A'\n</code></pre>"},{"location":"usage/#verifying-tokens","title":"Verifying tokens","text":"<p>To verify a Jws signature, you need the matching public key:</p> <pre><code>from jwskate import JwsCompact\n\njws = JwsCompact(\n    \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.\"\n    \"SGVsbG8gV29ybGQh.\"\n    \"1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCs\"\n    \"GIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixl\"\n    \"xs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoU\"\n    \"xlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedd\"\n    \"dFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ\"\n)\npublic_jwk = {\n    \"kty\": \"RSA\",\n    \"kid\": \"JWK-ABCD\",\n    \"alg\": \"RS256\",\n    \"n\": \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\",\n    \"e\": \"AQAB\",\n}\nif jws.verify_signature(public_jwk):\n    print(\"Signature is verified.\")\nelse:\n    print(\"Signature verification failed!\")\n</code></pre>"},{"location":"usage/#signing-tokens","title":"Signing tokens","text":"<p>To sign a Jws, you need its payload, the private key and alg to sign with, and provide those to <code>JwsCompact.sign()</code>:</p> <pre><code>from jwskate import JwsCompact\n\npayload = b\"Hello World!\"\nprivate_jwk = {\n    \"kty\": \"RSA\",\n    \"kid\": \"JWK-ABCD\",\n    \"alg\": \"RS256\",\n    \"n\": \"2jgK-5aws3_fjllgnAacPkwjbz3RCeAHni1pcHvReuTgk9qEiTmXWJiSS_F20VeI1zEwFM36e836ROCyOQ8cjjaPWpdzCajWC0koY7X8MPhZbdoSptOmDBseRCyYqmeMCp8mTTOD6Cs43SiIYSMNlPuio89qjf_4u32eVF_5YqOGtwfzC4p2NUPPCxpljYpAcf2BBG1tRX1mY4WP_8zwmx3ZH7Sy0V_fXI46tzDqfRXdMhHW7ARJAnEr_EJhlMgUaM7FUQKUNpi1ZdeeLxYv44eRx9-Roy5zTG1b0yRuaKaAG3559572quOcxISZzK5Iy7BhE7zxVa9jabEl-Y1Daw\",\n    \"e\": \"AQAB\",\n    \"d\": \"XCtpsCRQ1DBBm51yqdQ88C82lEjW30Xp0cy6iVEzBKZhmPGmI1PY8gnXWQ5PMlK3sLTM6yypDNvORoNlo6YXWJYA7LGlXEIczj2DOsJmF8T9-OEwGZixvNFDcmYnwWnlA6N_CQKmR0ziQr9ZAzZMCU5Tvr7f8cRZKdAALQEwk5FYpLnEbXOBduJtY9x2kddJSCJwRaEJhx0fG_pJAO3yLUZBY20dZK8UrxDoCgB9eiZV3N4uWGt367r1MDdaxGY6l6bC1HZCHkttBuTxfSUMCgooZevdU6ThQNpFrwZNY3KoP-OksEdqMs-neecfk_AQREkubDW2VPNFnaVEa38BKQ\",\n    \"p\": \"8QNZGwUINpkuZi8l2ZfQzKVeOeNe3aQ7UW0wperM-63DFEJDRO1UyNC1n6yeo8_RxPZKSTlr6xZDoilQq23mopeF6O0ZmYz6E2VWJuma65V-A7tB-6xjqUXPlSkCNA6Ia8kMeCmNpKs0r0ijTBf_2y2GSsNH4EcP7XzcDEeJIh0\",\n    \"q\": \"58nWgg-qRorRddwKM7qhLxJnEDsnCiYhbKJrP78OfBZ-839bNRvL5D5sfjJqxcKMQidgpYZVvVNL8oDEywcC5T7kKW0HK1JUdYiX9DuI40Mv9WzXQ8B8FBjp5wV4IX6_0KgyIiyoUiKpVHBvO0YFPUYuk0Ns4H9yEws93RWwhSc\",\n    \"dp\": \"zFsLZcaphSnzVr9pd4urhqo9MBZjbMmBZnSQCE8ECe729ymMQlh-SFv3dHF4feuLsVcn-9iNceMJ6-jeNs1T_s89wxevWixYKrQFDa-MJW83T1CrDQvJ4VCJR69i5-Let43cXdLWACcO4AVWOQIsdpquQJw-SKPYlIUHS_4n_90\",\n    \"dq\": \"fP79rNnhy3TlDBgDcG3-qjHUXo5nuTNi5wCXsaLInuZKw-k0OGmrBIUdYNizd744gRxXJCxTZGvdEwOaHJrFVvcZd7WSHiyh21g0CcNpSJVc8Y8mbyUIRJZC3RC3_egqbM2na4KFqvWCN0UC1wYloSuNxmCgAFj6HYb8b5NYxBU\",\n    \"qi\": \"hxXfLYgwrfZBvZ27nrPsm6mLuoO-V2rKdOj3-YDJzf0gnVGBLl0DZbgydZ8WZmSLn2290mO_J8XY-Ss8PjLYbz3JXPDNLMJ-da3iEPKTvh6OfliM_dBxhaW8sq5afLMUR0H8NeabbWkfPz5h0W11CCBYxsyPC6CzniFYCYXfByU\",\n}\n\njws = JwsCompact.sign(payload, jwk=private_jwk, alg=\"RS256\")\nstr(jws)\n# 'eyJhbGciOiJSUzI1NiIsImtpZCI6IkpXSy1BQkNEIn0.SGVsbG8gV29ybGQh.1eucS9ZaTnAJyfVNhxLJ_phFN1rexm0l-nIXWBjUImdS29z55BuxH6NjGpltSXKrgYxYQxqGCsGIxlSVoIEhKVdhE1Vd9NPJRyw7I4zBRdwVvcqMRODMqDxCiqbDQ_5bI5jAqFEJAFCXZo2T4ixlxs-2eXtmSEp6vX51Tg1pvicM5_YrKfS8Jn3lt9xW5RaNKUJ94KVLlov_IncFsh2bg5jdo1SEoUxlB2II0JdlfCsgHohJd58eWjFToeNtH1eiXGeZOHblMLz5a5AhY8jY3C424-tggj6BK6fwpedddFD3mtFFTNw6KT-2EgTeOlEA09pQqW5hosCj2duAlR-FQQ'\n</code></pre>"},{"location":"usage/#jwe","title":"JWE","text":"<p>The <code>JweCompact</code> class represents a syntactically valid JWE token.</p>"},{"location":"usage/#parsing-and-decrypting-jwe-tokens","title":"Parsing and decrypting JWE tokens","text":"<p>Provide the serialized token value to <code>JweCompact</code>, then use <code>.decrypt()</code> with the private key to decrypt the token payload:</p> <pre><code>from jwskate import JweCompact\n\njwe = JweCompact(\n    \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n    \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\"\n    \"ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\"\n    \"Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\"\n    \"mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\"\n    \"1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\"\n    \"6UklfCpIMfIjf7iGdXKHzg.\"\n    \"48V1_ALb6US04U3b.\"\n    \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\"\n    \"SdiwkIr3ajwQzaBtQD_A.\"\n    \"XFBoMYUZodetZdvTiFvSkQ\"\n)\n\n# all 'raw' attributes are accessible:\njwe.headers\n# {'alg': 'RSA-OAEP', 'enc': 'A256GCM'}\njwe.alg\n# 'RSA-OAEP'\njwe.enc\n# 'A256GCM'\njwe.ciphertext\n# b\"\\xe5\\xec\\xa6\\xf15\\xbfs\\xc4\\xae+Im'z\\xe9`\\x8c\\xcex43\\xed0\\x0b\\xbe\\xdb\\xbaPoh2\\x8e/\\xa7;=\\xb5\\x7f\\xc4\\x15(R\\xf2 {\\x8f\\xa8\\xe2I\\xd8\\xb0\\x90\\x8a\\xf7j&lt;\\x10\\xcd\\xa0m@?\\xc0\"\njwe.wrapped_cek\n# b'8\\xa3\\x9a\\xc0:5\\xde\\x04i\\xda\\x88\\xda\\x1d^\\xcb\\x16\\x96\\\\\\x81^\\xd3\\xe85Y)&lt;\\x8a8\\xc4\\xd8Rb\\xa8L%IF\\x07$\\x08\\xbfd\\x88\\xc4\\xf4\\xdc\\x91\\x9e\\x8a\\x9b\\x04u\\x8d\\xe6\\xc7\\xf7\\xad-\\xb6\\xd6J\\xb1k\\xd3\\x99\\x0b\\xcd\\xc4\\xab\\xe2\\xa2\\x80\\xab\\xb6\\r\\xed\\xefc\\xc1\\x04[\\xdby\\xdfk\\xa7=w\\xe4\\xad\\x9c\\x89\\x86\\xc8P\\xdbJ\\xfd8\\xb9[\\xb1\"\\x9eY\\x9a\\xcd`7\\x12\\x8a+`\\xda\\xd7\\x80|K\\x8a\\xf3U\\x19mu\\x8c\\x1a\\x9b\\xf9C\\xa7\\x95\\xe7d\\x06)A\\xd6\\xfb\\xe8WH(\\xb6\\x95\\x9a\\xa8\\x1f\\xc1~\\xd7Y\\x1co\\xdb}\\xb6\\x8b\\xeb\\xc3\\xc5\\x17\\xea7:?\\xb4D\\xca\\xce\\x95K\\xcd\\xf8\\xb0C\\'\\xb2&lt;b\\xc1 \\xeez`\\x9e\\xde9\\xb7o\\xd27\\xbc\\xd7\\xce\\xb4\\xa6\\x96\\xa6j\\xfa7\\xe5H(E\\xd6\\xd8h\\x17(\\x87\\xd4\\x1c\\x7f)P\\xaf\\xae\\xa8s\\xab\\xc5Yt\\\\g\\xf6S\\xd8\\xb6\\xb0T%\\x93#-\\xdb\\xacc\\xe2\\xe9I%|*H1\\xf2#\\x7f\\xb8\\x86ur\\x87\\xce'\njwe.initialization_vector\n# b'\\xe3\\xc5u\\xfc\\x02\\xdb\\xe9D\\xb4\\xe1M\\xdb'\njwe.authentication_tag\n# b'\\\\Ph1\\x85\\x19\\xa1\\xd7\\xade\\xdb\\xd3\\x88[\\xd2\\x91'\n\n\nprivate_jwk = {\n    \"kty\": \"RSA\",\n    \"n\": \"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW\"\n    \"cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S\"\n    \"psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a\"\n    \"sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS\"\n    \"tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj\"\n    \"YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\",\n    \"e\": \"AQAB\",\n    \"d\": \"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N\"\n    \"WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9\"\n    \"3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk\"\n    \"qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl\"\n    \"t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd\"\n    \"VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\",\n    \"p\": \"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-\"\n    \"SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf\"\n    \"fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\",\n    \"q\": \"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm\"\n    \"UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX\"\n    \"IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\",\n    \"dp\": \"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL\"\n    \"hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827\"\n    \"rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\",\n    \"dq\": \"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj\"\n    \"ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB\"\n    \"UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\",\n    \"qi\": \"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7\"\n    \"AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3\"\n    \"eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\",\n}\npayload = jwe.decrypt(private_jwk)\nassert payload == b\"The true sign of intelligence is not knowledge but imagination.\"\n\n# you can also decrypt only the CEK (returned as SymmetricJwk instance):\ncek = jwe.unwrap_cek(private_jwk)\nassert cek == {\"kty\": \"oct\", \"k\": \"saH0gFSP4XM_tAP_a5rU9ooHbltwLiJpL4LLLnrqQPw\"}\n</code></pre>"},{"location":"usage/#encrypting-jwe-tokens","title":"Encrypting JWE tokens","text":"<p>To encrypt a JWE token, use <code>JweCompact.encrypt()</code> with the plaintext, public key, key management alg (<code>alg</code>) and encryption alg (<code>enc</code>):</p> <pre><code>from jwskate import JweCompact, Jwk\n\nplaintext = b\"Encrypting JWE is easy!\"\nprivate_jwk = Jwk.generate_for_kty(\"EC\")\npublic_jwk = private_jwk.public_jwk()\n\njwe = JweCompact.encrypt(plaintext, public_jwk, alg=\"ECDH-ES+A128KW\", enc=\"A128GCM\")\nstr(jwe)\n# 'eyJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTI1NiIsIngiOiI3a2VIdGxXdnVQQWVfYzR3d1hsNXFBZENHYzNKSk9KX0c5WThWU29Cc0tBIiwieSI6ImlyVFpRVzFlckZUSGd4WG1nUVdpcTVBYXdNOXNtamxybE96X2RTMmpld1kifSwiYWxnIjoiRUNESC1FUytBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.s7iUWLT2TG_kRnxuRvMxL5lY1oVRRVlI.kQaT5CM0HYfdwQ9H.49Trq2lpEtOEk8u_HP20TuJ80xpkqK8.RsQMBzvLj5i9bk4eew21gg'\n</code></pre>"},{"location":"usage/#jwt","title":"JWT","text":"<p>JWT tokens are JWS tokens which contain a JSON object as payload. Some attributes of this JSON object are standardised to represent the token issuer, audience, and lifetime.</p> <p>The <code>Jwt</code> class and its subclasses represent a syntactically valid Jwt token. It then allows to access the JWT content and verify its signature.</p> <p>Note that a JWT token can optionally be encrypted. In that case, the signed JWT content will be the plaintext of a JWE token. Decrypting that JWE can then be achieved with the <code>JweCompact</code> class, then this plaintext can be manipulated with the <code>Jwt</code> class.</p>"},{"location":"usage/#parsing-jwt-tokens","title":"Parsing JWT tokens","text":"<p>To parse an existing JWT token, simply initialize a <code>Jwt</code> with the token value as parameter. An instance of <code>Jwt</code> exposes all the JWT attributes, and a <code>verify_signature()</code> method just like <code>JwsCompact()</code>. Claims can be accessed either:</p> <ul> <li>with the <code>claims</code> attribute, which is a dict of the parsed JSON content</li> <li>with subscription: <code>jwt['attribute']</code> does a key lookup inside the <code>claims</code> dict, just like <code>jwt.claims['attribute']</code></li> <li>with attribute access: <code>jwt.attribute</code> does the same as <code>jwt.claims['attribute']</code>. Note that attribute names   containing special characters are not accessible this way due to Python syntax for attribute names.</li> <li>for standardised attributes, with a dedicated special attribute, which will parse and validate the attribute value.   Example: <code>jwt.expires_at</code> returns a <code>datetime</code> initialised from the <code>exp</code> claim.</li> </ul> <pre><code>from jwskate import Jwt\n\njwt = Jwt(\n    \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\"\n)\n\njwt.claims\n# {'acr': '2',\n#  'amr': ['pwd', 'otp'],\n#  'aud': 'client_id',\n#  'auth_time': 1629204560,\n#  'exp': 1629204620,\n#  'iat': 1629204560,\n#  'iss': 'https://myas.local',\n#  'nonce': 'nonce',\n#  'sub': '123456'}\n\n# example claim access via subscription:\njwt[\"acr\"]\n# '2'\n\n# example claim access via attribute:\njwt.sub\n# '123456'\n\n# example special claim access:\njwt.expires_at\n# datetime.datetime(2021, 8, 17, 12, 50, 20, tzinfo=datetime.timezone.utc)\n\n# the raw 'exp' value is still accessible with the other means:\njwt[\"exp\"] == jwt.exp == 1629204620\n# True\n\n# other special attributes:\njwt.audiences  # always return a list\n# ['client_id']\njwt.issued_at\n# datetime.datetime(2021, 8, 17, 12, 49, 20, tzinfo=datetime.timezone.utc)\njwt.not_before  # this would be a datetime if there was a valid 'nbf' claim in the token\nNone\njwt.subject  # return the 'sub' claim, and makes sure it is a string\n# '123456'\njwt.issuer  # return the 'iss' claim, and makes sure that it is a string\n# 'https://myas.local'\n\n\njwt.headers\n# {'alg': 'RS256', 'kid': 'my_key'}\n\njwt.signature\n# b\"\\xc1G\\xe33(\\xe59'olQ\\x85?\\xc3\\xbc\\xc0g\\r\\x04\\xae\\xda\\x91\\xec\\x8eP\\x13/a\\xc3YrQT\\xb6\\x89\\x0e\\xcb\\x18KP\\xfcf\\xa3T\\xc7\\xa3P\\xd5\\xd4\\x11\\xd4U\\xde\\x80Y\\xf7\\x8aR|\\x93\\xc6_\\xfc\\xf8m\\xc4\\xfd\\xafn\\xe7\\x02_\\x0f'\\xe0\\x84\\xf0\\xe1\\ng\\xe4`\\x04o\\xa9\\t\\xe7W\\xfd\\xda!\\xb7\\xd3}@B\\xe1\\xfd\\x1b\\x1e\\xbd&lt;w\\xfa\\xb4|@\\xfc\\xf1\\x12\\xee\\xef\\xbc\\x04H\\x83\\xc2V\\xa4\\x18\\xcbf\\xe4\\xe0R\\xeeq\\xce\\xb7\\xc8`oh+$\\xab;ag\\xceCl\\x12XX\\xb9Q\\xf2\\xa0T\\x93\\xf3@\\xf1\\xb5\\x80M\\x81-\\x8f\\x04\\xeb\\xc6\\x86^\\xfa\\xe0&gt;\\xbc\\x1e\\x8d\\xc1K\\xf5\\x87\\xc0\\xcaF\\xc0\\xc5\\xfb\\xd1\\xd2Tw\\x96]p\\x1e\\xa0oT[\\xbc\\xe0\\xc6\\x867)\\xb0\\xc8W7\\xa6\\xbcl\\xec\\xd9\\x1fN\\x800QE\\xa7\\xc1\\x05W\\x80\\x905z\\t\\xd6\\xdd0\\xd2C\\x98|\\xdc\\x8d\\xab\\x1e\\xe65\\xfa,O\\xb7`,\\xbbs\\xb0\\x0c3[\\x96D)\\xca\\xdd\\xff\\x9a\\xcc\"\n\n# verifying the signature:\nassert jwt.verify_signature(\n    {\n        \"kty\": \"RSA\",\n        \"kid\": \"my_key\",\n        \"alg\": \"RS256\",\n        \"n\": \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\",\n        \"e\": \"AQAB\",\n    }\n)\n\n# verifying expiration:\nassert jwt.is_expired()\n</code></pre>"},{"location":"usage/#validating-jwt-tokens","title":"Validating JWT tokens","text":"<p>To validate a JWT token, verifying the signature is usually not enough. You probably want to validate the issuer, audience, expiration date, and other claims. To make things easier, use <code>SignedJwt.validate()</code>. It raises exceptions if one of the check fails:</p> <pre><code>from jwskate import Jwt\n\njwt = Jwt(\n    \"eyJhbGciOiJSUzI1NiIsImtpZCI6Im15X2tleSJ9.\"\n    \"eyJhY3IiOiIyIiwiYW1yIjpbInB3ZCIsIm90cCJdLCJhdWQiOiJjbGllbnRfaWQiLCJhdXRoX3RpbWUiOjE2MjkyMDQ1NjAsImV4cCI6MTYyOTIwNDYyMCwiaWF0IjoxNjI5MjA0NTYwLCJpc3MiOiJodHRwczovL215YXMubG9jYWwiLCJub25jZSI6Im5vbmNlIiwic3ViIjoiMTIzNDU2In0.wUfjMyjlOSdvbFGFP8O8wGcNBK7akeyOUBMvYcNZclFUtokOyxhLUPxmo1THo1DV1BHUVd6AWfeKUnyTxl_8-G3E_a9u5wJfDyfghPDhCmfkYARvqQnnV_3aIbfTfUBC4f0bHr08d_q0fED88RLu77wESIPCVqQYy2bk4FLucc63yGBvaCskqzthZ85DbBJYWLlR8qBUk_NA8bWATYEtjwTrxoZe-uA-vB6NwUv1h8DKRsDF-9HSVHeWXXAeoG9UW7zgxoY3KbDIVzemvGzs2R9OgDBRRafBBVeAkDV6CdbdMNJDmHzcjase5jX6LE-3YCy7c7AMM1uWRCnK3f-azA\"\n)\njwk = {\n    \"kty\": \"RSA\",\n    \"kid\": \"my_key\",\n    \"alg\": \"RS256\",\n    \"n\": \"2m4QVSHdUo2DFSbGY24cJbxE10KbgdkSCtm0YZ1q0Zmna8pJg8YhaWCJHV7D5AxQ_L1b1PK0jsdpGYWc5-Pys0FB2hyABGPxXIdg1mjxn6geHLpWzsA3MHD29oqfl0Rt7g6AFc5St3lBgJCyWtci6QYBmBkX9oIMOx9pgv4BaT6y1DdrNh27-oSMXZ0a58KwnC6jbCpdA3V3Eume-Be1Tx9lJN3j6S8ydT7CGY1Xd-sc3oB8pXfkr1_EYf0Sgb9EwOJfqlNK_kVjT3GZ-1JJMKJ6zkU7H0yXe2SKXAzfayvJaIcYrk-sYwmf-u7yioOLLvjlGjysN7SOSM8socACcw\",\n    \"e\": \"AQAB\",\n}\n\njwt.validate(jwk, issuer=\"https://myas.local\", audience=\"client_id\")\n# at the time you run this, it will probably raise a `jwskate.ExpiredJwt` exception\n</code></pre>"},{"location":"usage/#signing-jwt-tokens","title":"Signing JWT tokens","text":"<p>To sign a set of claims into a JWT, use <code>Jwt.sign()</code>. It takes the claims (as a dict), the signing key, and the signature alg to use (if the key doesn't have an 'alg' parameter).</p> <pre><code>from jwskate import Jwt, Jwk\n\nclaims = {\"claim1\": \"value1\", \"claim2\": \"value2\"}\njwk = Jwk.generate_for_kty(\"EC\", crv=\"P-256\")\njwt = Jwt.sign(claims, jwk, alg=\"ES256\")\n\nprint(jwt)\n# eyJhbGciOiJFUzI1NiJ9.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.mqqXTljXQwNff0Sah88oFGBNWC9XpZxUj3WDa9-00UAyuEoL6cey-rHQNtmYgYgPRgI_HnWpRm5M4_a9qv9m0g\n</code></pre>"},{"location":"usage/#jwt-headers","title":"JWT headers","text":"<p>The default header will contain the signing algorithm identifier (alg) and the JWK Key Identifier (kid), if there was one in the used JWK. You can add additional headers by using the <code>extra_headers</code> parameter to <code>Jwt.sign()</code>:</p> <pre><code>from jwskate import Jwt, Jwk\n\nclaims = {\"claim1\": \"value1\", \"claim2\": \"value2\"}\njwk = Jwk.generate_for_kty(\"EC\", crv=\"P-256\")\njwt = Jwt.sign(claims, jwk, alg=\"ES256\", extra_headers={\"header1\": \"value1\"})\n\nprint(jwt)\n# eyJoZWFkZXIxIjoidmFsdWUxIiwiYWxnIjoiRVMyNTYifQ.eyJjbGFpbTEiOiJ2YWx1ZTEiLCJjbGFpbTIiOiJ2YWx1ZTIifQ.m0Bi8D6Rdi6HeH4J45JPSaeGPxjboAf_-efQ3mUAi6Gs0ipC0MXg9rd727IIINUsVfU0geUn7IwA1HjoTOsHvg\nprint(jwt.headers)\n# {'header1': 'value1', 'alg': 'ES256'}\n</code></pre>"}]}